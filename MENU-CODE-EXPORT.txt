‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë GWI POS ‚Äî MENU BUILDER CODE EXPORT                                           ‚ïë
‚ïë Generated: 2026-02-06 06:36:54                                           ‚ïë
‚ïë Files: 12                                                                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

TABLE OF CONTENTS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

ItemEditor.tsx                                  1483 lines
ModifierFlowEditor.tsx                           594 lines
ItemTreeView.tsx                                 383 lines
page.tsx                                        2150 lines
route.ts                                         517 lines
route.ts                                         107 lines
route.ts                                         221 lines
route.ts                                         300 lines
route.ts                                         189 lines
route.ts                                         185 lines
route.ts                                         447 lines
index.ts                                         537 lines

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/components/menu/ItemEditor.tsx
LINES:     1483
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

'use client'

import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { formatCurrency } from '@/lib/utils'

interface Ingredient {
  id: string
  ingredientId: string
  name: string
  isIncluded: boolean
  allowNo: boolean
  allowLite: boolean
  allowExtra: boolean
  allowOnSide: boolean
  allowSwap: boolean
  extraPrice: number
}

interface IngredientLibraryItem {
  id: string
  name: string
  category: string | null
  categoryName?: string | null      // NEW: from categoryRelation.name
  parentIngredientId?: string | null // NEW: to identify child items
}

interface Modifier {
  id: string
  name: string
  price: number
  allowNo?: boolean
  allowLite?: boolean
  allowOnSide?: boolean
  allowExtra?: boolean
  extraPrice?: number
  isDefault?: boolean
  sortOrder: number
  ingredientId?: string | null
  ingredientName?: string | null
  childModifierGroupId?: string | null
  childModifierGroup?: ModifierGroup | null
  isLabel?: boolean
}

interface ModifierGroup {
  id: string
  name: string
  displayName?: string
  minSelections: number
  maxSelections: number
  isRequired: boolean
  allowStacking?: boolean
  tieredPricingConfig?: any
  exclusionGroupKey?: string | null
  sortOrder: number
  modifiers: Modifier[]
}

interface MenuItem {
  id: string
  name: string
  price: number
  description?: string
  categoryId: string
  categoryType?: string
  isActive: boolean
  isAvailable: boolean
}

interface ItemEditorProps {
  item: MenuItem | null
  ingredientsLibrary: IngredientLibraryItem[]
  onItemUpdated: () => void
  onToggle86?: (item: MenuItem) => void
  onDelete?: (itemId: string) => void
  refreshKey?: number
  onSelectGroup?: (groupId: string | null) => void
}

export function ItemEditor({ item, ingredientsLibrary, onItemUpdated, onToggle86, onDelete, refreshKey, onSelectGroup }: ItemEditorProps) {
  const [ingredients, setIngredients] = useState<Ingredient[]>([])
  const [modifierGroups, setModifierGroups] = useState<ModifierGroup[]>([])
  const [loading, setLoading] = useState(false)
  const [saving, setSaving] = useState(false)

  // Collapse states
  const [ingredientsExpanded, setIngredientsExpanded] = useState(false)

  // Forms
  const [showIngredientPicker, setShowIngredientPicker] = useState(false)
  const [ingredientSearch, setIngredientSearch] = useState('')

  // Modifier group editing state
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set())
  const toggleExpanded = (groupId: string) => {
    setExpandedGroups(prev => {
      const next = new Set(prev)
      if (next.has(groupId)) next.delete(groupId)
      else next.add(groupId)
      return next
    })
  }
  const [showNewGroupForm, setShowNewGroupForm] = useState(false)
  const [newGroupName, setNewGroupName] = useState('')
  const [addingModifierTo, setAddingModifierTo] = useState<string | null>(null)
  const [newModName, setNewModName] = useState('')
  const [newModPrice, setNewModPrice] = useState('')
  const [linkingModifier, setLinkingModifier] = useState<{ groupId: string; modId: string } | null>(null)
  const [modIngredientSearch, setModIngredientSearch] = useState('')
  const [draggedGroupId, setDraggedGroupId] = useState<string | null>(null)
  const [dragOverGroupId, setDragOverGroupId] = useState<string | null>(null)
  const [renamingGroupId, setRenamingGroupId] = useState<string | null>(null)
  const [renameValue, setRenameValue] = useState('')
  const [addingType, setAddingType] = useState<'item' | 'choice' | null>(null)
  const [editingModifierId, setEditingModifierId] = useState<string | null>(null)
  const [editModValues, setEditModValues] = useState<{ name: string; price: string; extraPrice: string }>({ name: '', price: '', extraPrice: '' })
  const [draggedModifierId, setDraggedModifierId] = useState<string | null>(null)
  const [dragOverModifierId, setDragOverModifierId] = useState<string | null>(null)

  // Load data when item changes or refreshKey updates
  useEffect(() => {
    if (!item?.id) {
      setIngredients([])
      setModifierGroups([])
      return
    }
    loadData()
  }, [item?.id, refreshKey])

  const loadData = async () => {
    if (!item?.id) return
    setLoading(true)
    try {
      const [ingRes, groupsRes] = await Promise.all([
        fetch(`/api/menu/items/${item.id}/ingredients`),
        fetch(`/api/menu/items/${item.id}/modifier-groups`),
      ])
      const [ingData, groupsData] = await Promise.all([ingRes.json(), groupsRes.json()])
      setIngredients(ingData.data || [])
      setModifierGroups(groupsData.data || [])
    } catch (e) {
      console.error('Failed to load data:', e)
    } finally {
      setLoading(false)
    }
  }

  // Ingredient functions
  const saveIngredients = async (newIngredients: typeof ingredients) => {
    if (!item?.id) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/ingredients`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ingredients: newIngredients.map(i => ({
            ingredientId: i.ingredientId,
            isIncluded: i.isIncluded,
            allowNo: i.allowNo,
            allowLite: i.allowLite,
            allowExtra: i.allowExtra,
            allowOnSide: i.allowOnSide,
            allowSwap: i.allowSwap,
            extraPrice: i.extraPrice,
          }))
        }),
      })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to save:', e)
    } finally {
      setSaving(false)
    }
  }

  const addIngredient = (ingredientId: string) => {
    const lib = ingredientsLibrary.find(i => i.id === ingredientId)
    if (!lib) return
    const newIngredients = [...ingredients, {
      id: '', ingredientId, name: lib.name, isIncluded: true,
      allowNo: true, allowLite: true, allowExtra: true, allowOnSide: true, allowSwap: true, extraPrice: 0,
    }]
    saveIngredients(newIngredients)
    setShowIngredientPicker(false)
    setIngredientSearch('')
  }

  const removeIngredient = (ingredientId: string) => {
    saveIngredients(ingredients.filter(i => i.ingredientId !== ingredientId))
  }

  const toggleIngredientOption = (ingredientId: string, option: 'allowNo' | 'allowLite' | 'allowExtra' | 'allowOnSide' | 'allowSwap') => {
    saveIngredients(ingredients.map(i => i.ingredientId === ingredientId ? { ...i, [option]: !i[option] } : i))
  }

  const updateExtraPrice = (ingredientId: string, price: number) => {
    saveIngredients(ingredients.map(i => i.ingredientId === ingredientId ? { ...i, extraPrice: price } : i))
  }

  // Modifier group CRUD functions
  const createGroup = async () => {
    if (!item?.id || !newGroupName.trim()) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newGroupName.trim(), minSelections: 0, maxSelections: 1 }),
      })
      setNewGroupName('')
      setShowNewGroupForm(false)
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to create group:', e)
    } finally {
      setSaving(false)
    }
  }

  const updateGroup = async (groupId: string, updates: Partial<ModifierGroup>) => {
    if (!item?.id) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to update group:', e)
    } finally {
      setSaving(false)
    }
  }

  const startRename = (groupId: string, currentName: string) => {
    setRenamingGroupId(groupId)
    setRenameValue(currentName)
  }

  // Helper to find a group by ID (recursive search through child groups)
  const findGroupById = (id: string): ModifierGroup | undefined => {
    for (const g of modifierGroups) {
      if (g.id === id) return g
      for (const m of g.modifiers) {
        if (m.childModifierGroup?.id === id) return m.childModifierGroup
        // Recurse into child group modifiers
        if (m.childModifierGroup) {
          for (const cm of m.childModifierGroup.modifiers) {
            if (cm.childModifierGroup?.id === id) return cm.childModifierGroup
          }
        }
      }
    }
    return undefined
  }

  // Helper to find a modifier by ID (recursive search through child groups)
  const findModifierById = (id: string): Modifier | undefined => {
    for (const g of modifierGroups) {
      for (const m of g.modifiers) {
        if (m.id === id) return m
        if (m.childModifierGroup) {
          for (const cm of m.childModifierGroup.modifiers) {
            if (cm.id === id) return cm
          }
        }
      }
    }
    return undefined
  }

  const commitRename = async (groupId: string) => {
    const trimmed = renameValue.trim()
    if (trimmed) {
      // Find the group name (could be top-level or a nested child group)
      const currentGroup = findGroupById(groupId)
      if (!currentGroup || currentGroup.name !== trimmed) {
        await updateGroup(groupId, { name: trimmed })
      }
    }
    setRenamingGroupId(null)
    setRenameValue('')
  }

  const deleteGroup = async (groupId: string) => {
    if (!item?.id || !confirm('Delete this modifier group?')) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}`, { method: 'DELETE' })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to delete group:', e)
    } finally {
      setSaving(false)
    }
  }

  const duplicateGroup = async (groupId: string) => {
    if (!item?.id) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ duplicateFromGroupId: groupId }),
      })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to duplicate group:', e)
    } finally {
      setSaving(false)
    }
  }

  const reorderGroups = async (fromId: string, toId: string) => {
    if (!item?.id || fromId === toId) return

    // Build top-level list (same filter as the render)
    const childGroupIdSet = new Set<string>()
    modifierGroups.forEach(g => {
      g.modifiers.forEach(m => {
        if (m.childModifierGroupId) childGroupIdSet.add(m.childModifierGroupId)
      })
    })
    const topLevel = modifierGroups.filter(g => !childGroupIdSet.has(g.id))

    const fromIndex = topLevel.findIndex(g => g.id === fromId)
    const toIndex = topLevel.findIndex(g => g.id === toId)
    if (fromIndex === -1 || toIndex === -1) return

    // Reorder the top-level list
    const reordered = [...topLevel]
    const [moved] = reordered.splice(fromIndex, 1)
    reordered.splice(toIndex, 0, moved)

    // Build new full list: reordered top-level + unchanged child groups
    const newFull = [
      ...reordered,
      ...modifierGroups.filter(g => childGroupIdSet.has(g.id)),
    ]
    setModifierGroups(newFull)

    // Persist only top-level sort orders
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sortOrders: reordered.map((g, i) => ({ id: g.id, sortOrder: i })),
        }),
      })
      onItemUpdated()
    } catch (e) {
      console.error('Failed to reorder groups:', e)
      await loadData() // Rollback on failure
    }
  }

  const reorderModifiers = async (groupId: string, fromModId: string, toModId: string) => {
    if (!item?.id || fromModId === toModId) return

    // Find the group (could be top-level or child)
    const group = findGroupById(groupId)
    if (!group) return

    const mods = [...group.modifiers]
    const fromIdx = mods.findIndex(m => m.id === fromModId)
    const toIdx = mods.findIndex(m => m.id === toModId)
    if (fromIdx === -1 || toIdx === -1) return

    const [moved] = mods.splice(fromIdx, 1)
    mods.splice(toIdx, 0, moved)

    // Optimistic UI update
    const newGroups = modifierGroups.map(g => {
      if (g.id === groupId) {
        return { ...g, modifiers: mods }
      }
      // Also check child groups
      return {
        ...g,
        modifiers: g.modifiers.map(m => {
          if (m.childModifierGroup?.id === groupId) {
            return { ...m, childModifierGroup: { ...m.childModifierGroup, modifiers: mods } }
          }
          return m
        })
      }
    })
    setModifierGroups(newGroups)

    // Persist: update sort orders for all modifiers in the group
    try {
      await Promise.all(mods.map((m, idx) =>
        fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}/modifiers`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ modifierId: m.id, sortOrder: idx }),
        })
      ))
      onItemUpdated()
    } catch (e) {
      console.error('Failed to reorder modifiers:', e)
      await loadData() // rollback
    }
  }

  const addModifier = async (groupId: string) => {
    if (!item?.id || !newModName.trim()) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}/modifiers`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newModName.trim(), price: parseFloat(newModPrice) || 0 }),
      })
      setNewModName('')
      setNewModPrice('')
      setAddingModifierTo(null)
      setAddingType(null)
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to add modifier:', e)
    } finally {
      setSaving(false)
    }
  }

  const updateModifier = async (groupId: string, modifierId: string, updates: Partial<Modifier>) => {
    if (!item?.id) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}/modifiers`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ modifierId, ...updates }),
      })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to update modifier:', e)
    } finally {
      setSaving(false)
    }
  }

  const deleteModifier = async (groupId: string, modifierId: string) => {
    if (!item?.id) return
    setSaving(true)
    try {
      await fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}/modifiers?modifierId=${modifierId}`, {
        method: 'DELETE',
      })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to delete modifier:', e)
    } finally {
      setSaving(false)
    }
  }

  const startEditModifier = (mod: Modifier) => {
    setEditingModifierId(mod.id)
    setEditModValues({
      name: mod.name,
      price: String(mod.price || 0),
      extraPrice: String(mod.extraPrice || 0),
    })
  }

  const commitEditModifier = async (groupId: string, modId: string) => {
    const updates: Partial<Modifier> = {}
    const currentMod = findModifierById(modId)

    if (!currentMod) { setEditingModifierId(null); return }

    const newName = editModValues.name.trim()
    const newPrice = parseFloat(editModValues.price) || 0
    const newExtraPrice = parseFloat(editModValues.extraPrice) || 0

    if (newName && newName !== currentMod.name) updates.name = newName
    if (newPrice !== currentMod.price) updates.price = newPrice
    if (newExtraPrice !== (currentMod.extraPrice || 0)) updates.extraPrice = newExtraPrice

    if (Object.keys(updates).length > 0) {
      await updateModifier(groupId, modId, updates)
    }
    setEditingModifierId(null)
  }

  const createChildGroup = async (parentModifierId: string) => {
    if (!item?.id) return
    setSaving(true)
    try {
      const res = await fetch(`/api/menu/items/${item.id}/modifier-groups`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: 'New Sub-Group',
          minSelections: 0,
          maxSelections: 1,
          parentModifierId
        }),
      })
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to create child group:', e)
    } finally {
      setSaving(false)
    }
  }

  const addChoice = async (groupId: string) => {
    if (!item?.id || !newModName.trim()) return
    setSaving(true)
    try {
      // Step 1: Create modifier with isLabel=true, price=0, all pre-mods false
      const modRes = await fetch(`/api/menu/items/${item.id}/modifier-groups/${groupId}/modifiers`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: newModName.trim(),
          price: 0,
          allowNo: false,
          allowLite: false,
          allowOnSide: false,
          allowExtra: false,
          isLabel: true,
        }),
      })
      const modData = await modRes.json()
      const modifierId = modData.data?.id
      if (!modifierId) throw new Error('Failed to create choice modifier')

      // Step 2: Create child group linked to this modifier (same name)
      await fetch(`/api/menu/items/${item.id}/modifier-groups`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: newModName.trim(),
          minSelections: 0,
          maxSelections: 1,
          parentModifierId: modifierId,
        }),
      })

      setNewModName('')
      setNewModPrice('')
      setAddingModifierTo(null)
      setAddingType(null)
      await loadData()
      onItemUpdated()
    } catch (e) {
      console.error('Failed to add choice:', e)
    } finally {
      setSaving(false)
    }
  }

  const linkIngredient = async (groupId: string, modifierId: string, ingredientId: string | null) => {
    await updateModifier(groupId, modifierId, { ingredientId })
    setLinkingModifier(null)
    setModIngredientSearch('')
  }

  // Helper to render a choice row (navigation modifier with child group)
  const renderChoiceRow = (groupId: string, mod: Modifier, depth: number = 0) => {
    const childGroup = mod.childModifierGroup
    const itemCount = childGroup?.modifiers?.length || 0

    return (
      <div
        key={mod.id}
        className={`space-y-1 ${draggedModifierId === mod.id ? 'opacity-50' : ''} ${dragOverModifierId === mod.id && draggedModifierId !== mod.id ? 'ring-2 ring-indigo-300 rounded' : ''}`}
        draggable
        onDragStart={(e) => {
          e.stopPropagation()
          setDraggedModifierId(mod.id)
          e.dataTransfer.effectAllowed = 'move'
          e.dataTransfer.setData('text/plain', mod.id)
        }}
        onDragOver={(e) => {
          e.preventDefault()
          e.stopPropagation()
          setDragOverModifierId(mod.id)
        }}
        onDragLeave={() => setDragOverModifierId(null)}
        onDrop={(e) => {
          e.preventDefault()
          e.stopPropagation()
          if (draggedModifierId) reorderModifiers(groupId, draggedModifierId, mod.id)
          setDraggedModifierId(null)
          setDragOverModifierId(null)
        }}
        onDragEnd={() => {
          setDraggedModifierId(null)
          setDragOverModifierId(null)
        }}
      >
        <div className="flex items-center gap-2 px-2 py-1.5 bg-amber-50 border border-amber-200 rounded text-sm">
          <span className="cursor-grab text-gray-300 hover:text-gray-500 text-xs" title="Drag to reorder">‚†ø</span>
          <span className="text-amber-500 text-xs">üìÅ</span>
          {editingModifierId === mod.id ? (
            <input
              type="text"
              value={editModValues.name}
              onChange={(e) => setEditModValues(prev => ({ ...prev, name: e.target.value }))}
              onBlur={() => commitEditModifier(groupId, mod.id)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') commitEditModifier(groupId, mod.id)
                if (e.key === 'Escape') setEditingModifierId(null)
              }}
              className="flex-1 px-1 py-0.5 text-sm font-medium border rounded bg-white"
              autoFocus
            />
          ) : (
            <span
              className="flex-1 font-medium text-amber-800 truncate cursor-pointer hover:text-amber-600"
              onDoubleClick={() => startEditModifier(mod)}
              title="Double-click to rename"
            >
              {mod.name}
            </span>
          )}
          <span className="text-[9px] px-1.5 py-0.5 bg-amber-100 text-amber-600 rounded font-medium">
            {itemCount} {itemCount === 1 ? 'item' : 'items'}
          </span>
          <button
            onClick={() => deleteModifier(groupId, mod.id)}
            className="text-red-400 hover:text-red-600 text-xs"
            title="Delete choice and its group"
          >
            √ó
          </button>
        </div>
        {childGroup && renderChildGroup(childGroup, depth + 1)}
      </div>
    )
  }

  // Helper to render a modifier row with all controls
  const renderModifierRow = (groupId: string, mod: Modifier, depth: number = 0) => {
    // If this is a choice (label with child group), render it differently
    if (mod.isLabel && mod.childModifierGroupId) {
      return renderChoiceRow(groupId, mod, depth)
    }

    const isLinking = linkingModifier?.groupId === groupId && linkingModifier?.modId === mod.id
    const filteredIngredients = ingredientsLibrary.filter(ing =>
      ing.name.toLowerCase().includes(modIngredientSearch.toLowerCase())
    )

    return (
      <div
        key={mod.id}
        className={`space-y-1 ${draggedModifierId === mod.id ? 'opacity-50' : ''} ${dragOverModifierId === mod.id && draggedModifierId !== mod.id ? 'ring-2 ring-indigo-300 rounded' : ''}`}
        draggable
        onDragStart={(e) => {
          e.stopPropagation()
          setDraggedModifierId(mod.id)
          e.dataTransfer.effectAllowed = 'move'
          e.dataTransfer.setData('text/plain', mod.id)
        }}
        onDragOver={(e) => {
          e.preventDefault()
          e.stopPropagation()
          setDragOverModifierId(mod.id)
        }}
        onDragLeave={() => setDragOverModifierId(null)}
        onDrop={(e) => {
          e.preventDefault()
          e.stopPropagation()
          if (draggedModifierId) reorderModifiers(groupId, draggedModifierId, mod.id)
          setDraggedModifierId(null)
          setDragOverModifierId(null)
        }}
        onDragEnd={() => {
          setDraggedModifierId(null)
          setDragOverModifierId(null)
        }}
      >
        <div className="flex items-center gap-2 px-2 py-1.5 bg-white border rounded text-sm">
          <span className="cursor-grab text-gray-300 hover:text-gray-500 text-xs" title="Drag to reorder">‚†ø</span>
          {editingModifierId === mod.id ? (
            <input
              type="text"
              value={editModValues.name}
              onChange={(e) => setEditModValues(prev => ({ ...prev, name: e.target.value }))}
              onBlur={() => commitEditModifier(groupId, mod.id)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') commitEditModifier(groupId, mod.id)
                if (e.key === 'Escape') setEditingModifierId(null)
              }}
              className="flex-1 px-1 py-0.5 text-sm border rounded bg-white min-w-0"
              autoFocus
              onClick={(e) => e.stopPropagation()}
            />
          ) : (
            <span
              className="flex-1 truncate cursor-pointer hover:text-indigo-600"
              onDoubleClick={() => startEditModifier(mod)}
              title="Double-click to edit"
            >
              {mod.name}
            </span>
          )}

          {/* Ingredient Link Badge */}
          {mod.ingredientId && mod.ingredientName && (
            <span className="text-[9px] px-1.5 py-0.5 bg-purple-100 text-purple-700 rounded flex items-center gap-1">
              üîó {mod.ingredientName}
              <button
                onClick={() => linkIngredient(groupId, mod.id, null)}
                className="hover:text-purple-900"
              >
                √ó
              </button>
            </span>
          )}

          {/* Link Ingredient Button */}
          <button
            onClick={() => setLinkingModifier(isLinking ? null : { groupId, modId: mod.id })}
            className={`w-5 h-5 rounded text-xs ${isLinking ? 'bg-purple-500 text-white' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}
            title="Link Ingredient"
          >
            üîó
          </button>

          {/* Pre-modifier toggles */}
          <div className="flex gap-0.5">
            <button
              onClick={() => updateModifier(groupId, mod.id, { allowNo: !mod.allowNo })}
              className={`w-5 h-5 rounded text-[9px] font-bold ${mod.allowNo ? 'bg-red-500 text-white' : 'bg-red-100 text-red-400'}`}
            >
              N
            </button>
            <button
              onClick={() => updateModifier(groupId, mod.id, { allowLite: !mod.allowLite })}
              className={`w-5 h-5 rounded text-[9px] font-bold ${mod.allowLite ? 'bg-yellow-500 text-white' : 'bg-yellow-100 text-yellow-400'}`}
            >
              L
            </button>
            <button
              onClick={() => updateModifier(groupId, mod.id, { allowOnSide: !mod.allowOnSide })}
              className={`w-5 h-5 rounded text-[9px] font-bold ${mod.allowOnSide ? 'bg-blue-500 text-white' : 'bg-blue-100 text-blue-400'}`}
            >
              S
            </button>
            <button
              onClick={() => updateModifier(groupId, mod.id, { allowExtra: !mod.allowExtra })}
              className={`w-5 h-5 rounded text-[9px] font-bold ${mod.allowExtra ? 'bg-green-500 text-white' : 'bg-green-100 text-green-400'}`}
            >
              E
            </button>
          </div>

          {editingModifierId === mod.id ? (
            <div className="flex items-center gap-0.5">
              <span className="text-[9px] text-gray-500">$</span>
              <input
                type="number"
                value={editModValues.price}
                onChange={(e) => setEditModValues(prev => ({ ...prev, price: e.target.value }))}
                onBlur={() => commitEditModifier(groupId, mod.id)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') commitEditModifier(groupId, mod.id)
                  if (e.key === 'Escape') setEditingModifierId(null)
                }}
                className="w-14 px-1 py-0.5 text-xs border rounded text-center"
                step="0.01"
                min="0"
              />
            </div>
          ) : (
            <span
              className="text-xs text-green-600 cursor-pointer hover:underline"
              onDoubleClick={() => startEditModifier(mod)}
              title="Double-click to edit price"
            >
              {mod.price > 0 ? `+${formatCurrency(mod.price)}` : '$0'}
            </span>
          )}

          {editingModifierId === mod.id && mod.allowExtra && (
            <div className="flex items-center gap-0.5">
              <span className="text-[9px] text-gray-500">E$</span>
              <input
                type="number"
                value={editModValues.extraPrice}
                onChange={(e) => setEditModValues(prev => ({ ...prev, extraPrice: e.target.value }))}
                onBlur={() => commitEditModifier(groupId, mod.id)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') commitEditModifier(groupId, mod.id)
                  if (e.key === 'Escape') setEditingModifierId(null)
                }}
                className="w-14 px-1 py-0.5 text-xs border rounded text-center"
                step="0.01"
                min="0"
              />
            </div>
          )}

          <button
            onClick={() => deleteModifier(groupId, mod.id)}
            className="text-red-400 hover:text-red-600 text-xs"
          >
            √ó
          </button>

          {/* Create Child Group Button ‚Äî only if no child group exists yet */}
          {!mod.childModifierGroupId && (
            <button
              onClick={(e) => { e.stopPropagation(); createChildGroup(mod.id) }}
              className="w-5 h-5 rounded bg-indigo-100 text-indigo-600 hover:bg-indigo-200 text-xs font-bold"
              title="Add sub-group"
            >
              +‚ñ∂
            </button>
          )}
        </div>

        {/* Ingredient Search Dropdown */}
        {isLinking && (
          <div className="ml-4 p-2 bg-purple-50 border border-purple-200 rounded">
            <input
              type="text"
              value={modIngredientSearch}
              onChange={(e) => setModIngredientSearch(e.target.value)}
              placeholder="Search ingredients..."
              className="w-full px-2 py-1 text-xs border rounded mb-1"
              autoFocus
            />
            <div className="max-h-48 overflow-y-auto space-y-0.5">
              {filteredIngredients.length === 0 ? (
                <div className="text-xs text-gray-400 text-center py-2">
                  {modIngredientSearch ? 'No matches' : 'Type to search'}
                </div>
              ) : (
                (() => {
                  // Group by category, sort categories alphabetically
                  const grouped = filteredIngredients.reduce((acc, ing) => {
                    const cat = ing.categoryName || ing.category || 'Uncategorized'
                    if (!acc[cat]) acc[cat] = []
                    acc[cat].push(ing)
                    return acc
                  }, {} as Record<string, typeof filteredIngredients>)

                  // Sort categories alphabetically
                  const sortedCategories = Object.keys(grouped).sort()

                  return sortedCategories.map(category => (
                    <div key={category}>
                      <div className="text-[10px] font-semibold text-purple-700 uppercase tracking-wide px-2 py-1 bg-purple-50/50 sticky top-0">
                        {category}
                      </div>
                      {grouped[category]
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(ing => (
                          <button
                            key={ing.id}
                            onClick={() => linkIngredient(groupId, mod.id, ing.id)}
                            className="w-full text-left px-3 py-1 text-xs hover:bg-purple-100 rounded flex justify-between items-center"
                          >
                            <span>{ing.name}</span>
                          </button>
                        ))
                      }
                    </div>
                  ))
                })()
              )}
            </div>
          </div>
        )}

        {/* Render Child Group Recursively */}
        {mod.childModifierGroup && renderChildGroup(mod.childModifierGroup, depth + 1)}
      </div>
    )
  }

  // Helper to render child modifier groups recursively
  const renderChildGroup = (childGroup: ModifierGroup, depth: number = 1) => {
    const isExpanded = expandedGroups.has(childGroup.id)
    const isEmpty = childGroup.modifiers.length === 0
    const indentClass = `ml-${depth * 4} pl-3 border-l-2 border-indigo-200`

    return (
      <div key={childGroup.id} className={`mt-2 ${indentClass}`}>
        <div className="text-xs text-gray-500 mb-1">After selecting parent modifier:</div>
        <div className={`border rounded-lg overflow-hidden ${childGroup.isRequired ? 'border-l-4 border-red-400' : ''} ${isEmpty ? 'border-dashed' : ''}`}>
          {/* Child Group Header */}
          {/* Child Group Header */}
          <div className="px-3 py-2 bg-gray-50 flex items-center gap-2">
            {/* Expand/collapse toggle */}
            <button
              onClick={() => {
                toggleExpanded(childGroup.id)
                onSelectGroup?.(isExpanded ? null : childGroup.id)
              }}
              className="flex-shrink-0"
            >
              <span className={`text-xs transition-transform ${isExpanded ? 'rotate-90' : ''} ${childGroup.isRequired && isEmpty ? 'text-red-500' : isEmpty ? 'text-gray-300' : 'text-green-500'}`}>
                ‚ñ∂
              </span>
            </button>

            {/* Name - double-click to rename */}
            {renamingGroupId === childGroup.id ? (
              <input
                type="text"
                value={renameValue}
                onChange={(e) => setRenameValue(e.target.value)}
                onBlur={() => commitRename(childGroup.id)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') commitRename(childGroup.id)
                  if (e.key === 'Escape') { setRenamingGroupId(null); setRenameValue('') }
                }}
                className="flex-1 px-1 py-0.5 text-sm font-medium border rounded bg-white"
                autoFocus
                onClick={(e) => e.stopPropagation()}
              />
            ) : (
              <span
                className="flex-1 font-medium text-sm truncate cursor-pointer hover:text-indigo-600"
                onClick={(e) => e.stopPropagation()}
                onDoubleClick={(e) => { e.stopPropagation(); startRename(childGroup.id, childGroup.name) }}
                title="Double-click to rename"
              >
                {childGroup.name}
              </span>
            )}

            <span className="text-xs text-gray-400">{childGroup.modifiers.length}</span>

            {/* Action buttons */}
            <button
              onClick={(e) => { e.stopPropagation(); startRename(childGroup.id, childGroup.name) }}
              className="text-gray-400 hover:text-indigo-600 text-xs px-0.5"
              title="Rename"
              disabled={saving}
            >
              ‚úèÔ∏è
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); duplicateGroup(childGroup.id) }}
              className="text-gray-400 hover:text-indigo-600 text-xs px-0.5"
              title="Duplicate Group"
              disabled={saving}
            >
              ‚ßâ
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); deleteGroup(childGroup.id) }}
              className="text-gray-400 hover:text-red-600 text-xs px-0.5"
              title="Delete Group"
              disabled={saving}
            >
              üóë
            </button>
          </div>

          {/* Child Group Expanded Content */}
          {isExpanded && (
            <div className="border-t" draggable={false} onDragStart={(e) => e.stopPropagation()}>
              {/* Compact settings summary - edit in right panel */}
              <div className="px-3 py-1.5 bg-gray-50/50 border-b text-xs text-gray-400 flex items-center justify-between">
                <span>
                  {childGroup.minSelections}-{childGroup.maxSelections} selections
                  {childGroup.isRequired && <span className="ml-1 text-red-500 font-medium">¬∑ Required</span>}
                  {childGroup.allowStacking && <span className="ml-1 text-yellow-600">¬∑ Stacking</span>}
                </span>
                <span className="text-gray-300">Edit in panel ‚Üí</span>
              </div>

              {/* Child Modifiers */}
              <div className="p-2 space-y-1">
                {isEmpty && (
                  <div className="text-center text-gray-400 text-xs py-2 italic">
                    Add modifiers to get started
                  </div>
                )}
                {childGroup.modifiers.map(mod => renderModifierRow(childGroup.id, mod, depth))}

                {/* Add Modifier to Child Group */}
                {addingModifierTo === childGroup.id ? (
                  <div className="flex gap-1 mt-2">
                    <input
                      type="text"
                      value={newModName}
                      onChange={(e) => setNewModName(e.target.value)}
                      placeholder="Name"
                      className="flex-1 px-2 py-1 text-xs border rounded"
                      autoFocus
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          if (addingType === 'choice') {
                            addChoice(childGroup.id)
                          } else {
                            addModifier(childGroup.id)
                          }
                        }
                      }}
                    />
                    {addingType === 'item' && (
                      <input
                        type="number"
                        value={newModPrice}
                        onChange={(e) => setNewModPrice(e.target.value)}
                        placeholder="$"
                        className="w-14 px-2 py-1 text-xs border rounded"
                        step="0.01"
                      />
                    )}
                    <Button
                      size="sm"
                      variant="primary"
                      onClick={() => addingType === 'choice' ? addChoice(childGroup.id) : addModifier(childGroup.id)}
                      disabled={!newModName.trim()}
                    >
                      +
                    </Button>
                    <Button size="sm" variant="ghost" onClick={() => { setAddingModifierTo(null); setAddingType(null); setNewModName(''); setNewModPrice('') }}>
                      √ó
                    </Button>
                  </div>
                ) : (
                  <div className="flex gap-1">
                    <button
                      onClick={() => { setAddingModifierTo(childGroup.id); setAddingType('item') }}
                      className="flex-1 py-1 text-xs text-indigo-600 hover:bg-indigo-50 rounded border border-dashed border-indigo-300"
                    >
                      + Add Item
                    </button>
                    <button
                      onClick={() => { setAddingModifierTo(childGroup.id); setAddingType('choice') }}
                      className="flex-1 py-1 text-xs text-amber-600 hover:bg-amber-50 rounded border border-dashed border-amber-300"
                    >
                      + Add Choice
                    </button>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    )
  }

  const filteredLibrary = ingredientsLibrary.filter(lib =>
    !ingredients.find(i => i.ingredientId === lib.id) &&
    lib.name.toLowerCase().includes(ingredientSearch.toLowerCase())
  )

  if (!item) {
    return (
      <div className="h-full flex items-center justify-center text-gray-400 p-4 bg-gray-50">
        <p className="text-sm">Select an item to edit</p>
      </div>
    )
  }

  return (
    <div className="h-full flex flex-col bg-white">
      {/* Item Header */}
      <div className="p-4 border-b bg-gradient-to-r from-blue-600 to-indigo-600 text-white">
        <div className="flex items-start justify-between gap-3">
          <div>
            <h2 className="text-xl font-bold">{item.name}</h2>
            <p className="text-2xl font-bold mt-1">{formatCurrency(item.price)}</p>
          </div>
          <div className="flex gap-2">
            {onToggle86 && (
              <button
                onClick={() => onToggle86(item)}
                className={`px-3 py-1.5 rounded text-sm font-medium ${
                  !item.isAvailable ? 'bg-white text-blue-600' : 'bg-white/20 hover:bg-white/30'
                }`}
              >
                {!item.isAvailable ? 'Restore' : '86 It'}
              </button>
            )}
            {onDelete && (
              <button
                onClick={() => onDelete(item.id)}
                className="px-3 py-1.5 rounded text-sm bg-red-500/80 hover:bg-red-500"
              >
                Delete
              </button>
            )}
          </div>
        </div>
      </div>

      {/* Scrollable Content */}
      <div className="flex-1 overflow-y-auto">
        {loading ? (
          <div className="p-8 text-center text-gray-400">Loading...</div>
        ) : (
          <>
            {/* INGREDIENTS SECTION - Collapsible */}
            <div className="border-b">
              <button
                onClick={() => setIngredientsExpanded(!ingredientsExpanded)}
                className="w-full px-4 py-3 bg-green-50 flex items-center justify-between hover:bg-green-100 transition-colors"
              >
                <div className="flex items-center gap-2">
                  <span className={`text-green-600 transition-transform ${ingredientsExpanded ? 'rotate-90' : ''}`}>‚ñ∂</span>
                  <span className="font-semibold text-green-900">ü•ó Ingredients</span>
                  <span className="text-sm text-green-600">({ingredients.length})</span>
                  {(() => {
                    const customizableCount = ingredients.filter(i => i.allowNo || i.allowLite || i.allowExtra || i.allowOnSide || i.allowSwap).length
                    return customizableCount > 0 ? (
                      <span className="text-xs text-green-500">¬∑ {customizableCount} customizable</span>
                    ) : null
                  })()}
                </div>
                <span
                  role="button"
                  tabIndex={0}
                  className="text-green-600 text-xs font-semibold px-2 py-1 hover:bg-green-100 rounded cursor-pointer"
                  onClick={(e) => { e.stopPropagation(); setShowIngredientPicker(!showIngredientPicker); setIngredientsExpanded(true) }}
                  onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.stopPropagation(); setShowIngredientPicker(!showIngredientPicker); setIngredientsExpanded(true) } }}
                >
                  + Add
                </span>
              </button>

              {ingredientsExpanded && (
                <div className="p-3 space-y-2">
                  {/* Ingredient Picker */}
                  {showIngredientPicker && (
                    <div className="p-2 border rounded bg-green-50/50 mb-2">
                      <input
                        type="text"
                        value={ingredientSearch}
                        onChange={(e) => setIngredientSearch(e.target.value)}
                        placeholder="Search ingredients..."
                        className="w-full px-2 py-1 text-sm border rounded mb-2"
                        autoFocus
                      />
                      <div className="max-h-48 overflow-y-auto space-y-2">
                        {(() => {
                          const limited = filteredLibrary.slice(0, 12)
                          const grouped = limited.reduce((acc, lib) => {
                            const cat = lib.categoryName || lib.category || 'Other'
                            if (!acc[cat]) acc[cat] = []
                            acc[cat].push(lib)
                            return acc
                          }, {} as Record<string, typeof limited>)
                          return Object.entries(grouped).map(([category, items]) => (
                            <div key={category}>
                              <div className="text-xs font-semibold text-green-700 px-2 py-1">{category}</div>
                              {items.map(lib => (
                                <button
                                  key={lib.id}
                                  onClick={() => addIngredient(lib.id)}
                                  className="w-full text-left px-2 py-1 text-sm hover:bg-green-100 rounded"
                                >
                                  {lib.name}
                                </button>
                              ))}
                            </div>
                          ))
                        })()}
                      </div>
                    </div>
                  )}

                  {ingredients.length === 0 ? (
                    <p className="text-gray-400 text-sm text-center py-2">No ingredients</p>
                  ) : (
                    ingredients.map(ing => (
                      <div key={ing.ingredientId} className="flex items-center gap-2 px-2 py-1.5 bg-gray-50 rounded border">
                        <span className="flex-1 text-sm truncate">{ing.name}</span>
                        <div className="flex gap-0.5 items-center">
                          <button
                            onClick={() => toggleIngredientOption(ing.ingredientId, 'allowNo')}
                            className={`w-5 h-5 rounded text-[9px] font-bold ${ing.allowNo ? 'bg-red-500 text-white' : 'bg-red-100 text-red-400'}`}
                          >
                            N
                          </button>
                          <button
                            onClick={() => toggleIngredientOption(ing.ingredientId, 'allowLite')}
                            className={`w-5 h-5 rounded text-[9px] font-bold ${ing.allowLite ? 'bg-yellow-500 text-white' : 'bg-yellow-100 text-yellow-400'}`}
                          >
                            L
                          </button>
                          <button
                            onClick={() => toggleIngredientOption(ing.ingredientId, 'allowOnSide')}
                            className={`w-5 h-5 rounded text-[9px] font-bold ${ing.allowOnSide ? 'bg-blue-500 text-white' : 'bg-blue-100 text-blue-400'}`}
                          >
                            S
                          </button>
                          <button
                            onClick={() => toggleIngredientOption(ing.ingredientId, 'allowExtra')}
                            className={`w-5 h-5 rounded text-[9px] font-bold ${ing.allowExtra ? 'bg-green-500 text-white' : 'bg-green-100 text-green-400'}`}
                          >
                            E
                          </button>
                          {ing.allowExtra && (
                            <input
                              type="number"
                              value={ing.extraPrice || ''}
                              onChange={(e) => updateExtraPrice(ing.ingredientId, parseFloat(e.target.value) || 0)}
                              placeholder="$"
                              className="w-12 px-1 text-xs border rounded"
                              step="0.01"
                              min="0"
                            />
                          )}
                          <button
                            onClick={() => toggleIngredientOption(ing.ingredientId, 'allowSwap')}
                            className={`w-5 h-5 rounded text-[9px] font-bold ${ing.allowSwap ? 'bg-purple-500 text-white' : 'bg-purple-100 text-purple-400'}`}
                          >
                            Sw
                          </button>
                        </div>
                        <button onClick={() => removeIngredient(ing.ingredientId)} className="text-red-400 hover:text-red-600">√ó</button>
                      </div>
                    ))
                  )}
                </div>
              )}
            </div>

            {/* MODIFIER GROUPS - Interactive Editor */}
            <div className="border-b">
              <div className="px-4 py-3 bg-indigo-50 flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <span className="font-semibold text-indigo-900">‚öôÔ∏è Modifier Groups</span>
                  <span className="text-sm text-indigo-600">({modifierGroups.length})</span>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  className="text-indigo-600 text-xs"
                  onClick={() => setShowNewGroupForm(true)}
                  disabled={saving}
                >
                  + Add Group
                </Button>
              </div>

              {/* New Group Form */}
              {showNewGroupForm && (
                <div className="p-2 border-b bg-indigo-50/50">
                  <input
                    type="text"
                    value={newGroupName}
                    onChange={(e) => setNewGroupName(e.target.value)}
                    placeholder="Group name"
                    className="w-full px-2 py-1 text-sm border rounded mb-2"
                    autoFocus
                    onKeyDown={(e) => e.key === 'Enter' && createGroup()}
                  />
                  <div className="flex gap-1">
                    <Button size="sm" onClick={createGroup} disabled={!newGroupName.trim() || saving}>
                      Create
                    </Button>
                    <Button size="sm" variant="ghost" onClick={() => { setShowNewGroupForm(false); setNewGroupName('') }}>
                      Cancel
                    </Button>
                  </div>
                </div>
              )}

              {/* Groups List ‚Äî filter out child groups (they render nested under parent modifier) */}
              <div className="p-3 space-y-2">
                {(() => {
                  // Build set of child group IDs so we can exclude them from the top-level list
                  const childGroupIdSet = new Set<string>()
                  modifierGroups.forEach(g => {
                    g.modifiers.forEach(m => {
                      if (m.childModifierGroupId) childGroupIdSet.add(m.childModifierGroupId)
                    })
                  })
                  const topLevelGroups = modifierGroups.filter(g => !childGroupIdSet.has(g.id))

                  return topLevelGroups.length === 0 ? (
                    <p className="text-gray-400 text-sm text-center py-2">No modifier groups</p>
                  ) : (
                    topLevelGroups.map(group => {
                    const isExpanded = expandedGroups.has(group.id)
                    const isEmpty = group.modifiers.length === 0
                    const childModCount = group.modifiers.filter(m => m.childModifierGroupId).length

                    return (
                      <div
                        key={group.id}
                        className={`border rounded-lg overflow-hidden ${group.isRequired ? 'border-l-4 border-red-400' : ''} ${draggedGroupId === group.id ? 'opacity-50' : ''} ${dragOverGroupId === group.id && draggedGroupId !== group.id ? 'ring-2 ring-indigo-400' : ''}`}
                        draggable
                        onDragStart={(e) => {
                          setDraggedGroupId(group.id)
                          e.dataTransfer.effectAllowed = 'copyMove'
                          // Set data for cross-item copy
                          e.dataTransfer.setData('application/x-modifier-group', JSON.stringify({
                            groupId: group.id,
                            sourceItemId: item.id,
                            groupName: group.name,
                          }))
                        }}
                        onDragOver={(e) => {
                          e.preventDefault()
                          setDragOverGroupId(group.id)
                        }}
                        onDragLeave={() => setDragOverGroupId(null)}
                        onDrop={(e) => {
                          e.preventDefault()
                          if (draggedGroupId) reorderGroups(draggedGroupId, group.id)
                          setDraggedGroupId(null)
                          setDragOverGroupId(null)
                        }}
                        onDragEnd={() => {
                          setDraggedGroupId(null)
                          setDragOverGroupId(null)
                        }}
                      >
                        {/* Group Header - click to expand */}
                        <div
                          className="px-3 py-2 bg-gray-50 flex items-center gap-2 cursor-pointer"
                          onClick={() => {
                            toggleExpanded(group.id)
                            onSelectGroup?.(isExpanded ? null : group.id)
                          }}
                        >
                          <span className="cursor-grab text-gray-400 hover:text-gray-600 mr-1" title="Drag to reorder">‚†ø</span>
                          <span className={`text-xs transition-transform ${isExpanded ? 'rotate-90' : ''}`}>‚ñ∂</span>
                          {renamingGroupId === group.id ? (
                            <input
                              type="text"
                              value={renameValue}
                              onChange={(e) => setRenameValue(e.target.value)}
                              onBlur={() => commitRename(group.id)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') commitRename(group.id)
                                if (e.key === 'Escape') { setRenamingGroupId(null); setRenameValue('') }
                              }}
                              className="flex-1 px-1 py-0.5 text-sm font-medium border rounded bg-white"
                              autoFocus
                              onClick={(e) => e.stopPropagation()}
                            />
                          ) : (
                            <span
                              className="flex-1 font-medium text-sm truncate"
                              onDoubleClick={(e) => { e.stopPropagation(); startRename(group.id, group.name) }}
                              title="Double-click to rename"
                            >
                              {group.name}
                            </span>
                          )}
                          {childModCount > 0 && <span className="text-[9px] px-1 bg-indigo-100 text-indigo-600 rounded">{childModCount}‚ñ∂</span>}
                          <span className="text-xs text-gray-400">{group.modifiers.length}</span>
                          <button
                            onClick={(e) => { e.stopPropagation(); startRename(group.id, group.name) }}
                            className="text-gray-400 hover:text-indigo-600 text-xs px-0.5"
                            title="Rename"
                            disabled={saving}
                          >
                            ‚úèÔ∏è
                          </button>
                          <button
                            onClick={(e) => { e.stopPropagation(); duplicateGroup(group.id) }}
                            className="text-gray-400 hover:text-indigo-600 text-xs px-1"
                            title="Duplicate Group"
                            disabled={saving}
                          >
                            ‚ßâ
                          </button>
                        </div>

                        {/* Expanded: Settings + Modifiers */}
                        {isExpanded && (
                          <div className="border-t" draggable={false} onDragStart={(e) => e.stopPropagation()}>
                            {/* Compact settings summary - edit in right panel */}
                            <div className="px-3 py-1.5 bg-gray-50/50 border-b text-xs text-gray-400 flex items-center justify-between">
                              <span>
                                {group.minSelections}-{group.maxSelections} selections
                                {group.isRequired && <span className="ml-1 text-red-500 font-medium">¬∑ Required</span>}
                                {group.allowStacking && <span className="ml-1 text-yellow-600">¬∑ Stacking</span>}
                              </span>
                              <span className="text-gray-300">Edit in panel ‚Üí</span>
                            </div>

                            {/* Modifier rows */}
                            <div className="p-2 space-y-1">
                              {isEmpty && (
                                <div className="text-center text-gray-400 text-xs py-2 italic">
                                  Add modifiers to get started
                                </div>
                              )}
                              {group.modifiers.map(mod => renderModifierRow(group.id, mod))}

                              {/* Add modifier form */}
                              {addingModifierTo === group.id ? (
                                <div className="flex gap-1 mt-2">
                                  <input
                                    type="text"
                                    value={newModName}
                                    onChange={(e) => setNewModName(e.target.value)}
                                    placeholder="Name"
                                    className="flex-1 px-2 py-1 text-xs border rounded"
                                    autoFocus
                                    onKeyDown={(e) => {
                                      if (e.key === 'Enter') {
                                        if (addingType === 'choice') {
                                          addChoice(group.id)
                                        } else {
                                          addModifier(group.id)
                                        }
                                      }
                                    }}
                                  />
                                  {addingType === 'item' && (
                                    <input
                                      type="number"
                                      value={newModPrice}
                                      onChange={(e) => setNewModPrice(e.target.value)}
                                      placeholder="$"
                                      className="w-14 px-2 py-1 text-xs border rounded"
                                      step="0.01"
                                    />
                                  )}
                                  <Button
                                    size="sm"
                                    variant="primary"
                                    onClick={() => addingType === 'choice' ? addChoice(group.id) : addModifier(group.id)}
                                    disabled={!newModName.trim() || saving}
                                  >
                                    +
                                  </Button>
                                  <Button size="sm" variant="ghost" onClick={() => { setAddingModifierTo(null); setAddingType(null); setNewModName(''); setNewModPrice('') }}>
                                    √ó
                                  </Button>
                                </div>
                              ) : (
                                <div className="flex gap-1">
                                  <button
                                    onClick={() => { setAddingModifierTo(group.id); setAddingType('item') }}
                                    className="flex-1 py-1 text-xs text-indigo-600 hover:bg-indigo-50 rounded border border-dashed border-indigo-300"
                                    disabled={saving}
                                  >
                                    + Add Item
                                  </button>
                                  <button
                                    onClick={() => { setAddingModifierTo(group.id); setAddingType('choice') }}
                                    className="flex-1 py-1 text-xs text-amber-600 hover:bg-amber-50 rounded border border-dashed border-amber-300"
                                    disabled={saving}
                                  >
                                    + Add Choice
                                  </button>
                                </div>
                              )}
                            </div>
                          </div>
                        )}
                      </div>
                    )
                  })
                  )
                })()}
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  )
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/components/menu/ModifierFlowEditor.tsx
LINES:      594
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

'use client'

import { useState, useEffect } from 'react'

interface TieredPricingConfig {
  enabled: boolean
  modes: {
    flat_tiers: boolean
    free_threshold: boolean
  }
  flat_tiers?: {
    tiers: Array<{
      upTo: number
      price: number
    }>
    overflowPrice: number
  }
  free_threshold?: {
    freeCount: number
  }
}

interface ModifierGroup {
  id: string
  name: string
  displayName?: string | null
  minSelections: number
  maxSelections: number
  isRequired: boolean
  allowStacking?: boolean
  tieredPricingConfig?: TieredPricingConfig | null
  exclusionGroupKey?: string | null
  modifiers: Array<{
    id: string
    name: string
  }>
}

interface ModifierFlowEditorProps {
  item: { id: string; name: string } | null
  selectedGroupId: string | null
  refreshKey?: number
  onGroupUpdated: () => void
}

export function ModifierFlowEditor({
  item,
  selectedGroupId,
  refreshKey,
  onGroupUpdated,
}: ModifierFlowEditorProps) {
  const [group, setGroup] = useState<ModifierGroup | null>(null)
  const [allGroups, setAllGroups] = useState<ModifierGroup[]>([])
  const [loading, setLoading] = useState(false)
  const [tieredPricing, setTieredPricing] = useState<TieredPricingConfig>({
    enabled: false,
    modes: {
      flat_tiers: false,
      free_threshold: false,
    },
  })
  const [exclusionKey, setExclusionKey] = useState('')

  // Load group data when selectedGroupId changes
  useEffect(() => {
    if (!item?.id || !selectedGroupId) {
      setGroup(null)
      return
    }

    const loadGroupData = async () => {
      setLoading(true)
      try {
        const response = await fetch(`/api/menu/items/${item.id}/modifier-groups`)
        if (response.ok) {
          const data = await response.json()
          const groups = data.data || data.modifierGroups || []
          setAllGroups(groups)

          const foundGroup = groups.find((g: ModifierGroup) => g.id === selectedGroupId)
          if (foundGroup) {
            setGroup(foundGroup)
            setTieredPricing(foundGroup.tieredPricingConfig || {
              enabled: false,
              modes: {
                flat_tiers: false,
                free_threshold: false,
              },
            })
            setExclusionKey(foundGroup.exclusionGroupKey || '')
          }
        }
      } catch (error) {
        console.error('Failed to load group data:', error)
      } finally {
        setLoading(false)
      }
    }

    loadGroupData()
  }, [item?.id, selectedGroupId, refreshKey])

  const saveChanges = async () => {
    if (!item?.id || !selectedGroupId) return
    // Don't save if user is still creating a new key
    if (exclusionKey === '__new__') return

    try {
      const response = await fetch(`/api/menu/items/${item.id}/modifier-groups/${selectedGroupId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tieredPricingConfig: tieredPricing,
          exclusionGroupKey: exclusionKey || null,
        }),
      })

      if (response.ok) {
        onGroupUpdated()
      }
    } catch (error) {
      console.error('Failed to save group settings:', error)
    }
  }

  const handleTieredPricingToggle = (enabled: boolean) => {
    const newConfig = { ...tieredPricing, enabled }
    setTieredPricing(newConfig)
  }

  const handleModeToggle = (mode: 'flat_tiers' | 'free_threshold', checked: boolean) => {
    const newConfig = {
      ...tieredPricing,
      modes: {
        ...tieredPricing.modes,
        [mode]: checked,
      },
    }
    setTieredPricing(newConfig)
  }

  const handleAddTier = () => {
    const newConfig = {
      ...tieredPricing,
      flat_tiers: {
        ...(tieredPricing.flat_tiers || { tiers: [], overflowPrice: 0 }),
        tiers: [
          ...(tieredPricing.flat_tiers?.tiers || []),
          { upTo: 1, price: 0 },
        ],
      },
    }
    setTieredPricing(newConfig)
  }

  const handleRemoveTier = (index: number) => {
    if (!tieredPricing.flat_tiers) return
    const newTiers = tieredPricing.flat_tiers.tiers.filter((_, i) => i !== index)
    const newConfig = {
      ...tieredPricing,
      flat_tiers: {
        ...tieredPricing.flat_tiers,
        tiers: newTiers,
      },
    }
    setTieredPricing(newConfig)
  }

  const handleTierChange = (index: number, field: 'upTo' | 'price', value: number) => {
    if (!tieredPricing.flat_tiers) return
    const newTiers = [...tieredPricing.flat_tiers.tiers]
    newTiers[index] = { ...newTiers[index], [field]: value }
    const newConfig = {
      ...tieredPricing,
      flat_tiers: {
        ...tieredPricing.flat_tiers,
        tiers: newTiers,
      },
    }
    setTieredPricing(newConfig)
  }

  const handleOverflowPriceChange = (value: number) => {
    const newConfig = {
      ...tieredPricing,
      flat_tiers: {
        ...(tieredPricing.flat_tiers || { tiers: [], overflowPrice: 0 }),
        overflowPrice: value,
      },
    }
    setTieredPricing(newConfig)
  }

  const handleFreeCountChange = (value: number) => {
    const newConfig = {
      ...tieredPricing,
      free_threshold: {
        freeCount: value,
      },
    }
    setTieredPricing(newConfig)
  }

  // Get other groups with the same exclusion key
  const relatedGroups = allGroups.filter(
    g => g.id !== selectedGroupId && g.exclusionGroupKey === exclusionKey && exclusionKey !== ''
  )

  if (!selectedGroupId) {
    return (
      <div className="h-full flex items-center justify-center text-gray-400 bg-white p-6">
        <div className="text-center">
          <svg className="w-10 h-10 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
          </svg>
          <p className="text-sm font-medium">Select a modifier group</p>
          <p className="text-xs mt-1">to configure pricing rules</p>
        </div>
      </div>
    )
  }

  if (loading || !group) {
    return (
      <div className="h-full flex items-center justify-center text-gray-400 bg-white p-6">
        <p className="text-sm">Loading group settings...</p>
      </div>
    )
  }

  const handleSettingChange = async (updates: Record<string, any>) => {
    if (!item?.id || !selectedGroupId) return
    try {
      const response = await fetch(`/api/menu/items/${item.id}/modifier-groups/${selectedGroupId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      })
      if (response.ok) {
        // Reload group data
        const loadGroupData = async () => {
          setLoading(true)
          try {
            const response = await fetch(`/api/menu/items/${item.id}/modifier-groups`)
            if (response.ok) {
              const data = await response.json()
              const groups = data.data || data.modifierGroups || []
              setAllGroups(groups)

              const foundGroup = groups.find((g: ModifierGroup) => g.id === selectedGroupId)
              if (foundGroup) {
                setGroup(foundGroup)
                setTieredPricing(foundGroup.tieredPricingConfig || {
                  enabled: false,
                  modes: {
                    flat_tiers: false,
                    free_threshold: false,
                  },
                })
                setExclusionKey(foundGroup.exclusionGroupKey || '')
              }
            }
          } catch (error) {
            console.error('Failed to load group data:', error)
          } finally {
            setLoading(false)
          }
        }
        await loadGroupData()
        onGroupUpdated()
      }
    } catch (e) {
      console.error('Failed to update group settings:', e)
    }
  }

  const handleDeleteGroup = async () => {
    if (!item?.id || !selectedGroupId || !confirm('Delete this modifier group?')) return
    try {
      const response = await fetch(`/api/menu/items/${item.id}/modifier-groups/${selectedGroupId}`, {
        method: 'DELETE',
      })
      if (response.ok) {
        onGroupUpdated()
      }
    } catch (e) {
      console.error('Failed to delete group:', e)
    }
  }

  return (
    <div className="h-full overflow-y-auto bg-white">
      <div className="p-4 space-y-6">
        {/* Section 1: Group Summary (Read-only) */}
        <div className="border-b pb-4">
          <h3 className="text-lg font-bold text-gray-800">{group.displayName || group.name}</h3>
          <div className="flex gap-2 mt-2 flex-wrap">
            {group.isRequired && (
              <span className="text-xs px-2 py-0.5 rounded bg-red-100 text-red-700 font-medium">
                Required
              </span>
            )}
            {group.allowStacking && (
              <span className="text-xs px-2 py-0.5 rounded bg-yellow-100 text-yellow-700 font-medium">
                Stacking
              </span>
            )}
            <span className="text-xs px-2 py-0.5 rounded bg-gray-100 text-gray-700">
              {group.minSelections}-{group.maxSelections} selections
            </span>
            <span className="text-xs px-2 py-0.5 rounded bg-blue-100 text-blue-700">
              {group.modifiers.length} modifiers
            </span>
          </div>
        </div>

        {/* Group Settings */}
        <div className="border-b pb-4">
          <h3 className="text-sm font-semibold text-gray-700 mb-3">Group Settings</h3>
          <div className="space-y-3">
            {/* Min/Max Selections */}
            <div className="flex items-center gap-2">
              <span className="text-sm text-gray-600 w-24">Selections:</span>
              <input
                type="number"
                value={group.minSelections}
                onChange={(e) => handleSettingChange({ minSelections: parseInt(e.target.value) || 0 })}
                className="w-16 px-2 py-1.5 border rounded text-center text-sm"
                min="0"
              />
              <span className="text-gray-400">to</span>
              <input
                type="number"
                value={group.maxSelections}
                onChange={(e) => handleSettingChange({ maxSelections: parseInt(e.target.value) || 1 })}
                className="w-16 px-2 py-1.5 border rounded text-center text-sm"
                min="1"
              />
            </div>
            {/* Required Toggle */}
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={group.isRequired}
                onChange={(e) => handleSettingChange({ isRequired: e.target.checked })}
                className="w-4 h-4 rounded"
              />
              <span className="text-sm text-gray-700">Required</span>
              <span className="text-xs text-gray-400">Customer must make a selection</span>
            </label>
            {/* Stacking Toggle */}
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={group.allowStacking ?? false}
                onChange={(e) => handleSettingChange({ allowStacking: e.target.checked })}
                className="w-4 h-4 rounded"
              />
              <span className="text-sm text-gray-700">Allow Stacking</span>
              <span className="text-xs text-gray-400">Same item can be selected multiple times</span>
            </label>
            {/* Delete Group */}
            <button
              onClick={() => handleDeleteGroup()}
              className="text-red-500 hover:text-red-700 text-sm px-3 py-1.5 border border-red-200 rounded hover:bg-red-50 w-full"
            >
              Delete Group
            </button>
          </div>
        </div>

        {/* Section 2: Tiered Pricing */}
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <label className="text-sm font-semibold text-gray-700">Tiered Pricing</label>
            <label className="relative inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={tieredPricing.enabled}
                onChange={(e) => {
                  handleTieredPricingToggle(e.target.checked)
                  if (e.target.checked) {
                    // Auto-save on toggle
                    setTimeout(saveChanges, 100)
                  } else {
                    saveChanges()
                  }
                }}
                className="sr-only peer"
              />
              <div className="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
            </label>
          </div>

          {tieredPricing.enabled && (
            <div className="space-y-4 pl-4 border-l-2 border-gray-200">
              {/* Mode Checkboxes */}
              <div className="space-y-2">
                <label className="flex items-center gap-2 text-sm">
                  <input
                    type="checkbox"
                    checked={tieredPricing.modes.flat_tiers}
                    onChange={(e) => {
                      handleModeToggle('flat_tiers', e.target.checked)
                      setTimeout(saveChanges, 100)
                    }}
                    className="w-4 h-4 text-blue-600 rounded"
                  />
                  <span className="text-gray-700">Flat Tiers ‚Äî Fixed price per tier</span>
                </label>
                <label className="flex items-center gap-2 text-sm">
                  <input
                    type="checkbox"
                    checked={tieredPricing.modes.free_threshold}
                    onChange={(e) => {
                      handleModeToggle('free_threshold', e.target.checked)
                      setTimeout(saveChanges, 100)
                    }}
                    className="w-4 h-4 text-blue-600 rounded"
                  />
                  <span className="text-gray-700">Free Threshold ‚Äî First N selections free</span>
                </label>
              </div>

              {/* Flat Tiers Configuration */}
              {tieredPricing.modes.flat_tiers && (
                <div className="space-y-2 p-3 bg-gray-50 rounded border border-gray-200">
                  <p className="text-xs font-semibold text-gray-600 mb-2">Flat Tier Rules</p>
                  {tieredPricing.flat_tiers?.tiers.map((tier, index) => (
                    <div key={index} className="flex items-center gap-2">
                      <span className="text-xs text-gray-600 whitespace-nowrap">First</span>
                      <input
                        type="number"
                        min="1"
                        value={tier.upTo}
                        onChange={(e) => handleTierChange(index, 'upTo', parseInt(e.target.value) || 1)}
                        onBlur={saveChanges}
                        className="w-16 px-2 py-1 text-xs border border-gray-300 rounded"
                      />
                      <span className="text-xs text-gray-600 whitespace-nowrap">selections ‚Üí</span>
                      <span className="text-xs text-gray-600">$</span>
                      <input
                        type="number"
                        min="0"
                        step="0.01"
                        value={tier.price}
                        onChange={(e) => handleTierChange(index, 'price', parseFloat(e.target.value) || 0)}
                        onBlur={saveChanges}
                        className="w-20 px-2 py-1 text-xs border border-gray-300 rounded"
                      />
                      <span className="text-xs text-gray-600">each</span>
                      <button
                        onClick={() => {
                          handleRemoveTier(index)
                          setTimeout(saveChanges, 100)
                        }}
                        className="ml-auto text-red-600 hover:text-red-700 text-xs"
                      >
                        Remove
                      </button>
                    </div>
                  ))}
                  <button
                    onClick={() => {
                      handleAddTier()
                      setTimeout(saveChanges, 100)
                    }}
                    className="text-xs text-blue-600 hover:text-blue-700 font-medium"
                  >
                    + Add Tier
                  </button>
                  <div className="flex items-center gap-2 mt-3 pt-2 border-t border-gray-300">
                    <span className="text-xs text-gray-600">Overflow price:</span>
                    <span className="text-xs text-gray-600">$</span>
                    <input
                      type="number"
                      min="0"
                      step="0.01"
                      value={tieredPricing.flat_tiers?.overflowPrice || 0}
                      onChange={(e) => handleOverflowPriceChange(parseFloat(e.target.value) || 0)}
                      onBlur={saveChanges}
                      className="w-20 px-2 py-1 text-xs border border-gray-300 rounded"
                    />
                  </div>
                </div>
              )}

              {/* Free Threshold Configuration */}
              {tieredPricing.modes.free_threshold && (
                <div className="space-y-2 p-3 bg-gray-50 rounded border border-gray-200">
                  <p className="text-xs font-semibold text-gray-600 mb-2">Free Threshold Rule</p>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-gray-600">First</span>
                    <input
                      type="number"
                      min="0"
                      value={tieredPricing.free_threshold?.freeCount || 0}
                      onChange={(e) => handleFreeCountChange(parseInt(e.target.value) || 0)}
                      onBlur={saveChanges}
                      className="w-16 px-2 py-1 text-xs border border-gray-300 rounded"
                    />
                    <span className="text-xs text-gray-600">selections are FREE, rest use modifier prices</span>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Section 3: Exclusion Rules */}
        <div className="space-y-3 border-t pt-4">
          <label className="block">
            <span className="text-sm font-semibold text-gray-700">Exclusion Group</span>
            <p className="mt-0.5 text-xs text-gray-500">
              Prevent duplicate selections across groups. Modifiers selected in one group will be greyed out in related groups.
            </p>
            <select
              value={exclusionKey}
              onChange={(e) => {
                setExclusionKey(e.target.value)
                // Auto-save on change
                setTimeout(saveChanges, 100)
              }}
              className="mt-2 block w-full px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white"
            >
              <option value="">No exclusion group</option>
              {/* Show existing exclusion keys from other groups */}
              {(() => {
                const existingKeys = new Set<string>()
                allGroups.forEach(g => {
                  if (g.exclusionGroupKey && g.id !== selectedGroupId) {
                    existingKeys.add(g.exclusionGroupKey)
                  }
                })
                // Also include current key if it's custom
                if (exclusionKey && !existingKeys.has(exclusionKey)) {
                  existingKeys.add(exclusionKey)
                }
                return Array.from(existingKeys).sort().map(key => (
                  <option key={key} value={key}>{key}</option>
                ))
              })()}
              <option value="__new__">+ Create new exclusion group...</option>
            </select>
          </label>

          {/* New exclusion key input (shown when "Create new" selected) */}
          {exclusionKey === '__new__' && (
            <div className="flex gap-2">
              <input
                type="text"
                placeholder="e.g., sauces, toppings, sides"
                className="flex-1 px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                autoFocus
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && (e.target as HTMLInputElement).value.trim()) {
                    setExclusionKey((e.target as HTMLInputElement).value.trim())
                    setTimeout(saveChanges, 100)
                  }
                }}
                onBlur={(e) => {
                  const val = e.target.value.trim()
                  if (val) {
                    setExclusionKey(val)
                    setTimeout(saveChanges, 100)
                  } else {
                    setExclusionKey('')
                    setTimeout(saveChanges, 100)
                  }
                }}
              />
            </div>
          )}

          {/* Show related groups */}
          {relatedGroups.length > 0 && (
            <div className="p-3 bg-blue-50 rounded border border-blue-200">
              <p className="text-xs font-semibold text-blue-700 mb-2">
                Related Groups (sharing key &ldquo;{exclusionKey}&rdquo;):
              </p>
              <ul className="space-y-1">
                {relatedGroups.map(g => (
                  <li key={g.id} className="text-xs text-blue-600">
                    &bull; {g.displayName || g.name}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/components/menu/ItemTreeView.tsx
LINES:      383
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

'use client'

import { useState, useEffect } from 'react'
import { formatCurrency } from '@/lib/utils'

interface ModifierGroup {
  id: string
  name: string
  displayName?: string
  minSelections: number
  maxSelections: number
  isRequired: boolean
  modifiers: {
    id: string
    name: string
    price: number
    childModifierGroupId?: string
    childModifierGroup?: ModifierGroup | null
  }[]
}

interface Ingredient {
  id: string
  ingredientId: string
  name: string
  isIncluded: boolean
  allowNo: boolean
  allowLite: boolean
  allowExtra: boolean
  allowOnSide: boolean
  allowSwap: boolean
  extraPrice: number
}

interface MenuItem {
  id: string
  name: string
  price: number
  description?: string
  printerIds?: string[] | null
}

interface ItemTreeViewProps {
  item: MenuItem | null
  onSelectNode?: (nodeType: string, nodeId: string) => void
  selectedNode?: { type: string; id: string } | null
  refreshKey?: number  // triggers data re-fetch when incremented
}

type ExpandedState = Record<string, boolean>

export function ItemTreeView({ item, onSelectNode, selectedNode, refreshKey }: ItemTreeViewProps) {
  const [itemOwnedGroups, setItemOwnedGroups] = useState<ModifierGroup[]>([])
  const [sharedGroups, setSharedGroups] = useState<ModifierGroup[]>([])
  const [ingredients, setIngredients] = useState<Ingredient[]>([])
  const [loading, setLoading] = useState(false)
  const [expanded, setExpanded] = useState<ExpandedState>({
    root: true,
    ingredients: true,
    modifiers: true,
    printing: false,
  })

  useEffect(() => {
    if (!item?.id) {
      setItemOwnedGroups([])
      setSharedGroups([])
      setIngredients([])
      return
    }

    setLoading(true)
    Promise.all([
      fetch(`/api/menu/items/${item.id}/modifier-groups`).then(r => r.json()),
      fetch(`/api/menu/items/${item.id}/modifiers`).then(r => r.json()),
      fetch(`/api/menu/items/${item.id}/ingredients`).then(r => r.json()),
    ])
      .then(([ownedData, sharedData, ingData]) => {
        setItemOwnedGroups(ownedData.data || [])
        setSharedGroups(sharedData.modifierGroups || [])
        setIngredients(ingData.data || [])
      })
      .catch(console.error)
      .finally(() => setLoading(false))
  }, [item?.id, refreshKey])

  const toggle = (key: string) => {
    setExpanded(prev => ({ ...prev, [key]: !prev[key] }))
  }

  const isNodeSelected = (type: string, id: string) => {
    return selectedNode?.type === type && selectedNode?.id === id
  }

  if (!item) {
    return (
      <div className="h-full flex items-center justify-center text-gray-400 p-4">
        <p className="text-sm">Select an item to view its structure</p>
      </div>
    )
  }

  // Tree node component
  const TreeNode = ({
    label,
    nodeKey,
    icon,
    children,
    isLeaf = false,
    onClick,
    badge,
    depth = 0,
    nodeType,
    nodeId,
    isRequired = false,
    isEmpty = false,
  }: {
    label: string
    nodeKey: string
    icon?: React.ReactNode
    children?: React.ReactNode
    isLeaf?: boolean
    onClick?: () => void
    badge?: React.ReactNode
    depth?: number
    nodeType?: string
    nodeId?: string
    isRequired?: boolean
    isEmpty?: boolean
  }) => {
    const isExpanded = expanded[nodeKey]
    const isSelected = nodeType && nodeId ? isNodeSelected(nodeType, nodeId) : false
    const indent = depth * 16

    return (
      <div style={{ marginLeft: indent }}>
        <div
          className={`flex items-center gap-1 py-1 px-2 rounded cursor-pointer transition-colors text-sm ${
            isSelected
              ? 'bg-blue-100 text-blue-800'
              : 'hover:bg-blue-50/50'
          }`}
          onClick={() => {
            if (!isLeaf) toggle(nodeKey)
            if (onClick) onClick()
            if (onSelectNode && nodeType && nodeId) onSelectNode(nodeType, nodeId)
          }}
        >
          {!isLeaf ? (
            <span className="flex items-center gap-0.5">
              <span className={`text-gray-400 transition-transform ${isExpanded ? 'rotate-90' : ''}`}>
                ‚ñ∂
              </span>
              {isRequired && <span className="w-1.5 h-1.5 rounded-full bg-red-500" title="Required" />}
            </span>
          ) : (
            <span className="w-3" />
          )}
          {icon && <span className="text-gray-500">{icon}</span>}
          <span className={`flex-1 truncate ${isLeaf ? 'text-gray-600' : 'font-medium'} ${isEmpty ? 'italic text-gray-400' : ''}`}>
            {label}
          </span>
          {badge}
        </div>
        {!isLeaf && isExpanded && children && (
          <div className="ml-2 border-l border-gray-200">
            {children}
          </div>
        )}
      </div>
    )
  }

  // Render modifier group recursively
  const renderModifierGroup = (group: ModifierGroup, depth: number = 0, prefix: string = '') => {
    const groupKey = `${prefix}group-${group.id}`
    const isEmpty = group.modifiers.length === 0

    // Count child modifier groups for depth indicator
    const childGroupCount = group.modifiers.filter(m => m.childModifierGroup).length

    return (
      <TreeNode
        key={group.id}
        label={group.displayName || group.name}
        nodeKey={groupKey}
        nodeType="modifierGroup"
        nodeId={group.id}
        depth={depth}
        isRequired={group.isRequired}
        isEmpty={isEmpty}
        badge={
          <div className="flex items-center gap-1">
            <span className="text-xs text-gray-400">
              {group.modifiers.length}
            </span>
            {childGroupCount > 0 && (
              <span className="text-xs text-purple-600 font-medium" title={`${childGroupCount} nested group${childGroupCount > 1 ? 's' : ''}`}>
                +{childGroupCount}
              </span>
            )}
          </div>
        }
      >
        {group.modifiers.map(mod => (
          <div key={mod.id}>
            <TreeNode
              label={mod.name}
              nodeKey={`${groupKey}-mod-${mod.id}`}
              nodeType="modifier"
              nodeId={mod.id}
              isLeaf={!mod.childModifierGroup}
              depth={depth + 1}
              badge={
                <div className="flex items-center gap-1">
                  {mod.childModifierGroup && (
                    <span className="text-xs text-purple-500" title="Has child group">‚ñ∂</span>
                  )}
                  {mod.price > 0 && (
                    <span className="text-xs text-green-600">+{formatCurrency(mod.price)}</span>
                  )}
                </div>
              }
            >
              {mod.childModifierGroup && renderModifierGroup(mod.childModifierGroup, depth + 2, `${groupKey}-`)}
            </TreeNode>
          </div>
        ))}
      </TreeNode>
    )
  }

  return (
    <div className="h-full flex flex-col bg-white border-r">
      {/* Header */}
      <div className="p-3 border-b bg-gray-50">
        <h3 className="font-semibold text-sm text-gray-700">Item Structure</h3>
      </div>

      {/* Tree Content */}
      <div className="flex-1 overflow-y-auto p-2">
        {loading ? (
          <div className="text-center py-4 text-gray-400 text-sm">Loading...</div>
        ) : (
          <div className="space-y-1">
            {/* Root Item */}
            <TreeNode
              label={item.name}
              nodeKey="root"
              nodeType="item"
              nodeId={item.id}
              icon={<span>üì¶</span>}
              badge={
                <span className="text-xs font-medium text-blue-600">
                  {formatCurrency(item.price)}
                </span>
              }
            >
              {/* Ingredients Branch */}
              <TreeNode
                label="Ingredients"
                nodeKey="ingredients"
                nodeType="ingredientsSection"
                nodeId="ingredients"
                icon={<span>ü•ó</span>}
                badge={
                  <span className="text-xs text-gray-400">{ingredients.length}</span>
                }
              >
                {ingredients.length === 0 ? (
                  <div className="py-1 px-4 text-xs text-gray-400 italic">None</div>
                ) : (
                  ingredients.map(ing => (
                    <TreeNode
                      key={ing.id}
                      label={ing.name}
                      nodeKey={`ing-${ing.ingredientId}`}
                      nodeType="ingredient"
                      nodeId={ing.ingredientId}
                      isLeaf
                      depth={1}
                      badge={
                        <div className="flex gap-0.5">
                          {ing.allowNo && <span className="w-2 h-2 rounded-full bg-red-400" title="No" />}
                          {ing.allowLite && <span className="w-2 h-2 rounded-full bg-yellow-400" title="Lite" />}
                          {ing.allowOnSide && <span className="w-2 h-2 rounded-full bg-blue-400" title="Side" />}
                          {ing.allowExtra && <span className="w-2 h-2 rounded-full bg-green-400" title="Extra" />}
                          {ing.allowSwap && <span className="w-2 h-2 rounded-full bg-purple-400" title="Swap" />}
                        </div>
                      }
                    />
                  ))
                )}
              </TreeNode>

              {/* Item Modifier Groups Branch */}
              <TreeNode
                label="Item Modifiers"
                nodeKey="itemModifiers"
                nodeType="itemModifiersSection"
                nodeId="itemModifiers"
                icon={<span>‚öôÔ∏è</span>}
                badge={
                  <span className="text-xs text-gray-400">
                    {itemOwnedGroups.length > 0
                      ? `${itemOwnedGroups.length} group${itemOwnedGroups.length !== 1 ? 's' : ''} ¬∑ ${itemOwnedGroups.reduce((sum, g) => sum + g.modifiers.length, 0)} option${itemOwnedGroups.reduce((sum, g) => sum + g.modifiers.length, 0) !== 1 ? 's' : ''}`
                      : '0'}
                  </span>
                }
              >
                {itemOwnedGroups.length === 0 ? (
                  <div className="py-1 px-4 text-xs text-gray-400 italic">None</div>
                ) : (
                  itemOwnedGroups.map(group => renderModifierGroup(group, 1))
                )}
              </TreeNode>

              {/* Shared Modifier Groups Branch */}
              {sharedGroups.length > 0 && (
                <TreeNode
                  label="Shared Modifiers"
                  nodeKey="sharedModifiers"
                  nodeType="sharedModifiersSection"
                  nodeId="sharedModifiers"
                  icon={<span>üîó</span>}
                  badge={
                    <span className="text-xs text-gray-400">{sharedGroups.length}</span>
                  }
                >
                  {sharedGroups.map(group => (
                    <TreeNode
                      key={group.id}
                      label={group.displayName || group.name}
                      nodeKey={`shared-${group.id}`}
                      nodeType="sharedModifierGroup"
                      nodeId={group.id}
                      depth={1}
                      badge={
                        <span className="text-xs text-gray-400">{group.modifiers.length}</span>
                      }
                    >
                      {group.modifiers.map(mod => (
                        <TreeNode
                          key={mod.id}
                          label={mod.name}
                          nodeKey={`shared-${group.id}-mod-${mod.id}`}
                          isLeaf
                          depth={2}
                          badge={
                            mod.price > 0 ? (
                              <span className="text-xs text-green-600">+{formatCurrency(mod.price)}</span>
                            ) : null
                          }
                        />
                      ))}
                    </TreeNode>
                  ))}
                </TreeNode>
              )}

              {/* Print Routing Branch */}
              <TreeNode
                label="Print Routing"
                nodeKey="printing"
                nodeType="printingSection"
                nodeId="printing"
                icon={<span>üñ®Ô∏è</span>}
              >
                {!item.printerIds || item.printerIds.length === 0 ? (
                  <div className="py-1 px-4 text-xs text-gray-400 italic">Category default</div>
                ) : (
                  <div className="py-1 px-4 text-xs text-gray-500">
                    {item.printerIds.length} printer(s) configured
                  </div>
                )}
              </TreeNode>
            </TreeNode>
          </div>
        )}
      </div>
    </div>
  )
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/(admin)/menu/page.tsx
LINES:     2150
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { useAuthStore } from '@/stores/auth-store'
import { formatCurrency } from '@/lib/utils'
import { ItemTreeView } from '@/components/menu/ItemTreeView'
import { ItemEditor } from '@/components/menu/ItemEditor'
import { ModifierFlowEditor } from '@/components/menu/ModifierFlowEditor'
import { AdminPageHeader } from '@/components/admin/AdminPageHeader'
import { AdminSubNav, menuSubNav } from '@/components/admin/AdminSubNav'

// Category types for reporting and item builder selection
const CATEGORY_TYPES = [
  { value: 'food', label: 'Food', color: '#22c55e', description: 'Kitchen items, appetizers, entrees' },
  { value: 'drinks', label: 'Drinks', color: '#3b82f6', description: 'Non-alcoholic beverages' },
  { value: 'liquor', label: 'Liquor', color: '#8b5cf6', description: 'Beer, wine, spirits' },
  { value: 'pizza', label: 'Pizza', color: '#ef4444', description: 'Pizza items with sectional toppings builder' },
  { value: 'entertainment', label: 'Entertainment', color: '#f97316', description: 'Pool tables, darts, games - timed billing' },
  { value: 'combos', label: 'Combos', color: '#ec4899', description: 'Bundled items' },
]

interface Category {
  id: string
  name: string
  color: string
  categoryType: string
  categoryShow: string // 'bar' | 'food' | 'entertainment' | 'all'
  itemCount: number
  isActive: boolean
  printerIds?: string[] | null
}

// Bartender view section options
const CATEGORY_SHOW_OPTIONS = [
  { value: 'bar', label: 'Bar', color: '#3b82f6', description: 'Shows in Bar section only' },
  { value: 'food', label: 'Food', color: '#f97316', description: 'Shows in Food section only' },
  { value: 'entertainment', label: 'Entertainment', color: '#8b5cf6', description: 'Shows in Entertainment mode' },
  { value: 'all', label: 'All', color: '#22c55e', description: 'Shows in both Bar and Food sections' },
]

interface Printer {
  id: string
  name: string
  printerRole: 'receipt' | 'kitchen' | 'bar'
  isActive: boolean
}

interface KDSScreen {
  id: string
  name: string
  screenType: 'kds' | 'entertainment'
  isActive: boolean
}

// Combined type for print destinations (printers + KDS screens)
interface PrintDestination {
  id: string
  name: string
  type: 'printer' | 'kds'
  role?: string
  isActive: boolean
}

interface MenuItem {
  id: string
  name: string
  price: number
  categoryId: string
  description?: string
  isActive: boolean
  isAvailable: boolean
  itemType?: string
  timedPricing?: { per15Min?: number; per30Min?: number; perHour?: number; minimum?: number } | null
  minimumMinutes?: number | null
  modifierGroupCount?: number
  modifierGroups?: { id: string; showOnline: boolean }[]
  commissionType?: string | null
  commissionValue?: number | null
  // Liquor Builder fields
  isLiquorItem?: boolean
  hasRecipe?: boolean
  recipeIngredientCount?: number
  totalPourCost?: number | null
  profitMargin?: number | null
  // Pour size options (new format with labels)
  pourSizes?: Record<string, number | { label: string; multiplier: number }> | null
  defaultPourSize?: string | null
  applyPourToModifiers?: boolean
  // Entertainment fields
  entertainmentStatus?: 'available' | 'in_use' | 'maintenance' | null
  currentOrderId?: string | null
  blockTimeMinutes?: number | null
  // Printer routing
  printerIds?: string[] | null
  backupPrinterIds?: string[] | null
  // Combo print mode
  comboPrintMode?: 'individual' | 'primary' | 'all' | null
}

interface ModifierGroup {
  id: string
  name: string
  displayName?: string
  modifierTypes: string[]
  minSelections: number
  maxSelections: number
  isRequired: boolean
  modifiers: { id: string; name: string; price: number }[]
}

interface IngredientLibraryItem {
  id: string
  name: string
  category: string | null          // legacy string field
  categoryName: string | null      // NEW: from categoryRelation.name
  parentIngredientId: string | null // NEW: to identify child items
  allowNo: boolean
  allowLite: boolean
  allowOnSide: boolean
  allowExtra: boolean
  extraPrice: number
  allowSwap: boolean
  swapModifierGroupId: string | null
  swapUpcharge: number
}

interface MenuItemIngredient {
  id: string
  ingredientId: string
  name: string
  category: string | null
  isIncluded: boolean
  sortOrder: number
  extraPrice: number
  allowNo: boolean
  allowLite: boolean
  allowOnSide: boolean
  allowExtra: boolean
  allowSwap: boolean
  swapUpcharge: number
}

// Modifier type definitions for filtering
const MODIFIER_TYPES = [
  { value: 'universal', label: 'Universal', color: '#6b7280' },
  { value: 'food', label: 'Food', color: '#22c55e' },
  { value: 'liquor', label: 'Liquor', color: '#8b5cf6' },
  { value: 'retail', label: 'Retail', color: '#f59e0b' },
  { value: 'entertainment', label: 'Entertainment', color: '#f97316' },
  { value: 'combo', label: 'Combo', color: '#ec4899' },
]

// Map category types to their primary modifier type
const CATEGORY_TO_MODIFIER_TYPE: Record<string, string> = {
  food: 'food',
  drinks: 'food',
  liquor: 'liquor',
  entertainment: 'entertainment',
  combos: 'combo',
  retail: 'retail',
}

// Pour size configurations for liquor items
const DEFAULT_POUR_SIZES: Record<string, { label: string; multiplier: number }> = {
  standard: { label: 'Standard Pour', multiplier: 1.0 },
  shot: { label: 'Shot', multiplier: 1.0 },
  double: { label: 'Double', multiplier: 2.0 },
  tall: { label: 'Tall', multiplier: 1.5 },
  short: { label: 'Short', multiplier: 0.75 },
}

// Helper to convert old format (Record<string, number>) to new format
function normalizePourSizes(data: Record<string, number | { label: string; multiplier: number }> | null): Record<string, { label: string; multiplier: number }> {
  // Return empty object if no data - nothing selected by default
  if (!data) return {}

  const result: Record<string, { label: string; multiplier: number }> = {}
  for (const [key, value] of Object.entries(data)) {
    if (typeof value === 'number') {
      // Old format: just a multiplier number
      result[key] = {
        label: DEFAULT_POUR_SIZES[key]?.label || key.charAt(0).toUpperCase() + key.slice(1),
        multiplier: value
      }
    } else {
      // New format: { label, multiplier }
      result[key] = value
    }
  }
  return result
}

export default function MenuManagementPage() {
  const router = useRouter()
  const { employee, isAuthenticated } = useAuthStore()
  const [categories, setCategories] = useState<Category[]>([])
  const [items, setItems] = useState<MenuItem[]>([])
  const [modifierGroups, setModifierGroups] = useState<ModifierGroup[]>([])
  const [ingredientsLibrary, setIngredientsLibrary] = useState<IngredientLibraryItem[]>([])
  const [printers, setPrinters] = useState<Printer[]>([])
  const [kdsScreens, setKdsScreens] = useState<KDSScreen[]>([])
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [showCategoryModal, setShowCategoryModal] = useState(false)
  const [showItemModal, setShowItemModal] = useState(false)
  const [editingCategory, setEditingCategory] = useState<Category | null>(null)
  const [editingItem, setEditingItem] = useState<MenuItem | null>(null)
  const [selectedItemForEditor, setSelectedItemForEditor] = useState<MenuItem | null>(null)
  const [selectedTreeNode, setSelectedTreeNode] = useState<{ type: string; id: string } | null>(null)
  const [refreshKey, setRefreshKey] = useState(0)
  const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null)
  const [dragOverItemId, setDragOverItemId] = useState<string | null>(null)

  // Refs for scroll containers
  const categoriesScrollRef = useRef<HTMLDivElement>(null)
  const itemsScrollRef = useRef<HTMLDivElement>(null)

  // Define loadMenu first so it can be used in useEffects
  const loadMenu = useCallback(async () => {
    try {
      // Add cache-busting for fresh entertainment status
      const timestamp = Date.now()

      const locationId = employee?.location?.id
      const [menuResponse, modifiersResponse, ingredientsResponse, printersResponse, kdsResponse] = await Promise.all([
        fetch(`/api/menu?_t=${timestamp}`, {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
          }
        }),
        fetch('/api/menu/modifiers'),
        locationId ? fetch(`/api/ingredients?locationId=${locationId}`) : Promise.resolve(null),
        locationId ? fetch(`/api/hardware/printers?locationId=${locationId}`) : Promise.resolve(null),
        locationId ? fetch(`/api/hardware/kds-screens?locationId=${locationId}`) : Promise.resolve(null)
      ])

      if (menuResponse.ok) {
        const data = await menuResponse.json()
        // Filter out liquor and drinks categories - they belong in Liquor Builder
        const foodCategories = data.categories.filter((c: Category) =>
          c.categoryType !== 'liquor' && c.categoryType !== 'drinks'
        )
        setCategories(foodCategories)
        // Force new array reference to ensure React re-renders
        setItems([...data.items])
      }

      if (modifiersResponse.ok) {
        const modData = await modifiersResponse.json()
        setModifierGroups(modData.modifierGroups)
      }

      if (ingredientsResponse?.ok) {
        const ingData = await ingredientsResponse.json()
        const ingredients = (ingData.data || []).map((ing: any) => ({
          ...ing,
          categoryName: ing.categoryRelation?.name || ing.category || null,
        }))
        setIngredientsLibrary(ingredients)
      }

      if (printersResponse?.ok) {
        const printerData = await printersResponse.json()
        setPrinters(printerData.printers || [])
      }

      if (kdsResponse?.ok) {
        const kdsData = await kdsResponse.json()
        setKdsScreens(kdsData.screens || [])
      }
    } catch (error) {
      console.error('Failed to load menu:', error)
    } finally {
      setIsLoading(false)
    }
  }, [employee?.location?.id])

  // Create ref to avoid stale closures
  const loadMenuRef = useRef(loadMenu)
  loadMenuRef.current = loadMenu

  // Initial load
  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/login?redirect=/menu')
      return
    }
    loadMenuRef.current()
  }, [isAuthenticated, router])

  // Refresh menu when switching categories (especially for entertainment status updates)
  useEffect(() => {
    if (selectedCategory) {
      loadMenuRef.current()
    }
  }, [selectedCategory])

  // Auto-refresh when viewing entertainment category (for real-time status updates)
  const selectedCategoryType = categories.find(c => c.id === selectedCategory)?.categoryType
  useEffect(() => {
    if (selectedCategoryType !== 'entertainment') return

    // Poll every 3 seconds for entertainment status changes
    const interval = setInterval(() => {
      loadMenuRef.current()
    }, 3000)

    // Also refresh on visibility/focus changes
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        loadMenuRef.current()
      }
    }
    const handleFocus = () => {
      loadMenuRef.current()
    }

    document.addEventListener('visibilitychange', handleVisibilityChange)
    window.addEventListener('focus', handleFocus)

    return () => {
      clearInterval(interval)
      document.removeEventListener('visibilitychange', handleVisibilityChange)
      window.removeEventListener('focus', handleFocus)
    }
  }, [selectedCategoryType])

  // Handler for cross-item modifier group copy
  const handleCopyModifierGroup = async (groupId: string, sourceItemId: string, targetItemId: string, groupName: string) => {
    try {
      const response = await fetch(`/api/menu/items/${targetItemId}/modifier-groups`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          duplicateFromGroupId: groupId,
          copyFromItemId: sourceItemId,
        }),
      })

      if (response.ok) {
        // Show success toast
        const targetItem = items.find(i => i.id === targetItemId)
        console.log(`‚úì Copied "${groupName}" to "${targetItem?.name}"`)

        // Refresh menu
        await loadMenu()
        setRefreshKey(prev => prev + 1)

        // If the target item is currently selected, refresh will show the new group
      } else {
        console.error('Failed to copy modifier group')
      }
    } catch (error) {
      console.error('Error copying modifier group:', error)
    }
  }

  const handleSaveCategory = async (categoryData: Partial<Category>) => {
    try {
      const method = editingCategory ? 'PUT' : 'POST'
      const url = editingCategory
        ? `/api/menu/categories/${editingCategory.id}`
        : '/api/menu/categories'

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(categoryData),
      })

      if (response.ok) {
        loadMenu()
        setShowCategoryModal(false)
        setEditingCategory(null)
      }
    } catch (error) {
      console.error('Failed to save category:', error)
    }
  }

  const handleSaveItem = async (itemData: Omit<Partial<MenuItem>, 'modifierGroups'> & { modifierGroups?: { id: string; showOnline: boolean }[]; ingredientIds?: { ingredientId: string; isIncluded?: boolean }[] }) => {
    try {
      const method = editingItem ? 'PUT' : 'POST'
      const url = editingItem
        ? `/api/menu/items/${editingItem.id}`
        : '/api/menu/items'

      const { modifierGroups: modifierGroupsData, ingredientIds, ...itemFields } = itemData

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...itemFields, categoryId: selectedCategory }),
      })

      if (response.ok) {
        const savedItem = await response.json()
        const itemId = editingItem?.id || savedItem.id

        // Save modifier group links if provided (new format with showOnline)
        if (modifierGroupsData !== undefined && itemId) {
          await fetch(`/api/menu/items/${itemId}/modifiers`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ modifierGroups: modifierGroupsData }),
          })
        }

        // Save ingredient links if provided
        if (ingredientIds !== undefined && itemId) {
          await fetch(`/api/menu/items/${itemId}/ingredients`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ingredients: ingredientIds }),
          })
        }

        loadMenu()
        setShowItemModal(false)
        setEditingItem(null)
      }
    } catch (error) {
      console.error('Failed to save item:', error)
    }
  }

  const handleDeleteCategory = async (id: string) => {
    if (!confirm('Delete this category and all its items?')) return
    try {
      await fetch(`/api/menu/categories/${id}`, { method: 'DELETE' })
      loadMenu()
      if (selectedCategory === id) {
        setSelectedCategory(categories[0]?.id || null)
      }
    } catch (error) {
      console.error('Failed to delete category:', error)
    }
  }

  const handleDeleteItem = async (id: string) => {
    if (!confirm('Delete this item?')) return
    try {
      await fetch(`/api/menu/items/${id}`, { method: 'DELETE' })
      loadMenu()
    } catch (error) {
      console.error('Failed to delete item:', error)
    }
  }

  const handleToggleItem86 = async (item: MenuItem) => {
    try {
      await fetch(`/api/menu/items/${item.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ isAvailable: !item.isAvailable }),
      })
      loadMenu()
    } catch (error) {
      console.error('Failed to toggle 86:', error)
    }
  }

  const filteredItems = items.filter(item => item.categoryId === selectedCategory)
  const selectedCategoryData = categories.find(c => c.id === selectedCategory)

  if (!isAuthenticated) return null

  return (
    <div className="h-screen bg-gray-100 flex flex-col overflow-hidden">
      {/* Header - compact: override mb-6 from shared components */}
      <div className="bg-white border-b shrink-0 px-4 py-1 [&>div]:!mb-1 [&>.flex]:!mb-1">
        <AdminPageHeader
          title="Menu Items"
          backHref="/orders"
        />
        <AdminSubNav items={menuSubNav} basePath="/menu" />
      </div>

      {/* Categories Bar - Horizontal Scroll */}
      <div className="bg-white border-b px-4 py-1.5 shrink-0">
        <div className="flex items-center gap-2 mb-1">
          <span className="text-xs font-medium text-gray-500">Categories</span>
          <Button
            variant="ghost"
            size="sm"
            className="text-blue-600 h-6 text-xs px-2"
            onClick={() => {
              setEditingCategory(null)
              setShowCategoryModal(true)
            }}
          >
            + Add
          </Button>
        </div>
        <div
          ref={categoriesScrollRef}
          className="flex gap-1.5 overflow-x-auto pb-1 scrollbar-thin scrollbar-thumb-gray-300"
        >
          {isLoading ? (
            <div className="text-gray-400 py-2">Loading...</div>
          ) : categories.length === 0 ? (
            <div className="text-gray-400 py-2">No categories - click + Add to create one</div>
          ) : (
            categories.map(category => {
              const typeInfo = CATEGORY_TYPES.find(t => t.value === category.categoryType)
              const isSelected = selectedCategory === category.id
              return (
                <button
                  key={category.id}
                  onClick={() => {
                    setSelectedCategory(category.id)
                    setSelectedItemForEditor(null)
                    setSelectedGroupId(null)
                  }}
                  className={`shrink-0 px-3 py-1.5 rounded-lg border-2 transition-all flex items-center gap-1.5 text-sm ${
                    isSelected
                      ? 'border-blue-500 bg-blue-50'
                      : 'border-transparent bg-gray-100 hover:bg-gray-200'
                  }`}
                >
                  <div
                    className="w-3 h-3 rounded"
                    style={{ backgroundColor: category.color }}
                  />
                  <span className={`font-medium whitespace-nowrap ${isSelected ? 'text-blue-700' : ''}`}>
                    {category.name}
                  </span>
                  <span className={`text-sm ${isSelected ? 'text-blue-500' : 'text-gray-400'}`}>
                    ({category.itemCount})
                  </span>
                  {isSelected && (
                    <span
                      role="button"
                      tabIndex={0}
                      onClick={(e) => {
                        e.stopPropagation()
                        setEditingCategory(category)
                        setShowCategoryModal(true)
                      }}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                          e.stopPropagation()
                          setEditingCategory(category)
                          setShowCategoryModal(true)
                        }
                      }}
                      className="ml-1 p-1 hover:bg-blue-100 rounded cursor-pointer"
                    >
                      <svg className="w-3 h-3 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                      </svg>
                    </span>
                  )}
                </button>
              )
            })
          )}
        </div>
      </div>

      {/* Items Bar - Horizontal Scroll */}
      {selectedCategory && (
        <div className="bg-white border-b px-4 py-1.5 shrink-0">
          <div className="flex items-center gap-2 mb-1">
            <span className="text-xs font-medium text-gray-500">
              {selectedCategoryData?.name} Items
            </span>
            {selectedCategoryData?.categoryType === 'liquor' && (
              <span className="text-xs bg-purple-100 text-purple-700 px-2 py-0.5 rounded-full">
                ‚Üí Opens in Liquor Builder
              </span>
            )}
            {selectedCategoryData?.categoryType === 'entertainment' && (
              <span className="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded-full">
                ‚Üí Opens in Entertainment Builder
              </span>
            )}
            <Button
              variant="ghost"
              size="sm"
              className="text-blue-600 h-6 text-xs px-2"
              onClick={() => {
                // Route liquor categories to the Liquor Builder
                if (selectedCategoryData?.categoryType === 'liquor') {
                  router.push('/liquor-builder')
                } else if (selectedCategoryData?.categoryType === 'entertainment') {
                  router.push('/timed-rentals')
                } else {
                  setEditingItem(null)
                  setShowItemModal(true)
                }
              }}
            >
              + Add Item
            </Button>
          </div>
          <div
            ref={itemsScrollRef}
            className="flex gap-2 overflow-x-auto pb-1 scrollbar-thin scrollbar-thumb-gray-300"
          >
            {filteredItems.length === 0 ? (
              <div className="text-gray-400 py-2">No items - click + Add Item to create one</div>
            ) : (
              filteredItems.map(item => {
                const isSelected = selectedItemForEditor?.id === item.id
                return (
                  <button
                    key={item.id}
                    onClick={() => {
                      // Route liquor items to the Liquor Builder
                      if (selectedCategoryData?.categoryType === 'liquor') {
                        router.push(`/liquor-builder?item=${item.id}`)
                      } else if (selectedCategoryData?.categoryType === 'entertainment') {
                        router.push(`/timed-rentals?item=${item.id}`)
                      } else {
                        setSelectedItemForEditor(item)
                        setSelectedGroupId(null)
                      }
                    }}
                    onDragOver={(e) => {
                      // Only accept modifier group drags
                      if (e.dataTransfer.types.includes('application/x-modifier-group')) {
                        e.preventDefault()
                        e.dataTransfer.dropEffect = 'copy'
                        setDragOverItemId(item.id)
                      }
                    }}
                    onDragLeave={() => {
                      setDragOverItemId(null)
                    }}
                    onDrop={(e) => {
                      e.preventDefault()
                      setDragOverItemId(null)
                      const data = e.dataTransfer.getData('application/x-modifier-group')
                      if (data) {
                        const { groupId, sourceItemId, groupName } = JSON.parse(data)
                        if (sourceItemId !== item.id) {
                          // Call the cross-item copy handler
                          handleCopyModifierGroup(groupId, sourceItemId, item.id, groupName)
                        }
                      }
                    }}
                    className={`shrink-0 px-3 py-1.5 rounded-lg border-2 transition-all text-left min-w-[120px] ${
                      dragOverItemId === item.id
                        ? 'ring-2 ring-indigo-400 bg-indigo-50'
                        : isSelected
                        ? 'border-blue-500 bg-blue-50'
                        : !item.isAvailable
                        ? 'border-transparent bg-gray-100 opacity-50'
                        : 'border-transparent bg-gray-100 hover:bg-gray-200'
                    }`}
                  >
                    <div className="flex items-center justify-between gap-1">
                      <span className={`font-medium text-xs ${isSelected ? 'text-blue-700' : ''}`}>
                        {item.name}
                      </span>
                      {!item.isAvailable && (
                        <span className="text-[9px] bg-red-100 text-red-700 px-1 rounded">86</span>
                      )}
                    </div>
                    <div className="flex items-center gap-2">
                      <span className={`text-xs font-bold ${isSelected ? 'text-blue-600' : 'text-green-600'}`}>
                        {formatCurrency(item.price)}
                      </span>
                      {item.modifierGroupCount && item.modifierGroupCount > 0 && (
                        <span className="text-[9px] text-purple-600">
                          {item.modifierGroupCount} mod
                        </span>
                      )}
                    </div>
                    {item.itemType === 'timed_rental' && (
                      <div className={`text-[9px] ${
                        item.entertainmentStatus === 'in_use' ? 'text-red-600' : 'text-green-600'
                      }`}>
                        {item.entertainmentStatus === 'in_use' ? '‚óè IN USE' : '‚óè AVAILABLE'}
                      </div>
                    )}
                  </button>
                )
              })
            )}
          </div>
        </div>
      )}

      {/* Main Content Area - 3 Columns: Tree View + Editor + Modifier Groups Builder */}
      <div className="flex-1 flex overflow-hidden">
        {/* LEFT: Tree View - Navigation map */}
        <div className={`shrink-0 transition-all duration-300 overflow-hidden ${
          selectedItemForEditor ? 'w-56' : 'w-0'
        }`}>
          <ItemTreeView
            item={selectedItemForEditor}
            refreshKey={refreshKey}
            selectedNode={selectedTreeNode}
            onSelectNode={(type, id) => setSelectedTreeNode({ type, id })}
          />
        </div>

        {/* CENTER: Item Editor (what's live on the front end) */}
        <div className="flex-1 overflow-hidden border-l">
          {!selectedCategory ? (
            <div className="h-full flex items-center justify-center text-gray-400 bg-gray-50">
              <div className="text-center">
                <svg className="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                </svg>
                <p className="font-medium">Select a category</p>
                <p className="text-xs mt-1">Click on a category above</p>
              </div>
            </div>
          ) : !selectedItemForEditor ? (
            <div className="h-full flex items-center justify-center text-gray-400 bg-gray-50">
              <div className="text-center">
                <svg className="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                </svg>
                <p className="font-medium">Select an item</p>
                <p className="text-xs mt-1">Click on an item above</p>
              </div>
            </div>
          ) : (
            <ItemEditor
              item={selectedItemForEditor}
              ingredientsLibrary={ingredientsLibrary}
              refreshKey={refreshKey}
              onSelectGroup={setSelectedGroupId}
              onItemUpdated={() => {
                loadMenu()
                setRefreshKey(prev => prev + 1)
              }}
              onToggle86={handleToggleItem86}
              onDelete={(itemId) => {
                handleDeleteItem(itemId)
                setSelectedItemForEditor(null)
                setSelectedGroupId(null)
              }}
            />
          )}
        </div>

        {/* RIGHT: Modifier Flow Editor */}
        <div className={`shrink-0 transition-all duration-300 overflow-hidden border-l ${
          selectedItemForEditor ? 'w-96' : 'w-0'
        }`}>
          <ModifierFlowEditor
            item={selectedItemForEditor}
            selectedGroupId={selectedGroupId}
            refreshKey={refreshKey}
            onGroupUpdated={() => {
              loadMenu()
              setRefreshKey(prev => prev + 1)
            }}
          />
        </div>
      </div>

      {/* Category Modal */}
      {showCategoryModal && (
        <CategoryModal
          category={editingCategory}
          printers={printers}
          kdsScreens={kdsScreens}
          onSave={handleSaveCategory}
          onClose={() => {
            setShowCategoryModal(false)
            setEditingCategory(null)
          }}
        />
      )}

      {/* Item Modal */}
      {showItemModal && selectedCategoryData && (
        <ItemModal
          item={editingItem}
          categoryType={selectedCategoryData.categoryType}
          modifierGroups={modifierGroups}
          ingredientsLibrary={ingredientsLibrary}
          printers={printers}
          kdsScreens={kdsScreens}
          locationId={employee?.location?.id || ''}
          onSave={handleSaveItem}
          onClose={() => {
            setShowItemModal(false)
            setEditingItem(null)
          }}
        />
      )}
    </div>
  )
}

// Category Modal Component
function CategoryModal({
  category,
  printers,
  kdsScreens,
  onSave,
  onClose
}: {
  category: Category | null
  printers: Printer[]
  kdsScreens: KDSScreen[]
  onSave: (data: Partial<Category>) => void
  onClose: () => void
}) {
  const [name, setName] = useState(category?.name || '')
  const [color, setColor] = useState(category?.color || '#3b82f6')
  const [categoryType, setCategoryType] = useState(category?.categoryType || 'food')
  const [printerIds, setPrinterIds] = useState<string[]>(category?.printerIds || [])
  const [isDropdownOpen, setIsDropdownOpen] = useState(false)

  // Combine printers and KDS screens into destinations
  const printDestinations: PrintDestination[] = [
    ...printers.filter(p => p.isActive).map(p => ({
      id: p.id,
      name: p.name,
      type: 'printer' as const,
      role: p.printerRole,
      isActive: p.isActive
    })),
    ...kdsScreens.filter(k => k.isActive).map(k => ({
      id: k.id,
      name: k.name,
      type: 'kds' as const,
      role: k.screenType,
      isActive: k.isActive
    }))
  ]

  const selectedDestinations = printDestinations.filter(d => printerIds.includes(d.id))

  const colors = [
    '#ef4444', '#f97316', '#eab308', '#22c55e',
    '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280'
  ]

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>{category ? 'Edit Category' : 'New Category'}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">Name</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="e.g., Appetizers"
              autoFocus
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Category Type</label>
            <div className="space-y-2">
              {CATEGORY_TYPES.map(type => (
                <label
                  key={type.value}
                  className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer border-2 transition-all ${
                    categoryType === type.value
                      ? 'border-blue-500 bg-blue-50'
                      : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <input
                    type="radio"
                    name="categoryType"
                    value={type.value}
                    checked={categoryType === type.value}
                    onChange={(e) => setCategoryType(e.target.value)}
                    className="w-4 h-4"
                  />
                  <div
                    className="w-4 h-4 rounded"
                    style={{ backgroundColor: type.color }}
                  />
                  <div className="flex-1">
                    <p className="font-medium text-sm">{type.label}</p>
                    <p className="text-xs text-gray-500">{type.description}</p>
                  </div>
                </label>
              ))}
            </div>
          </div>

          {/* Print Destinations - Multiple (Dropdown with checkboxes) */}
          {printDestinations.length > 0 && (
            <div className="relative">
              <label className="block text-sm font-medium mb-2">Default Print Destinations</label>
              <button
                type="button"
                onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                className="w-full px-3 py-2 border rounded-lg text-left flex items-center justify-between bg-white hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <span className={selectedDestinations.length === 0 ? 'text-gray-500' : ''}>
                  {selectedDestinations.length === 0
                    ? 'Select destinations...'
                    : selectedDestinations.map(d => d.name).join(', ')}
                </span>
                <span className="text-gray-400">{isDropdownOpen ? '‚ñ≤' : '‚ñº'}</span>
              </button>

              {isDropdownOpen && (
                <div className="absolute z-10 mt-1 w-full bg-white border rounded-lg shadow-lg max-h-60 overflow-auto">
                  {printDestinations.length === 0 ? (
                    <div className="px-3 py-2 text-gray-500 text-sm">No destinations available</div>
                  ) : (
                    <>
                      {printers.filter(p => p.isActive).length > 0 && (
                        <div className="px-3 py-1 text-xs font-semibold text-gray-500 bg-gray-50 border-b">
                          Printers
                        </div>
                      )}
                      {printers.filter(p => p.isActive).map(printer => (
                        <label
                          key={printer.id}
                          className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer"
                        >
                          <input
                            type="checkbox"
                            checked={printerIds.includes(printer.id)}
                            onChange={() => {
                              setPrinterIds(prev =>
                                prev.includes(printer.id)
                                  ? prev.filter(id => id !== printer.id)
                                  : [...prev, printer.id]
                              )
                            }}
                            className="w-4 h-4 rounded border-gray-300 text-blue-500 focus:ring-blue-500"
                          />
                          <span className="flex-1">{printer.name}</span>
                          <span className="text-xs text-gray-400">{printer.printerRole}</span>
                        </label>
                      ))}
                      {kdsScreens.filter(k => k.isActive).length > 0 && (
                        <div className="px-3 py-1 text-xs font-semibold text-gray-500 bg-gray-50 border-b border-t">
                          KDS Screens
                        </div>
                      )}
                      {kdsScreens.filter(k => k.isActive).map(screen => (
                        <label
                          key={screen.id}
                          className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer"
                        >
                          <input
                            type="checkbox"
                            checked={printerIds.includes(screen.id)}
                            onChange={() => {
                              setPrinterIds(prev =>
                                prev.includes(screen.id)
                                  ? prev.filter(id => id !== screen.id)
                                  : [...prev, screen.id]
                              )
                            }}
                            className="w-4 h-4 rounded border-gray-300 text-blue-500 focus:ring-blue-500"
                          />
                          <span className="flex-1">{screen.name}</span>
                          <span className="text-xs text-gray-400">{screen.screenType}</span>
                        </label>
                      ))}
                    </>
                  )}
                </div>
              )}
              <p className="text-xs text-gray-500 mt-1">
                {printerIds.length === 0
                  ? 'Using system default'
                  : `Sending to ${printerIds.length} destination(s)`}
              </p>
            </div>
          )}

          <div>
            <label className="block text-sm font-medium mb-2">Color</label>
            <div className="flex gap-2 flex-wrap">
              {colors.map(c => (
                <button
                  key={c}
                  type="button"
                  className={`w-10 h-10 rounded-lg ${color === c ? 'ring-2 ring-offset-2 ring-blue-500' : ''}`}
                  style={{ backgroundColor: c }}
                  onClick={() => setColor(c)}
                />
              ))}
            </div>
          </div>

          <div className="flex gap-2 pt-4">
            <Button variant="outline" className="flex-1" onClick={onClose}>
              Cancel
            </Button>
            <Button
              variant="primary"
              className="flex-1"
              disabled={!name.trim()}
              onClick={() => onSave({ name, color, categoryType, printerIds: printerIds.length > 0 ? printerIds : null })}
            >
              {category ? 'Save Changes' : 'Create Category'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

// Item Modal Component
function ItemModal({
  item,
  categoryType,
  modifierGroups,
  ingredientsLibrary,
  printers,
  kdsScreens,
  locationId,
  onSave,
  onClose
}: {
  item: MenuItem | null
  categoryType: string
  modifierGroups: ModifierGroup[]
  ingredientsLibrary: IngredientLibraryItem[]
  printers: Printer[]
  kdsScreens: KDSScreen[]
  locationId: string
  onSave: (data: Omit<Partial<MenuItem>, 'modifierGroups'> & { modifierGroups?: { id: string; showOnline: boolean }[]; ingredientIds?: { ingredientId: string; isIncluded?: boolean }[] }) => void
  onClose: () => void
}) {
  const [name, setName] = useState(item?.name || '')
  const [price, setPrice] = useState(item?.price?.toString() || '')
  const [description, setDescription] = useState(item?.description || '')
  const [commissionType, setCommissionType] = useState<string>(item?.commissionType || '')
  const [commissionValue, setCommissionValue] = useState<string>(
    item?.commissionValue?.toString() || ''
  )
  const [printerIds, setPrinterIds] = useState<string[]>(item?.printerIds || [])
  const [backupPrinterIds, setBackupPrinterIds] = useState<string[]>(item?.backupPrinterIds || [])
  const [comboPrintMode, setComboPrintMode] = useState<'individual' | 'primary' | 'all'>(item?.comboPrintMode || 'individual')
  const [isPrinterDropdownOpen, setIsPrinterDropdownOpen] = useState(false)
  const [isBackupDropdownOpen, setIsBackupDropdownOpen] = useState(false)

  // Combine printers and KDS screens into destinations
  const printDestinations: PrintDestination[] = [
    ...printers.filter(p => p.isActive).map(p => ({
      id: p.id,
      name: p.name,
      type: 'printer' as const,
      role: p.printerRole,
      isActive: p.isActive
    })),
    ...kdsScreens.filter(k => k.isActive).map(k => ({
      id: k.id,
      name: k.name,
      type: 'kds' as const,
      role: k.screenType,
      isActive: k.isActive
    }))
  ]

  const selectedDestinations = printDestinations.filter(d => printerIds.includes(d.id))
  const selectedBackupDestinations = printDestinations.filter(d => backupPrinterIds.includes(d.id))
  const [selectedModifierGroups, setSelectedModifierGroups] = useState<{ id: string; showOnline: boolean }[]>(
    item?.modifierGroups?.map(g => ({ id: g.id, showOnline: true })) || []
  )
  const [isLoadingModifiers, setIsLoadingModifiers] = useState(false)

  // Ingredients state - includes pre-modifier overrides
  const [selectedIngredients, setSelectedIngredients] = useState<{
    ingredientId: string
    isIncluded: boolean
    allowNo?: boolean
    allowLite?: boolean
    allowExtra?: boolean
    allowOnSide?: boolean
  }[]>([])
  const [isLoadingIngredients, setIsLoadingIngredients] = useState(false)
  const [showIngredientPicker, setShowIngredientPicker] = useState(false)

  // Modifier type filters - for liquor, default to liquor only; others get primary + universal
  const primaryModType = CATEGORY_TO_MODIFIER_TYPE[categoryType] || 'food'
  const isLiquorCategory = categoryType === 'liquor'
  const isComboCategory = categoryType === 'combos'
  const [enabledModifierTypes, setEnabledModifierTypes] = useState<string[]>(
    isLiquorCategory ? ['liquor'] :
    isComboCategory ? ['universal', 'combo', 'food'] : // Combos can use food modifiers too
    ['universal', primaryModType]
  )

  // Filter modifier groups by enabled types (check if any of group's types match enabled types)
  const filteredModifierGroups = modifierGroups.filter(
    group => {
      const groupTypes = group.modifierTypes || ['universal']
      return groupTypes.some(type => enabledModifierTypes.includes(type))
    }
  )

  // Pour size options for liquor items - now stores { label, multiplier } for each
  const [enabledPourSizes, setEnabledPourSizes] = useState<Record<string, { label: string; multiplier: number }>>(
    normalizePourSizes(item?.pourSizes as Record<string, number | { label: string; multiplier: number }> | null)
  )
  const [defaultPourSize, setDefaultPourSize] = useState(item?.defaultPourSize || 'standard')
  const [applyPourToModifiers, setApplyPourToModifiers] = useState(item?.applyPourToModifiers || false)

  // Timed pricing for entertainment items
  const [isTimedItem, setIsTimedItem] = useState(item?.itemType === 'timed_rental')
  const [per15Min, setPer15Min] = useState(item?.timedPricing?.per15Min?.toString() || '')
  const [per30Min, setPer30Min] = useState(item?.timedPricing?.per30Min?.toString() || '')
  const [perHour, setPerHour] = useState(item?.timedPricing?.perHour?.toString() || '')
  const [minimumMinutes, setMinimumMinutes] = useState(item?.minimumMinutes?.toString() || '15')

  // Show entertainment builder if category is entertainment OR item is already a timed rental
  const isEntertainment = categoryType === 'entertainment' || item?.itemType === 'timed_rental'

  // Load existing modifier group links when editing
  useEffect(() => {
    if (item?.id) {
      setIsLoadingModifiers(true)
      fetch(`/api/menu/items/${item.id}/modifiers`)
        .then(res => res.json())
        .then(data => {
          if (data.modifierGroups) {
            setSelectedModifierGroups(data.modifierGroups.map((g: { id: string; showOnline?: boolean }) => ({
              id: g.id,
              showOnline: g.showOnline ?? true
            })))
          }
        })
        .catch(console.error)
        .finally(() => setIsLoadingModifiers(false))
    }
  }, [item?.id])

  // Load existing ingredients when editing
  useEffect(() => {
    if (item?.id) {
      setIsLoadingIngredients(true)
      fetch(`/api/menu/items/${item.id}/ingredients`)
        .then(res => res.json())
        .then(data => {
          if (data.data) {
            setSelectedIngredients(data.data.map((ing: MenuItemIngredient) => ({
              ingredientId: ing.ingredientId,
              isIncluded: ing.isIncluded,
              allowNo: ing.allowNo,
              allowLite: ing.allowLite,
              allowExtra: ing.allowExtra,
              allowOnSide: ing.allowOnSide,
            })))
          }
        })
        .catch(console.error)
        .finally(() => setIsLoadingIngredients(false))
    }
  }, [item?.id])

  const toggleModifierGroup = (groupId: string) => {
    setSelectedModifierGroups(prev => {
      const existing = prev.find(g => g.id === groupId)
      if (existing) {
        return prev.filter(g => g.id !== groupId)
      } else {
        return [...prev, { id: groupId, showOnline: true }]
      }
    })
  }

  const toggleModifierGroupOnline = (groupId: string) => {
    setSelectedModifierGroups(prev =>
      prev.map(g => g.id === groupId ? { ...g, showOnline: !g.showOnline } : g)
    )
  }

  const selectedModifierGroupIds = selectedModifierGroups.map(g => g.id)

  const handleSave = () => {
    const timedPricing = isEntertainment && isTimedItem
      ? {
          per15Min: per15Min ? parseFloat(per15Min) : undefined,
          per30Min: per30Min ? parseFloat(per30Min) : undefined,
          perHour: perHour ? parseFloat(perHour) : undefined,
        }
      : null

    // Pour sizes only for liquor items - save in new format with labels
    const pourSizesData = isLiquorCategory && Object.keys(enabledPourSizes).length > 0
      ? enabledPourSizes
      : null

    onSave({
      name,
      price: parseFloat(price),
      description: description || undefined,
      itemType: isEntertainment && isTimedItem ? 'timed_rental' : 'standard',
      timedPricing,
      minimumMinutes: isEntertainment && isTimedItem && minimumMinutes ? parseInt(minimumMinutes) : null,
      commissionType: commissionType || null,
      commissionValue: commissionValue ? parseFloat(commissionValue) : null,
      modifierGroups: selectedModifierGroups,
      // Liquor pour sizes
      pourSizes: pourSizesData,
      defaultPourSize: isLiquorCategory ? defaultPourSize : null,
      applyPourToModifiers: isLiquorCategory ? applyPourToModifiers : false,
      // Ingredients
      ingredientIds: selectedIngredients,
      // Printer routing
      printerIds: printerIds.length > 0 ? printerIds : null,
      backupPrinterIds: backupPrinterIds.length > 0 ? backupPrinterIds : null,
      // Combo print mode
      comboPrintMode: isComboCategory ? comboPrintMode : null,
    })
  }

  const addIngredient = (ingredientId: string) => {
    if (!selectedIngredients.find(i => i.ingredientId === ingredientId)) {
      setSelectedIngredients([...selectedIngredients, { ingredientId, isIncluded: true }])
    }
    setShowIngredientPicker(false)
  }

  const removeIngredient = (ingredientId: string) => {
    setSelectedIngredients(selectedIngredients.filter(i => i.ingredientId !== ingredientId))
  }

  const toggleIngredientIncluded = (ingredientId: string) => {
    setSelectedIngredients(selectedIngredients.map(i =>
      i.ingredientId === ingredientId ? { ...i, isIncluded: !i.isIncluded } : i
    ))
  }

  const updateIngredientOption = (ingredientId: string, option: 'allowNo' | 'allowLite' | 'allowExtra' | 'allowOnSide', value: boolean) => {
    setSelectedIngredients(selectedIngredients.map(i =>
      i.ingredientId === ingredientId ? { ...i, [option]: value } : i
    ))
  }

  // Show ingredients for food and drinks items (not liquor, entertainment, combos)
  const showIngredientsSection = categoryType === 'food' || categoryType === 'drinks'

  const togglePourSize = (size: string) => {
    const newSizes = { ...enabledPourSizes }
    if (newSizes[size]) {
      delete newSizes[size]
      // If we removed the default, set a new default
      if (defaultPourSize === size && Object.keys(newSizes).length > 0) {
        setDefaultPourSize(Object.keys(newSizes)[0])
      }
    } else {
      // Add with default values
      newSizes[size] = { ...DEFAULT_POUR_SIZES[size] }
    }
    setEnabledPourSizes(newSizes)
  }

  const updatePourSizeLabel = (size: string, label: string) => {
    setEnabledPourSizes(prev => ({
      ...prev,
      [size]: { ...prev[size], label }
    }))
  }

  const updatePourSizeMultiplier = (size: string, multiplier: number) => {
    setEnabledPourSizes(prev => ({
      ...prev,
      [size]: { ...prev[size], multiplier }
    }))
  }

  const resetPourSizeToDefault = (size: string) => {
    setEnabledPourSizes(prev => ({
      ...prev,
      [size]: { ...DEFAULT_POUR_SIZES[size] }
    }))
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <Card className="w-full max-w-lg max-h-[90vh] overflow-y-auto">
        <CardHeader>
          <CardTitle>{item ? 'Edit Item' : 'New Item'}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">Name</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder={isEntertainment ? 'e.g., Pool Table 1' : 'e.g., Buffalo Wings'}
              autoFocus
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">Base Price</label>
            <div className="relative">
              <span className="absolute left-3 top-2 text-gray-500">$</span>
              <input
                type="number"
                step="0.01"
                min="0"
                value={price}
                onChange={(e) => setPrice(e.target.value)}
                className="w-full pl-7 pr-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="0.00"
              />
            </div>
          </div>

          {/* Entertainment/Timed Pricing Section */}
          {isEntertainment && (
            <div className="bg-orange-50 border border-orange-200 rounded-lg p-4">
              <label className="flex items-center gap-2 cursor-pointer mb-3">
                <input
                  type="checkbox"
                  checked={isTimedItem}
                  onChange={(e) => setIsTimedItem(e.target.checked)}
                  className="w-4 h-4"
                />
                <span className="font-medium text-orange-800">Enable Timed Billing</span>
              </label>

              {isTimedItem && (
                <div className="space-y-3">
                  <p className="text-sm text-orange-700">
                    Set rates for different time increments. Leave blank to skip that option.
                  </p>

                  <div className="grid grid-cols-3 gap-3">
                    <div>
                      <label className="block text-xs text-orange-700 mb-1">Per 15 min</label>
                      <div className="relative">
                        <span className="absolute left-2 top-2 text-gray-500 text-sm">$</span>
                        <input
                          type="number"
                          step="0.01"
                          min="0"
                          value={per15Min}
                          onChange={(e) => setPer15Min(e.target.value)}
                          className="w-full pl-6 pr-2 py-2 border rounded text-sm"
                          placeholder="5.00"
                        />
                      </div>
                    </div>
                    <div>
                      <label className="block text-xs text-orange-700 mb-1">Per 30 min</label>
                      <div className="relative">
                        <span className="absolute left-2 top-2 text-gray-500 text-sm">$</span>
                        <input
                          type="number"
                          step="0.01"
                          min="0"
                          value={per30Min}
                          onChange={(e) => setPer30Min(e.target.value)}
                          className="w-full pl-6 pr-2 py-2 border rounded text-sm"
                          placeholder="8.00"
                        />
                      </div>
                    </div>
                    <div>
                      <label className="block text-xs text-orange-700 mb-1">Per Hour</label>
                      <div className="relative">
                        <span className="absolute left-2 top-2 text-gray-500 text-sm">$</span>
                        <input
                          type="number"
                          step="0.01"
                          min="0"
                          value={perHour}
                          onChange={(e) => setPerHour(e.target.value)}
                          className="w-full pl-6 pr-2 py-2 border rounded text-sm"
                          placeholder="15.00"
                        />
                      </div>
                    </div>
                  </div>

                  <div>
                    <label className="block text-xs text-orange-700 mb-1">Minimum Minutes</label>
                    <select
                      value={minimumMinutes}
                      onChange={(e) => setMinimumMinutes(e.target.value)}
                      className="w-full px-3 py-2 border rounded text-sm"
                    >
                      <option value="15">15 minutes</option>
                      <option value="30">30 minutes</option>
                      <option value="60">1 hour</option>
                    </select>
                  </div>
                </div>
              )}
            </div>
          )}

          <div>
            <label className="block text-sm font-medium mb-1">Description (optional)</label>
            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Brief description..."
              rows={2}
            />
          </div>

          {/* Commission Section */}
          <div>
            <label className="block text-sm font-medium mb-2">Commission (optional)</label>
            <div className="flex gap-3 items-start">
              <div className="flex-1">
                <select
                  value={commissionType}
                  onChange={(e) => {
                    setCommissionType(e.target.value)
                    if (!e.target.value) setCommissionValue('')
                  }}
                  className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">No commission</option>
                  <option value="fixed">Fixed amount ($)</option>
                  <option value="percent">Percentage (%)</option>
                </select>
              </div>
              {commissionType && (
                <div className="w-32">
                  <div className="relative">
                    <span className="absolute left-3 top-2 text-gray-500">
                      {commissionType === 'fixed' ? '$' : '%'}
                    </span>
                    <input
                      type="number"
                      step={commissionType === 'fixed' ? '0.01' : '0.1'}
                      min="0"
                      value={commissionValue}
                      onChange={(e) => setCommissionValue(e.target.value)}
                      className="w-full pl-7 pr-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder="0"
                    />
                  </div>
                </div>
              )}
            </div>
            {commissionType && (
              <p className="text-xs text-gray-500 mt-1">
                {commissionType === 'fixed'
                  ? 'Employee earns this fixed amount per sale'
                  : 'Employee earns this percentage of the sale price'}
              </p>
            )}
          </div>

          {/* Pour Size Options - only for liquor items */}
          {isLiquorCategory && (
            <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
              <label className="block text-sm font-medium mb-2 text-purple-800">
                Pour Size Quick Buttons
              </label>
              <p className="text-xs text-purple-600 mb-3">
                Enable quick pour options for this drink. Customize names and multipliers as needed.
              </p>

              <div className="space-y-2 mb-3">
                {Object.entries(DEFAULT_POUR_SIZES).map(([sizeKey, defaults]) => {
                  const isEnabled = enabledPourSizes[sizeKey] !== undefined
                  const currentConfig = enabledPourSizes[sizeKey]
                  const isCustomized = currentConfig && (
                    currentConfig.label !== defaults.label ||
                    currentConfig.multiplier !== defaults.multiplier
                  )

                  return (
                    <div
                      key={sizeKey}
                      className={`p-3 border rounded-lg transition-colors ${
                        isEnabled
                          ? 'border-purple-500 bg-purple-100'
                          : 'border-gray-200 bg-white'
                      }`}
                    >
                      <div className="flex items-center gap-3">
                        {/* Enable checkbox */}
                        <input
                          type="checkbox"
                          checked={isEnabled}
                          onChange={() => togglePourSize(sizeKey)}
                          className="w-4 h-4 text-purple-600 flex-shrink-0"
                        />

                        {isEnabled ? (
                          <>
                            {/* Editable label */}
                            <input
                              type="text"
                              value={currentConfig?.label || ''}
                              onChange={(e) => updatePourSizeLabel(sizeKey, e.target.value)}
                              className="flex-1 px-2 py-1 text-sm border rounded focus:outline-none focus:ring-1 focus:ring-purple-500 bg-white"
                              placeholder="Button label"
                            />

                            {/* Editable multiplier */}
                            <div className="flex items-center gap-1 flex-shrink-0">
                              <input
                                type="text"
                                inputMode="decimal"
                                key={`${sizeKey}-${currentConfig?.multiplier}`}
                                defaultValue={currentConfig?.multiplier || 1}
                                onBlur={(e) => {
                                  const num = parseFloat(e.target.value)
                                  if (!isNaN(num) && num > 0) {
                                    updatePourSizeMultiplier(sizeKey, num)
                                  } else {
                                    e.target.value = String(currentConfig?.multiplier || 1)
                                  }
                                }}
                                className="w-14 px-1 py-1 text-sm border rounded focus:outline-none focus:ring-1 focus:ring-purple-500 text-center bg-white"
                                placeholder="1.0"
                              />
                              <span className="text-xs text-purple-600">√ó</span>
                            </div>

                            {/* Reset checkbox */}
                            {isCustomized && (
                              <label className="flex items-center gap-1 text-xs text-gray-500 cursor-pointer flex-shrink-0" title="Reset to default">
                                <input
                                  type="checkbox"
                                  checked={false}
                                  onChange={() => resetPourSizeToDefault(sizeKey)}
                                  className="w-3 h-3"
                                />
                                <span>Reset</span>
                              </label>
                            )}
                          </>
                        ) : (
                          <div className="flex-1 flex items-center justify-between text-gray-400">
                            <span className="text-sm">{defaults.label}</span>
                            <span className="text-xs">{defaults.multiplier}√ó</span>
                          </div>
                        )}
                      </div>
                    </div>
                  )
                })}
              </div>

              {Object.keys(enabledPourSizes).length > 1 && (
                <div className="mb-3">
                  <label className="block text-xs font-medium mb-1 text-purple-700">Default Pour</label>
                  <select
                    value={defaultPourSize}
                    onChange={(e) => setDefaultPourSize(e.target.value)}
                    className="w-full px-2 py-1.5 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                  >
                    {Object.entries(enabledPourSizes).map(([sizeKey, config]) => (
                      <option key={sizeKey} value={sizeKey}>
                        {config.label}
                      </option>
                    ))}
                  </select>
                </div>
              )}

              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={applyPourToModifiers}
                  onChange={(e) => setApplyPourToModifiers(e.target.checked)}
                  className="w-4 h-4 text-purple-600"
                />
                <span className="text-sm text-purple-800">Apply multiplier to spirit modifiers too</span>
              </label>
              <p className="text-xs text-purple-600 mt-1 ml-6">
                When checked, a double will also double the upcharge for premium spirits
              </p>
            </div>
          )}

          {/* Ingredients Section - for food and drinks items */}
          {showIngredientsSection && (
            <div>
              <div className="flex items-center justify-between mb-2">
                <label className="text-sm font-medium">Ingredients (What&apos;s In It)</label>
                <div className="flex items-center gap-2">
                  <a
                    href="/ingredients"
                    target="_blank"
                    className="text-xs text-blue-600 hover:underline"
                  >
                    Manage Library
                  </a>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => setShowIngredientPicker(!showIngredientPicker)}
                  >
                    + Add Ingredient
                  </Button>
                </div>
              </div>

              {isLoadingIngredients ? (
                <p className="text-sm text-gray-500">Loading ingredients...</p>
              ) : ingredientsLibrary.length === 0 ? (
                <div className="text-sm text-gray-500 p-3 bg-amber-50 border border-amber-200 rounded-lg">
                  <p className="font-medium text-amber-800">No ingredients in library</p>
                  <p className="mt-1">
                    <a href="/ingredients" className="text-blue-600 hover:underline font-medium">
                      ‚Üí Go to Ingredients
                    </a>{' '}
                    to create ingredients like Lettuce, Tomato, Bacon, etc.
                  </p>
                </div>
              ) : selectedIngredients.length === 0 ? (
                <p className="text-sm text-gray-500">
                  No ingredients added. Click &quot;+ Add Ingredient&quot; above, or{' '}
                  <a href="/ingredients" className="text-blue-600 hover:underline">create new ingredients</a>.
                </p>
              ) : (
                <div className="space-y-2 border rounded-lg p-2">
                  {selectedIngredients.map(sel => {
                    const ing = ingredientsLibrary.find(i => i.id === sel.ingredientId)
                    if (!ing) return null
                    return (
                      <div
                        key={sel.ingredientId}
                        className="p-2 bg-gray-50 rounded space-y-2"
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <label className="flex items-center gap-2 cursor-pointer">
                              <input
                                type="checkbox"
                                checked={sel.isIncluded}
                                onChange={() => toggleIngredientIncluded(sel.ingredientId)}
                                className="w-4 h-4"
                              />
                              <span className={`font-medium ${sel.isIncluded ? '' : 'text-gray-400 line-through'}`}>
                                {ing.name}
                              </span>
                            </label>
                            {ing.category && (
                              <span className="text-xs text-gray-400">{ing.category}</span>
                            )}
                          </div>
                          <button
                            type="button"
                            onClick={() => removeIngredient(sel.ingredientId)}
                            className="text-red-500 hover:text-red-700 text-sm"
                          >
                            Remove
                          </button>
                        </div>
                        {/* Pre-modifier options - colored toggle buttons */}
                        <div className="flex items-center gap-2 ml-6">
                          <button
                            type="button"
                            onClick={() => updateIngredientOption(sel.ingredientId, 'allowNo', !(sel.allowNo ?? ing.allowNo))}
                            className={`px-2 py-1 text-xs rounded transition-all ${
                              (sel.allowNo ?? ing.allowNo)
                                ? 'bg-red-500 text-white'
                                : 'bg-red-100 text-red-700 hover:bg-red-200'
                            }`}
                          >
                            No
                          </button>
                          <button
                            type="button"
                            onClick={() => updateIngredientOption(sel.ingredientId, 'allowLite', !(sel.allowLite ?? ing.allowLite))}
                            className={`px-2 py-1 text-xs rounded transition-all ${
                              (sel.allowLite ?? ing.allowLite)
                                ? 'bg-yellow-500 text-white'
                                : 'bg-yellow-100 text-yellow-700 hover:bg-yellow-200'
                            }`}
                          >
                            Lite
                          </button>
                          <button
                            type="button"
                            onClick={() => updateIngredientOption(sel.ingredientId, 'allowOnSide', !(sel.allowOnSide ?? ing.allowOnSide))}
                            className={`px-2 py-1 text-xs rounded transition-all ${
                              (sel.allowOnSide ?? ing.allowOnSide)
                                ? 'bg-blue-500 text-white'
                                : 'bg-blue-100 text-blue-700 hover:bg-blue-200'
                            }`}
                          >
                            Side
                          </button>
                          <button
                            type="button"
                            onClick={() => updateIngredientOption(sel.ingredientId, 'allowExtra', !(sel.allowExtra ?? ing.allowExtra))}
                            className={`px-2 py-1 text-xs rounded transition-all ${
                              (sel.allowExtra ?? ing.allowExtra)
                                ? 'bg-green-500 text-white'
                                : 'bg-green-100 text-green-700 hover:bg-green-200'
                            }`}
                          >
                            Ex
                          </button>
                          {(sel.allowExtra ?? ing.allowExtra) && ing.extraPrice > 0 && (
                            <span className="text-green-600 ml-2">
                              Extra +{formatCurrency(ing.extraPrice)}
                            </span>
                          )}
                        </div>
                      </div>
                    )
                  })}
                </div>
              )}

              {/* Ingredient Picker Dropdown */}
              {showIngredientPicker && (
                <div className="mt-2 border rounded-lg p-2 bg-white shadow-lg max-h-48 overflow-y-auto">
                  {ingredientsLibrary.filter(ing =>
                    !selectedIngredients.find(s => s.ingredientId === ing.id)
                  ).length === 0 ? (
                    <p className="text-sm text-gray-500 p-2">
                      All ingredients added. <a href="/ingredients" className="text-blue-600 hover:underline">Create more</a>
                    </p>
                  ) : (
                    ingredientsLibrary
                      .filter(ing => !selectedIngredients.find(s => s.ingredientId === ing.id))
                      .map(ing => (
                        <button
                          key={ing.id}
                          type="button"
                          onClick={() => addIngredient(ing.id)}
                          className="w-full text-left p-2 hover:bg-gray-50 rounded flex items-center justify-between"
                        >
                          <span>{ing.name}</span>
                          {ing.category && (
                            <span className="text-xs text-gray-400">{ing.category}</span>
                          )}
                        </button>
                      ))
                  )}
                </div>
              )}

              {selectedIngredients.length > 0 && (
                <p className="text-xs text-gray-500 mt-1">
                  {selectedIngredients.filter(i => i.isIncluded).length} included by default,{' '}
                  {selectedIngredients.filter(i => !i.isIncluded).length} optional
                </p>
              )}
            </div>
          )}

          {/* Print Destinations - override category default (Dropdown with checkboxes) */}
          {printDestinations.length > 0 && (
            <div className="space-y-3">
              <div className="relative">
                <label className="block text-sm font-medium mb-2">Print Destinations (override category)</label>
                <button
                  type="button"
                  onClick={() => setIsPrinterDropdownOpen(!isPrinterDropdownOpen)}
                  className="w-full px-3 py-2 border rounded-lg text-left flex items-center justify-between bg-white hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <span className={selectedDestinations.length === 0 ? 'text-gray-500' : ''}>
                    {selectedDestinations.length === 0
                      ? 'Use category default...'
                      : selectedDestinations.map(d => d.name).join(', ')}
                  </span>
                  <span className="text-gray-400">{isPrinterDropdownOpen ? '‚ñ≤' : '‚ñº'}</span>
                </button>

                {isPrinterDropdownOpen && (
                  <div className="absolute z-10 mt-1 w-full bg-white border rounded-lg shadow-lg max-h-60 overflow-auto">
                    {printers.filter(p => p.isActive).length > 0 && (
                      <div className="px-3 py-1 text-xs font-semibold text-gray-500 bg-gray-50 border-b">
                        Printers
                      </div>
                    )}
                    {printers.filter(p => p.isActive).map(printer => (
                      <label
                        key={printer.id}
                        className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer"
                      >
                        <input
                          type="checkbox"
                          checked={printerIds.includes(printer.id)}
                          onChange={() => {
                            setPrinterIds(prev =>
                              prev.includes(printer.id)
                                ? prev.filter(id => id !== printer.id)
                                : [...prev, printer.id]
                            )
                          }}
                          className="w-4 h-4 rounded border-gray-300 text-blue-500 focus:ring-blue-500"
                        />
                        <span className="flex-1">{printer.name}</span>
                        <span className="text-xs text-gray-400">{printer.printerRole}</span>
                      </label>
                    ))}
                    {kdsScreens.filter(k => k.isActive).length > 0 && (
                      <div className="px-3 py-1 text-xs font-semibold text-gray-500 bg-gray-50 border-b border-t">
                        KDS Screens
                      </div>
                    )}
                    {kdsScreens.filter(k => k.isActive).map(screen => (
                      <label
                        key={screen.id}
                        className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer"
                      >
                        <input
                          type="checkbox"
                          checked={printerIds.includes(screen.id)}
                          onChange={() => {
                            setPrinterIds(prev =>
                              prev.includes(screen.id)
                                ? prev.filter(id => id !== screen.id)
                                : [...prev, screen.id]
                            )
                          }}
                          className="w-4 h-4 rounded border-gray-300 text-blue-500 focus:ring-blue-500"
                        />
                        <span className="flex-1">{screen.name}</span>
                        <span className="text-xs text-gray-400">{screen.screenType}</span>
                      </label>
                    ))}
                  </div>
                )}
                <p className="text-xs text-gray-500 mt-1">
                  {printerIds.length === 0
                    ? 'Using category default destinations'
                    : `Sending to ${printerIds.length} destination(s)`}
                </p>
              </div>

              {/* Backup Destinations - only show if primary destinations are selected */}
              {printerIds.length > 0 && (
                <div className="relative">
                  <label className="block text-sm font-medium mb-2">Backup Destinations (failover)</label>
                  <button
                    type="button"
                    onClick={() => setIsBackupDropdownOpen(!isBackupDropdownOpen)}
                    className="w-full px-3 py-2 border rounded-lg text-left flex items-center justify-between bg-white hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-orange-500"
                  >
                    <span className={selectedBackupDestinations.length === 0 ? 'text-gray-500' : ''}>
                      {selectedBackupDestinations.length === 0
                        ? 'Select backup destinations...'
                        : selectedBackupDestinations.map(d => d.name).join(', ')}
                    </span>
                    <span className="text-gray-400">{isBackupDropdownOpen ? '‚ñ≤' : '‚ñº'}</span>
                  </button>

                  {isBackupDropdownOpen && (
                    <div className="absolute z-10 mt-1 w-full bg-white border rounded-lg shadow-lg max-h-60 overflow-auto">
                      {printers.filter(p => p.isActive && !printerIds.includes(p.id)).length > 0 && (
                        <div className="px-3 py-1 text-xs font-semibold text-gray-500 bg-gray-50 border-b">
                          Printers
                        </div>
                      )}
                      {printers.filter(p => p.isActive && !printerIds.includes(p.id)).map(printer => (
                        <label
                          key={printer.id}
                          className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer"
                        >
                          <input
                            type="checkbox"
                            checked={backupPrinterIds.includes(printer.id)}
                            onChange={() => {
                              setBackupPrinterIds(prev =>
                                prev.includes(printer.id)
                                  ? prev.filter(id => id !== printer.id)
                                  : [...prev, printer.id]
                              )
                            }}
                            className="w-4 h-4 rounded border-gray-300 text-orange-500 focus:ring-orange-500"
                          />
                          <span className="flex-1">{printer.name}</span>
                          <span className="text-xs text-gray-400">{printer.printerRole}</span>
                        </label>
                      ))}
                      {kdsScreens.filter(k => k.isActive && !printerIds.includes(k.id)).length > 0 && (
                        <div className="px-3 py-1 text-xs font-semibold text-gray-500 bg-gray-50 border-b border-t">
                          KDS Screens
                        </div>
                      )}
                      {kdsScreens.filter(k => k.isActive && !printerIds.includes(k.id)).map(screen => (
                        <label
                          key={screen.id}
                          className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer"
                        >
                          <input
                            type="checkbox"
                            checked={backupPrinterIds.includes(screen.id)}
                            onChange={() => {
                              setBackupPrinterIds(prev =>
                                prev.includes(screen.id)
                                  ? prev.filter(id => id !== screen.id)
                                  : [...prev, screen.id]
                              )
                            }}
                            className="w-4 h-4 rounded border-gray-300 text-orange-500 focus:ring-orange-500"
                          />
                          <span className="flex-1">{screen.name}</span>
                          <span className="text-xs text-gray-400">{screen.screenType}</span>
                        </label>
                      ))}
                    </div>
                  )}
                  <p className="text-xs text-gray-500 mt-1">Used if primary destinations fail</p>
                </div>
              )}
            </div>
          )}

          {/* Combo Print Mode - only for combo items */}
          {isComboCategory && printers.length > 0 && (
            <div>
              <label className="block text-sm font-medium mb-2">Combo Printing</label>
              <div className="space-y-2">
                <label className={`flex items-start gap-3 p-3 rounded-lg cursor-pointer border-2 transition-all ${
                  comboPrintMode === 'individual' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-gray-300'
                }`}>
                  <input
                    type="radio"
                    name="comboPrintMode"
                    value="individual"
                    checked={comboPrintMode === 'individual'}
                    onChange={(e) => setComboPrintMode(e.target.value as 'individual' | 'primary' | 'all')}
                    className="mt-1"
                  />
                  <div>
                    <p className="font-medium text-sm">Individual Routing</p>
                    <p className="text-xs text-gray-500">Each item follows its own print rules (burger‚Üíkitchen, drink‚Üíbar)</p>
                  </div>
                </label>
                <label className={`flex items-start gap-3 p-3 rounded-lg cursor-pointer border-2 transition-all ${
                  comboPrintMode === 'primary' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-gray-300'
                }`}>
                  <input
                    type="radio"
                    name="comboPrintMode"
                    value="primary"
                    checked={comboPrintMode === 'primary'}
                    onChange={(e) => setComboPrintMode(e.target.value as 'individual' | 'primary' | 'all')}
                    className="mt-1"
                  />
                  <div>
                    <p className="font-medium text-sm">Single Printer</p>
                    <p className="text-xs text-gray-500">Entire combo prints to one printer for assembly coordination</p>
                  </div>
                </label>
                <label className={`flex items-start gap-3 p-3 rounded-lg cursor-pointer border-2 transition-all ${
                  comboPrintMode === 'all' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-gray-300'
                }`}>
                  <input
                    type="radio"
                    name="comboPrintMode"
                    value="all"
                    checked={comboPrintMode === 'all'}
                    onChange={(e) => setComboPrintMode(e.target.value as 'individual' | 'primary' | 'all')}
                    className="mt-1"
                  />
                  <div>
                    <p className="font-medium text-sm">All Printers</p>
                    <p className="text-xs text-gray-500">Full combo ticket prints at ALL relevant stations</p>
                  </div>
                </label>
              </div>
            </div>
          )}

          {/* Modifier Groups Section - only for non-entertainment or non-timed items */}
          {(!isEntertainment || !isTimedItem) && (
            <div>
              <div className="flex items-center justify-between mb-2">
                <label className="text-sm font-medium">Modifier Groups</label>
                {/* Compact type filter - dropdown to add more types */}
                <div className="flex items-center gap-2">
                  <div className="flex gap-1">
                    {enabledModifierTypes.map(type => {
                      const typeInfo = MODIFIER_TYPES.find(t => t.value === type)
                      if (!typeInfo) return null
                      return (
                        <span
                          key={type}
                          className="inline-flex items-center gap-1 px-2 py-0.5 text-xs font-medium rounded-full text-white"
                          style={{ backgroundColor: typeInfo.color }}
                        >
                          {typeInfo.label}
                          {enabledModifierTypes.length > 1 && (
                            <button
                              type="button"
                              onClick={() => setEnabledModifierTypes(enabledModifierTypes.filter(t => t !== type))}
                              className="hover:bg-white/20 rounded-full p-0.5"
                            >
                              <svg className="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M6 18L18 6M6 6l12 12" />
                              </svg>
                            </button>
                          )}
                        </span>
                      )
                    })}
                  </div>
                  <select
                    value=""
                    onChange={(e) => {
                      if (e.target.value && !enabledModifierTypes.includes(e.target.value)) {
                        setEnabledModifierTypes([...enabledModifierTypes, e.target.value])
                      }
                    }}
                    className="text-xs px-2 py-1 border rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500"
                  >
                    <option value="">+ Add type</option>
                    {MODIFIER_TYPES.filter(t => !enabledModifierTypes.includes(t.value)).map(type => (
                      <option key={type.value} value={type.value}>{type.label}</option>
                    ))}
                  </select>
                </div>
              </div>

              {isLoadingModifiers ? (
                <p className="text-sm text-gray-500">Loading modifiers...</p>
              ) : filteredModifierGroups.length === 0 ? (
                <p className="text-sm text-gray-500">
                  {modifierGroups.length === 0
                    ? 'No modifier groups available. Create them in the Modifiers section.'
                    : 'No modifier groups match the selected types.'}
                </p>
              ) : (
                <div className="space-y-2 max-h-48 overflow-y-auto border rounded-lg p-2">
                  {filteredModifierGroups.map(group => {
                    const groupTypes = group.modifierTypes || ['universal']
                    return (
                      <label
                        key={group.id}
                        className={`flex items-center gap-3 p-2 rounded cursor-pointer hover:bg-gray-50 ${
                          selectedModifierGroupIds.includes(group.id) ? 'bg-blue-50 border border-blue-200' : ''
                        }`}
                      >
                        <input
                          type="checkbox"
                          checked={selectedModifierGroupIds.includes(group.id)}
                          onChange={() => toggleModifierGroup(group.id)}
                          className="w-4 h-4"
                        />
                        <div className="flex-1">
                          <div className="flex items-center gap-1">
                            <p className="font-medium text-sm">{group.name}</p>
                            {groupTypes.slice(0, 2).map(type => {
                              const typeInfo = MODIFIER_TYPES.find(t => t.value === type) || MODIFIER_TYPES[0]
                              return (
                                <span
                                  key={type}
                                  className="px-1 py-0.5 text-[9px] font-medium rounded text-white"
                                  style={{ backgroundColor: typeInfo.color }}
                                >
                                  {typeInfo.label}
                                </span>
                              )
                            })}
                            {groupTypes.length > 2 && (
                              <span className="text-[9px] text-gray-400">+{groupTypes.length - 2}</span>
                            )}
                          </div>
                          <p className="text-xs text-gray-500">
                            {group.modifiers.length} options
                            {group.isRequired && <span className="text-red-500 ml-1">(Required)</span>}
                          </p>
                        </div>
                      </label>
                    )
                  })}
                </div>
              )}
              {selectedModifierGroupIds.length > 0 && (
                <p className="text-xs text-gray-500 mt-1">
                  {selectedModifierGroupIds.length} modifier group(s) selected
                </p>
              )}

              {/* Online Modifier Groups - show which groups appear for online ordering */}
              {selectedModifierGroups.length > 0 && (
                <div className="mt-4 border-t pt-4">
                  <label className="text-sm font-medium text-purple-700">Online Modifier Groups</label>
                  <p className="text-xs text-gray-500 mb-2">
                    Select which modifier groups appear for online orders
                  </p>
                  <div className="space-y-2 border rounded-lg p-2 bg-purple-50/50">
                    {selectedModifierGroups.map(selected => {
                      const group = modifierGroups.find(g => g.id === selected.id)
                      if (!group) return null
                      return (
                        <label
                          key={selected.id}
                          className={`flex items-center gap-3 p-2 rounded cursor-pointer ${
                            selected.showOnline ? 'bg-purple-100 border border-purple-300' : 'bg-white border border-gray-200'
                          }`}
                        >
                          <input
                            type="checkbox"
                            checked={selected.showOnline}
                            onChange={() => toggleModifierGroupOnline(selected.id)}
                            className="w-4 h-4 accent-purple-600"
                          />
                          <div className="flex-1">
                            <p className={`font-medium text-sm ${selected.showOnline ? 'text-purple-800' : 'text-gray-500'}`}>
                              {group.name}
                            </p>
                            <p className="text-xs text-gray-500">
                              {group.modifiers.length} options
                              {group.isRequired && <span className="text-red-500 ml-1">(Required)</span>}
                            </p>
                          </div>
                          {!selected.showOnline && (
                            <span className="text-xs text-amber-600 font-medium">Hidden online</span>
                          )}
                        </label>
                      )
                    })}
                  </div>
                  <p className="text-xs text-gray-500 mt-1">
                    {selectedModifierGroups.filter(g => g.showOnline).length} of {selectedModifierGroups.length} groups visible online
                  </p>
                </div>
              )}
            </div>
          )}

          <div className="flex gap-2 pt-4">
            <Button variant="outline" className="flex-1" onClick={onClose}>
              Cancel
            </Button>
            <Button
              variant="primary"
              className="flex-1"
              disabled={!name.trim() || !price}
              onClick={handleSave}
            >
              {item ? 'Save Changes' : 'Create Item'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/menu/items/[id]/modifier-groups/route.ts
LINES:      517
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { Prisma } from '@prisma/client'

interface RouteParams {
  params: Promise<{ id: string }>
}

// Type for modifier with optional child group
type ModifierWithChild = Prisma.ModifierGetPayload<{
  include: {
    ingredient: { select: { id: true; name: true; category: true } }
    childModifierGroup: {
      include: {
        modifiers: {
          include: {
            ingredient: { select: { id: true; name: true; category: true } }
          }
        }
      }
    }
  }
}>

// Helper function to recursively format modifier groups
function formatModifierGroup(group: {
  id: string
  name: string
  displayName: string | null
  minSelections: number
  maxSelections: number
  isRequired: boolean
  allowStacking: boolean
  sortOrder: number
  tieredPricingConfig: any
  exclusionGroupKey: string | null
  modifiers: ModifierWithChild[]
}, allGroups: Map<string, typeof group>): object {
  return {
    id: group.id,
    name: group.name,
    displayName: group.displayName,
    minSelections: group.minSelections,
    maxSelections: group.maxSelections,
    isRequired: group.isRequired,
    allowStacking: group.allowStacking,
    tieredPricingConfig: group.tieredPricingConfig,
    exclusionGroupKey: group.exclusionGroupKey,
    sortOrder: group.sortOrder,
    modifiers: group.modifiers.map(m => {
      const childGroup = m.childModifierGroupId ? allGroups.get(m.childModifierGroupId) : null
      return {
        id: m.id,
        name: m.name,
        price: Number(m.price),
        allowNo: m.allowNo,
        allowLite: m.allowLite,
        allowOnSide: m.allowOnSide,
        allowExtra: m.allowExtra,
        extraPrice: Number(m.extraPrice),
        isDefault: m.isDefault,
        sortOrder: m.sortOrder,
        isLabel: m.isLabel ?? false,
        ingredientId: m.ingredientId,
        ingredientName: m.ingredient?.name || null,
        childModifierGroupId: m.childModifierGroupId,
        childModifierGroup: childGroup ? formatModifierGroup(childGroup, allGroups) : null,
      }
    }),
  }
}

// GET /api/menu/items/[id]/modifier-groups - Get item-owned modifier groups with nested children
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId } = await params

    const menuItem = await db.menuItem.findUnique({
      where: { id: menuItemId },
      select: { id: true, locationId: true },
    })

    if (!menuItem) {
      return NextResponse.json({ error: 'Menu item not found' }, { status: 404 })
    }

    // Shared include shape for modifiers (used by both queries)
    const modifierInclude = {
      where: { deletedAt: null, isActive: true },
      orderBy: { sortOrder: 'asc' as const },
      include: {
        ingredient: {
          select: { id: true, name: true, category: true },
        },
        childModifierGroup: {
          include: {
            modifiers: {
              where: { deletedAt: null, isActive: true },
              include: {
                ingredient: {
                  select: { id: true, name: true, category: true },
                },
              },
            },
          },
        },
      },
    }

    // 1. Get item-OWNED modifier groups (new pattern ‚Äî menuItemId set on group)
    const ownedGroups = await db.modifierGroup.findMany({
      where: {
        menuItemId,
        deletedAt: null,
      },
      include: { modifiers: modifierInclude },
      orderBy: { sortOrder: 'asc' },
    })

    // 2. Get SHARED modifier groups via junction table (legacy pattern)
    const sharedLinks = await db.menuItemModifierGroup.findMany({
      where: {
        menuItemId,
        deletedAt: null,
        modifierGroup: { deletedAt: null },
      },
      include: {
        modifierGroup: {
          include: { modifiers: modifierInclude },
        },
      },
      orderBy: { sortOrder: 'asc' },
    })

    // 3. Merge both sources ‚Äî owned groups first, then shared (no duplicates)
    const ownedIds = new Set(ownedGroups.map(g => g.id))
    const sharedGroups = sharedLinks
      .map(link => link.modifierGroup)
      .filter(g => !ownedIds.has(g.id))

    const allGroups = [...ownedGroups, ...sharedGroups]

    // Build a map of all groups for recursive lookup
    const groupMap = new Map<string, typeof allGroups[0]>()
    allGroups.forEach(g => groupMap.set(g.id, g))

    // Return ALL groups - child groups remain in the list for editing
    // The childModifierGroup reference is just a link, not a move
    return NextResponse.json({
      data: allGroups.map(g => formatModifierGroup(g, groupMap)),
    })
  } catch (error) {
    console.error('Error fetching item modifier groups:', error)
    return NextResponse.json({ error: 'Failed to fetch modifier groups' }, { status: 500 })
  }
}

// POST /api/menu/items/[id]/modifier-groups - Create a new item-owned modifier group
// If parentModifierId is provided, creates as child group and links to that modifier
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId } = await params
    const body = await request.json()
    const {
      name,
      minSelections = 0,
      maxSelections = 1,
      isRequired = false,
      templateId, // Optional: copy from template
      parentModifierId, // Optional: create as child group and link to this modifier
      duplicateFromGroupId, // Optional: deep copy existing group
      copyFromItemId, // Optional: source item ID for cross-item copy
    } = body

    const menuItem = await db.menuItem.findUnique({
      where: { id: menuItemId },
      select: { id: true, locationId: true },
    })

    if (!menuItem) {
      return NextResponse.json({ error: 'Menu item not found' }, { status: 404 })
    }

    // If parentModifierId provided, verify it belongs to a group owned by this item
    if (parentModifierId) {
      const parentModifier = await db.modifier.findFirst({
        where: {
          id: parentModifierId,
          modifierGroup: { menuItemId },
        },
      })
      if (!parentModifier) {
        return NextResponse.json({ error: 'Parent modifier not found' }, { status: 404 })
      }
    }

    // Get max sort order
    const maxSort = await db.modifierGroup.aggregate({
      where: { menuItemId },
      _max: { sortOrder: true },
    })

    // If duplicating from existing group
    if (duplicateFromGroupId) {
      // If copying from another item, use copyFromItemId; otherwise use current menuItemId
      const sourceItemId = copyFromItemId || menuItemId

      const sourceGroup = await db.modifierGroup.findFirst({
        where: { id: duplicateFromGroupId, menuItemId: sourceItemId },
        include: {
          modifiers: {
            where: { deletedAt: null },
            orderBy: { sortOrder: 'asc' },
            include: {
              childModifierGroup: {
                include: {
                  modifiers: {
                    where: { deletedAt: null },
                    orderBy: { sortOrder: 'asc' },
                  },
                },
              },
            },
          },
        },
      })

      if (!sourceGroup) {
        return NextResponse.json({ error: 'Source group not found' }, { status: 404 })
      }

      // Deep copy: group + all modifiers + child groups recursively
      const newGroup = await db.$transaction(async (tx) => {
        // Phase 1: Create the parent group (without modifiers)
        const created = await tx.modifierGroup.create({
          data: {
            locationId: menuItem.locationId,
            menuItemId, // ALWAYS assign to the TARGET item
            name: name || `${sourceGroup.name} (Copy)`,
            minSelections: sourceGroup.minSelections,
            maxSelections: sourceGroup.maxSelections,
            isRequired: sourceGroup.isRequired,
            allowStacking: sourceGroup.allowStacking,
            tieredPricingConfig: sourceGroup.tieredPricingConfig ?? Prisma.JsonNull,
            exclusionGroupKey: null, // Don't copy exclusion key ‚Äî user sets fresh
            sortOrder: (maxSort._max.sortOrder || 0) + 1,
          },
        })

        // Phase 2: Create child groups for modifiers that need them
        const childGroupMap = new Map<string, string>() // old modifier ID -> new child group ID
        let childSortOffset = 0

        for (const mod of sourceGroup.modifiers) {
          if (mod.childModifierGroup) {
            const childGroup = await tx.modifierGroup.create({
              data: {
                locationId: menuItem.locationId,
                menuItemId, // Also owned by the target item
                name: mod.childModifierGroup.name,
                minSelections: mod.childModifierGroup.minSelections,
                maxSelections: mod.childModifierGroup.maxSelections,
                isRequired: mod.childModifierGroup.isRequired,
                allowStacking: mod.childModifierGroup.allowStacking,
                sortOrder: (maxSort._max.sortOrder || 0) + 2 + childSortOffset,
              },
            })
            childGroupMap.set(mod.id, childGroup.id)
            childSortOffset++

            // Create modifiers for the child group
            for (const cm of mod.childModifierGroup.modifiers) {
              await tx.modifier.create({
                data: {
                  locationId: menuItem.locationId,
                  modifierGroupId: childGroup.id,
                  name: cm.name,
                  price: cm.price,
                  allowNo: cm.allowNo,
                  allowLite: cm.allowLite,
                  allowOnSide: cm.allowOnSide,
                  allowExtra: cm.allowExtra,
                  extraPrice: cm.extraPrice,
                  isDefault: cm.isDefault,
                  sortOrder: cm.sortOrder,
                  ingredientId: cm.ingredientId,
                  isLabel: cm.isLabel ?? false,
                },
              })
            }
          }
        }

        // Phase 3: Create all modifiers with their childModifierGroupId links
        for (const mod of sourceGroup.modifiers) {
          await tx.modifier.create({
            data: {
              locationId: menuItem.locationId,
              modifierGroupId: created.id,
              name: mod.name,
              price: mod.price,
              allowNo: mod.allowNo,
              allowLite: mod.allowLite,
              allowOnSide: mod.allowOnSide,
              allowExtra: mod.allowExtra,
              extraPrice: mod.extraPrice,
              isDefault: mod.isDefault,
              sortOrder: mod.sortOrder,
              ingredientId: mod.ingredientId,
              isLabel: mod.isLabel ?? false,
              childModifierGroupId: childGroupMap.get(mod.id) || null,
            },
          })
        }

        // Fetch the created group with modifiers for response
        const groupWithModifiers = await tx.modifierGroup.findUnique({
          where: { id: created.id },
          include: {
            modifiers: {
              where: { deletedAt: null },
              orderBy: { sortOrder: 'asc' },
            },
          },
        })

        return groupWithModifiers!
      })

      // Return same format as existing POST response
      return NextResponse.json({
        data: {
          id: newGroup.id,
          name: newGroup.name,
          displayName: newGroup.displayName,
          minSelections: newGroup.minSelections,
          maxSelections: newGroup.maxSelections,
          isRequired: newGroup.isRequired,
          allowStacking: newGroup.allowStacking,
          tieredPricingConfig: newGroup.tieredPricingConfig,
          exclusionGroupKey: newGroup.exclusionGroupKey,
          sortOrder: newGroup.sortOrder,
          modifiers: newGroup.modifiers.map(m => ({
            id: m.id,
            name: m.name,
            price: Number(m.price),
            allowNo: m.allowNo,
            allowLite: m.allowLite,
            allowOnSide: m.allowOnSide,
            allowExtra: m.allowExtra,
            extraPrice: Number(m.extraPrice),
            isDefault: m.isDefault,
            sortOrder: m.sortOrder,
            ingredientId: m.ingredientId,
            childModifierGroupId: m.childModifierGroupId,
            isLabel: m.isLabel ?? false,
          })),
        },
      })
    }

    // If copying from template, get template data
    let templateModifiers: Array<{
      name: string
      price: number
      allowNo: boolean
      allowLite: boolean
      allowOnSide: boolean
      allowExtra: boolean
      extraPrice: number
      isDefault: boolean
      sortOrder: number
    }> = []

    if (templateId) {
      const template = await db.modifierGroupTemplate.findUnique({
        where: { id: templateId },
        include: {
          modifiers: {
            orderBy: { sortOrder: 'asc' },
          },
        },
      })

      if (template) {
        templateModifiers = template.modifiers.map(m => ({
          name: m.name,
          price: Number(m.price),
          allowNo: m.allowNo,
          allowLite: m.allowLite,
          allowOnSide: m.allowOnSide,
          allowExtra: m.allowExtra,
          extraPrice: Number(m.extraPrice),
          isDefault: m.isDefault,
          sortOrder: m.sortOrder,
        }))
      }
    }

    // Use transaction if we need to link to parent modifier
    const group = await db.$transaction(async (tx) => {
      // Create the modifier group owned by this item
      const newGroup = await tx.modifierGroup.create({
        data: {
          locationId: menuItem.locationId,
          menuItemId, // This makes it item-specific!
          name: name || 'New Group',
          minSelections,
          maxSelections,
          isRequired,
          sortOrder: (maxSort._max.sortOrder || 0) + 1,
          // Create modifiers from template if provided
          modifiers: templateModifiers.length > 0
            ? {
                create: templateModifiers.map(m => ({
                  locationId: menuItem.locationId,
                  name: m.name,
                  price: m.price,
                  allowNo: m.allowNo,
                  allowLite: m.allowLite,
                  allowOnSide: m.allowOnSide,
                  allowExtra: m.allowExtra,
                  extraPrice: m.extraPrice,
                  isDefault: m.isDefault,
                  sortOrder: m.sortOrder,
                })),
              }
            : undefined,
        },
        include: {
          modifiers: {
            where: { deletedAt: null },
            orderBy: { sortOrder: 'asc' },
          },
        },
      })

      // If this is a child group, link it to the parent modifier
      if (parentModifierId) {
        await tx.modifier.update({
          where: { id: parentModifierId },
          data: { childModifierGroupId: newGroup.id },
        })
      }

      return newGroup
    })

    return NextResponse.json({
      data: {
        id: group.id,
        name: group.name,
        minSelections: group.minSelections,
        maxSelections: group.maxSelections,
        isRequired: group.isRequired,
        allowStacking: group.allowStacking,
        tieredPricingConfig: group.tieredPricingConfig,
        exclusionGroupKey: group.exclusionGroupKey,
        sortOrder: group.sortOrder,
        modifiers: group.modifiers.map(m => ({
          id: m.id,
          name: m.name,
          price: Number(m.price),
          allowNo: m.allowNo,
          allowLite: m.allowLite,
          allowOnSide: m.allowOnSide,
          allowExtra: m.allowExtra,
          extraPrice: Number(m.extraPrice),
          isDefault: m.isDefault,
          sortOrder: m.sortOrder,
          isLabel: m.isLabel ?? false,
        })),
      },
    })
  } catch (error) {
    console.error('Error creating modifier group:', error)
    return NextResponse.json({ error: 'Failed to create modifier group' }, { status: 500 })
  }
}

// PATCH /api/menu/items/[id]/modifier-groups - Bulk update sort orders
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId } = await params
    const body = await request.json()
    const { sortOrders } = body // Array of { id: string, sortOrder: number }

    if (!Array.isArray(sortOrders)) {
      return NextResponse.json({ error: 'sortOrders array required' }, { status: 400 })
    }

    // Verify all groups belong to this item
    const groups = await db.modifierGroup.findMany({
      where: { menuItemId, id: { in: sortOrders.map(s => s.id) } },
      select: { id: true },
    })

    if (groups.length !== sortOrders.length) {
      return NextResponse.json({ error: 'Some groups not found' }, { status: 404 })
    }

    // Bulk update in transaction
    await db.$transaction(
      sortOrders.map(({ id, sortOrder }) =>
        db.modifierGroup.update({
          where: { id },
          data: { sortOrder },
        })
      )
    )

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error updating modifier group sort orders:', error)
    return NextResponse.json({ error: 'Failed to update sort orders' }, { status: 500 })
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/menu/items/[id]/modifier-groups/[groupId]/route.ts
LINES:      107
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { Prisma } from '@prisma/client'
import { db } from '@/lib/db'

interface RouteParams {
  params: Promise<{ id: string; groupId: string }>
}

// PUT /api/menu/items/[id]/modifier-groups/[groupId] - Update modifier group
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId, groupId } = await params
    const body = await request.json()
    const { name, minSelections, maxSelections, isRequired, sortOrder, allowStacking, tieredPricingConfig, exclusionGroupKey } = body

    // Verify group belongs to this item
    const group = await db.modifierGroup.findFirst({
      where: { id: groupId, menuItemId },
    })

    if (!group) {
      return NextResponse.json({ error: 'Modifier group not found' }, { status: 404 })
    }

    const updated = await db.modifierGroup.update({
      where: { id: groupId },
      data: {
        name: name !== undefined ? name : undefined,
        minSelections: minSelections !== undefined ? minSelections : undefined,
        maxSelections: maxSelections !== undefined ? maxSelections : undefined,
        isRequired: isRequired !== undefined ? isRequired : undefined,
        sortOrder: sortOrder !== undefined ? sortOrder : undefined,
        allowStacking: allowStacking !== undefined ? allowStacking : undefined,
        tieredPricingConfig: tieredPricingConfig !== undefined ? (tieredPricingConfig ?? Prisma.JsonNull) : undefined,
        exclusionGroupKey: exclusionGroupKey !== undefined ? (exclusionGroupKey || null) : undefined,
      },
      include: {
        modifiers: {
          where: { deletedAt: null, isActive: true },
          orderBy: { sortOrder: 'asc' },
        },
      },
    })

    return NextResponse.json({
      data: {
        id: updated.id,
        name: updated.name,
        minSelections: updated.minSelections,
        maxSelections: updated.maxSelections,
        isRequired: updated.isRequired,
        allowStacking: updated.allowStacking,
        sortOrder: updated.sortOrder,
        tieredPricingConfig: updated.tieredPricingConfig,
        exclusionGroupKey: updated.exclusionGroupKey,
        modifiers: updated.modifiers.map(m => ({
          id: m.id,
          name: m.name,
          price: Number(m.price),
          allowNo: m.allowNo,
          allowLite: m.allowLite,
          allowOnSide: m.allowOnSide,
          allowExtra: m.allowExtra,
          extraPrice: Number(m.extraPrice),
          isDefault: m.isDefault,
          sortOrder: m.sortOrder,
        })),
      },
    })
  } catch (error) {
    console.error('Error updating modifier group:', error)
    return NextResponse.json({ error: 'Failed to update modifier group' }, { status: 500 })
  }
}

// DELETE /api/menu/items/[id]/modifier-groups/[groupId] - Delete modifier group
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId, groupId } = await params

    // Verify group belongs to this item
    const group = await db.modifierGroup.findFirst({
      where: { id: groupId, menuItemId },
    })

    if (!group) {
      return NextResponse.json({ error: 'Modifier group not found' }, { status: 404 })
    }

    // Soft delete the group and its modifiers
    await db.$transaction([
      db.modifier.updateMany({
        where: { modifierGroupId: groupId },
        data: { deletedAt: new Date() },
      }),
      db.modifierGroup.update({
        where: { id: groupId },
        data: { deletedAt: new Date() },
      }),
    ])

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting modifier group:', error)
    return NextResponse.json({ error: 'Failed to delete modifier group' }, { status: 500 })
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/menu/items/[id]/modifier-groups/[groupId]/modifiers/route.ts
LINES:      221
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

interface RouteParams {
  params: Promise<{ id: string; groupId: string }>
}

// POST /api/menu/items/[id]/modifier-groups/[groupId]/modifiers - Add modifier
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId, groupId } = await params
    const body = await request.json()
    const {
      name,
      price = 0,
      allowNo = true,
      allowLite = false,
      allowOnSide = false,
      allowExtra = false,
      extraPrice = 0,
      isDefault = false,
      ingredientId,
      childModifierGroupId,
      isLabel = false,
    } = body

    // Verify group belongs to this item
    const group = await db.modifierGroup.findFirst({
      where: { id: groupId, menuItemId },
      select: { id: true, locationId: true },
    })

    if (!group) {
      return NextResponse.json({ error: 'Modifier group not found' }, { status: 404 })
    }

    // Get max sort order
    const maxSort = await db.modifier.aggregate({
      where: { modifierGroupId: groupId },
      _max: { sortOrder: true },
    })

    const modifier = await db.modifier.create({
      data: {
        locationId: group.locationId,
        modifierGroupId: groupId,
        name: name || 'New Modifier',
        price,
        allowNo,
        allowLite,
        allowOnSide,
        allowExtra,
        extraPrice,
        isDefault,
        ingredientId: ingredientId || null,
        childModifierGroupId: childModifierGroupId || null,
        isLabel,
        sortOrder: (maxSort._max.sortOrder || 0) + 1,
      },
      include: {
        ingredient: {
          select: { id: true, name: true },
        },
        childModifierGroup: {
          select: { id: true, name: true },
        },
      },
    })

    return NextResponse.json({
      data: {
        id: modifier.id,
        name: modifier.name,
        price: Number(modifier.price),
        allowNo: modifier.allowNo,
        allowLite: modifier.allowLite,
        allowOnSide: modifier.allowOnSide,
        allowExtra: modifier.allowExtra,
        extraPrice: Number(modifier.extraPrice),
        isDefault: modifier.isDefault,
        sortOrder: modifier.sortOrder,
        ingredientId: modifier.ingredientId,
        ingredientName: modifier.ingredient?.name || null,
        childModifierGroupId: modifier.childModifierGroupId,
        childModifierGroupName: modifier.childModifierGroup?.name || null,
        isLabel: modifier.isLabel,
      },
    })
  } catch (error) {
    console.error('Error creating modifier:', error)
    return NextResponse.json({ error: 'Failed to create modifier' }, { status: 500 })
  }
}

// PUT /api/menu/items/[id]/modifier-groups/[groupId]/modifiers - Update modifier
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId, groupId } = await params
    const body = await request.json()
    const {
      modifierId,
      name,
      price,
      allowNo,
      allowLite,
      allowOnSide,
      allowExtra,
      extraPrice,
      isDefault,
      ingredientId,
      childModifierGroupId,
      isLabel,
    } = body

    if (!modifierId) {
      return NextResponse.json({ error: 'modifierId is required' }, { status: 400 })
    }

    // Verify modifier belongs to this group
    const modifier = await db.modifier.findFirst({
      where: { id: modifierId, modifierGroupId: groupId },
    })

    if (!modifier) {
      return NextResponse.json({ error: 'Modifier not found' }, { status: 404 })
    }

    const updated = await db.modifier.update({
      where: { id: modifierId },
      data: {
        name: name !== undefined ? name : undefined,
        price: price !== undefined ? price : undefined,
        allowNo: allowNo !== undefined ? allowNo : undefined,
        allowLite: allowLite !== undefined ? allowLite : undefined,
        allowOnSide: allowOnSide !== undefined ? allowOnSide : undefined,
        allowExtra: allowExtra !== undefined ? allowExtra : undefined,
        extraPrice: extraPrice !== undefined ? extraPrice : undefined,
        isDefault: isDefault !== undefined ? isDefault : undefined,
        ingredientId: ingredientId !== undefined ? (ingredientId || null) : undefined,
        childModifierGroupId: childModifierGroupId !== undefined ? (childModifierGroupId || null) : undefined,
        isLabel: isLabel !== undefined ? isLabel : undefined,
      },
      include: {
        ingredient: {
          select: { id: true, name: true },
        },
        childModifierGroup: {
          select: { id: true, name: true },
        },
      },
    })

    return NextResponse.json({
      data: {
        id: updated.id,
        name: updated.name,
        price: Number(updated.price),
        allowNo: updated.allowNo,
        allowLite: updated.allowLite,
        allowOnSide: updated.allowOnSide,
        allowExtra: updated.allowExtra,
        extraPrice: Number(updated.extraPrice),
        isDefault: updated.isDefault,
        sortOrder: updated.sortOrder,
        ingredientId: updated.ingredientId,
        ingredientName: updated.ingredient?.name || null,
        childModifierGroupId: updated.childModifierGroupId,
        childModifierGroupName: updated.childModifierGroup?.name || null,
        isLabel: updated.isLabel,
      },
    })
  } catch (error) {
    console.error('Error updating modifier:', error)
    return NextResponse.json({ error: 'Failed to update modifier' }, { status: 500 })
  }
}

// DELETE /api/menu/items/[id]/modifier-groups/[groupId]/modifiers - Delete modifier
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { groupId } = await params
    const { searchParams } = new URL(request.url)
    const modifierId = searchParams.get('modifierId')

    if (!modifierId) {
      return NextResponse.json({ error: 'modifierId is required' }, { status: 400 })
    }

    // Verify modifier belongs to this group
    const modifier = await db.modifier.findFirst({
      where: { id: modifierId, modifierGroupId: groupId },
    })

    if (!modifier) {
      return NextResponse.json({ error: 'Modifier not found' }, { status: 404 })
    }

    // Soft delete
    await db.modifier.update({
      where: { id: modifierId },
      data: { deletedAt: new Date() },
    })

    // Cascade soft-delete to child modifier group and its modifiers
    if (modifier.childModifierGroupId) {
      await db.modifier.updateMany({
        where: { modifierGroupId: modifier.childModifierGroupId, deletedAt: null },
        data: { deletedAt: new Date() },
      })
      await db.modifierGroup.update({
        where: { id: modifier.childModifierGroupId },
        data: { deletedAt: new Date() },
      })
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting modifier:', error)
    return NextResponse.json({ error: 'Failed to delete modifier' }, { status: 500 })
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/menu/items/route.ts
LINES:      300
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

// GET /api/menu/items - Fetch menu items, optionally filtered by category
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const categoryId = searchParams.get('categoryId')
    const locationId = searchParams.get('locationId')
    const includeStock = searchParams.get('includeStock') === 'true'

    // Build filter
    const where: {
      isActive: boolean
      deletedAt: null
      categoryId?: string
      locationId?: string
    } = {
      isActive: true,
      deletedAt: null,
    }

    if (categoryId) {
      where.categoryId = categoryId
    }
    if (locationId) {
      where.locationId = locationId
    }

    const items = await db.menuItem.findMany({
      where,
      orderBy: { sortOrder: 'asc' },
      include: {
        category: {
          select: { name: true, categoryType: true }
        },
        modifierGroups: {
          where: {
            deletedAt: null,
            modifierGroup: { deletedAt: null }
          },
          include: {
            modifierGroup: {
              include: {
                modifiers: {
                  where: { deletedAt: null, isActive: true },
                  select: {
                    id: true,
                    name: true,
                    price: true,
                    spiritTier: true,
                  },
                  orderBy: { sortOrder: 'asc' }
                }
              }
            }
          }
        },
        // Include ingredients for stock status (only if requested)
        ...(includeStock ? {
          ingredients: {
            where: { deletedAt: null },
            include: {
              ingredient: {
                select: {
                  id: true,
                  name: true,
                  isDailyCountItem: true,
                  currentPrepStock: true,
                  lowStockThreshold: true,
                  criticalStockThreshold: true,
                  onlineStockThreshold: true,
                }
              }
            }
          }
        } : {})
      }
    })

    // Helper to calculate stock status for an item
    type StockStatus = 'in_stock' | 'low_stock' | 'critical' | 'out_of_stock'
    function getStockStatus(item: typeof items[0]): {
      status: StockStatus
      lowestIngredient?: { name: string; stock: number; threshold: number }
    } {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const itemWithIngredients = item as any
      if (!includeStock || !itemWithIngredients.ingredients) {
        return { status: 'in_stock' }
      }

      let worstStatus: StockStatus = 'in_stock'
      let lowestIngredient: { name: string; stock: number; threshold: number } | undefined

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      for (const link of itemWithIngredients.ingredients) {
        const ing = link.ingredient
        if (!ing || !ing.isDailyCountItem) continue

        const stock = Number(ing.currentPrepStock || 0)
        const criticalThreshold = Number(ing.criticalStockThreshold || 0)
        const lowThreshold = Number(ing.lowStockThreshold || 0)

        // Check stock levels - worst status wins
        if (stock <= 0) {
          worstStatus = 'out_of_stock'
          lowestIngredient = { name: ing.name, stock, threshold: criticalThreshold }
          break // Can't get worse than out of stock
        } else if (stock <= criticalThreshold && criticalThreshold > 0) {
          if (worstStatus === 'in_stock' || worstStatus === 'low_stock') {
            worstStatus = 'critical'
            lowestIngredient = { name: ing.name, stock, threshold: criticalThreshold }
          }
        } else if (stock <= lowThreshold && lowThreshold > 0 && worstStatus === 'in_stock') {
          worstStatus = 'low_stock'
          lowestIngredient = { name: ing.name, stock, threshold: lowThreshold }
        }
      }

      return { status: worstStatus, lowestIngredient }
    }

    return NextResponse.json({
      items: items.map(item => {
        // Check if this is a pizza item based on category type OR item type
        const isPizzaItem = item.itemType === 'pizza' || item.category?.categoryType === 'pizza'

        // Check for spirit upgrade group
        const spiritGroup = item.modifierGroups.find(mg => mg.modifierGroup.isSpiritGroup)
        const spiritModifiers = spiritGroup?.modifierGroup.modifiers || []

        // Group spirit modifiers by tier
        const spiritTiers = spiritModifiers.length > 0 ? {
          well: spiritModifiers.filter(m => m.spiritTier === 'well').map(m => ({
            id: m.id, name: m.name, price: Number(m.price)
          })),
          call: spiritModifiers.filter(m => m.spiritTier === 'call').map(m => ({
            id: m.id, name: m.name, price: Number(m.price)
          })),
          premium: spiritModifiers.filter(m => m.spiritTier === 'premium').map(m => ({
            id: m.id, name: m.name, price: Number(m.price)
          })),
          top_shelf: spiritModifiers.filter(m => m.spiritTier === 'top_shelf').map(m => ({
            id: m.id, name: m.name, price: Number(m.price)
          })),
        } : null

        // Get stock status
        const stockInfo = getStockStatus(item)

        return {
          id: item.id,
          categoryId: item.categoryId,
          categoryName: item.category?.name,
          categoryType: item.category?.categoryType,
          name: item.name,
          price: Number(item.price),
          priceCC: item.priceCC ? Number(item.priceCC) : null,
          description: item.description,
          isActive: item.isActive,
          isAvailable: item.isAvailable,
          itemType: item.itemType,
          hasModifiers: item.modifierGroups.length > 0 || isPizzaItem,
          // Only count non-spirit modifier groups for "other" modifiers
          hasOtherModifiers: item.modifierGroups.filter(mg => !mg.modifierGroup.isSpiritGroup).length > 0 || isPizzaItem,
          isPizza: isPizzaItem,
          // Entertainment/timed rental fields
          entertainmentStatus: item.itemType === 'timed_rental' ? (item.entertainmentStatus || 'available') : null,
          blockTimeMinutes: item.itemType === 'timed_rental' ? item.blockTimeMinutes : null,
          timedPricing: item.itemType === 'timed_rental' ? item.timedPricing : null,
          pourSizes: item.pourSizes,
          defaultPourSize: item.defaultPourSize,
          applyPourToModifiers: item.applyPourToModifiers,
          // Spirit tier data for quick selection
          spiritTiers,
          // Stock status (only included if requested)
          ...(includeStock ? {
            stockStatus: stockInfo.status,
            stockWarning: stockInfo.lowestIngredient,
          } : {}),
        }
      })
    })
  } catch (error) {
    console.error('Failed to fetch items:', error)
    return NextResponse.json(
      { error: 'Failed to fetch items' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      name,
      price,
      description,
      categoryId,
      commissionType,
      commissionValue,
      availableFrom,
      availableTo,
      availableDays,
      // Pour size options for liquor items
      pourSizes,
      defaultPourSize,
      applyPourToModifiers,
      // Printer routing
      printerIds,
      backupPrinterIds,
      // Combo print mode
      comboPrintMode,
    } = body

    if (!name?.trim()) {
      return NextResponse.json(
        { error: 'Name is required' },
        { status: 400 }
      )
    }

    if (price === undefined || price < 0) {
      return NextResponse.json(
        { error: 'Valid price is required' },
        { status: 400 }
      )
    }

    // Get the location from the category
    const category = await db.category.findUnique({
      where: { id: categoryId },
      select: { locationId: true }
    })

    if (!category) {
      return NextResponse.json(
        { error: 'Category not found' },
        { status: 400 }
      )
    }

    // Get max sort order in category
    const maxSortOrder = await db.menuItem.aggregate({
      where: { categoryId },
      _max: { sortOrder: true }
    })

    const item = await db.menuItem.create({
      data: {
        locationId: category.locationId,
        categoryId,
        name: name.trim(),
        price,
        description: description || null,
        sortOrder: (maxSortOrder._max.sortOrder || 0) + 1,
        commissionType: commissionType || null,
        commissionValue: commissionValue ?? null,
        availableFrom: availableFrom || null,
        availableTo: availableTo || null,
        availableDays: availableDays || null,
        // Pour size options
        pourSizes: pourSizes || null,
        defaultPourSize: defaultPourSize || null,
        applyPourToModifiers: applyPourToModifiers || false,
        // Printer routing
        printerIds: printerIds && printerIds.length > 0 ? printerIds : null,
        backupPrinterIds: backupPrinterIds && backupPrinterIds.length > 0 ? backupPrinterIds : null,
        // Combo print mode
        comboPrintMode: comboPrintMode || null,
      }
    })

    return NextResponse.json({
      id: item.id,
      categoryId: item.categoryId,
      name: item.name,
      price: Number(item.price),
      description: item.description,
      isActive: item.isActive,
      isAvailable: item.isAvailable,
      commissionType: item.commissionType,
      commissionValue: item.commissionValue ? Number(item.commissionValue) : null,
      availableFrom: item.availableFrom,
      availableTo: item.availableTo,
      availableDays: item.availableDays,
      printerIds: item.printerIds,
      backupPrinterIds: item.backupPrinterIds,
      comboPrintMode: item.comboPrintMode,
    })
  } catch (error) {
    console.error('Failed to create item:', error)
    return NextResponse.json(
      { error: 'Failed to create item' },
      { status: 500 }
    )
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/menu/items/[id]/route.ts
LINES:      189
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchMenuUpdate } from '@/lib/socket-dispatch'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params

    const item = await db.menuItem.findFirst({
      where: { id, deletedAt: null },
      include: {
        category: {
          select: { id: true, name: true, categoryType: true },
        },
        modifierGroups: {
          where: { modifierGroup: { deletedAt: null } },
          select: { modifierGroupId: true },
        },
      },
    })

    if (!item) {
      return NextResponse.json(
        { error: 'Item not found' },
        { status: 404 }
      )
    }

    // Check if this is a pizza item based on category type OR item type
    const isPizzaItem = item.itemType === 'pizza' || item.category?.categoryType === 'pizza'

    return NextResponse.json({
      item: {
        id: item.id,
        categoryId: item.categoryId,
        categoryName: item.category?.name,
        categoryType: item.category?.categoryType,
        name: item.name,
        price: Number(item.price),
        priceCC: item.priceCC ? Number(item.priceCC) : null,
        description: item.description,
        isActive: item.isActive,
        isAvailable: item.isAvailable,
        itemType: item.itemType,
        isPizza: isPizzaItem,
        hasModifiers: item.modifierGroups.length > 0 || isPizzaItem,
        modifierGroups: item.modifierGroups,
        // Entertainment/timed rental fields
        entertainmentStatus: item.itemType === 'timed_rental' ? (item.entertainmentStatus || 'available') : null,
        blockTimeMinutes: item.itemType === 'timed_rental' ? item.blockTimeMinutes : null,
        timedPricing: item.itemType === 'timed_rental' ? item.timedPricing : null,
        pourSizes: item.pourSizes,
        defaultPourSize: item.defaultPourSize,
      },
    })
  } catch (error) {
    console.error('Failed to get item:', error)
    return NextResponse.json(
      { error: 'Failed to get item' },
      { status: 500 }
    )
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const {
      name,
      price,
      priceCC,
      description,
      isActive,
      isAvailable,
      showOnPOS,
      sortOrder,
      deletedAt,
      commissionType,
      commissionValue,
      availableFrom,
      availableTo,
      availableDays,
      // Pour size options
      pourSizes,
      defaultPourSize,
      applyPourToModifiers,
      // Printer routing (arrays)
      printerIds,
      backupPrinterIds,
      // Combo print mode
      comboPrintMode,
    } = body

    const item = await db.menuItem.update({
      where: { id },
      data: {
        ...(name !== undefined && { name }),
        ...(price !== undefined && { price }),
        ...(priceCC !== undefined && { priceCC: priceCC || null }),
        ...(description !== undefined && { description }),
        ...(isActive !== undefined && { isActive }),
        ...(isAvailable !== undefined && { isAvailable }),
        ...(showOnPOS !== undefined && { showOnPOS }),
        ...(sortOrder !== undefined && { sortOrder }),
        ...(deletedAt !== undefined && { deletedAt: deletedAt ? new Date(deletedAt) : null }),
        ...(commissionType !== undefined && { commissionType: commissionType || null }),
        ...(commissionValue !== undefined && { commissionValue: commissionValue ?? null }),
        ...(availableFrom !== undefined && { availableFrom: availableFrom || null }),
        ...(availableTo !== undefined && { availableTo: availableTo || null }),
        ...(availableDays !== undefined && { availableDays: availableDays || null }),
        // Pour size options
        ...(pourSizes !== undefined && { pourSizes: pourSizes || null }),
        ...(defaultPourSize !== undefined && { defaultPourSize: defaultPourSize || null }),
        ...(applyPourToModifiers !== undefined && { applyPourToModifiers }),
        // Printer routing - arrays of printer IDs
        ...(printerIds !== undefined && {
          printerIds: printerIds && printerIds.length > 0 ? printerIds : null
        }),
        ...(backupPrinterIds !== undefined && {
          backupPrinterIds: backupPrinterIds && backupPrinterIds.length > 0 ? backupPrinterIds : null
        }),
        // Combo print mode
        ...(comboPrintMode !== undefined && { comboPrintMode: comboPrintMode || null }),
      }
    })

    // Dispatch socket event for real-time update
    const action = deletedAt ? 'deleted' : (item.deletedAt === null && deletedAt === undefined) ? 'updated' : 'restored'
    dispatchMenuUpdate(item.locationId, {
      action,
      menuItemId: item.id,
      bottleId: item.linkedBottleProductId || undefined,
      name: item.name,
    }, { async: true })

    return NextResponse.json({
      id: item.id,
      categoryId: item.categoryId,
      name: item.name,
      price: Number(item.price),
      priceCC: item.priceCC ? Number(item.priceCC) : null,
      description: item.description,
      isActive: item.isActive,
      isAvailable: item.isAvailable,
      commissionType: item.commissionType,
      commissionValue: item.commissionValue ? Number(item.commissionValue) : null,
      availableFrom: item.availableFrom,
      availableTo: item.availableTo,
      availableDays: item.availableDays,
      pourSizes: item.pourSizes,
      defaultPourSize: item.defaultPourSize,
      applyPourToModifiers: item.applyPourToModifiers,
      printerIds: item.printerIds,
      backupPrinterIds: item.backupPrinterIds,
      comboPrintMode: item.comboPrintMode,
    })
  } catch (error) {
    console.error('Failed to update item:', error)
    return NextResponse.json(
      { error: 'Failed to update item' },
      { status: 500 }
    )
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params

    await db.menuItem.delete({ where: { id } })
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to delete item:', error)
    return NextResponse.json(
      { error: 'Failed to delete item' },
      { status: 500 }
    )
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/menu/items/[id]/ingredients/route.ts
LINES:      185
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

interface RouteParams {
  params: Promise<{ id: string }>
}

// GET /api/menu/items/[id]/ingredients - Get ingredients for a menu item
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId } = await params

    // Verify menu item exists
    const menuItem = await db.menuItem.findUnique({
      where: { id: menuItemId },
      select: { id: true, locationId: true },
    })

    if (!menuItem) {
      return NextResponse.json({ error: 'Menu item not found' }, { status: 404 })
    }

    const ingredients = await db.menuItemIngredient.findMany({
      where: { menuItemId },
      include: {
        ingredient: {
          include: {
            swapGroup: {
              select: {
                id: true,
                name: true,
                ingredients: {
                  where: { isActive: true, deletedAt: null },
                  select: {
                    id: true,
                    name: true,
                    extraPrice: true,
                  },
                  orderBy: { sortOrder: 'asc' },
                },
              },
            },
          },
        },
      },
      orderBy: { sortOrder: 'asc' },
    })

    return NextResponse.json({
      data: ingredients.map(mi => ({
        id: mi.id,
        ingredientId: mi.ingredientId,
        name: mi.ingredient.name,
        category: mi.ingredient.category,
        isIncluded: mi.isIncluded,
        sortOrder: mi.sortOrder,
        // Modification options (use override if set, otherwise ingredient default)
        allowNo: mi.allowNo ?? mi.ingredient.allowNo,
        allowLite: mi.allowLite ?? mi.ingredient.allowLite,
        allowOnSide: mi.allowOnSide ?? mi.ingredient.allowOnSide,
        allowExtra: mi.allowExtra ?? mi.ingredient.allowExtra,
        extraPrice: Number(mi.extraPrice ?? mi.ingredient.extraPrice),
        allowSwap: mi.ingredient.allowSwap,
        swapUpcharge: Number(mi.ingredient.swapUpcharge),
        // Swap options (ingredients that can be swapped for this one)
        swapGroup: mi.ingredient.swapGroup ? {
          id: mi.ingredient.swapGroup.id,
          name: mi.ingredient.swapGroup.name,
          ingredients: mi.ingredient.swapGroup.ingredients.map(ing => ({
            id: ing.id,
            name: ing.name,
            extraPrice: Number(ing.extraPrice),
          })),
        } : null,
        // Override flags
        hasExtraPriceOverride: mi.extraPrice !== null,
      })),
    })
  } catch (error) {
    console.error('Error fetching menu item ingredients:', error)
    return NextResponse.json({ error: 'Failed to fetch ingredients' }, { status: 500 })
  }
}

// POST /api/menu/items/[id]/ingredients - Save ingredients for a menu item
// Replaces all existing ingredient links
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: menuItemId } = await params
    const body = await request.json()
    // Array of { ingredientId, isIncluded?, allowNo?, allowLite?, allowExtra?, allowOnSide?, extraPriceOverride?, swapUpchargeOverride? }
    const { ingredients } = body

    if (!Array.isArray(ingredients)) {
      return NextResponse.json({ error: 'ingredients array is required' }, { status: 400 })
    }

    // Verify menu item exists and get locationId
    const menuItem = await db.menuItem.findUnique({
      where: { id: menuItemId },
      select: { id: true, locationId: true },
    })

    if (!menuItem) {
      return NextResponse.json({ error: 'Menu item not found' }, { status: 404 })
    }

    // Verify all ingredient IDs exist
    const ingredientIds = ingredients.map(i => i.ingredientId)
    const existingIngredients = await db.ingredient.findMany({
      where: { id: { in: ingredientIds }, locationId: menuItem.locationId },
      select: { id: true },
    })
    const existingIds = new Set(existingIngredients.map(i => i.id))
    const invalidIds = ingredientIds.filter(id => !existingIds.has(id))
    if (invalidIds.length > 0) {
      return NextResponse.json(
        { error: `Invalid ingredient IDs: ${invalidIds.join(', ')}` },
        { status: 400 }
      )
    }

    // Delete existing and create new in a transaction
    await db.$transaction(async (tx) => {
      // Delete existing links
      await tx.menuItemIngredient.deleteMany({
        where: { menuItemId },
      })

      // Create new links
      if (ingredients.length > 0) {
        await tx.menuItemIngredient.createMany({
          data: ingredients.map((ing, index) => ({
            locationId: menuItem.locationId,
            menuItemId,
            ingredientId: ing.ingredientId,
            isIncluded: ing.isIncluded ?? true,
            isBase: ing.isBase ?? true,
            sortOrder: ing.sortOrder ?? index,
            quantity: ing.quantity ?? null,
            unit: ing.unit ?? null,
            // Pre-modifier overrides (null = use ingredient defaults)
            allowNo: ing.allowNo ?? null,
            allowLite: ing.allowLite ?? null,
            allowExtra: ing.allowExtra ?? null,
            allowOnSide: ing.allowOnSide ?? null,
            extraPrice: ing.extraPrice ?? null,
          })),
        })
      }
    })

    // Fetch and return updated ingredients
    const updated = await db.menuItemIngredient.findMany({
      where: { menuItemId },
      include: {
        ingredient: {
          include: {
            swapGroup: {
              select: { id: true, name: true },
            },
          },
        },
      },
      orderBy: { sortOrder: 'asc' },
    })

    return NextResponse.json({
      data: updated.map(mi => ({
        id: mi.id,
        ingredientId: mi.ingredientId,
        name: mi.ingredient.name,
        category: mi.ingredient.category,
        isIncluded: mi.isIncluded,
        isBase: mi.isBase,
        sortOrder: mi.sortOrder,
        extraPrice: Number(mi.extraPrice ?? mi.ingredient.extraPrice),
        swapUpcharge: Number(mi.ingredient.swapUpcharge),
      })),
    })
  } catch (error) {
    console.error('Error saving menu item ingredients:', error)
    return NextResponse.json({ error: 'Failed to save ingredients' }, { status: 500 })
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/app/api/ingredients/route.ts
LINES:      447
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

// GET /api/ingredients - List ingredients with filtering and grouping
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')
    const categoryId = searchParams.get('categoryId')
    const includeInactive = searchParams.get('includeInactive') === 'true'
    const visibility = searchParams.get('visibility') || 'visible' // 'visible', 'admin_only', 'all'
    const groupByCategory = searchParams.get('groupByCategory') === 'true'
    const hierarchy = searchParams.get('hierarchy') === 'true'
    const baseOnly = searchParams.get('baseOnly') === 'true' // Only get base ingredients (no children)
    const deletedOnly = searchParams.get('deletedOnly') === 'true' // Only get soft-deleted ingredients

    if (!locationId) {
      return NextResponse.json({ error: 'locationId is required' }, { status: 400 })
    }

    // Build visibility filter
    const visibilityFilter = visibility === 'all'
      ? {}
      : { visibility: visibility === 'admin_only' ? { in: ['visible', 'admin_only'] } : 'visible' }

    // Build hierarchy filter - when hierarchy=true, only get root ingredients (parentIngredientId = null)
    // When baseOnly=true, only get base ingredients
    const hierarchyFilter = hierarchy || baseOnly
      ? { parentIngredientId: null }
      : {}

    // Build deletion filter
    const deletionFilter = deletedOnly
      ? { deletedAt: { not: null } } // Only deleted items
      : { deletedAt: null } // Only non-deleted items (default)

    const ingredients = await db.ingredient.findMany({
      where: {
        locationId,
        ...deletionFilter,
        ...(categoryId ? { categoryId } : {}),
        ...(includeInactive ? {} : { isActive: true }),
        ...visibilityFilter,
        ...hierarchyFilter,
      },
      include: {
        categoryRelation: {
          select: {
            id: true,
            code: true,
            name: true,
            icon: true,
            color: true,
          },
        },
        inventoryItem: {
          select: {
            id: true,
            name: true,
            storageUnit: true,
          },
        },
        prepItem: {
          select: {
            id: true,
            name: true,
            outputUnit: true,
          },
        },
        swapGroup: {
          select: {
            id: true,
            name: true,
          },
        },
        // Include parent ingredient info
        parentIngredient: {
          select: {
            id: true,
            name: true,
            standardQuantity: true,
            standardUnit: true,
          },
        },
        // Include child ingredients (preparations) when hierarchy mode
        ...(hierarchy ? {
          childIngredients: {
            where: { deletedAt: null },
            include: {
              inventoryItem: {
                select: { id: true, name: true, storageUnit: true },
              },
              prepItem: {
                select: { id: true, name: true, outputUnit: true },
              },
              // Recursively include grandchildren (one level deep for now)
              childIngredients: {
                where: { deletedAt: null },
                select: {
                  id: true,
                  locationId: true,
                  name: true,
                  description: true,
                  categoryId: true,
                  preparationType: true,
                  yieldPercent: true,
                  batchYield: true,
                  portionSize: true,
                  portionUnit: true,
                  liteMultiplier: true,
                  extraMultiplier: true,
                  standardQuantity: true,
                  standardUnit: true,
                  isBaseIngredient: true,
                  isActive: true,
                  visibility: true,
                  isDailyCountItem: true,
                  currentPrepStock: true,
                  lowStockThreshold: true,
                  criticalStockThreshold: true,
                  onlineStockThreshold: true,
                  parentIngredientId: true,
                },
              },
            },
            orderBy: { sortOrder: 'asc' },
          },
        } : {}),
        _count: {
          select: {
            menuItemIngredients: true,
            childIngredients: true,
          },
        },
      },
      orderBy: [
        { categoryRelation: { sortOrder: 'asc' } },
        { sortOrder: 'asc' },
      ],
    })

    // Helper to format child ingredients recursively
    const formatChildIngredient = (child: typeof ingredients[0]['childIngredients'][0] | any, parent?: any): any => ({
      id: child.id,
      locationId: child.locationId,
      name: child.name,
      description: child.description,
      categoryId: child.categoryId,
      preparationType: child.preparationType,
      yieldPercent: child.yieldPercent ? Number(child.yieldPercent) : null,
      batchYield: child.batchYield ? Number(child.batchYield) : null,
      portionSize: child.portionSize ? Number(child.portionSize) : null,
      portionUnit: child.portionUnit,
      liteMultiplier: child.liteMultiplier ? Number(child.liteMultiplier) : 0.5,
      extraMultiplier: child.extraMultiplier ? Number(child.extraMultiplier) : 2.0,
      standardQuantity: child.standardQuantity ? Number(child.standardQuantity) : null,
      standardUnit: child.standardUnit,
      isBaseIngredient: child.isBaseIngredient,
      isActive: child.isActive,
      visibility: child.visibility,
      isDailyCountItem: child.isDailyCountItem || false,
      countPrecision: child.countPrecision || 'whole',
      currentPrepStock: child.currentPrepStock ? Number(child.currentPrepStock) : 0,
      lowStockThreshold: child.lowStockThreshold ? Number(child.lowStockThreshold) : null,
      criticalStockThreshold: child.criticalStockThreshold ? Number(child.criticalStockThreshold) : null,
      onlineStockThreshold: child.onlineStockThreshold ? Number(child.onlineStockThreshold) : null,
      inventoryItem: child.inventoryItem,
      prepItem: child.prepItem,
      // Critical: include parent info so modal knows this is a prep item
      parentIngredientId: child.parentIngredientId,
      parentIngredient: parent ? {
        id: parent.id,
        name: parent.name,
        standardQuantity: parent.standardQuantity ? Number(parent.standardQuantity) : null,
        standardUnit: parent.standardUnit,
      } : null,
      childIngredients: child.childIngredients?.map((c: any) => formatChildIngredient(c, child)) || [],
    })

    // Format ingredients
    const formattedIngredients = ingredients.map(ing => ({
      id: ing.id,
      locationId: ing.locationId,
      name: ing.name,
      description: ing.description,
      category: ing.category, // Legacy string
      categoryId: ing.categoryId,
      categoryRelation: ing.categoryRelation,
      inventoryItemId: ing.inventoryItemId,
      inventoryItem: ing.inventoryItem,
      prepItemId: ing.prepItemId,
      prepItem: ing.prepItem,
      standardQuantity: ing.standardQuantity ? Number(ing.standardQuantity) : null,
      standardUnit: ing.standardUnit,
      allowNo: ing.allowNo,
      allowLite: ing.allowLite,
      allowExtra: ing.allowExtra,
      allowOnSide: ing.allowOnSide,
      extraPrice: Number(ing.extraPrice),
      liteMultiplier: Number(ing.liteMultiplier),
      extraMultiplier: Number(ing.extraMultiplier),
      allowSwap: ing.allowSwap,
      swapGroupId: ing.swapGroupId,
      swapGroup: ing.swapGroup,
      swapUpcharge: Number(ing.swapUpcharge),
      visibility: ing.visibility,
      sortOrder: ing.sortOrder,
      isActive: ing.isActive,
      usedByCount: ing._count.menuItemIngredients,
      // Hierarchy fields
      parentIngredientId: ing.parentIngredientId,
      parentIngredient: ing.parentIngredient,
      preparationType: ing.preparationType,
      yieldPercent: ing.yieldPercent ? Number(ing.yieldPercent) : null,
      batchYield: ing.batchYield ? Number(ing.batchYield) : null,
      portionSize: ing.portionSize ? Number(ing.portionSize) : null,
      portionUnit: ing.portionUnit,
      isBaseIngredient: ing.isBaseIngredient,
      isDailyCountItem: ing.isDailyCountItem || false,
      countPrecision: ing.countPrecision || 'whole',
      childIngredients: (ing as any).childIngredients?.map((c: any) => formatChildIngredient(c, ing)) || [],
      childCount: ing._count.childIngredients,
      createdAt: ing.createdAt,
      updatedAt: ing.updatedAt,
    }))

    // Optionally group by category
    if (groupByCategory) {
      const grouped: Record<string, {
        category: {
          id: string
          code: number
          name: string
          icon: string | null
          color: string | null
        } | null
        ingredients: typeof formattedIngredients
      }> = {}

      for (const ing of formattedIngredients) {
        const catId = ing.categoryId || 'uncategorized'
        if (!grouped[catId]) {
          grouped[catId] = {
            category: ing.categoryRelation || null,
            ingredients: [],
          }
        }
        grouped[catId].ingredients.push(ing)
      }

      return NextResponse.json({
        data: Object.values(grouped).sort((a, b) => {
          if (!a.category) return 1
          if (!b.category) return -1
          return 0
        }),
      })
    }

    return NextResponse.json({ data: formattedIngredients })
  } catch (error) {
    console.error('Error fetching ingredients:', error)
    return NextResponse.json({ error: 'Failed to fetch ingredients' }, { status: 500 })
  }
}

// POST /api/ingredients - Create a new ingredient
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      locationId,
      name,
      description,
      categoryId,
      inventoryItemId,
      prepItemId,
      standardQuantity,
      standardUnit,
      // Source and purchase info
      sourceType = 'delivered',
      purchaseUnit,
      purchaseCost,
      unitsPerPurchase,
      // Customization
      allowNo = true,
      allowLite = true,
      allowExtra = true,
      allowOnSide = false,
      extraPrice = 0,
      liteMultiplier = 0.5,
      extraMultiplier = 2.0,
      allowSwap = false,
      swapGroupId,
      swapUpcharge = 0,
      visibility = 'visible',
      sortOrder,
      // Hierarchy fields
      parentIngredientId,
      preparationType,
      yieldPercent,
      isBaseIngredient = true,
      // Input/Output transformation (for prep items)
      inputQuantity,
      inputUnit,
      outputQuantity,
      outputUnit,
      // Quick 86
      showOnQuick86 = false,
    } = body

    if (!locationId || !name) {
      return NextResponse.json(
        { error: 'locationId and name are required' },
        { status: 400 }
      )
    }

    // Check for duplicate name
    const existing = await db.ingredient.findFirst({
      where: { locationId, name, deletedAt: null },
    })
    if (existing) {
      return NextResponse.json(
        { error: 'An ingredient with this name already exists' },
        { status: 409 }
      )
    }

    // Validate categoryId if provided
    if (categoryId) {
      const category = await db.ingredientCategory.findUnique({ where: { id: categoryId } })
      if (!category || category.deletedAt) {
        return NextResponse.json(
          { error: 'Invalid category' },
          { status: 400 }
        )
      }
    }

    // Validate parentIngredientId if provided
    let parentIngredient = null
    if (parentIngredientId) {
      parentIngredient = await db.ingredient.findUnique({ where: { id: parentIngredientId } })
      if (!parentIngredient || parentIngredient.deletedAt) {
        return NextResponse.json(
          { error: 'Invalid parent ingredient' },
          { status: 400 }
        )
      }
    }

    // Get max sortOrder if not provided
    let finalSortOrder = sortOrder
    if (finalSortOrder === undefined) {
      const maxSort = await db.ingredient.aggregate({
        where: { locationId },
        _max: { sortOrder: true },
      })
      finalSortOrder = (maxSort._max.sortOrder ?? -1) + 1
    }

    // If this is a child ingredient (has parentIngredientId), inherit category from parent
    // and set isBaseIngredient to false
    const finalCategoryId = parentIngredientId && parentIngredient
      ? parentIngredient.categoryId
      : categoryId
    const finalIsBaseIngredient = parentIngredientId ? false : isBaseIngredient

    const ingredient = await db.ingredient.create({
      data: {
        locationId,
        name,
        description,
        categoryId: finalCategoryId,
        inventoryItemId,
        prepItemId,
        standardQuantity,
        standardUnit,
        // Source and purchase info
        sourceType,
        purchaseUnit: sourceType === 'delivered' ? purchaseUnit : null,
        purchaseCost: sourceType === 'delivered' ? purchaseCost : null,
        unitsPerPurchase: sourceType === 'delivered' ? unitsPerPurchase : null,
        // Customization
        allowNo,
        allowLite,
        allowExtra,
        allowOnSide,
        extraPrice,
        liteMultiplier,
        extraMultiplier,
        allowSwap,
        swapGroupId: allowSwap ? swapGroupId : null,
        swapUpcharge: allowSwap ? swapUpcharge : 0,
        visibility,
        sortOrder: finalSortOrder,
        // Hierarchy fields
        parentIngredientId,
        preparationType: parentIngredientId ? preparationType : null,
        yieldPercent: parentIngredientId ? yieldPercent : null,
        isBaseIngredient: finalIsBaseIngredient,
        // Input/Output transformation (for prep items)
        inputQuantity: parentIngredientId ? inputQuantity : null,
        inputUnit: parentIngredientId ? inputUnit : null,
        outputQuantity: parentIngredientId ? outputQuantity : null,
        outputUnit: parentIngredientId ? outputUnit : null,
        // Quick 86
        showOnQuick86,
      },
      include: {
        categoryRelation: {
          select: { id: true, code: true, name: true, icon: true, color: true },
        },
        inventoryItem: {
          select: { id: true, name: true, storageUnit: true },
        },
        prepItem: {
          select: { id: true, name: true, outputUnit: true },
        },
        swapGroup: {
          select: { id: true, name: true },
        },
        parentIngredient: {
          select: { id: true, name: true, standardQuantity: true, standardUnit: true },
        },
      },
    })

    return NextResponse.json({
      data: {
        ...ingredient,
        standardQuantity: ingredient.standardQuantity ? Number(ingredient.standardQuantity) : null,
        purchaseCost: ingredient.purchaseCost ? Number(ingredient.purchaseCost) : null,
        unitsPerPurchase: ingredient.unitsPerPurchase ? Number(ingredient.unitsPerPurchase) : null,
        extraPrice: Number(ingredient.extraPrice),
        liteMultiplier: Number(ingredient.liteMultiplier),
        extraMultiplier: Number(ingredient.extraMultiplier),
        swapUpcharge: Number(ingredient.swapUpcharge),
        yieldPercent: ingredient.yieldPercent ? Number(ingredient.yieldPercent) : null,
      },
    })
  } catch (error) {
    console.error('Error creating ingredient:', error)
    return NextResponse.json({ error: 'Failed to create ingredient' }, { status: 500 })
  }
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /src/types/index.ts
LINES:      537
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Shared Types for GWI POS
// Consolidated type definitions used across the application

/**
 * Category for menu organization
 */
export interface Category {
  id: string
  name: string
  color: string
  categoryType?: 'food' | 'drinks' | 'liquor' | 'entertainment' | 'combos' | 'pizza'
}

/**
 * Menu item with pricing and availability
 */
export interface MenuItem {
  id: string
  categoryId: string
  name: string
  price: number
  isAvailable: boolean
  modifierGroupCount?: number
  itemType?: string
  timedPricing?: {
    per15Min?: number
    per30Min?: number
    perHour?: number
    minimum?: number
  }
  // Entertainment item fields
  entertainmentStatus?: 'available' | 'in_use' | 'maintenance' | null
  currentOrderId?: string | null
  blockTimeMinutes?: number | null  // Default block time for entertainment items
  // Pour size options for liquor items (can be old or new format)
  // Old format: { shot: 1.0, double: 2.0 }
  // New format: { shot: { label: "Shot", multiplier: 1.0 }, double: { label: "Double", multiplier: 2.0 } }
  pourSizes?: Record<string, number | { label: string; multiplier: number }> | null
  defaultPourSize?: string | null
  applyPourToModifiers?: boolean
  // Liquor item flag
  isLiquorItem?: boolean
}

/**
 * Modifier within a modifier group
 */
export interface Modifier {
  id: string
  name: string
  price: number
  upsellPrice?: number | null
  allowedPreModifiers?: string[] | null
  extraPrice?: number | null
  isDefault: boolean
  childModifierGroupId?: string | null
  // Spirit selection fields (Liquor Builder)
  spiritTier?: 'well' | 'call' | 'premium' | 'top_shelf' | null
  linkedBottleProductId?: string | null
  linkedBottleProduct?: {
    id: string
    name: string
    pourCost: number | null
  } | null
  is86d?: boolean
  isLabel?: boolean
}

/**
 * Group of modifiers for an item
 */
export interface ModifierGroup {
  id: string
  name: string
  displayName?: string
  minSelections: number
  maxSelections: number
  isRequired: boolean
  allowStacking?: boolean  // Allow selecting the same modifier multiple times (e.g., 2x Fries for 2 side choices)
  // Tiered pricing configuration
  tieredPricingConfig?: {
    enabled: boolean
    modes: { flat_tiers: boolean; free_threshold: boolean }
    flat_tiers?: {
      tiers: Array<{ upTo: number; price: number }>
      overflowPrice: number
    }
    free_threshold?: {
      freeCount: number
    }
  } | null
  // Exclusion group key for cross-group duplicate prevention
  exclusionGroupKey?: string | null
  modifiers: Modifier[]
  // Modifier types for filtering/coloring
  modifierTypes?: string[]  // e.g., ['liquor'], ['food', 'combo'], etc.
  // Spirit group fields (Liquor Builder)
  isSpiritGroup?: boolean
  spiritConfig?: {
    spiritCategoryId: string
    spiritCategoryName: string
    upsellEnabled: boolean
    upsellPromptText?: string | null
    defaultTier: string
  } | null
}

/**
 * A modifier that has been selected for an order item
 */
export interface SelectedModifier {
  id: string
  name: string
  price: number
  preModifier?: string  // 'no', 'light', 'extra', etc.
  childModifierGroupId?: string | null
  depth: number         // 0 = top-level, 1 = child, 2 = grandchild, etc.
  parentModifierId?: string  // ID of parent modifier if this is a child
  // Spirit selection fields (Liquor Builder)
  spiritTier?: 'well' | 'call' | 'premium' | 'top_shelf' | null
  linkedBottleProductId?: string | null
}

/**
 * An item on an order with its modifiers
 */
export interface OrderItem {
  id: string
  menuItemId: string
  name: string
  quantity: number
  price: number
  modifiers: { id: string; name: string; price: number; preModifier?: string }[]
  specialNotes?: string
  status?: 'pending' | 'sent' | 'preparing' | 'ready' | 'served' | 'voided' | 'comped'
  voidReason?: string
  sentToKitchen?: boolean
  seatNumber?: number
  courseNumber?: number
  holdUntil?: Date | null
  firedAt?: Date | null
  // Pizza builder configuration (for pizza items)
  pizzaConfig?: PizzaOrderConfig
}

/**
 * Combo template component with options
 */
export interface ComboComponent {
  id: string
  slotName: string
  displayName: string
  sortOrder: number
  isRequired: boolean
  minSelections: number
  maxSelections: number
  menuItemId?: string | null
  menuItem?: {
    id: string
    name: string
    price: number
    modifierGroups?: {
      modifierGroup: ModifierGroup
    }[]
  } | null
  itemPriceOverride?: number | null
  modifierPriceOverrides?: Record<string, number> | null
  options: {
    id: string
    menuItemId: string
    name: string
    upcharge: number
    sortOrder: number
    isAvailable: boolean
  }[]
}

/**
 * Combo template structure
 */
export interface ComboTemplate {
  id: string
  basePrice: number
  comparePrice?: number | null
  components: ComboComponent[]
}

/**
 * Payment information for an order
 */
export interface PaymentInfo {
  id: string
  method: 'cash' | 'credit' | 'debit' | 'gift_card' | 'house_account'
  amount: number
  tipAmount: number
  totalAmount: number
  cardLast4?: string
  giftCardNumber?: string
  houseAccountId?: string
  changeGiven?: number
}

/**
 * Order status enum
 */
export type OrderStatus = 'open' | 'paid' | 'closed' | 'voided' | 'refunded'

/**
 * Open order summary for display
 */
export interface OpenOrderSummary {
  id: string
  orderNumber: string
  tableId?: string
  tableName?: string
  tabId?: string
  tabName?: string
  employeeId: string
  employeeName: string
  status: OrderStatus
  subtotal: number
  total: number
  itemCount: number
  createdAt: string
  updatedAt: string
}

/**
 * Timed session for entertainment items
 */
export interface TimedSession {
  id: string
  orderItemId: string
  menuItemName: string
  startTime: string
  rateType: 'per_15_min' | 'per_30_min' | 'per_hour' | 'flat_rate'
  rateAmount: number
  currentAmount: number
  elapsedMinutes: number
  status: 'active' | 'paused' | 'stopped'
  tableName?: string
}

/**
 * Tab for bar/quick service
 */
export interface Tab {
  id: string
  name: string
  status: 'open' | 'paid' | 'closed'
  preAuthAmount?: number
  cardLast4?: string
  employeeId: string
  employeeName?: string
  subtotal: number
  items: OrderItem[]
  createdAt: string
}

/**
 * Employee with role and permissions
 */
export interface Employee {
  id: string
  name: string
  email?: string
  roleId: string
  roleName?: string
  permissions?: string[]
  isActive: boolean
  location?: {
    id: string
    name: string
  }
}

/**
 * Customer with loyalty and account info
 */
export interface Customer {
  id: string
  firstName: string
  lastName: string
  email?: string
  phone?: string
  loyaltyPoints?: number
  houseAccountId?: string
  createdAt: string
}

/**
 * Discount applied to an order
 */
export interface AppliedDiscount {
  id: string
  name: string
  amount: number
  percent?: number | null
  discountType: 'percent' | 'fixed' | 'bogo' | 'item' | 'category'
}

/**
 * Gift card information
 */
export interface GiftCard {
  id: string
  cardNumber: string
  balance: number
  originalAmount: number
  status: 'active' | 'depleted' | 'deactivated'
  expiresAt?: string
}

/**
 * House account for business customers
 */
export interface HouseAccount {
  id: string
  name: string
  companyName?: string
  creditLimit: number
  currentBalance: number
  status: 'active' | 'suspended' | 'closed'
}

// ==================== Pizza Builder Types ====================

/**
 * Pizza configuration for a location
 */
export interface PizzaConfig {
  id: string
  locationId: string
  maxSections: number
  defaultSections: number
  sectionOptions: number[]
  pricingMode: 'fractional' | 'flat' | 'hybrid'
  hybridPricing?: { whole: number; half: number; quarter: number; eighth: number } | null
  freeToppingsEnabled: boolean
  freeToppingsCount: number
  freeToppingsMode: 'per_pizza' | 'per_size'
  extraToppingPrice?: number | null
  showVisualBuilder: boolean
  showToppingList: boolean
  defaultToListView: boolean
  // Builder mode settings (Skill 109)
  builderMode: 'quick' | 'visual' | 'both'
  defaultBuilderMode: 'quick' | 'visual'
  allowModeSwitch: boolean
}

/**
 * Pizza size option
 */
export interface PizzaSize {
  id: string
  locationId: string
  name: string
  displayName?: string | null
  inches?: number | null
  slices: number
  basePrice: number
  priceMultiplier: number
  toppingMultiplier: number
  freeToppings: number
  sortOrder: number
  isDefault: boolean
  isActive: boolean
}

/**
 * Pizza crust option
 */
export interface PizzaCrust {
  id: string
  locationId: string
  name: string
  displayName?: string | null
  price: number
  isDefault: boolean
  isActive: boolean
  sortOrder: number
}

/**
 * Pizza sauce option
 */
export interface PizzaSauce {
  id: string
  locationId: string
  name: string
  displayName?: string | null
  price: number
  isDefault: boolean
  isActive: boolean
  sortOrder: number
  allowLight: boolean
  allowExtra: boolean
  extraPrice: number
}

/**
 * Pizza cheese option
 */
export interface PizzaCheese {
  id: string
  locationId: string
  name: string
  displayName?: string | null
  price: number
  isDefault: boolean
  isActive: boolean
  sortOrder: number
  allowLight: boolean
  allowExtra: boolean
  extraPrice: number
}

/**
 * Pizza topping option
 */
export interface PizzaTopping {
  id: string
  locationId: string
  name: string
  displayName?: string | null
  category: 'meat' | 'veggie' | 'cheese' | 'premium' | 'seafood' | 'standard'
  price: number
  extraPrice?: number | null
  isActive: boolean
  sortOrder: number
  color?: string | null
  iconUrl?: string | null
}

/**
 * Selected topping on a pizza with section coverage
 */
export interface PizzaToppingSelection {
  toppingId: string
  name: string
  sections: number[]
  amount: 'light' | 'regular' | 'extra'
  price: number
  basePrice: number
}

/**
 * Pizza specialty (pre-built pizza)
 */
export interface PizzaSpecialty {
  id: string
  locationId: string
  menuItemId: string
  menuItem: {
    id: string
    name: string
    price: number
  }
  defaultCrustId?: string | null
  defaultCrust?: PizzaCrust | null
  defaultSauceId?: string | null
  defaultSauce?: PizzaSauce | null
  defaultCheeseId?: string | null
  defaultCheese?: PizzaCheese | null
  sauceAmount: 'none' | 'light' | 'regular' | 'extra'
  cheeseAmount: 'none' | 'light' | 'regular' | 'extra'
  toppings: Array<{
    toppingId: string
    name: string
    sections: number[]
    amount: 'light' | 'regular' | 'extra'
  }>
  allowSizeChange: boolean
  allowCrustChange: boolean
  allowSauceChange: boolean
  allowCheeseChange: boolean
  allowToppingMods: boolean
}

/**
 * Sauce selection with sections (like toppings)
 */
export interface PizzaSauceSelection {
  sauceId: string
  name: string
  sections: number[]
  amount: 'none' | 'light' | 'regular' | 'extra'
  price: number
}

/**
 * Cheese selection with sections (like toppings)
 */
export interface PizzaCheeseSelection {
  cheeseId: string
  name: string
  sections: number[]
  amount: 'none' | 'light' | 'regular' | 'extra'
  price: number
}

/**
 * Full pizza order configuration
 */
export interface PizzaOrderConfig {
  sizeId: string
  crustId: string
  // Legacy fields for backwards compatibility
  sauceId: string | null
  cheeseId: string | null
  sauceAmount: 'none' | 'light' | 'regular' | 'extra'
  cheeseAmount: 'none' | 'light' | 'regular' | 'extra'
  // New sectional arrays
  sauces?: PizzaSauceSelection[]
  cheeses?: PizzaCheeseSelection[]
  toppings: PizzaToppingSelection[]
  cookingInstructions?: string
  cutStyle?: string
  specialNotes?: string
  totalPrice: number
  priceBreakdown: {
    sizePrice: number
    crustPrice: number
    saucePrice: number
    cheesePrice: number
    toppingsPrice: number
  }
}

// Re-export payment types
export type {
  SimulatedPaymentResult,
  SimulatedCardReaderProps,
  CardReadMethod,
  CardReaderState,
} from './payment'

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FILE: /prisma/schema.prisma (SELECTED MODELS ONLY)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Extracted models: Modifier, ModifierGroup, MenuItem, MenuItemModifierGroup,
// Ingredient, IngredientCategory

model Modifier {
  id              String        @id @default(cuid())
  locationId      String
  location        Location      @relation(fields: [locationId], references: [id])
  modifierGroupId String
  modifierGroup   ModifierGroup @relation(fields: [modifierGroupId], references: [id], onDelete: Cascade)

  name        String
  displayName String?

  // Pricing
  // If linkedMenuItemId is set and price is 0, use linked item's price
  // If price > 0, it acts as a price override or upcharge
  price       Decimal  @default(0)
  priceType   String   @default("upcharge") // 'upcharge' (add to base), 'override' (replace base), 'from_item' (use linked item price)
  upsellPrice Decimal? // Special price when offered as upsell
  cost        Decimal?

  // Pre-modifier support - explicit boolean fields for each option
  // These work just like ingredient pre-mods for consistent inventory tracking
  allowNo      Boolean  @default(true)
  allowLite    Boolean  @default(false)
  allowOnSide  Boolean  @default(false)
  allowExtra   Boolean  @default(false)
  extraPrice   Decimal  @default(0) // Price when "extra" is selected

  // Legacy JSON field - kept for backwards compatibility
  allowedPreModifiers Json? // Array of allowed prefixes: ["no", "lite", "extra", "side"]
  extraUpsellPrice    Decimal? // Upsell price for "extra"

  // Link to ingredient for inventory deduction
  // When this modifier is ordered, deduct from this ingredient's stock
  ingredientId String?
  ingredient   Ingredient? @relation("ModifierIngredient", fields: [ingredientId], references: [id])

  // Sub-modifier support - when selected, prompts for additional modifiers
  childModifierGroupId String?
  childModifierGroup   ModifierGroup? @relation("SubModifier", fields: [childModifierGroupId], references: [id])

  // Commission (Skill 29)
  commissionType  String? // 'fixed' | 'percent' | null
  commissionValue Decimal?

  // Linked Menu Item - for spirit upgrades, links to actual menu item for pricing/reporting
  // When set, sales are tracked against this item for reporting purposes
  linkedMenuItemId String?
  linkedMenuItem   MenuItem? @relation("LinkedModifierItem", fields: [linkedMenuItemId], references: [id])

  // Liquor Builder - Spirit fields
  spiritTier            String? // 'well', 'call', 'premium', 'top_shelf'
  linkedBottleProductId String? // Links to bottle inventory
  linkedBottleProduct   BottleProduct? @relation(fields: [linkedBottleProductId], references: [id])
  pourSizeOz            Decimal? // Override default pour size

  // Display
  sortOrder Int     @default(0)
  isDefault Boolean @default(false)
  isActive  Boolean @default(true)

  // Channel visibility (for online ordering overrides)
  showOnPOS    Boolean @default(true)  // Visible to servers on POS
  showOnline   Boolean @default(true)  // Visible for online ordering

  // Inventory tracking (Skill 115)
  isLabel      Boolean @default(false) // True = grouping only, no inventory tracking

  // Printer routing for modifiers
  // printerRouting: "follow" (default) = prints with main item
  //                 "also" = prints with main item AND to printerIds
  //                 "only" = prints ONLY to printerIds (not with main item)
  printerRouting String @default("follow")
  printerIds     Json?  // Array of printer IDs when routing is "also" or "only"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Sync fields (for cloud sync and soft deletes)
  deletedAt DateTime?
  syncedAt  DateTime?

  orderItemModifiers OrderItemModifier[]

  // Print routing rules for this specific modifier
  printRules PrintRule[]

  // Inventory link (Skill 115)
  inventoryLink ModifierInventoryLink?

  @@index([locationId])
  @@index([modifierGroupId])
  @@index([childModifierGroupId])
  @@index([linkedBottleProductId])
  @@index([linkedMenuItemId])
}

model ModifierGroup {
  id         String   @id @default(cuid())
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  // NEW: Item ownership - each modifier group belongs to ONE specific menu item
  // This enables per-item reporting and customization without affecting other items
  menuItemId String?
  menuItem   MenuItem? @relation("ItemModifierGroups", fields: [menuItemId], references: [id], onDelete: Cascade)

  name        String
  displayName String?

  // Modifier Types: food, liquor, retail, entertainment, combo, universal (can have multiple)
  modifierTypes Json @default("[\"universal\"]")

  // Requirements
  minSelections Int     @default(0)
  maxSelections Int     @default(1)
  isRequired    Boolean @default(false)
  allowStacking Boolean @default(false) // Allow selecting the same modifier multiple times

  // Tiered pricing: define pricing tiers based on selection count
  // mode: "flat_tiers" = all selections use tier price, "free_threshold" = first N free then use modifier's own price
  // Example flat_tiers: { "mode": "flat_tiers", "tiers": [{ "upTo": 3, "price": 0 }, { "upTo": 4, "price": 0.75 }, { "upTo": null, "price": 1.50 }] }
  // Example free_threshold: { "mode": "free_threshold", "tiers": [{ "upTo": 3, "price": 0 }] }
  tieredPricingConfig Json?

  // Exclusion: groups with the same key on the same item prevent duplicate modifier selections
  // Example: Side Choice 1 and Side Choice 2 both have exclusionGroupKey: "side-choices"
  exclusionGroupKey String?

  // Online Ordering Override
  hasOnlineOverride Boolean @default(false) // Enable separate modifier management for online orders

  // Display
  sortOrder Int @default(0)

  // Liquor Builder - Spirit Group Configuration
  isSpiritGroup Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Sync fields (for cloud sync and soft deletes)
  deletedAt DateTime?
  syncedAt  DateTime?

  modifiers Modifier[]
  menuItems MenuItemModifierGroup[] // Legacy junction - kept for backwards compatibility

  // Modifiers that use this group as a sub-modifier
  parentModifiers Modifier[] @relation("SubModifier")

  // Combo components that use this modifier group
  comboComponents ComboComponent[]

  // Liquor Builder - Spirit configuration
  spiritConfig SpiritModifierGroup?

  @@index([locationId])
  @@index([menuItemId])
}

model MenuItem {
  id         String   @id @default(cuid())
  locationId String
  location   Location @relation(fields: [locationId], references: [id])
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  // Identity
  name        String
  displayName String?
  description String?
  sku         String?
  imageUrl    String?

  // Pricing
  price   Decimal          // Cash price (or base price if no dual pricing)
  priceCC Decimal?         // Credit card price (for dual pricing)
  cost    Decimal?         // For profit tracking

  // Tax
  taxRate     Decimal? // Override location default
  isTaxExempt Boolean  @default(false)

  // Display & Behavior
  sortOrder  Int     @default(0)
  isActive   Boolean @default(true)
  showOnPOS  Boolean @default(true)
  showOnline Boolean @default(true)

  // Kitchen
  prepStationId String? // Override category station
  prepStation   PrepStation? @relation(fields: [prepStationId], references: [id])
  prepTime      Int? // Minutes
  courseNumber  Int? // Override category course

  // Printer routing - override category's printers for this item
  // JSON array of printer IDs, e.g., ["printer-1", "printer-2"]
  printerIds       Json?
  backupPrinterIds Json? // Backup printers if primary fails

  // Tag-based routing (Routing Engine) - overrides category's routeTags if set
  // JSON array of route tags, e.g., ["pizza", "expo-only"]
  routeTags Json?

  // Inventory
  trackInventory Boolean @default(false)
  currentStock   Int?
  lowStockAlert  Int?
  isAvailable    Boolean @default(true) // 86'd when false

  // Type
  itemType String @default("standard") // standard, combo, timed_rental

  // Combo Print Mode - how combo components print to stations
  // 'individual' - Each component follows its own print rules (burger‚Üíkitchen, drink‚Üíbar)
  // 'primary' - Entire combo prints to the combo's assigned printer
  // 'all' - Full combo ticket prints at ALL relevant stations
  comboPrintMode String? // null for non-combos, 'individual' | 'primary' | 'all'

  // Timed Rental Pricing (Skill 81) - for pool tables, dart boards, etc.
  timedPricing   Json? // { per15Min: 5.00, per30Min: 8.00, perHour: 15.00, minimum: 15 }
  // Per-minute pricing (replaces timedPricing JSON)
  ratePerMinute      Decimal?  // e.g., 0.25 = $0.25/min
  minimumCharge      Decimal?  // e.g., 15.00 = $15 minimum
  incrementMinutes   Int?      @default(15)  // Charges in blocks after minimum
  minimumMinutes Int? // Minimum rental time in minutes
  graceMinutes   Int? // Grace period before next increment

  // Prepaid packages - discounted upfront deals
  // Format: [{ minutes: 30, price: 10, label: "30 Min Deal" }, { minutes: 60, price: 15, label: "1 Hour Special" }]
  prepaidPackages    Json?

  // Happy Hour - automatic time-based discounts
  happyHourEnabled   Boolean?  @default(false)
  happyHourDiscount  Int?      @default(50)  // Percentage off (50 = 50% off)
  happyHourStart     String?   // "13:00" (1 PM in 24h format)
  happyHourEnd       String?   // "16:00" (4 PM in 24h format)
  happyHourDays      Json?     // ["monday", "tuesday", "wednesday", "thursday", "friday"]

  // Entertainment tracking (Skill 94-97)
  entertainmentStatus String? // 'available', 'in_use', 'maintenance'
  currentOrderId      String? // Links to order currently using this item
  currentOrderItemId  String? // Links to specific order item
  blockTimeMinutes    Int? // If set, sells in blocks (30, 60, 90 mins)
  maxConcurrentUses   Int?    @default(1) // For items with multiple units
  currentUseCount     Int?    @default(0) // Current number in use

  // Menu Scheduling (Skill 40)
  availableFrom String? // Time format "HH:mm" e.g., "06:00"
  availableTo   String? // Time format "HH:mm" e.g., "11:00"
  availableDays String? // Comma-separated days: "0,1,2,3,4,5,6" (0=Sunday)

  // Commission (Skill 29)
  commissionType  String? // 'fixed' | 'percent' | null
  commissionValue Decimal?

  // Liquor Pour Sizes - quick pricing options for liquor items
  // Stores enabled pour sizes and their multipliers: { shot: 1.0, double: 2.0, tall: 1.5, short: 0.75 }
  pourSizes            Json?
  defaultPourSize      String? // Default selection: 'shot', 'double', 'tall', 'short'
  applyPourToModifiers Boolean @default(false) // Apply pour multiplier to spirit modifiers too

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Sync fields (for cloud sync and soft deletes)
  deletedAt DateTime?
  syncedAt  DateTime?

  // Relations
  modifierGroups         MenuItemModifierGroup[] // Legacy junction - kept for backwards compatibility
  ownedModifierGroups    ModifierGroup[] @relation("ItemModifierGroups") // NEW: Item-specific modifier groups
  orderItems             OrderItem[]
  upsellTriggers         UpsellConfig[]          @relation("TriggerItem")
  upsellSuggestions      UpsellConfig[]          @relation("SuggestionItem")
  comboComponentItems    ComboComponent[]        @relation("ComboComponentItem")
  comboComponentDefaults ComboComponent[]        @relation("ComboComponentDefault")
  comboOptions           ComboComponentOption[]

  // Liquor Builder - Recipe ingredients for cocktails
  recipeIngredients RecipeIngredient[]

  // Direct link to bottle product (for spirit items like "Patron Silver" on the menu)
  // This enables bottles to be the source of truth for liquor menu items
  linkedBottleProductId String?
  linkedBottleProduct   BottleProduct? @relation("LinkedBottleMenuItems", fields: [linkedBottleProductId], references: [id])

  // Modifiers that link to this item (for spirit upgrades, etc.)
  linkedModifiers Modifier[] @relation("LinkedModifierItem")

  // Menu Item Ingredients - what's in this item
  ingredients MenuItemIngredient[]

  // Recipe costing (Skill 115)
  recipe MenuItemRecipe?

  // Print routing rules for this specific item
  printRules PrintRule[]

  // Pizza Builder - specialty pizza configuration
  pizzaSpecialty PizzaSpecialty?

  // Floor Plan Elements linked to this item (for entertainment items)
  floorPlanElements FloorPlanElement[]

  @@unique([locationId, sku])
  @@index([locationId])
  @@index([categoryId])
  @@index([prepStationId])
  @@index([isActive, showOnPOS])
}

model MenuItemModifierGroup {
  id              String        @id @default(cuid())
  locationId      String
  location        Location      @relation(fields: [locationId], references: [id])
  menuItemId      String
  menuItem        MenuItem      @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  modifierGroupId String
  modifierGroup   ModifierGroup @relation(fields: [modifierGroupId], references: [id], onDelete: Cascade)

  sortOrder  Int     @default(0)
  showOnline Boolean @default(true) // Whether this modifier group appears for online ordering
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Sync fields (for cloud sync and soft deletes)
  deletedAt DateTime?
  syncedAt  DateTime?


  @@unique([menuItemId, modifierGroupId])
  @@index([locationId])
}

model Ingredient {
  id          String   @id @default(cuid())
  locationId  String
  location    Location @relation(fields: [locationId], references: [id])

  // Identity
  name        String   // "Lettuce", "Bacon", "Ranch"
  description String?  // Optional description

  // Legacy category string - deprecated, use categoryId instead
  category   String? // "produce", "protein", "dairy" - kept for backwards compatibility

  // New Category relation (optional for backwards compatibility, required in UI)
  categoryId       String?
  categoryRelation IngredientCategory? @relation(fields: [categoryId], references: [id])

  // Inventory Link (for deduction tracking)
  // Links to InventoryItem OR PrepItem - one must be set for inventory tracking
  inventoryItemId String?
  inventoryItem   InventoryItem? @relation("IngredientInventoryLink", fields: [inventoryItemId], references: [id])
  prepItemId      String?
  prepItem        PrepItem?      @relation("IngredientPrepLink", fields: [prepItemId], references: [id])

  // Standard portion (used in recipes and for deduction)
  standardQuantity Decimal?  // e.g., 1.5
  standardUnit     String?   // "oz", "slice", "each", "g"

  // Source type: How is this item obtained?
  sourceType       String    @default("delivered")  // "delivered" = purchased from vendor, "made" = made from recipe

  // Purchase info (for delivered items)
  purchaseUnit     String?   // What you order: "case", "bag", "bottle", "gallon", "box", "jar", "each"
  purchaseCost     Decimal?  // Cost per purchase unit (e.g., $45 per case)
  unitsPerPurchase Decimal?  // How many storage units per purchase (e.g., 120 slices per case)
  // Note: standardUnit is the storage/usage unit (slices, lb, oz, etc.)
  // costPerUnit is calculated: purchaseCost / unitsPerPurchase

  // Order Customization Options
  allowNo         Boolean @default(true)   // Customer can say "No X"
  allowLite       Boolean @default(true)   // Customer can say "Lite X"
  allowExtra      Boolean @default(true)   // Customer can say "Extra X"
  allowOnSide     Boolean @default(false)  // Customer can say "X on side"

  // Pricing for customizations
  extraPrice      Decimal @default(0)      // Upcharge for "Extra"

  // Inventory multipliers for customizations
  liteMultiplier  Decimal @default(0.5)    // Lite = 50% of standard
  extraMultiplier Decimal @default(2.0)    // Extra = 200% of standard

  // Swap configuration
  allowSwap           Boolean              @default(false)
  swapGroupId         String?              // Links to a group of swappable ingredients
  swapGroup           IngredientSwapGroup? @relation(fields: [swapGroupId], references: [id])
  swapUpcharge        Decimal              @default(0)

  // Visibility (for future use)
  // "visible" = staff sees in counts/POS
  // "admin_only" = only managers see (for cost tracking)
  // "hidden" = system internal, deprecated items
  visibility      String  @default("visible")  // "visible", "admin_only", "hidden"

  // Display
  sortOrder       Int     @default(0)
  isActive        Boolean @default(true)

  // Menu Item links (which items use this ingredient)
  menuItemIngredients MenuItemIngredient[]

  // Modifiers that deduct from this ingredient
  linkedModifiers     Modifier[] @relation("ModifierIngredient")

  // ========== INGREDIENT HIERARCHY (Parent/Child Preparations) ==========
  // Allows tracking preparations like: Raw Chicken ‚Üí Sliced Chicken, Diced Chicken
  // Child ingredient cost = Parent cost / yieldPercent
  parentIngredientId String?
  parentIngredient   Ingredient?  @relation("IngredientHierarchy", fields: [parentIngredientId], references: [id])
  childIngredients   Ingredient[] @relation("IngredientHierarchy")

  // Preparation info (for child ingredients)
  preparationType    String?   // "Sliced", "Diced", "Cooked", "Marinated", "Ground"
  yieldPercent       Decimal?  // e.g., 0.94 = 94% yield (6% cooking loss)
  batchYield         Decimal?  // How many of this prep item from 1 unit of parent (e.g., 16 slices from 1 lb)

  // ========== EXPLICIT INPUT ‚Üí OUTPUT (New Model) ==========
  // For prep items: defines the transformation from parent to this item
  // Example: 6 oz Raw Chicken ‚Üí 2 oz Shredded Chicken

  // INPUT: How much of parent is consumed to make this prep item
  inputQuantity      Decimal?  // e.g., 6 (oz of raw chicken)
  inputUnit          String?   // e.g., "oz" - should match or be convertible to parent's unit

  // OUTPUT: How much of this prep item is produced
  outputQuantity     Decimal?  @default(1)  // e.g., 2 (oz shredded) or 1 (crust)
  outputUnit         String?   @default("each")  // e.g., "oz" for bulk, "each" for discrete items

  // ========== RECIPE BATCH YIELD (For Inventory Items) ==========
  // For inventory items with recipes: defines how much one recipe batch makes
  // Example: "This dough recipe makes 50 lb" or "This sauce recipe makes 1 gallon"
  recipeYieldQuantity Decimal?  // e.g., 50
  recipeYieldUnit     String?   // e.g., "lb", "gallons", "batches"

  // DEPRECATED: Legacy fields - kept for migration, use inputQuantity/outputQuantity instead
  portionSize        Decimal?  // DEPRECATED: Use inputQuantity
  portionUnit        String?   // DEPRECATED: Use inputUnit

  // Daily counting (for prep items counted each morning)
  isDailyCountItem   Boolean @default(false)  // Include in daily prep count
  currentPrepStock   Decimal @default(0)      // Current stock from last count
  lastCountedAt      DateTime?                // When last counted
  countPrecision     String  @default("whole") // 'whole' = integers only (pizzas), 'decimal' = allow decimals (oz, lbs)

  // Stock alert thresholds (for prep items)
  lowStockThreshold      Decimal?  // Show üü° warning on POS when below this
  criticalStockThreshold Decimal?  // Show üî¥ critical on POS when below this
  onlineStockThreshold   Decimal?  // Show "Limited availability" online when below this

  // Daily count behavior
  resetDailyToZero       Boolean @default(true)   // true = fresh prep (expect 0), false = carry forward
  varianceHandling       String  @default("auto_adjust")  // 'auto_adjust', 'require_reason', 'auto_waste'
  varianceThreshold      Decimal @default(10)     // % threshold for requiring reason (e.g., 10 = 10%)

  // Is this a base ingredient (root) or a preparation (child)?
  isBaseIngredient   Boolean @default(true)

  // ========== 86 STATUS (Out of Stock) ==========
  // When an ingredient is 86'd, all menu items and modifiers using it become unavailable
  is86d              Boolean   @default(false)   // Currently out of stock
  last86dAt          DateTime?                   // When it was last marked as 86
  last86dBy          String?                     // Employee ID who marked it
  showOnQuick86      Boolean   @default(false)   // Show in Quick 86 custom list at top

  // Daily Prep Count relations (for prep-style ingredients)
  trayConfigs              PrepTrayConfig[]             @relation("IngredientTrayConfigs")
  dailyCountItems          DailyPrepCountItem[]         @relation("IngredientDailyCountItems")
  dailyCountTransactions   DailyPrepCountTransaction[]  @relation("IngredientDailyCountTransactions")

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
  syncedAt  DateTime?

  // Recipe components - what raw materials make this inventory item
  recipeComponents   IngredientRecipe[] @relation("RecipeOutput")
  // Where this ingredient is used as a component
  usedInRecipes      IngredientRecipe[] @relation("RecipeComponent")

  // Stock adjustment history
  stockAdjustments IngredientStockAdjustment[]

  @@unique([locationId, name])
  @@index([locationId])
  @@index([categoryId])
  @@index([parentIngredientId])
}

model IngredientCategory {
  id          String   @id @default(cuid())
  locationId  String
  location    Location @relation(fields: [locationId], references: [id])

  // Identity - code is IMMUTABLE after creation (for historical tracking)
  code        Int      // Auto-assigned sequential number, NEVER changes
  name        String   // "Produce", "Protein" - can be renamed
  description String?

  // Display
  icon        String?  // Emoji or icon name: "ü•¨", "üçñ"
  color       String?  // Hex color for UI grouping
  sortOrder   Int      @default(0)

  // Status
  isActive    Boolean  @default(true)

  // Relations
  ingredients Ingredient[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  syncedAt    DateTime?

  @@unique([locationId, code])  // Code unique per location
  @@unique([locationId, name])  // Name unique per location
  @@index([locationId])
}
