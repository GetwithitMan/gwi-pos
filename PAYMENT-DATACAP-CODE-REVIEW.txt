================================================================================
DATACAP & PAYMENT SYSTEM CODE REVIEW
Generated: $(date)
================================================================================

This document contains all code related to Datacap payment processing and 
the payment system for manual review.

TABLE OF CONTENTS:
1. Datacap Library Files (src/lib/datacap/)
2. Payment Library Files (src/lib/)
3. Payment Components (src/components/payment/)
4. Type Definitions (src/types/)
5. Datacap API Routes (src/app/api/datacap/)
6. Payment API Routes (src/app/api/)
7. Hardware API Routes (src/app/api/hardware/payment-readers/)

================================================================================

================================================================================
SECTION 1: DATACAP LIBRARY FILES
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/client.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — Client
// Handles all communication with Datacap devices (local HTTP) and cloud (HTTPS + Basic Auth)
// Every monetary transaction auto-calls EMVPadReset after completion

import { db } from '@/lib/db'
import type {
  DatacapConfig,
  DatacapRequestFields,
  DatacapResponse,
  SaleParams,
  PreAuthParams,
  CaptureParams,
  IncrementParams,
  AdjustParams,
  VoidParams,
  ReturnParams,
  DevicePromptParams,
  CollectCardParams,
  TranCode,
} from './types'
import { buildRequest, buildAdminRequest } from './xml-builder'
import { parseResponse } from './xml-parser'
import { getSequenceNo, updateSequenceNo } from './sequence'
import { simulateResponse } from './simulator'
import {
  LOCAL_ENDPOINT,
  POS_PACKAGE_ID,
  DEFAULT_LOCAL_TIMEOUT_MS,
  DEFAULT_CLOUD_TIMEOUT_MS,
  PAD_RESET_TIMEOUT_MS,
  PARAM_DOWNLOAD_TIMEOUT_MS,
  TRAN_CODES,
} from './constants'

// ─── Reader Info ─────────────────────────────────────────────────────────────

interface ReaderInfo {
  id: string
  ipAddress: string
  port: number
  merchantId?: string | null
  communicationMode: string
  cloudUsername?: string | null
  cloudPassword?: string | null
}

async function getReaderInfo(readerId: string): Promise<ReaderInfo> {
  const reader = await db.paymentReader.findUnique({
    where: { id: readerId },
    select: {
      id: true,
      ipAddress: true,
      port: true,
      merchantId: true,
      communicationMode: true,
      cloudUsername: true,
      cloudPassword: true,
    },
  })
  if (!reader) throw new Error(`Payment reader not found: ${readerId}`)
  return reader as ReaderInfo
}

// ─── DatacapClient ───────────────────────────────────────────────────────────

export class DatacapClient {
  private config: DatacapConfig

  constructor(config: DatacapConfig) {
    this.config = config
  }

  // ─── Transport Layer ─────────────────────────────────────────────────────

  private async sendLocal(reader: ReaderInfo, xml: string, timeoutMs?: number): Promise<DatacapResponse> {
    const timeout = timeoutMs || this.config.localTimeoutMs || DEFAULT_LOCAL_TIMEOUT_MS
    const url = `http://${reader.ipAddress}:${reader.port}${LOCAL_ENDPOINT}`
    const controller = new AbortController()
    const timer = setTimeout(() => controller.abort(), timeout)

    try {
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/xml' },
        body: xml,
        signal: controller.signal,
      })

      if (!res.ok) {
        throw new Error(`Local reader responded with HTTP ${res.status}`)
      }

      const responseXml = await res.text()
      return parseResponse(responseXml)
    } catch (error: unknown) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Local reader timeout after ${timeout}ms`)
      }
      throw error
    } finally {
      clearTimeout(timer)
    }
  }

  private async sendCloud(xml: string, timeoutMs?: number): Promise<DatacapResponse> {
    if (!this.config.cloudUrl) throw new Error('Cloud URL not configured')
    if (!this.config.cloudUsername || !this.config.cloudPassword) {
      throw new Error('Cloud credentials not configured')
    }

    const timeout = timeoutMs || this.config.cloudTimeoutMs || DEFAULT_CLOUD_TIMEOUT_MS
    const credentials = Buffer.from(`${this.config.cloudUsername}:${this.config.cloudPassword}`).toString('base64')
    const controller = new AbortController()
    const timer = setTimeout(() => controller.abort(), timeout)

    try {
      const res = await fetch(this.config.cloudUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/xml',
          'Authorization': `Basic ${credentials}`,
        },
        body: xml,
        signal: controller.signal,
      })

      if (!res.ok) {
        throw new Error(`Cloud server responded with HTTP ${res.status}`)
      }

      const responseXml = await res.text()
      return parseResponse(responseXml)
    } catch (error: unknown) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Cloud server timeout after ${timeout}ms`)
      }
      throw error
    } finally {
      clearTimeout(timer)
    }
  }

  private async send(reader: ReaderInfo, xml: string, timeoutMs?: number): Promise<DatacapResponse> {
    const mode = reader.communicationMode || this.config.communicationMode

    // Simulated mode — no network calls
    if (mode === 'simulated') {
      // Extract tranCode from XML for simulator
      const tranCodeMatch = xml.match(/<TranCode>([^<]+)<\/TranCode>/)
      const tranCode = (tranCodeMatch?.[1] || 'EMVPadReset') as TranCode
      const simXml = simulateResponse(tranCode, { merchantId: '', operatorId: '', tranCode })
      return parseResponse(simXml)
    }

    if (mode === 'local') {
      return this.sendLocal(reader, xml, timeoutMs)
    }

    if (mode === 'cloud') {
      return this.sendCloud(xml, timeoutMs)
    }

    // local_with_cloud_fallback
    try {
      return await this.sendLocal(reader, xml, timeoutMs)
    } catch (localError) {
      console.warn('[Datacap] Local failed, trying cloud fallback:', localError)
      return this.sendCloud(xml, timeoutMs)
    }
  }

  // ─── Pad Reset Wrapper ───────────────────────────────────────────────────
  // CRITICAL: Every monetary transaction MUST be followed by EMVPadReset

  private async withPadReset<T>(
    readerId: string,
    fn: (reader: ReaderInfo, seqNo: string) => Promise<T>
  ): Promise<T> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)

    let result: T
    try {
      result = await fn(reader, seqNo)
    } finally {
      // Always pad reset, even if the transaction failed
      try {
        await this.padReset(readerId)
      } catch (resetError) {
        console.error('[Datacap] Pad reset failed after transaction:', resetError)
      }
    }

    return result
  }

  // ─── Field Builder ───────────────────────────────────────────────────────

  private buildBaseFields(reader: ReaderInfo, seqNo: string): Partial<DatacapRequestFields> {
    return {
      merchantId: reader.merchantId || this.config.merchantId,
      operatorId: this.config.operatorId,
      posPackageId: this.config.posPackageId || POS_PACKAGE_ID,
      sequenceNo: seqNo,
      acctNo: 'SecureDevice',
      tranDeviceId: 0,
    }
  }

  // ─── Update Sequence From Response ───────────────────────────────────────

  private async handleResponse(readerId: string, response: DatacapResponse): Promise<DatacapResponse> {
    if (response.sequenceNo) {
      await updateSequenceNo(readerId, response.sequenceNo)
    }
    return response
  }

  // ─── Transaction Methods ─────────────────────────────────────────────────

  async sale(readerId: string, params: SaleParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.SALE,
        invoiceNo: params.invoiceNo,
        refNo: params.invoiceNo,
        amounts: params.amounts,
        partialAuth: params.allowPartialAuth !== false ? 'Allow' : 'Deny',
        recordNumberRequested: params.requestRecordNo !== false,
        frequency: 'OneTime',
        cardHolderId: 'Allow_V2',
      }

      // Tip handling
      if (params.tipMode === 'suggestive') {
        fields.gratuity = {
          mode: 'SuggestivePrompt',
          suggestions: params.tipSuggestions || [15, 18, 20, 25],
          showTotal: true,
        }
      } else if (params.tipMode === 'prompt') {
        fields.gratuity = { mode: 'Prompt' }
      } else if (params.tipMode === 'included' && params.amounts.gratuity) {
        // Gratuity already in amounts — no special block needed
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async preAuth(readerId: string, params: PreAuthParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.PRE_AUTH,
        invoiceNo: params.invoiceNo,
        refNo: params.invoiceNo,
        amounts: { purchase: params.amount },
        partialAuth: 'Allow',
        recordNumberRequested: params.requestRecordNo !== false,
        frequency: 'OneTime',
        cardHolderId: 'Allow_V2',
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async preAuthCapture(readerId: string, params: CaptureParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.CAPTURE,
        recordNo: params.recordNo,
        amounts: {
          purchase: params.purchaseAmount,
          gratuity: params.gratuityAmount,
        },
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async incrementalAuth(readerId: string, params: IncrementParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.INCREMENT,
        recordNo: params.recordNo,
        amounts: { purchase: params.additionalAmount },
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async adjustGratuity(readerId: string, params: AdjustParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.ADJUST,
        recordNo: params.recordNo,
        amounts: {
          purchase: params.purchaseAmount,
          gratuity: params.gratuityAmount,
        },
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async voidSale(readerId: string, params: VoidParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.VOID_SALE,
        recordNo: params.recordNo,
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async voidReturn(readerId: string, params: VoidParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.VOID_RETURN,
        recordNo: params.recordNo,
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async emvReturn(readerId: string, params: ReturnParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)

      // Card present → EMVReturn (customer dips/taps)
      // Card not present → ReturnByRecordNo (use stored token)
      const cardPresent = params.cardPresent !== false
      const tranCode = cardPresent ? TRAN_CODES.RETURN : TRAN_CODES.RETURN_BY_RECORD

      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode,
        invoiceNo: params.invoiceNo,
        refNo: params.invoiceNo,
        amounts: { purchase: params.amount },
        recordNo: params.recordNo,
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  async collectCardData(readerId: string, params?: CollectCardParams): Promise<DatacapResponse> {
    return this.withPadReset(readerId, async (reader, seqNo) => {
      const base = this.buildBaseFields(reader, seqNo)
      const fields: DatacapRequestFields = {
        ...base,
        merchantId: base.merchantId!,
        operatorId: base.operatorId!,
        tranCode: TRAN_CODES.COLLECT_CARD,
        amounts: { purchase: params?.placeholderAmount || 0.01 },
        cardHolderId: 'Allow_V2',
      }

      const xml = buildRequest(fields)
      const response = await this.send(reader, xml)
      return this.handleResponse(readerId, response)
    })
  }

  // ─── Device Control ──────────────────────────────────────────────────────

  async padReset(readerId: string): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.PAD_RESET,
    }

    const xml = buildRequest(fields)
    const response = await this.send(reader, xml, PAD_RESET_TIMEOUT_MS)
    return this.handleResponse(readerId, response)
  }

  async paramDownload(readerId: string): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.PARAM_DOWNLOAD,
    }

    const xml = buildRequest(fields)
    const response = await this.send(reader, xml, PARAM_DOWNLOAD_TIMEOUT_MS)
    return this.handleResponse(readerId, response)
  }

  // ─── Batch Operations ────────────────────────────────────────────────────

  async batchSummary(readerId: string): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.BATCH_SUMMARY,
    }

    const xml = buildAdminRequest(fields)
    const response = await this.send(reader, xml)
    return this.handleResponse(readerId, response)
  }

  async batchClose(readerId: string): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.BATCH_CLOSE,
    }

    const xml = buildAdminRequest(fields)
    const response = await this.send(reader, xml)
    return this.handleResponse(readerId, response)
  }

  // ─── Device Prompts ──────────────────────────────────────────────────────

  async getSuggestiveTip(readerId: string, suggestions?: number[]): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.SUGGESTIVE_TIP,
      gratuitySuggestions: (suggestions || [15, 18, 20, 25]).join(','),
    }

    const xml = buildRequest(fields)
    const response = await this.send(reader, xml)
    return this.handleResponse(readerId, response)
  }

  async getSignature(readerId: string): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.SIGNATURE,
    }

    const xml = buildRequest(fields)
    const response = await this.send(reader, xml)
    return this.handleResponse(readerId, response)
  }

  async getYesNo(readerId: string, promptText: string): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.YES_NO,
      promptText,
    }

    const xml = buildRequest(fields)
    const response = await this.send(reader, xml)
    return this.handleResponse(readerId, response)
  }

  async getMultipleChoice(readerId: string, promptText: string, buttonLabels: string[]): Promise<DatacapResponse> {
    const reader = await getReaderInfo(readerId)
    const seqNo = await getSequenceNo(readerId)
    const base = this.buildBaseFields(reader, seqNo)

    const fields: DatacapRequestFields = {
      ...base,
      merchantId: base.merchantId!,
      operatorId: base.operatorId!,
      tranCode: TRAN_CODES.MULTIPLE_CHOICE,
      promptText,
      buttonLabels,
    }

    const xml = buildRequest(fields)
    const response = await this.send(reader, xml)
    return this.handleResponse(readerId, response)
  }
}

// ─── Factory ─────────────────────────────────────────────────────────────────

export function createDatacapClient(config: DatacapConfig): DatacapClient {
  return new DatacapClient(config)
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/constants.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — Constants
// Static values, error codes, and defaults

import type { TranCode } from './types'

// ─── Transaction Codes ───────────────────────────────────────────────────────

export const TRAN_CODES: Record<string, TranCode> = {
  // EMV card-present
  SALE: 'EMVSale',
  RETURN: 'EMVReturn',
  PRE_AUTH: 'EMVPreAuth',
  PRE_AUTH_COMPLETION: 'EMVPreAuthCompletion',
  FORCE_AUTH: 'EMVForceAuth',
  PAD_RESET: 'EMVPadReset',
  PARAM_DOWNLOAD: 'EMVParamDownload',
  // Record-based (card NOT present)
  CAPTURE: 'PreAuthCaptureByRecordNo',
  INCREMENT: 'IncrementalAuthByRecordNo',
  ADJUST: 'AdjustByRecordNo',
  VOID_SALE: 'VoidSaleByRecordNo',
  VOID_RETURN: 'VoidReturnByRecordNo',
  RETURN_BY_RECORD: 'ReturnByRecordNo',
  // Device prompts
  SUGGESTIVE_TIP: 'GetSuggestiveTip',
  SIGNATURE: 'GetSignature',
  YES_NO: 'GetYesNo',
  MULTIPLE_CHOICE: 'GetMultipleChoice',
  // Admin
  BATCH_SUMMARY: 'BatchSummary',
  BATCH_CLOSE: 'BatchClose',
  // Card data
  COLLECT_CARD: 'CollectCardData',
} as const

// ─── Monetary TranCodes (require pad reset after) ────────────────────────────

export const MONETARY_TRAN_CODES: Set<TranCode> = new Set([
  'EMVSale',
  'EMVReturn',
  'EMVPreAuth',
  'EMVPreAuthCompletion',
  'EMVForceAuth',
  'PreAuthCaptureByRecordNo',
  'IncrementalAuthByRecordNo',
  'AdjustByRecordNo',
  'VoidSaleByRecordNo',
  'VoidReturnByRecordNo',
  'ReturnByRecordNo',
  'CollectCardData',
])

// ─── Error Codes ─────────────────────────────────────────────────────────────

export interface ErrorCodeInfo {
  message: string
  description: string
  isRetryable: boolean
}

export const DATACAP_ERROR_CODES: Record<string, ErrorCodeInfo> = {
  '000000': { message: 'Success', description: 'Transaction approved', isRetryable: false },
  '000001': { message: 'Partial Approval', description: 'Approved for less than requested amount', isRetryable: false },

  // Declines
  '100001': { message: 'Declined', description: 'Card declined by issuer', isRetryable: false },
  '100002': { message: 'Insufficient Funds', description: 'Not enough balance on card', isRetryable: false },
  '100003': { message: 'Over Limit', description: 'Card has exceeded credit limit', isRetryable: false },
  '100004': { message: 'Expired Card', description: 'Card is expired', isRetryable: false },
  '100005': { message: 'Invalid Card', description: 'Card number is invalid', isRetryable: false },
  '100006': { message: 'Restricted Card', description: 'Card type not accepted', isRetryable: false },
  '100007': { message: 'Do Not Honor', description: 'Issuer declined without specific reason', isRetryable: false },
  '100008': { message: 'Card Removed', description: 'Card was removed before completion', isRetryable: true },
  '100009': { message: 'Duplicate Transaction', description: 'Same card, amount, and time detected', isRetryable: false },

  // Device errors
  '200001': { message: 'Device Not Ready', description: 'Reader is not ready for transactions', isRetryable: true },
  '200002': { message: 'Device Busy', description: 'Reader is processing another transaction', isRetryable: true },
  '200003': { message: 'Device Error', description: 'Hardware error on reader', isRetryable: true },
  '200004': { message: 'No Device', description: 'Reader not found at configured address', isRetryable: true },
  '200005': { message: 'Card Read Error', description: 'Could not read card data', isRetryable: true },
  '200006': { message: 'Timeout', description: 'Transaction timed out waiting for card', isRetryable: true },
  '200007': { message: 'Cancelled', description: 'Transaction cancelled by operator', isRetryable: false },

  // Communication errors
  '300001': { message: 'Communication Error', description: 'Could not reach processor', isRetryable: true },
  '300002': { message: 'Host Unavailable', description: 'Processor host is down', isRetryable: true },
  '300003': { message: 'Connection Timeout', description: 'Connection to processor timed out', isRetryable: true },

  // Config errors
  '400001': { message: 'Invalid Merchant', description: 'Merchant ID not recognized', isRetryable: false },
  '400002': { message: 'Invalid Terminal', description: 'Terminal ID not configured', isRetryable: false },
  '400003': { message: 'Param Download Required', description: 'Device needs EMVParamDownload', isRetryable: false },

  // Batch errors
  '500001': { message: 'Batch Empty', description: 'No transactions in current batch', isRetryable: false },
  '500002': { message: 'Batch Error', description: 'Error closing batch', isRetryable: true },
} as const

// ─── Card Type Mapping ───────────────────────────────────────────────────────

export const CARD_TYPE_MAP: Record<string, string> = {
  'VISA': 'visa',
  'MASTERCARD': 'mastercard',
  'MC': 'mastercard',
  'AMEX': 'amex',
  'AMERICAN EXPRESS': 'amex',
  'DISCOVER': 'discover',
  'DISC': 'discover',
  'DINERS': 'diners',
  'DINERS CLUB': 'diners',
  'JCB': 'jcb',
  'UNIONPAY': 'unionpay',
  'CUP': 'unionpay',
  'DEBIT': 'debit',
  'EBT': 'ebt',
}

// ─── Entry Method Mapping ────────────────────────────────────────────────────

export const ENTRY_METHOD_MAP: Record<string, string> = {
  'CHIP': 'Chip',
  'CONTACTLESS': 'Tap',
  'SWIPED': 'Swipe',
  'KEYED': 'Manual',
  'MANUAL': 'Manual',
  'FALLBACK': 'Swipe',     // Chip fallback to swipe
  'QRCODE': 'Tap',         // QR-based payment
}

// ─── CVM Mapping ─────────────────────────────────────────────────────────────

export const CVM_MAP: Record<string, string> = {
  'PIN': 'PIN_VERIFIED',
  'PIN_VERIFIED': 'PIN_VERIFIED',
  'SIGNATURE': 'SIGN',
  'SIGN': 'SIGN',
  'NO_CVM': 'NONE',
  'NONE': 'NONE',
  'ONLINE_PIN': 'ONLINE_PIN',
  'DEVICE': 'DEVICE_CVM',
}

// ─── Network Constants ───────────────────────────────────────────────────────

export const DEFAULT_PORTS: Record<string, number> = {
  PAX: 8080,
  INGENICO: 80,
}

export const CLOUD_URLS = {
  test: 'https://cloud-test.dcap.com/ProcessEMVTransaction/',
  prod: 'https://cloud-prod.dcap.com/ProcessEMVTransaction/',
} as const

export const LOCAL_ENDPOINT = '/ProcessEMVTransaction/'

export const DISCOVERY_PORT = 9001
export const DISCOVERY_RETRIES = 30
export const DISCOVERY_RETRY_DELAY_MS = 500

// ─── POS Identity ────────────────────────────────────────────────────────────

export const POS_PACKAGE_ID = 'GWI-POS:1.0'

// ─── Default Sequence Number ─────────────────────────────────────────────────

export const DEFAULT_SEQUENCE_NO = '0010010010'

// ─── Timeouts ────────────────────────────────────────────────────────────────

export const DEFAULT_LOCAL_TIMEOUT_MS = 60000   // 60s — customer has to interact with reader
export const DEFAULT_CLOUD_TIMEOUT_MS = 30000   // 30s — cloud should be faster
export const PAD_RESET_TIMEOUT_MS = 5000        // 5s — pad reset is quick
export const PARAM_DOWNLOAD_TIMEOUT_MS = 120000 // 2min — param download is slow

// ─── Tip Defaults ────────────────────────────────────────────────────────────

export const DEFAULT_TIP_SUGGESTIONS = [15, 18, 20, 25]
export const DEFAULT_TIP_DOLLAR_SUGGESTIONS = [1, 2, 3]
export const DEFAULT_TIP_DOLLAR_THRESHOLD = 15  // Under $15 → show dollar amounts

// ─── Pre-Auth Defaults ───────────────────────────────────────────────────────

export const DEFAULT_PRE_AUTH_AMOUNT = 1           // $1 hold
export const DEFAULT_INCREMENT_THRESHOLD = 80      // 80% of auth
export const DEFAULT_INCREMENT_AMOUNT = 25         // $25 increment
export const DEFAULT_MAX_TAB_ALERT = 500           // Alert manager at $500


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/discovery.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — UDP Device Discovery
// Broadcasts on port 9001 to find Datacap readers on the local network

import { DISCOVERY_PORT, DISCOVERY_RETRIES, DISCOVERY_RETRY_DELAY_MS } from './constants'
import type { DiscoveredDevice } from './types'

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}

/**
 * Discover a Datacap device by serial number via UDP broadcast.
 * Sends "Who has <SN>" on port 9001 and waits for "<SN> is at: <IP>".
 * Retries up to 30 times with 500ms delay between attempts.
 *
 * NOTE: This only works server-side (Node.js dgram). Browser cannot do UDP.
 */
export async function discoverDevice(serialNumber: string): Promise<DiscoveredDevice | null> {
  // Dynamic import — dgram is Node.js only
  let dgram: typeof import('dgram')
  try {
    dgram = await import('dgram')
  } catch {
    console.error('[Datacap Discovery] dgram not available — must run server-side')
    return null
  }

  for (let attempt = 0; attempt < DISCOVERY_RETRIES; attempt++) {
    try {
      const result = await new Promise<DiscoveredDevice | null>((resolve) => {
        const socket = dgram.createSocket('udp4')
        const timeout = setTimeout(() => {
          socket.close()
          resolve(null)
        }, DISCOVERY_RETRY_DELAY_MS)

        socket.on('message', (msg) => {
          clearTimeout(timeout)
          const response = msg.toString().trim()
          // Expected format: "<SN> is at: <IP>"
          const match = response.match(/^(.+?)\s+is at:\s*(.+)$/i)
          if (match && match[1] === serialNumber && match[2]) {
            socket.close()
            resolve({
              serialNumber,
              ipAddress: match[2].trim(),
              port: 8080, // Default — PAX uses 8080
            })
          } else {
            socket.close()
            resolve(null)
          }
        })

        socket.on('error', () => {
          clearTimeout(timeout)
          socket.close()
          resolve(null)
        })

        // Bind to any port, then broadcast
        socket.bind(() => {
          socket.setBroadcast(true)
          const message = Buffer.from(`Who has ${serialNumber}`)
          socket.send(message, 0, message.length, DISCOVERY_PORT, '255.255.255.255')
        })
      })

      if (result) {
        console.log(`[Datacap Discovery] Found ${serialNumber} at ${result.ipAddress} (attempt ${attempt + 1})`)
        return result
      }
    } catch (error) {
      console.warn(`[Datacap Discovery] Attempt ${attempt + 1} failed:`, error)
    }

    if (attempt < DISCOVERY_RETRIES - 1) {
      await sleep(DISCOVERY_RETRY_DELAY_MS)
    }
  }

  console.warn(`[Datacap Discovery] Device ${serialNumber} not found after ${DISCOVERY_RETRIES} attempts`)
  return null
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/helpers.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — Shared Helpers for API Routes
// Creates DatacapClient instances from location settings

import { db } from '@/lib/db'
import { parseSettings } from '@/lib/settings'
import { DatacapClient } from './client'
import type { DatacapConfig } from './types'
import { POS_PACKAGE_ID, CLOUD_URLS } from './constants'

/**
 * Create a DatacapClient configured for a specific location.
 * Reads payment settings from the location's settings JSON.
 */
export async function getDatacapClient(locationId: string): Promise<DatacapClient> {
  const location = await db.location.findUnique({
    where: { id: locationId },
    select: { settings: true },
  })

  if (!location) throw new Error(`Location not found: ${locationId}`)

  const settings = parseSettings(location.settings)
  const payments = settings.payments

  const config: DatacapConfig = {
    merchantId: payments.datacapMerchantId || '',
    operatorId: 'POS',
    posPackageId: POS_PACKAGE_ID,
    communicationMode: payments.processor === 'simulated' ? 'local' : 'local',
    cloudUrl: payments.testMode ? CLOUD_URLS.test : CLOUD_URLS.prod,
    localTimeoutMs: (payments.readerTimeoutSeconds || 30) * 1000,
  }

  return new DatacapClient(config)
}

/**
 * Validate that the location has Datacap configured and return the client.
 * Throws if processor is 'none'.
 */
export async function requireDatacapClient(locationId: string): Promise<DatacapClient> {
  const location = await db.location.findUnique({
    where: { id: locationId },
    select: { settings: true },
  })

  if (!location) throw new Error(`Location not found: ${locationId}`)

  const settings = parseSettings(location.settings)

  if (settings.payments.processor === 'none') {
    throw new Error('Payment processor not configured for this location')
  }

  return getDatacapClient(locationId)
}

/**
 * Validate that a reader belongs to the given location.
 */
export async function validateReader(readerId: string, locationId: string): Promise<void> {
  const reader = await db.paymentReader.findFirst({
    where: { id: readerId, locationId, deletedAt: null, isActive: true },
  })

  if (!reader) {
    throw new Error(`Active payment reader not found: ${readerId}`)
  }
}

/**
 * Parse a JSON request body with error handling.
 */
export async function parseBody<T>(request: Request): Promise<T> {
  try {
    return await request.json() as T
  } catch {
    throw new Error('Invalid JSON request body')
  }
}

/**
 * Standard error response for Datacap API routes.
 */
export function datacapErrorResponse(error: unknown, status = 500) {
  const message = error instanceof Error ? error.message : 'Internal server error'
  console.error('[Datacap API]', message)
  return Response.json({ error: message }, { status })
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/sequence.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — Sequence Number Management
// Each response echoes SequenceNo; use that value in the next request per reader

import { db } from '@/lib/db'
import { DEFAULT_SEQUENCE_NO } from './constants'

export async function getSequenceNo(readerId: string): Promise<string> {
  const reader = await db.paymentReader.findUnique({
    where: { id: readerId },
    select: { lastSequenceNo: true },
  })
  return reader?.lastSequenceNo || DEFAULT_SEQUENCE_NO
}

export async function updateSequenceNo(readerId: string, sequenceNo: string): Promise<void> {
  if (!sequenceNo) return
  await db.paymentReader.update({
    where: { id: readerId },
    data: { lastSequenceNo: sequenceNo },
  })
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/simulator.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — Built-in Simulator
// Returns realistic XML responses for testing without hardware

import type { DatacapRequestFields, TranCode } from './types'
import { DEFAULT_SEQUENCE_NO } from './constants'

function randomDigits(n: number): string {
  return Array.from({ length: n }, () => Math.floor(Math.random() * 10)).join('')
}

function randomAlphaNum(n: number): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  return Array.from({ length: n }, () => chars[Math.floor(Math.random() * chars.length)]).join('')
}

function incrementSequenceNo(seq: string): string {
  // Increment last 4 digits, wrapping at 9999
  const num = parseInt(seq.slice(-4), 10)
  const next = ((num + 10) % 10000).toString().padStart(4, '0')
  return seq.slice(0, -4) + next
}

const SIM_CARDS = [
  { type: 'VISA', last4: '4111', name: 'JOHN SMITH' },
  { type: 'MASTERCARD', last4: '5432', name: 'JANE DOE' },
  { type: 'AMEX', last4: '3782', name: 'ALEX JOHNSON' },
  { type: 'DISCOVER', last4: '6011', name: 'CHRIS WILSON' },
  { type: 'VISA', last4: '4242', name: 'SARAH MILLER' },
]

function randomCard() {
  return SIM_CARDS[Math.floor(Math.random() * SIM_CARDS.length)]
}

function wrapResponse(content: string): string {
  return `<RStream>${content}</RStream>`
}

interface SimOptions {
  sequenceNo?: string
  decline?: boolean
}

/**
 * Simulate a Datacap XML response for testing.
 * Returns valid XML matching real device format.
 */
export function simulateResponse(
  tranCode: TranCode,
  fields: DatacapRequestFields,
  options: SimOptions = {}
): string {
  const seqIn = fields.sequenceNo || options.sequenceNo || DEFAULT_SEQUENCE_NO
  const seqOut = incrementSequenceNo(seqIn)
  const card = randomCard()
  const authCode = randomDigits(6)
  const recordNo = `DC4:${randomAlphaNum(30)}`
  const refNo = fields.refNo || fields.invoiceNo || randomDigits(6)

  // Check for forced decline
  if (options.decline) {
    return wrapResponse(`
      <CmdStatus>Declined</CmdStatus>
      <DSIXReturnCode>100001</DSIXReturnCode>
      <ResponseOrigin>Processor</ResponseOrigin>
      <TextResponse>DECLINED</TextResponse>
      <SequenceNo>${seqOut}</SequenceNo>
      <TranCode>${tranCode}</TranCode>
    `)
  }

  switch (tranCode) {
    case 'EMVSale':
    case 'EMVPreAuth':
    case 'EMVPreAuthCompletion':
    case 'EMVForceAuth': {
      const amount = fields.amounts?.purchase?.toFixed(2) || '0.00'
      const gratuity = fields.amounts?.gratuity?.toFixed(2)
      return wrapResponse(`
        <CmdStatus>Approved</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Processor</ResponseOrigin>
        <TextResponse>APPROVED</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>${tranCode}</TranCode>
        <Authorize>${amount}</Authorize>
        <AuthCode>${authCode}</AuthCode>
        <RefNo>${refNo}</RefNo>
        <RecordNo>${recordNo}</RecordNo>
        <AcctNo>***${card.last4}</AcctNo>
        <CardType>${card.type}</CardType>
        <CardholderName>${card.name}</CardholderName>
        <CardholderID>SIM_${randomAlphaNum(16)}</CardholderID>
        <EntryMethod>CONTACTLESS</EntryMethod>
        <AID>A0000000031010</AID>
        <CVM>NO_CVM</CVM>
        ${gratuity ? `<Gratuity>${gratuity}</Gratuity>` : ''}
        <Line1>${card.type} ${tranCode === 'EMVPreAuth' ? 'PRE-AUTH' : 'SALE'}</Line1>
        <Line2>Card: ***${card.last4}</Line2>
        <Line3>Auth: ${authCode}</Line3>
        <Line4>Amount: $${amount}</Line4>
      `)
    }

    case 'EMVReturn': {
      const amount = fields.amounts?.purchase?.toFixed(2) || '0.00'
      return wrapResponse(`
        <CmdStatus>Approved</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Processor</ResponseOrigin>
        <TextResponse>RETURN APPROVED</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>EMVReturn</TranCode>
        <Authorize>${amount}</Authorize>
        <AuthCode>${authCode}</AuthCode>
        <RefNo>${refNo}</RefNo>
        <RecordNo>${recordNo}</RecordNo>
        <AcctNo>***${card.last4}</AcctNo>
        <CardType>${card.type}</CardType>
        <EntryMethod>CHIP</EntryMethod>
      `)
    }

    case 'PreAuthCaptureByRecordNo':
    case 'IncrementalAuthByRecordNo':
    case 'AdjustByRecordNo': {
      const amount = fields.amounts?.purchase?.toFixed(2) || '0.00'
      const gratuity = fields.amounts?.gratuity?.toFixed(2)
      const total = gratuity
        ? (parseFloat(amount) + parseFloat(gratuity)).toFixed(2)
        : amount
      return wrapResponse(`
        <CmdStatus>Approved</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Processor</ResponseOrigin>
        <TextResponse>APPROVED</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>${tranCode}</TranCode>
        <Authorize>${total}</Authorize>
        <AuthCode>${authCode}</AuthCode>
        <RefNo>${refNo}</RefNo>
        <RecordNo>${fields.recordNo || recordNo}</RecordNo>
      `)
    }

    case 'VoidSaleByRecordNo':
    case 'VoidReturnByRecordNo': {
      return wrapResponse(`
        <CmdStatus>Approved</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Processor</ResponseOrigin>
        <TextResponse>VOID APPROVED</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>${tranCode}</TranCode>
        <AuthCode>${authCode}</AuthCode>
        <RefNo>${refNo}</RefNo>
        <RecordNo>${fields.recordNo || recordNo}</RecordNo>
      `)
    }

    case 'ReturnByRecordNo': {
      const amount = fields.amounts?.purchase?.toFixed(2) || '0.00'
      return wrapResponse(`
        <CmdStatus>Approved</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Processor</ResponseOrigin>
        <TextResponse>RETURN APPROVED</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>ReturnByRecordNo</TranCode>
        <Authorize>${amount}</Authorize>
        <AuthCode>${authCode}</AuthCode>
        <RefNo>${refNo}</RefNo>
        <RecordNo>${fields.recordNo || recordNo}</RecordNo>
      `)
    }

    case 'EMVPadReset': {
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Client</ResponseOrigin>
        <TextResponse>Reset Successful</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>EMVPadReset</TranCode>
      `)
    }

    case 'EMVParamDownload': {
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Client</ResponseOrigin>
        <TextResponse>Parameter Download Successful</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>EMVParamDownload</TranCode>
      `)
    }

    case 'CollectCardData': {
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Device</ResponseOrigin>
        <TextResponse>Card Data Collected</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>CollectCardData</TranCode>
        <AcctNo>***${card.last4}</AcctNo>
        <CardType>${card.type}</CardType>
        <CardholderName>${card.name}</CardholderName>
        <CardholderID>SIM_${randomAlphaNum(16)}</CardholderID>
        <EntryMethod>CONTACTLESS</EntryMethod>
      `)
    }

    case 'GetSuggestiveTip': {
      const tipPercents = [15, 18, 20, 25]
      const selected = tipPercents[Math.floor(Math.random() * tipPercents.length)]
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Device</ResponseOrigin>
        <TextResponse>Tip Selected</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>GetSuggestiveTip</TranCode>
        <Gratuity>${selected}</Gratuity>
      `)
    }

    case 'GetSignature': {
      // Return a small base64 "signature" placeholder
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Device</ResponseOrigin>
        <TextResponse>Signature Captured</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>GetSignature</TranCode>
        <SignatureData>SIM_SIGNATURE_${randomAlphaNum(20)}</SignatureData>
      `)
    }

    case 'GetYesNo': {
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Device</ResponseOrigin>
        <TextResponse>Yes</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>GetYesNo</TranCode>
      `)
    }

    case 'GetMultipleChoice': {
      const choice = fields.buttonLabels?.[0] || 'Option 1'
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Device</ResponseOrigin>
        <TextResponse>${choice}</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>GetMultipleChoice</TranCode>
      `)
    }

    case 'BatchSummary': {
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Client</ResponseOrigin>
        <TextResponse>Batch Summary</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>BatchSummary</TranCode>
        <BatchNo>${randomDigits(6)}</BatchNo>
        <BatchItemCount>42</BatchItemCount>
      `)
    }

    case 'BatchClose': {
      return wrapResponse(`
        <CmdStatus>Success</CmdStatus>
        <DSIXReturnCode>000000</DSIXReturnCode>
        <ResponseOrigin>Processor</ResponseOrigin>
        <TextResponse>Batch Closed Successfully</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
        <TranCode>BatchClose</TranCode>
        <BatchNo>${randomDigits(6)}</BatchNo>
      `)
    }

    default: {
      return wrapResponse(`
        <CmdStatus>Error</CmdStatus>
        <DSIXReturnCode>200003</DSIXReturnCode>
        <ResponseOrigin>Client</ResponseOrigin>
        <TextResponse>Unknown TranCode: ${tranCode}</TextResponse>
        <SequenceNo>${seqOut}</SequenceNo>
      `)
    }
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/types.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — TypeScript Interfaces
// XML over HTTP to local devices or HTTPS with Basic Auth to Datacap cloud

// ─── Enums ───────────────────────────────────────────────────────────────────

export type TranCode =
  // EMV card-present transactions
  | 'EMVSale'
  | 'EMVReturn'
  | 'EMVPreAuth'
  | 'EMVPreAuthCompletion'
  | 'EMVForceAuth'
  | 'EMVPadReset'
  | 'EMVParamDownload'
  // Record-based (card NOT present — uses stored token)
  | 'PreAuthCaptureByRecordNo'
  | 'IncrementalAuthByRecordNo'
  | 'AdjustByRecordNo'
  | 'VoidSaleByRecordNo'
  | 'VoidReturnByRecordNo'
  | 'ReturnByRecordNo'
  // Device prompts
  | 'GetSuggestiveTip'
  | 'GetSignature'
  | 'GetYesNo'
  | 'GetMultipleChoice'
  // Admin / batch
  | 'BatchSummary'
  | 'BatchClose'
  // Card data collection (no charge)
  | 'CollectCardData'

export type CmdStatus = 'Approved' | 'Declined' | 'Error' | 'Success'

export type ResponseOrigin = 'Client' | 'Processor' | 'Device'

export type EntryMethod = 'Chip' | 'Tap' | 'Swipe' | 'Manual' | 'Keyed'

export type CVM = 'PIN_VERIFIED' | 'SIGN' | 'NONE' | 'ONLINE_PIN' | 'DEVICE_CVM'

export type GratuityMode = 'SuggestivePrompt' | 'Prompt' | 'PrintBlankLine'

export type DeviceType = 'PAX' | 'INGENICO'

export type CommunicationMode = 'local' | 'cloud' | 'local_with_cloud_fallback'

// ─── Configuration ───────────────────────────────────────────────────────────

export interface DatacapConfig {
  merchantId: string
  operatorId: string
  posPackageId: string
  communicationMode: CommunicationMode
  // Local connection
  defaultPort?: number
  // Cloud connection
  cloudUrl?: string
  cloudUsername?: string
  cloudPassword?: string
  // Timeouts
  localTimeoutMs?: number   // Default: 60000 (60s for card interaction)
  cloudTimeoutMs?: number   // Default: 30000
}

// ─── Request Fields ──────────────────────────────────────────────────────────

export interface DatacapAmountFields {
  purchase?: number
  gratuity?: number
  tax?: number
  cashBack?: number
}

export interface DatacapGratuityFields {
  mode: GratuityMode
  suggestions?: number[]  // e.g., [15, 18, 20, 25] for percentages
  showTotal?: boolean
}

export interface DatacapRequestFields {
  // Required
  merchantId: string
  operatorId: string
  tranCode: TranCode
  // Transaction identifiers
  invoiceNo?: string
  refNo?: string
  sequenceNo?: string
  // Device
  tranDeviceId?: number    // 0=default
  posPackageId?: string
  // Account — almost always 'SecureDevice' for EMV
  acctNo?: string
  // Amounts
  amounts?: DatacapAmountFields
  // Record-based operations (voids, captures, adjustments)
  recordNo?: string
  recordNumberRequested?: boolean
  frequency?: 'OneTime' | 'Recurring'
  // Partial auth
  partialAuth?: 'Allow' | 'Deny'
  // Gratuity / tip
  gratuity?: DatacapGratuityFields
  gratuitySuggestions?: string  // "15,18,20,25"
  // Device prompts
  promptText?: string
  buttonLabels?: string[]
  // Duplicate override
  duplicate?: 'Override'
  // CardholderID for card recognition
  cardHolderId?: 'Allow_V2'
  // Collect card data (no charge)
  collectData?: boolean
}

// ─── Response ────────────────────────────────────────────────────────────────

export interface DatacapResponse {
  // Status
  cmdStatus: CmdStatus
  dsixReturnCode: string
  responseOrigin: ResponseOrigin
  textResponse: string
  // Transaction identifiers
  sequenceNo?: string
  tranCode?: string
  // Authorization
  authorize?: string        // Amount authorized (string from XML)
  authCode?: string
  refNo?: string
  recordNo?: string         // Token for future operations (voids, captures, adjustments)
  // Card info
  acctNo?: string           // Masked card number (e.g., "***4111")
  cardLast4?: string        // Extracted last 4 digits
  cardType?: string         // Mapped: 'visa', 'mastercard', 'amex', 'discover'
  cardholderName?: string   // From chip data
  cardholderIdHash?: string // CardholderID for recognition
  entryMethod?: EntryMethod
  // EMV data
  aid?: string              // Application Identifier
  cvm?: CVM
  // Partial approval
  isPartialApproval: boolean
  partialAuthApprovalCode?: string
  // Print data
  printData?: Record<string, string>  // Line1 through Line36
  // Gratuity response
  gratuityAmount?: string
  // Batch info
  batchNo?: string
  batchItemCount?: string
  // Signature
  signatureData?: string
  // Raw XML for debugging
  rawXml: string
}

// ─── Error ───────────────────────────────────────────────────────────────────

export interface DatacapError {
  code: string
  text: string
  description: string
  isRetryable: boolean
  responseOrigin?: ResponseOrigin
}

// ─── Transaction Parameters ──────────────────────────────────────────────────

export interface SaleParams {
  invoiceNo: string
  amounts: DatacapAmountFields
  tipMode?: 'suggestive' | 'prompt' | 'included' | 'none'
  tipSuggestions?: number[]
  requestRecordNo?: boolean
  allowPartialAuth?: boolean
}

export interface PreAuthParams {
  invoiceNo: string
  amount: number
  requestRecordNo?: boolean
}

export interface CaptureParams {
  recordNo: string
  purchaseAmount: number
  gratuityAmount?: number
}

export interface IncrementParams {
  recordNo: string
  additionalAmount: number
}

export interface AdjustParams {
  recordNo: string
  purchaseAmount: number
  gratuityAmount: number
}

export interface VoidParams {
  recordNo: string
}

export interface ReturnParams {
  amount: number
  recordNo?: string           // If card not present, use stored token
  cardPresent?: boolean       // Default: true (EMVReturn) vs false (ReturnByRecordNo)
  invoiceNo?: string
}

export interface DevicePromptParams {
  promptType: 'tip' | 'yesno' | 'signature' | 'choice'
  promptText?: string
  suggestions?: number[]      // Tip percentages
  buttonLabels?: string[]     // For multiple choice
}

export interface CollectCardParams {
  placeholderAmount?: number  // Small amount for card read (default $0.01)
}

// ─── Discovery ───────────────────────────────────────────────────────────────

export interface DiscoveredDevice {
  serialNumber: string
  ipAddress: string
  port: number
  deviceType?: DeviceType
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/xml-builder.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — XML Request Builder
// Builds TStream XML requests for Datacap devices and cloud

import type { DatacapRequestFields, DatacapAmountFields, DatacapGratuityFields } from './types'

// ─── XML Helpers ─────────────────────────────────────────────────────────────

export function escapeXml(value: string): string {
  return value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
}

export function formatAmount(amount: number): string {
  return amount.toFixed(2)
}

function tag(name: string, value: string | number | boolean | undefined | null): string {
  if (value === undefined || value === null) return ''
  const strValue = typeof value === 'number' ? formatAmount(value) : String(value)
  return `<${name}>${escapeXml(strValue)}</${name}>`
}

// ─── Amount Block ────────────────────────────────────────────────────────────

export function buildAmountBlock(amounts: DatacapAmountFields): string {
  const parts: string[] = []
  if (amounts.purchase !== undefined) parts.push(`<Purchase>${formatAmount(amounts.purchase)}</Purchase>`)
  if (amounts.gratuity !== undefined) parts.push(`<Gratuity>${formatAmount(amounts.gratuity)}</Gratuity>`)
  if (amounts.tax !== undefined) parts.push(`<Tax>${formatAmount(amounts.tax)}</Tax>`)
  if (amounts.cashBack !== undefined) parts.push(`<CashBack>${formatAmount(amounts.cashBack)}</CashBack>`)
  if (parts.length === 0) return ''
  return `<Amount>${parts.join('')}</Amount>`
}

// ─── Gratuity Block ──────────────────────────────────────────────────────────

export function buildGratuityBlock(gratuity: DatacapGratuityFields): string {
  const parts: string[] = []

  if (gratuity.mode === 'SuggestivePrompt') {
    parts.push('<Gratuity>SuggestivePrompt</Gratuity>')
    if (gratuity.suggestions && gratuity.suggestions.length > 0) {
      parts.push(`<GratuitySuggestions>${gratuity.suggestions.join(',')}</GratuitySuggestions>`)
    }
    if (gratuity.showTotal) {
      parts.push('<GratuityShowTotal>Yes</GratuityShowTotal>')
    }
  } else if (gratuity.mode === 'Prompt') {
    parts.push('<Gratuity>Prompt</Gratuity>')
  } else if (gratuity.mode === 'PrintBlankLine') {
    parts.push('<Gratuity>PrintBlankLine</Gratuity>')
  }

  return parts.join('')
}

// ─── Account Block ───────────────────────────────────────────────────────────

function buildAccountBlock(acctNo: string): string {
  return `<Account><AcctNo>${escapeXml(acctNo)}</AcctNo></Account>`
}

// ─── Main Request Builder ────────────────────────────────────────────────────

export function buildRequest(fields: DatacapRequestFields): string {
  const parts: string[] = []

  // Required fields
  parts.push(tag('MerchantID', fields.merchantId))
  parts.push(tag('OperatorID', fields.operatorId))
  parts.push(tag('TranCode', fields.tranCode))

  // Transaction identifiers
  if (fields.invoiceNo) parts.push(tag('InvoiceNo', fields.invoiceNo))
  if (fields.refNo) parts.push(tag('RefNo', fields.refNo))
  if (fields.sequenceNo) parts.push(tag('SequenceNo', fields.sequenceNo))

  // Device
  if (fields.tranDeviceId !== undefined) parts.push(tag('TranDeviceID', String(fields.tranDeviceId)))
  if (fields.posPackageId) parts.push(tag('POSPackageID', fields.posPackageId))

  // Account — almost always 'SecureDevice' for EMV
  if (fields.acctNo) {
    parts.push(buildAccountBlock(fields.acctNo))
  }

  // Amounts
  if (fields.amounts) {
    parts.push(buildAmountBlock(fields.amounts))
  }

  // Partial auth
  if (fields.partialAuth) parts.push(tag('PartialAuth', fields.partialAuth))

  // Record number (for voids, captures, adjustments)
  if (fields.recordNo) {
    parts.push(tag('RecordNo', fields.recordNo))
  } else if (fields.recordNumberRequested) {
    parts.push('<RecordNo>RecordNumberRequested</RecordNo>')
    if (fields.frequency) parts.push(tag('Frequency', fields.frequency))
  }

  // CardholderID for card recognition
  if (fields.cardHolderId) parts.push(tag('CardHolderID', fields.cardHolderId))

  // Gratuity block
  if (fields.gratuity) {
    parts.push(buildGratuityBlock(fields.gratuity))
  }

  // Gratuity suggestions (shorthand — alternative to full gratuity block)
  if (fields.gratuitySuggestions) {
    parts.push(tag('GratuitySuggestions', fields.gratuitySuggestions))
  }

  // Device prompts
  if (fields.promptText) parts.push(tag('PromptText', fields.promptText))
  if (fields.buttonLabels && fields.buttonLabels.length > 0) {
    fields.buttonLabels.forEach((label, i) => {
      parts.push(tag(`Button${i + 1}`, label))
    })
  }

  // Duplicate override
  if (fields.duplicate) parts.push(tag('Duplicate', fields.duplicate))

  // Filter out empty strings
  const content = parts.filter(Boolean).join('')

  return `<TStream><Transaction>${content}</Transaction></TStream>`
}

// ─── Admin Request Builder (Batch operations) ────────────────────────────────

export function buildAdminRequest(fields: DatacapRequestFields): string {
  const parts: string[] = []

  parts.push(tag('MerchantID', fields.merchantId))
  parts.push(tag('OperatorID', fields.operatorId))
  parts.push(tag('TranCode', fields.tranCode))

  if (fields.sequenceNo) parts.push(tag('SequenceNo', fields.sequenceNo))
  if (fields.posPackageId) parts.push(tag('POSPackageID', fields.posPackageId))

  const content = parts.filter(Boolean).join('')

  return `<TStream><Admin>${content}</Admin></TStream>`
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/datacap/xml-parser.ts
────────────────────────────────────────────────────────────────────────────────
// Datacap Direct API — XML Response Parser
// Parses RStream XML responses from Datacap devices and cloud

import type { DatacapResponse, CmdStatus, ResponseOrigin, EntryMethod, CVM, DatacapError } from './types'
import { CARD_TYPE_MAP, ENTRY_METHOD_MAP, CVM_MAP, DATACAP_ERROR_CODES } from './constants'

// ─── Tag Extraction ──────────────────────────────────────────────────────────

export function extractTag(xml: string, tagName: string): string | undefined {
  // Match <TagName>value</TagName> — handles whitespace and multiline
  const regex = new RegExp(`<${tagName}>([\\s\\S]*?)</${tagName}>`, 'i')
  const match = xml.match(regex)
  if (match && match[1] !== undefined) {
    return match[1].trim()
  }
  return undefined
}

// ─── Card Last 4 Extraction ─────────────────────────────────────────────────

export function extractCardLast4(acctNo: string | undefined): string | undefined {
  if (!acctNo) return undefined
  // Formats: ***4111, ****4111, XXXX-XXXX-XXXX-4111, ************4111
  const match = acctNo.match(/(\d{4})\s*$/)
  return match ? match[1] : undefined
}

// ─── Print Data Extraction ───────────────────────────────────────────────────

export function extractPrintData(xml: string): Record<string, string> | undefined {
  const printData: Record<string, string> = {}
  let found = false

  for (let i = 1; i <= 36; i++) {
    const value = extractTag(xml, `Line${i}`)
    if (value) {
      printData[`Line${i}`] = value
      found = true
    }
  }

  return found ? printData : undefined
}

// ─── Card Type Mapping ───────────────────────────────────────────────────────

export function mapCardType(datacapCardType: string | undefined): string | undefined {
  if (!datacapCardType) return undefined
  return CARD_TYPE_MAP[datacapCardType.toUpperCase()] || datacapCardType.toLowerCase()
}

// ─── Entry Method Mapping ────────────────────────────────────────────────────

export function mapEntryMethod(datacapEntryMethod: string | undefined): EntryMethod | undefined {
  if (!datacapEntryMethod) return undefined
  const mapped = ENTRY_METHOD_MAP[datacapEntryMethod.toUpperCase()]
  return (mapped as EntryMethod) || undefined
}

// ─── CVM Mapping ─────────────────────────────────────────────────────────────

export function mapCVM(datacapCVM: string | undefined): CVM | undefined {
  if (!datacapCVM) return undefined
  const mapped = CVM_MAP[datacapCVM.toUpperCase()]
  return (mapped as CVM) || undefined
}

// ─── Main Response Parser ────────────────────────────────────────────────────

export function parseResponse(xml: string): DatacapResponse {
  const cmdStatus = (extractTag(xml, 'CmdStatus') || 'Error') as CmdStatus
  const dsixReturnCode = extractTag(xml, 'DSIXReturnCode') || ''
  const responseOrigin = (extractTag(xml, 'ResponseOrigin') || 'Client') as ResponseOrigin
  const textResponse = extractTag(xml, 'TextResponse') || ''

  // Transaction identifiers
  const sequenceNo = extractTag(xml, 'SequenceNo')
  const tranCode = extractTag(xml, 'TranCode')

  // Authorization
  const authorize = extractTag(xml, 'Authorize')
  const authCode = extractTag(xml, 'AuthCode')
  const refNo = extractTag(xml, 'RefNo')
  const recordNo = extractTag(xml, 'RecordNo')

  // Card info
  const acctNo = extractTag(xml, 'AcctNo')
  const cardLast4 = extractCardLast4(acctNo)
  const rawCardType = extractTag(xml, 'CardType')
  const cardType = mapCardType(rawCardType)
  const cardholderName = extractTag(xml, 'CardholderName') || extractTag(xml, 'CustomerName')
  const cardholderIdHash = extractTag(xml, 'CardholderID')

  // Entry method & EMV data
  const rawEntryMethod = extractTag(xml, 'EntryMethod')
  const entryMethod = mapEntryMethod(rawEntryMethod)
  const aid = extractTag(xml, 'AID')
  const rawCVM = extractTag(xml, 'CVM')
  const cvm = mapCVM(rawCVM)

  // Partial approval detection
  const partialAuthApprovalCode = extractTag(xml, 'PartialAuthApprovalCode')
  const isPartialApproval = partialAuthApprovalCode === 'Y' ||
    partialAuthApprovalCode === 'P' ||
    dsixReturnCode === '000001'

  // Print data (receipt lines)
  const printData = extractPrintData(xml)

  // Gratuity
  const gratuityAmount = extractTag(xml, 'Gratuity') || extractTag(xml, 'GratuityAmount')

  // Batch info
  const batchNo = extractTag(xml, 'BatchNo')
  const batchItemCount = extractTag(xml, 'BatchItemCount')

  // Signature
  const signatureData = extractTag(xml, 'SignatureData')

  return {
    cmdStatus,
    dsixReturnCode,
    responseOrigin,
    textResponse,
    sequenceNo,
    tranCode,
    authorize,
    authCode,
    refNo,
    recordNo,
    acctNo,
    cardLast4,
    cardType,
    cardholderName,
    cardholderIdHash,
    entryMethod,
    aid,
    cvm,
    isPartialApproval,
    partialAuthApprovalCode,
    printData,
    gratuityAmount,
    batchNo,
    batchItemCount,
    signatureData,
    rawXml: xml,
  }
}

// ─── Error Parser ────────────────────────────────────────────────────────────

export function parseError(response: DatacapResponse): DatacapError | null {
  if (response.cmdStatus === 'Approved' || response.cmdStatus === 'Success') {
    return null
  }

  const errorInfo = DATACAP_ERROR_CODES[response.dsixReturnCode]

  if (errorInfo) {
    return {
      code: response.dsixReturnCode,
      text: errorInfo.message,
      description: errorInfo.description,
      isRetryable: errorInfo.isRetryable,
      responseOrigin: response.responseOrigin,
    }
  }

  // Unknown error code — fall back to text response
  return {
    code: response.dsixReturnCode || 'UNKNOWN',
    text: response.textResponse || 'Unknown Error',
    description: `${response.responseOrigin}: ${response.textResponse || 'No additional information'}`,
    isRetryable: false,
    responseOrigin: response.responseOrigin,
  }
}


================================================================================
SECTION 2: PAYMENT LIBRARY FILES
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/payment-intent-manager.ts
────────────────────────────────────────────────────────────────────────────────
'use client'

import { offlineDb, PaymentIntent, PaymentIntentStatus } from './offline-db'

/**
 * PaymentIntentManager - Handles the payment handshake persistence
 *
 * This is the "final boss" of POS reliability. It ensures that if a server swipes
 * a card and the Wi-Fi blips during the authorization handshake, the terminal
 * "remembers" exactly what happened and doesn't leave anyone in limbo.
 *
 * Flow:
 * 1. Intent Created - Log intent BEFORE any network request
 * 2. Tokenizing - Getting card token from SDK
 * 3. Token Received - Token saved, ready to authorize
 * 4. Authorizing - Sent to gateway, awaiting response
 * 5. Authorized - Gateway approved
 * 6. Capture Pending - Waiting to capture (store-and-forward if offline)
 * 7. Captured - Payment captured successfully
 */

type PaymentMethodType = 'card' | 'cash' | 'gift_card' | 'house_account'

interface CreateIntentParams {
  orderId: string
  localOrderId?: string
  terminalId: string
  employeeId: string
  amount: number
  tipAmount?: number
  paymentMethod: PaymentMethodType
}

interface TokenizeResult {
  token: string
  cardBrand?: string
  cardLast4?: string
}

interface AuthorizationResult {
  success: boolean
  transactionId?: string
  authCode?: string
  declineReason?: string
}

class PaymentIntentManagerClass {
  private syncInterval: ReturnType<typeof setInterval> | null = null
  private isProcessing = false

  /**
   * Initialize the manager - starts the sync worker
   */
  initialize(): void {
    if (typeof window === 'undefined') return

    // Start sync worker (runs every 15 seconds)
    this.syncInterval = setInterval(() => {
      this.processPendingIntents()
    }, 15000)

    // Listen for online events to trigger immediate sync
    window.addEventListener('online', () => {
      console.log('[PaymentIntentManager] Connection restored, syncing...')
      this.processPendingIntents()
    })

    console.log('[PaymentIntentManager] Initialized')
  }

  /**
   * Generate an idempotency key (fingerprint) for deduplication
   * Format: {terminalId}-{orderId}-{timestamp}-{uuid}
   *
   * The UUID suffix ensures 100% collision resistance even if:
   * - Terminal clocks are out of sync with server
   * - App restarts and retries the same order
   * - Multiple terminals have identical timestamps
   */
  private generateIdempotencyKey(terminalId: string, orderId: string): string {
    const timestamp = Date.now()
    const uuid = crypto.randomUUID().slice(0, 8) // Short UUID suffix for collision resistance
    return `${terminalId}-${orderId}-${timestamp}-${uuid}`
  }

  /**
   * Step 1: Create Payment Intent
   * This MUST be called before any network request
   */
  async createIntent(params: CreateIntentParams): Promise<PaymentIntent> {
    const now = new Date().toISOString()
    const idempotencyKey = this.generateIdempotencyKey(params.terminalId, params.orderId)

    const intent: PaymentIntent = {
      id: crypto.randomUUID(),
      idempotencyKey,
      orderId: params.orderId,
      localOrderId: params.localOrderId,
      terminalId: params.terminalId,
      employeeId: params.employeeId,
      amount: params.amount,
      tipAmount: params.tipAmount || 0,
      subtotal: params.amount - (params.tipAmount || 0),
      paymentMethod: params.paymentMethod,
      status: 'intent_created',
      statusHistory: [
        {
          status: 'intent_created',
          timestamp: now,
          details: `Intent to charge $${params.amount.toFixed(2)} for order ${params.orderId}`,
        },
      ],
      createdAt: now,
      isOfflineCapture: false,
      needsReconciliation: false,
      attempts: 0,
    }

    await offlineDb.paymentIntents.add(intent)
    await this.logSync('payment_intent_created', intent.id, params.amount)

    console.log(`[PaymentIntentManager] Intent created: ${intent.id}`)
    return intent
  }

  /**
   * Step 2: Update intent with tokenized card data
   */
  async recordTokenization(
    intentId: string,
    tokenResult: TokenizeResult
  ): Promise<PaymentIntent> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()
    intent.cardToken = tokenResult.token
    intent.cardBrand = tokenResult.cardBrand
    intent.cardLast4 = tokenResult.cardLast4
    intent.status = 'token_received'
    intent.statusHistory.push({
      status: 'token_received',
      timestamp: now,
      details: `Card tokenized: ${tokenResult.cardBrand || 'Card'} ****${tokenResult.cardLast4 || '????'}`,
    })

    await offlineDb.paymentIntents.put(intent)
    await this.logSync('payment_tokenized', intentId, intent.amount)

    console.log(`[PaymentIntentManager] Token received for ${intentId}`)
    return intent
  }

  /**
   * Step 3: Mark intent as authorizing (about to send to gateway)
   */
  async markAuthorizing(intentId: string): Promise<PaymentIntent> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()
    intent.status = 'authorizing'
    intent.attempts += 1
    intent.lastAttempt = now
    intent.statusHistory.push({
      status: 'authorizing',
      timestamp: now,
      details: `Authorization attempt ${intent.attempts}`,
    })

    await offlineDb.paymentIntents.put(intent)
    return intent
  }

  /**
   * Step 4: Record authorization result from gateway
   */
  async recordAuthorization(
    intentId: string,
    result: AuthorizationResult
  ): Promise<PaymentIntent> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()

    if (result.success) {
      intent.status = 'authorized'
      intent.gatewayTransactionId = result.transactionId
      intent.authorizationCode = result.authCode
      intent.authorizedAt = now
      intent.statusHistory.push({
        status: 'authorized',
        timestamp: now,
        details: `Authorized: ${result.authCode}`,
      })
      await this.logSync('payment_authorized', intentId, intent.amount)
    } else {
      intent.status = 'declined'
      intent.lastError = result.declineReason || 'Card declined'
      intent.statusHistory.push({
        status: 'declined',
        timestamp: now,
        details: result.declineReason || 'Card declined by gateway',
      })
      await this.logSync('payment_declined', intentId, intent.amount)
    }

    await offlineDb.paymentIntents.put(intent)
    console.log(`[PaymentIntentManager] Authorization result for ${intentId}: ${intent.status}`)
    return intent
  }

  /**
   * Step 5: Mark for offline capture (when network is down after authorization)
   */
  async markForOfflineCapture(intentId: string): Promise<PaymentIntent> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()
    intent.status = 'capture_pending'
    intent.isOfflineCapture = true
    intent.offlineCapturedAt = now
    intent.needsReconciliation = true // Flag for EOD report
    intent.statusHistory.push({
      status: 'capture_pending',
      timestamp: now,
      details: 'Queued for offline capture - will sync when connection restored',
    })

    await offlineDb.paymentIntents.put(intent)
    await this.logSync('payment_offline_queued', intentId, intent.amount)

    console.log(`[PaymentIntentManager] Queued for offline capture: ${intentId}`)
    return intent
  }

  /**
   * Step 6: Record successful capture
   */
  async recordCapture(
    intentId: string,
    serverPaymentId?: string
  ): Promise<PaymentIntent> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()
    intent.status = 'captured'
    intent.capturedAt = now
    intent.syncedAt = now
    intent.statusHistory.push({
      status: 'captured',
      timestamp: now,
      details: serverPaymentId
        ? `Captured and synced: ${serverPaymentId}`
        : 'Payment captured successfully',
    })

    await offlineDb.paymentIntents.put(intent)
    await this.logSync('payment_captured', intentId, intent.amount)

    console.log(`[PaymentIntentManager] Captured: ${intentId}`)
    return intent
  }

  /**
   * Record a failed attempt (network error, etc.)
   */
  async recordFailure(intentId: string, error: string): Promise<PaymentIntent> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()
    intent.status = 'failed'
    intent.lastError = error
    intent.statusHistory.push({
      status: 'failed',
      timestamp: now,
      details: error,
    })

    await offlineDb.paymentIntents.put(intent)
    await this.logSync('payment_failed', intentId, intent.amount)

    console.log(`[PaymentIntentManager] Failed: ${intentId} - ${error}`)
    return intent
  }

  /**
   * Process pending intents when connection is restored
   * Uses batch sync-resolution endpoint for efficiency and idempotency
   */
  async processPendingIntents(): Promise<void> {
    if (this.isProcessing) return
    if (typeof navigator !== 'undefined' && !navigator.onLine) return

    this.isProcessing = true
    console.log('[PaymentIntentManager] Processing pending intents...')

    try {
      // Get all intents that need capture
      const pendingCaptures = await offlineDb.paymentIntents
        .where('status')
        .equals('capture_pending')
        .toArray()

      // Also check for authorized but not captured (edge case)
      const authorizedNotCaptured = await offlineDb.paymentIntents
        .where('status')
        .equals('authorized')
        .filter((i: PaymentIntent) => !i.capturedAt && Boolean(i.authorizedAt))
        .toArray()

      const allPending = [...pendingCaptures, ...authorizedNotCaptured]

      if (allPending.length === 0) {
        console.log('[PaymentIntentManager] No pending intents to sync')
        return
      }

      // Use batch sync-resolution endpoint
      await this.batchSyncIntents(allPending)

      console.log(`[PaymentIntentManager] Processed ${allPending.length} intents`)
    } catch (error) {
      console.error('[PaymentIntentManager] Error processing intents:', error)
    } finally {
      this.isProcessing = false
    }
  }

  /**
   * Batch sync multiple intents using the sync-resolution endpoint
   * This is more efficient and uses idempotency keys for deduplication
   */
  private async batchSyncIntents(intents: PaymentIntent[]): Promise<void> {
    // Convert intents to transaction format for the API
    const transactions = intents.map((intent) => ({
      localId: intent.id,
      orderId: intent.orderId,
      localOrderId: intent.localOrderId,
      idempotencyKey: intent.idempotencyKey,
      amount: intent.amount,
      tipAmount: intent.tipAmount,
      method: intent.paymentMethod,
      gatewayToken: intent.cardToken,
      cardBrand: intent.cardBrand,
      cardLast4: intent.cardLast4,
      authCode: intent.authorizationCode,
      gatewayTransactionId: intent.gatewayTransactionId,
      terminalId: intent.terminalId,
      employeeId: intent.employeeId,
      timestamp: intent.offlineCapturedAt || intent.createdAt,
    }))

    try {
      const response = await fetch('/api/orders/sync-resolution', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ transactions }),
      })

      if (response.ok) {
        const data = await response.json()
        console.log('[PaymentIntentManager] Batch sync result:', data.summary)

        // Update local intents based on results
        for (const result of data.results) {
          const intent = intents.find((i) => i.id === result.id)
          if (!intent) continue

          if (result.status === 'synced' || result.status === 'duplicate_ignored') {
            await this.recordCapture(intent.id, result.serverId)
            await this.logSync('payment_synced', intent.id, intent.amount)
          } else if (result.status === 'failed') {
            console.error(`[PaymentIntentManager] Sync failed for ${intent.id}: ${result.error}`)
            // Increment attempt counter but don't mark as failed - will retry
            intent.attempts += 1
            intent.lastAttempt = new Date().toISOString()
            intent.lastError = result.error
            await offlineDb.paymentIntents.put(intent)
          }
        }
      } else {
        const error = await response.json()
        console.error('[PaymentIntentManager] Batch sync failed:', error)
      }
    } catch (error) {
      console.error('[PaymentIntentManager] Network error during batch sync:', error)
    }
  }

  /**
   * Sync a single intent to the server
   */
  private async syncIntent(intent: PaymentIntent): Promise<void> {
    try {
      // Mark as syncing in status history
      intent.statusHistory.push({
        status: intent.status,
        timestamp: new Date().toISOString(),
        details: 'Syncing to server...',
      })
      await offlineDb.paymentIntents.put(intent)

      // Send to server
      const response = await fetch('/api/payments/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          intentId: intent.id,
          orderId: intent.orderId,
          localOrderId: intent.localOrderId,
          amount: intent.amount,
          tipAmount: intent.tipAmount,
          paymentMethod: intent.paymentMethod,
          cardToken: intent.cardToken,
          cardBrand: intent.cardBrand,
          cardLast4: intent.cardLast4,
          gatewayTransactionId: intent.gatewayTransactionId,
          authorizationCode: intent.authorizationCode,
          isOfflineCapture: intent.isOfflineCapture,
          offlineCapturedAt: intent.offlineCapturedAt,
          terminalId: intent.terminalId,
          employeeId: intent.employeeId,
        }),
      })

      if (response.ok) {
        const data = await response.json()
        await this.recordCapture(intent.id, data.paymentId)
        await this.logSync('payment_synced', intent.id, intent.amount)
      } else {
        const error = await response.json()
        console.error(`[PaymentIntentManager] Sync failed for ${intent.id}:`, error)
        // Don't mark as failed - will retry
      }
    } catch (error) {
      console.error(`[PaymentIntentManager] Network error syncing ${intent.id}:`, error)
      // Don't mark as failed - will retry on next interval
    }
  }

  /**
   * Get all intents that need reconciliation (for EOD report)
   */
  async getIntentsNeedingReconciliation(): Promise<PaymentIntent[]> {
    return offlineDb.paymentIntents
      .where('needsReconciliation')
      .equals(1) // IndexedDB stores booleans as 0/1
      .toArray()
  }

  /**
   * Get all offline-captured intents (for EOD report flagging)
   */
  async getOfflineCapturedIntents(): Promise<PaymentIntent[]> {
    return offlineDb.paymentIntents
      .where('isOfflineCapture')
      .equals(1)
      .filter((i) => i.status === 'captured')
      .toArray()
  }

  /**
   * Mark intent as reconciled (verified against bank statement)
   */
  async markReconciled(intentId: string, employeeId: string): Promise<void> {
    const intent = await offlineDb.paymentIntents.get(intentId)
    if (!intent) throw new Error(`Intent ${intentId} not found`)

    const now = new Date().toISOString()
    intent.needsReconciliation = false
    intent.reconciledAt = now
    intent.reconciledBy = employeeId
    intent.statusHistory.push({
      status: 'reconciled',
      timestamp: now,
      details: `Reconciled by employee ${employeeId}`,
    })

    await offlineDb.paymentIntents.put(intent)
  }

  /**
   * Get intent by ID
   */
  async getIntent(intentId: string): Promise<PaymentIntent | undefined> {
    return offlineDb.paymentIntents.get(intentId)
  }

  /**
   * Get all intents for an order
   */
  async getIntentsForOrder(orderId: string): Promise<PaymentIntent[]> {
    return offlineDb.paymentIntents.where('orderId').equals(orderId).toArray()
  }

  /**
   * Get recent intents for display
   */
  async getRecentIntents(limit = 50): Promise<PaymentIntent[]> {
    return offlineDb.paymentIntents
      .orderBy('createdAt')
      .reverse()
      .limit(limit)
      .toArray()
  }

  /**
   * Log to sync logs
   */
  private async logSync(
    action: 'payment_intent_created' | 'payment_tokenized' | 'payment_authorized' | 'payment_captured' | 'payment_offline_queued' | 'payment_synced' | 'payment_declined' | 'payment_failed',
    localId: string,
    amount: number
  ): Promise<void> {
    await offlineDb.syncLogs.add({
      timestamp: new Date().toISOString(),
      action,
      details: `${action} for $${amount.toFixed(2)}`,
      localId,
      amount,
    })
  }

  /**
   * Cleanup old captured intents (older than 30 days)
   */
  async cleanupOldIntents(): Promise<number> {
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    const oldIntents = await offlineDb.paymentIntents
      .where('status')
      .equals('captured')
      .filter((i: PaymentIntent) => Boolean(i.capturedAt) && new Date(i.capturedAt!) < thirtyDaysAgo)
      .toArray()

    for (const intent of oldIntents) {
      await offlineDb.paymentIntents.delete(intent.id)
    }

    return oldIntents.length
  }
}

// Singleton export
export const PaymentIntentManager = new PaymentIntentManagerClass()


────────────────────────────────────────────────────────────────────────────────
FILE: src/lib/payment.ts
────────────────────────────────────────────────────────────────────────────────
// Payment Utilities
// Skill 30: Payment Processing

import type { PaymentSettings } from './settings'

// Rounding utilities for cash payments
export function roundAmount(
  amount: number,
  rounding: PaymentSettings['cashRounding'],
  direction: PaymentSettings['roundingDirection']
): number {
  if (rounding === 'none') return amount

  const roundingValues = {
    nickel: 0.05,
    dime: 0.10,
    quarter: 0.25,
    dollar: 1.00,
  }

  const roundTo = roundingValues[rounding]

  switch (direction) {
    case 'up':
      return Math.ceil(amount / roundTo) * roundTo
    case 'down':
      return Math.floor(amount / roundTo) * roundTo
    case 'nearest':
    default:
      return Math.round(amount / roundTo) * roundTo
  }
}

// Calculate rounding adjustment
export function calculateRoundingAdjustment(
  originalAmount: number,
  rounding: PaymentSettings['cashRounding'],
  direction: PaymentSettings['roundingDirection']
): number {
  const rounded = roundAmount(originalAmount, rounding, direction)
  return Math.round((rounded - originalAmount) * 100) / 100
}

// Calculate change for cash payment
export function calculateChange(amountDue: number, amountTendered: number): number {
  const change = amountTendered - amountDue
  return Math.max(0, Math.round(change * 100) / 100)
}

// Quick cash amounts (for buttons)
export function getQuickCashAmounts(amountDue: number): number[] {
  const amounts: number[] = []

  // Exact amount
  amounts.push(amountDue)

  // Round up to nearest $5
  const roundTo5 = Math.ceil(amountDue / 5) * 5
  if (roundTo5 > amountDue) amounts.push(roundTo5)

  // Round up to nearest $10
  const roundTo10 = Math.ceil(amountDue / 10) * 10
  if (roundTo10 > roundTo5) amounts.push(roundTo10)

  // Round up to nearest $20
  const roundTo20 = Math.ceil(amountDue / 20) * 20
  if (roundTo20 > roundTo10) amounts.push(roundTo20)

  // $50 and $100 if applicable
  if (amountDue < 50 && !amounts.includes(50)) amounts.push(50)
  if (amountDue < 100 && !amounts.includes(100)) amounts.push(100)

  // Sort and return unique amounts
  return [...new Set(amounts)].sort((a, b) => a - b).slice(0, 5)
}

// Generate fake auth code for simulated payments
export function generateFakeAuthCode(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  let code = ''
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return code
}

// Generate fake transaction ID
export function generateFakeTransactionId(): string {
  return `SIM_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// Validate card last 4 digits
export function isValidLast4(last4: string): boolean {
  return /^\d{4}$/.test(last4)
}

// Card brand options
export const CARD_BRANDS = [
  { value: 'visa', label: 'Visa' },
  { value: 'mastercard', label: 'Mastercard' },
  { value: 'amex', label: 'American Express' },
  { value: 'discover', label: 'Discover' },
] as const

export type CardBrand = typeof CARD_BRANDS[number]['value']

// Payment method labels
export const PAYMENT_METHOD_LABELS: Record<string, string> = {
  cash: 'Cash',
  credit: 'Credit Card',
  debit: 'Debit Card',
  gift_card: 'Gift Card',
  house_account: 'House Account',
}

// Calculate tip amount from percentage
export function calculateTip(
  subtotal: number,
  tipPercent: number,
  calculateOn: 'subtotal' | 'total',
  total?: number
): number {
  const base = calculateOn === 'total' && total ? total : subtotal
  return Math.round(base * (tipPercent / 100) * 100) / 100
}

// Calculate tip percentage from amount
export function calculateTipPercent(
  tipAmount: number,
  subtotal: number,
  calculateOn: 'subtotal' | 'total',
  total?: number
): number {
  const base = calculateOn === 'total' && total ? total : subtotal
  if (base === 0) return 0
  return Math.round((tipAmount / base) * 100 * 10) / 10
}

// Check if order is fully paid
export function isFullyPaid(
  orderTotal: number,
  payments: { totalAmount: number; status: string }[]
): boolean {
  const paidAmount = payments
    .filter(p => p.status === 'completed')
    .reduce((sum, p) => sum + Number(p.totalAmount), 0)
  return paidAmount >= orderTotal
}

// Calculate remaining balance
export function calculateRemainingBalance(
  orderTotal: number,
  payments: { totalAmount: number; status: string }[]
): number {
  const paidAmount = payments
    .filter(p => p.status === 'completed')
    .reduce((sum, p) => sum + Number(p.totalAmount), 0)
  return Math.max(0, Math.round((orderTotal - paidAmount) * 100) / 100)
}

// Pre-auth expiration date
export function calculatePreAuthExpiration(days: number = 7): Date {
  const date = new Date()
  date.setDate(date.getDate() + days)
  return date
}

// Check if pre-auth is expired
export function isPreAuthExpired(expiresAt: Date | string | null): boolean {
  if (!expiresAt) return true
  const expiration = typeof expiresAt === 'string' ? new Date(expiresAt) : expiresAt
  return expiration < new Date()
}

// Format card display
export function formatCardDisplay(brand: string | null, last4: string | null): string {
  if (!last4) return 'No card'
  const brandLabel = brand ? CARD_BRANDS.find(b => b.value === brand)?.label || brand : 'Card'
  return `${brandLabel} ****${last4}`
}


================================================================================
SECTION 3: PAYMENT COMPONENTS
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/DatacapPaymentProcessor.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { CreditCardIcon, ArrowPathIcon, CheckBadgeIcon, XCircleIcon } from '@heroicons/react/24/outline'
import { useDatacap, DatacapResult } from '@/hooks/useDatacap'
import { SwapConfirmationModal } from './SwapConfirmationModal'
import { ReaderStatusIndicator } from './ReaderStatusIndicator'
import { formatCurrency } from '@/lib/utils'

interface DatacapPaymentProcessorProps {
  orderId: string
  amount: number
  subtotal?: number
  tipSettings?: {
    enabled: boolean
    suggestedPercentages: number[]
    calculateOn: 'subtotal' | 'total'
  }
  terminalId: string
  employeeId: string
  locationId: string
  tipMode?: 'suggestive' | 'prompt' | 'included' | 'none'
  onSuccess: (result: DatacapResult & { tipAmount: number }) => void
  onPartialApproval?: (result: DatacapResult & { tipAmount: number; remainingBalance: number }) => void
  onCancel: () => void
}

export function DatacapPaymentProcessor({
  orderId,
  amount,
  subtotal,
  tipSettings,
  terminalId,
  employeeId,
  locationId,
  tipMode: externalTipMode,
  onSuccess,
  onPartialApproval,
  onCancel,
}: DatacapPaymentProcessorProps) {
  const [tipAmount, setTipAmount] = useState(0)
  const [customTip, setCustomTip] = useState('')
  const [showCustomTip, setShowCustomTip] = useState(false)
  const [partialResult, setPartialResult] = useState<(DatacapResult & { tipAmount: number }) | null>(null)

  const {
    reader,
    backupReader,
    isReaderOnline,
    isProcessing,
    processingStatus,
    error,
    processPayment,
    cancelTransaction,
    swapToBackup,
    triggerBeep,
    canSwap,
    showSwapModal,
    setShowSwapModal,
    refreshReaderConfig,
  } = useDatacap({
    terminalId,
    employeeId,
    locationId,
    onSuccess: (result) => {
      // Check for partial approval
      if (result.isPartialApproval) {
        const remainingBalance = result.amountRequested - result.amountAuthorized
        setPartialResult({ ...result, tipAmount })
        onPartialApproval?.({ ...result, tipAmount, remainingBalance })
      } else {
        onSuccess({ ...result, tipAmount })
      }
    },
    onDeclined: (reason) => {
      console.log('[DatacapPaymentProcessor] Declined:', reason)
    },
    onError: (err) => {
      console.error('[DatacapPaymentProcessor] Error:', err)
    },
    onReaderOffline: () => {
      if (canSwap) {
        setShowSwapModal(true)
      }
    },
  })

  const totalToCharge = amount + tipAmount
  const tipBasis = subtotal || amount

  // Suggested tip percentages
  const suggestedPercentages = tipSettings?.suggestedPercentages || [15, 18, 20, 25]

  const handleCustomTip = () => {
    const tip = parseFloat(customTip) || 0
    setTipAmount(tip)
    setShowCustomTip(false)
  }

  const handleStartPayment = async () => {
    await processPayment({
      orderId,
      amount: totalToCharge,
      tipAmount,
      tipMode: externalTipMode || 'none',
    })

    // Success is handled via onSuccess callback
  }

  const handleConfirmSwap = () => {
    swapToBackup()
  }

  // Status text for UI
  const getStatusText = () => {
    switch (processingStatus) {
      case 'checking_reader':
        return 'Verifying reader...'
      case 'waiting_card':
        return 'Present card on reader...'
      case 'authorizing':
        return 'Authorizing...'
      case 'approved':
        return 'APPROVED'
      case 'declined':
        return 'DECLINED'
      case 'error':
        return error || 'Error'
      default:
        return ''
    }
  }

  return (
    <div className="flex flex-col h-full bg-slate-950 p-6 rounded-3xl border border-slate-800 shadow-2xl relative">
      {/* Financial Header */}
      <div className="text-center mb-6">
        <span className="text-[10px] font-black text-slate-500 uppercase tracking-[0.2em]">
          Amount Due
        </span>
        <h2 className="text-5xl font-black text-white font-mono mt-2">
          {formatCurrency(totalToCharge)}
        </h2>
        {tipAmount > 0 && (
          <p className="text-sm text-slate-400 mt-1">
            (includes {formatCurrency(tipAmount)} tip)
          </p>
        )}
      </div>

      {/* Quick Tip Selection */}
      {tipSettings?.enabled !== false && processingStatus === 'idle' && (
        <div className="mb-6">
          <p className="text-xs text-slate-500 uppercase tracking-wider mb-2">Add Tip</p>
          <div className="grid grid-cols-4 gap-2">
            {suggestedPercentages.map((percent) => {
              const tipValue = tipBasis * (percent / 100)
              const isSelected = Math.abs(tipAmount - tipValue) < 0.01
              return (
                <button
                  key={percent}
                  onClick={() => setTipAmount(tipValue)}
                  className={`py-3 rounded-xl text-sm font-bold transition-all ${
                    isSelected
                      ? 'bg-cyan-600 text-white border-2 border-cyan-400'
                      : 'bg-slate-900 border border-slate-800 text-slate-300 hover:border-cyan-500'
                  }`}
                >
                  {percent}%
                  <span className="block text-[10px] opacity-70">
                    {formatCurrency(tipValue)}
                  </span>
                </button>
              )
            })}
          </div>
          <div className="flex gap-2 mt-2">
            <button
              onClick={() => setTipAmount(0)}
              className={`flex-1 py-2 rounded-lg text-xs font-bold transition-all ${
                tipAmount === 0
                  ? 'bg-slate-700 text-white'
                  : 'bg-slate-900 border border-slate-800 text-slate-400 hover:text-white'
              }`}
            >
              No Tip
            </button>
            <button
              onClick={() => setShowCustomTip(true)}
              className="flex-1 py-2 rounded-lg text-xs font-bold bg-slate-900 border border-slate-800 text-slate-400 hover:text-white transition-all"
            >
              Custom
            </button>
          </div>

          {/* Custom Tip Input */}
          {showCustomTip && (
            <div className="mt-3 flex gap-2">
              <input
                type="number"
                value={customTip}
                onChange={(e) => setCustomTip(e.target.value)}
                placeholder="0.00"
                className="flex-1 bg-slate-900 border border-slate-700 rounded-lg p-2 text-white font-mono"
                autoFocus
              />
              <button
                onClick={handleCustomTip}
                className="px-4 py-2 bg-cyan-600 text-white rounded-lg font-bold"
              >
                Apply
              </button>
            </div>
          )}
        </div>
      )}

      {/* Hardware Status & Swap Trigger */}
      <div className="mt-auto space-y-4">
        <ReaderStatusIndicator
          reader={reader}
          isOnline={isReaderOnline}
          processingStatus={processingStatus}
          onSwapClick={() => setShowSwapModal(true)}
          canSwap={canSwap}
        />

        {/* Error Display */}
        {error && processingStatus === 'error' && (
          <div className="p-3 bg-red-900/30 border border-red-700 rounded-xl text-red-400 text-sm">
            {error}
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex gap-3">
          <button
            onClick={onCancel}
            disabled={isProcessing}
            className="flex-1 py-4 rounded-2xl font-bold text-sm border border-slate-700 text-slate-400 hover:text-white hover:border-slate-500 transition-all disabled:opacity-50"
          >
            Cancel
          </button>
          <button
            disabled={isProcessing || !isReaderOnline}
            onClick={handleStartPayment}
            className={`flex-[2] py-4 rounded-2xl font-black text-lg transition-all flex items-center justify-center gap-3 ${
              isProcessing
                ? 'bg-slate-800 text-slate-500 cursor-not-allowed'
                : !isReaderOnline
                ? 'bg-amber-900/50 text-amber-500 cursor-not-allowed'
                : 'bg-emerald-600 hover:bg-emerald-500 text-white shadow-lg shadow-emerald-900/20'
            }`}
          >
            {isProcessing ? (
              <>
                <ArrowPathIcon className="w-6 h-6 animate-spin" />
                <span className="text-sm">{getStatusText()}</span>
              </>
            ) : !isReaderOnline ? (
              <>
                <XCircleIcon className="w-6 h-6" />
                READER OFFLINE
              </>
            ) : (
              <>
                <CreditCardIcon className="w-6 h-6" />
                COLLECT PAYMENT
              </>
            )}
          </button>
        </div>
      </div>

      {/* Success Overlay */}
      <AnimatePresence>
        {processingStatus === 'approved' && !partialResult && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-emerald-600 flex flex-col items-center justify-center z-50 rounded-3xl"
          >
            <CheckBadgeIcon className="w-24 h-24 text-white mb-4" />
            <h2 className="text-3xl font-black text-white">APPROVED</h2>
            <p className="text-emerald-100 font-bold mt-2">Processing receipt...</p>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Partial Approval Overlay */}
      <AnimatePresence>
        {processingStatus === 'approved' && partialResult && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-amber-600 flex flex-col items-center justify-center z-50 rounded-3xl p-6"
          >
            <div className="text-center">
              <h2 className="text-2xl font-black text-white mb-2">PARTIAL APPROVAL</h2>
              <p className="text-amber-100 text-sm mb-6">Card has insufficient funds</p>

              <div className="bg-amber-700/50 rounded-2xl p-4 mb-6 space-y-2">
                <div className="flex justify-between text-amber-100">
                  <span>Requested:</span>
                  <span className="font-mono">{formatCurrency(partialResult.amountRequested)}</span>
                </div>
                <div className="flex justify-between text-white font-bold">
                  <span>Approved:</span>
                  <span className="font-mono">{formatCurrency(partialResult.amountAuthorized)}</span>
                </div>
                <div className="border-t border-amber-500 pt-2 flex justify-between text-amber-200">
                  <span>Remaining:</span>
                  <span className="font-mono font-bold">
                    {formatCurrency(partialResult.amountRequested - partialResult.amountAuthorized)}
                  </span>
                </div>
              </div>

              <p className="text-amber-100 text-xs mb-4">
                Accept partial or collect remaining with another payment method
              </p>

              <div className="flex gap-3">
                <button
                  onClick={() => {
                    setPartialResult(null)
                    cancelTransaction()
                  }}
                  className="flex-1 py-3 bg-amber-700 text-white rounded-xl font-bold"
                >
                  Void & Retry
                </button>
                <button
                  onClick={() => {
                    const remaining = partialResult.amountRequested - partialResult.amountAuthorized
                    onPartialApproval?.({ ...partialResult, remainingBalance: remaining })
                    setPartialResult(null)
                  }}
                  className="flex-1 py-3 bg-white text-amber-700 rounded-xl font-bold"
                >
                  Accept Partial
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Declined Overlay */}
      <AnimatePresence>
        {processingStatus === 'declined' && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-red-600 flex flex-col items-center justify-center z-50 rounded-3xl"
          >
            <XCircleIcon className="w-24 h-24 text-white mb-4" />
            <h2 className="text-3xl font-black text-white">DECLINED</h2>
            <p className="text-red-100 font-bold mt-2">{error || 'Card was declined'}</p>
            <button
              onClick={() => cancelTransaction()}
              className="mt-6 px-8 py-3 bg-white/20 text-white rounded-xl font-bold"
            >
              Try Again
            </button>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Swap Confirmation Modal */}
      {showSwapModal && backupReader && (
        <SwapConfirmationModal
          targetReader={backupReader}
          onCancel={() => setShowSwapModal(false)}
          onConfirm={handleConfirmSwap}
          onBeep={triggerBeep}
        />
      )}
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/GroupSummary.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import {
  XMarkIcon,
  CreditCardIcon,
  TableCellsIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  CheckCircleIcon,
  LinkIcon,
} from '@heroicons/react/24/outline'
import { formatCurrency } from '@/lib/utils'

export interface GroupTableFinancials {
  tableId: string
  tableName: string
  tableAbbreviation?: string
  isPrimary: boolean
  itemCount: number
  subtotal: number
  tax: number
  total: number
  paid: number
  remaining: number
  items: {
    id: string
    name: string
    quantity: number
    price: number
    seatNumber?: number
  }[]
}

interface GroupSummaryProps {
  isOpen: boolean
  virtualGroupId: string
  groupColor: string
  financials: GroupTableFinancials[]
  onFinalizeAll: () => void
  onPaySingleTable: (tableId: string) => void
  onClose: () => void
  isProcessing?: boolean
}

/**
 * GroupSummary - Checkout view for virtual table groups
 *
 * Shows per-table breakdown of items and totals, allowing:
 * - View of what each table ordered (T-S notation preserved)
 * - Pay entire group at once
 * - Pay individual tables separately
 * - Auto-dissolves group when fully paid
 */
export function GroupSummary({
  isOpen,
  virtualGroupId,
  groupColor,
  financials,
  onFinalizeAll,
  onPaySingleTable,
  onClose,
  isProcessing = false,
}: GroupSummaryProps) {
  const [expandedTables, setExpandedTables] = useState<Set<string>>(new Set())

  // Calculate grand totals
  const grandTotal = useMemo(
    () => financials.reduce((sum, f) => sum + f.total, 0),
    [financials]
  )
  const grandPaid = useMemo(
    () => financials.reduce((sum, f) => sum + f.paid, 0),
    [financials]
  )
  const grandRemaining = useMemo(
    () => financials.reduce((sum, f) => sum + f.remaining, 0),
    [financials]
  )
  const totalItems = useMemo(
    () => financials.reduce((sum, f) => sum + f.itemCount, 0),
    [financials]
  )

  const isFullyPaid = grandRemaining <= 0
  const tableCount = financials.length
  const paidTables = financials.filter(f => f.remaining <= 0).length

  if (!isOpen) return null

  const toggleTableExpanded = (tableId: string) => {
    setExpandedTables(prev => {
      const next = new Set(prev)
      if (next.has(tableId)) {
        next.delete(tableId)
      } else {
        next.add(tableId)
      }
      return next
    })
  }

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
        onClick={onClose}
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.95, opacity: 0 }}
          transition={{ type: 'spring', damping: 25, stiffness: 300 }}
          className="w-full max-w-2xl mx-4 bg-slate-900 rounded-2xl shadow-2xl border border-slate-700/50 overflow-hidden max-h-[90vh] flex flex-col"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Header */}
          <div className="flex items-center justify-between px-6 py-4 border-b border-slate-700/50">
            <div className="flex items-center gap-3">
              <div
                className="w-4 h-4 rounded-full animate-pulse"
                style={{ backgroundColor: groupColor }}
              />
              <div>
                <h2 className="text-lg font-semibold text-white flex items-center gap-2">
                  <LinkIcon className="w-5 h-5 text-cyan-400" />
                  Group Checkout
                </h2>
                <p className="text-sm text-slate-400">
                  {tableCount} tables · {totalItems} items
                </p>
              </div>
            </div>
            <button
              onClick={onClose}
              className="p-2 text-slate-400 hover:text-white hover:bg-slate-700 rounded-lg transition-colors"
            >
              <XMarkIcon className="w-5 h-5" />
            </button>
          </div>

          {/* Table breakdown */}
          <div className="flex-1 overflow-y-auto px-6 py-4 space-y-3">
            {financials.map((table) => {
              const isExpanded = expandedTables.has(table.tableId)
              const isPaid = table.remaining <= 0

              return (
                <motion.div
                  key={table.tableId}
                  layout
                  className={`rounded-xl border overflow-hidden transition-colors ${
                    isPaid
                      ? 'bg-green-900/20 border-green-700/50'
                      : 'bg-slate-800/50 border-slate-700/50'
                  }`}
                >
                  {/* Table header */}
                  <div
                    className="flex items-center justify-between p-4 cursor-pointer"
                    onClick={() => toggleTableExpanded(table.tableId)}
                  >
                    <div className="flex items-center gap-3">
                      <div className="flex items-center gap-2">
                        <TableCellsIcon className="w-5 h-5 text-slate-400" />
                        <span className="font-medium text-white">
                          {table.tableAbbreviation || table.tableName}
                        </span>
                        {table.isPrimary && (
                          <span className="px-1.5 py-0.5 text-xs font-medium bg-cyan-500/20 text-cyan-400 rounded">
                            Primary
                          </span>
                        )}
                      </div>
                      <span className="text-sm text-slate-400">
                        {table.itemCount} item{table.itemCount !== 1 ? 's' : ''}
                      </span>
                    </div>
                    <div className="flex items-center gap-4">
                      {isPaid ? (
                        <div className="flex items-center gap-2 text-green-400">
                          <CheckCircleIcon className="w-5 h-5" />
                          <span className="font-medium">Paid</span>
                        </div>
                      ) : (
                        <div className="text-right">
                          <div className="text-lg font-semibold text-white">
                            {formatCurrency(table.remaining)}
                          </div>
                          {table.paid > 0 && (
                            <div className="text-xs text-green-400">
                              {formatCurrency(table.paid)} paid
                            </div>
                          )}
                        </div>
                      )}
                      {isExpanded ? (
                        <ChevronUpIcon className="w-5 h-5 text-slate-400" />
                      ) : (
                        <ChevronDownIcon className="w-5 h-5 text-slate-400" />
                      )}
                    </div>
                  </div>

                  {/* Expanded items list */}
                  <AnimatePresence>
                    {isExpanded && (
                      <motion.div
                        initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }}
                        exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.2 }}
                        className="overflow-hidden"
                      >
                        <div className="px-4 pb-4 space-y-2">
                          {table.items.map((item) => (
                            <div
                              key={item.id}
                              className="flex items-center justify-between py-2 px-3 bg-slate-700/30 rounded-lg"
                            >
                              <div className="flex items-center gap-2">
                                {item.seatNumber && (
                                  <span className="text-xs text-slate-400 font-mono">
                                    S{item.seatNumber}
                                  </span>
                                )}
                                <span className="text-slate-200">
                                  {item.quantity > 1 && (
                                    <span className="text-slate-400 mr-1">
                                      {item.quantity}x
                                    </span>
                                  )}
                                  {item.name}
                                </span>
                              </div>
                              <span className="text-slate-300 font-medium">
                                {formatCurrency(item.price * item.quantity)}
                              </span>
                            </div>
                          ))}

                          {/* Table subtotals */}
                          <div className="mt-3 pt-3 border-t border-slate-700/50 space-y-1">
                            <div className="flex justify-between text-sm text-slate-400">
                              <span>Subtotal</span>
                              <span>{formatCurrency(table.subtotal)}</span>
                            </div>
                            {table.tax > 0 && (
                              <div className="flex justify-between text-sm text-slate-400">
                                <span>Tax</span>
                                <span>{formatCurrency(table.tax)}</span>
                              </div>
                            )}
                            <div className="flex justify-between font-medium text-white">
                              <span>Total</span>
                              <span>{formatCurrency(table.total)}</span>
                            </div>
                          </div>

                          {/* Pay single table button */}
                          {!isPaid && (
                            <button
                              onClick={(e) => {
                                e.stopPropagation()
                                onPaySingleTable(table.tableId)
                              }}
                              className="w-full mt-3 flex items-center justify-center gap-2 px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-medium transition-colors"
                            >
                              <CreditCardIcon className="w-4 h-4" />
                              Pay This Table Only
                            </button>
                          )}
                        </div>
                      </motion.div>
                    )}
                  </AnimatePresence>
                </motion.div>
              )
            })}
          </div>

          {/* Grand total footer */}
          <div className="px-6 py-4 border-t border-slate-700/50 bg-slate-800/50">
            {/* Progress indicator */}
            {tableCount > 1 && (
              <div className="mb-4">
                <div className="flex justify-between text-sm text-slate-400 mb-1">
                  <span>Payment Progress</span>
                  <span>
                    {paidTables} of {tableCount} tables paid
                  </span>
                </div>
                <div className="h-2 bg-slate-700 rounded-full overflow-hidden">
                  <div
                    className="h-full bg-gradient-to-r from-cyan-500 to-green-500 transition-all duration-500"
                    style={{ width: `${(grandPaid / grandTotal) * 100}%` }}
                  />
                </div>
              </div>
            )}

            {/* Grand totals */}
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm text-slate-400">Grand Total</div>
                <div className="text-2xl font-bold text-white">
                  {formatCurrency(grandTotal)}
                </div>
                {grandPaid > 0 && !isFullyPaid && (
                  <div className="text-sm">
                    <span className="text-green-400">
                      {formatCurrency(grandPaid)} paid
                    </span>
                    <span className="text-slate-400"> · </span>
                    <span className="text-amber-400">
                      {formatCurrency(grandRemaining)} remaining
                    </span>
                  </div>
                )}
              </div>
              <div className="flex gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                {isFullyPaid ? (
                  <button
                    onClick={onClose}
                    className="flex items-center gap-2 px-6 py-3 bg-green-500 text-white rounded-lg font-medium hover:bg-green-400 transition-colors"
                  >
                    <CheckCircleIcon className="w-5 h-5" />
                    Done - Group Paid
                  </button>
                ) : (
                  <button
                    onClick={onFinalizeAll}
                    disabled={isProcessing}
                    className={`flex items-center gap-2 px-6 py-3 rounded-lg font-medium transition-all ${
                      isProcessing
                        ? 'bg-slate-700 text-slate-400 cursor-wait'
                        : 'bg-cyan-500 text-white hover:bg-cyan-400 shadow-lg shadow-cyan-500/25'
                    }`}
                  >
                    <CreditCardIcon className="w-5 h-5" />
                    {isProcessing
                      ? 'Processing...'
                      : grandPaid > 0
                        ? `Pay Remaining ${formatCurrency(grandRemaining)}`
                        : 'Pay Entire Group'}
                  </button>
                )}
              </div>
            </div>
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/PaymentModal.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { formatCurrency } from '@/lib/utils'
import { calculateCardPrice } from '@/lib/pricing'
import { calculateTip, getQuickCashAmounts, calculateChange, PAYMENT_METHOD_LABELS } from '@/lib/payment'
import type { DualPricingSettings, TipSettings, PaymentSettings } from '@/lib/settings'
import { DatacapPaymentProcessor } from './DatacapPaymentProcessor'
import type { DatacapResult } from '@/hooks/useDatacap'

interface PaymentModalProps {
  isOpen: boolean
  onClose: () => void
  orderId: string | null
  orderTotal: number
  remainingBalance?: number
  subtotal?: number
  existingPayments?: { method: string; totalAmount: number }[]
  dualPricing: DualPricingSettings
  tipSettings?: TipSettings
  paymentSettings: PaymentSettings
  onPaymentComplete: () => void
  employeeId?: string
  terminalId?: string  // Required for Datacap integration
}

interface PendingPayment {
  method: 'cash' | 'credit' | 'debit' | 'gift_card' | 'house_account'
  amount: number
  tipAmount: number
  amountTendered?: number
  cardBrand?: string
  cardLast4?: string
  giftCardId?: string
  giftCardNumber?: string
  houseAccountId?: string
}

interface GiftCardInfo {
  id: string
  cardNumber: string
  currentBalance: number
  status: string
}

interface HouseAccountInfo {
  id: string
  name: string
  currentBalance: number
  creditLimit: number
  status: string
}

type PaymentStep = 'method' | 'cash' | 'tip' | 'gift_card' | 'house_account' | 'datacap_card'

// Default tip settings
const DEFAULT_TIP_SETTINGS: TipSettings = {
  enabled: true,
  suggestedPercentages: [15, 18, 20, 25],
  calculateOn: 'subtotal',
}

export function PaymentModal({
  isOpen,
  onClose,
  orderId,
  orderTotal,
  remainingBalance,
  subtotal,
  existingPayments = [],
  dualPricing,
  tipSettings = DEFAULT_TIP_SETTINGS,
  paymentSettings,
  onPaymentComplete,
  employeeId,
  terminalId,
}: PaymentModalProps) {
  // ALL HOOKS MUST BE AT THE TOP - before any conditional returns
  // State for fetched order data (when orderTotal is not provided)
  const [fetchedOrderTotal, setFetchedOrderTotal] = useState<number | null>(null)
  const [fetchedSubtotal, setFetchedSubtotal] = useState<number | null>(null)
  const [loadingOrder, setLoadingOrder] = useState(false)

  // Payment flow state
  const [step, setStep] = useState<PaymentStep>('method')
  const [selectedMethod, setSelectedMethod] = useState<'cash' | 'credit' | 'debit' | 'gift_card' | 'house_account' | null>(null)
  const [pendingPayments, setPendingPayments] = useState<PendingPayment[]>([])
  const [tipAmount, setTipAmount] = useState(0)
  const [customTip, setCustomTip] = useState('')
  const [isProcessing, setIsProcessing] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Cash payment state
  const [amountTendered, setAmountTendered] = useState('')
  const [customCashAmount, setCustomCashAmount] = useState('')

  // Gift card state
  const [giftCardNumber, setGiftCardNumber] = useState('')
  const [giftCardInfo, setGiftCardInfo] = useState<GiftCardInfo | null>(null)
  const [giftCardLoading, setGiftCardLoading] = useState(false)
  const [giftCardError, setGiftCardError] = useState<string | null>(null)

  // House account state
  const [houseAccounts, setHouseAccounts] = useState<HouseAccountInfo[]>([])
  const [selectedHouseAccount, setSelectedHouseAccount] = useState<HouseAccountInfo | null>(null)
  const [houseAccountSearch, setHouseAccountSearch] = useState('')
  const [houseAccountsLoading, setHouseAccountsLoading] = useState(false)

  // Fetch order data if orderTotal is 0 or not provided
  useEffect(() => {
    if (isOpen && orderId && orderTotal === 0) {
      setLoadingOrder(true)
      fetch(`/api/orders/${orderId}`)
        .then(res => res.json())
        .then(data => {
          setFetchedOrderTotal(data.total || 0)
          setFetchedSubtotal(data.subtotal || 0)
        })
        .catch(err => {
          console.error('Failed to fetch order:', err)
        })
        .finally(() => {
          setLoadingOrder(false)
        })
    }
  }, [isOpen, orderId, orderTotal])

  // Use fetched total if orderTotal was 0
  const effectiveOrderTotal = orderTotal > 0 ? orderTotal : (fetchedOrderTotal ?? 0)
  // Use subtotal from props or fetched or default to orderTotal
  const effectiveSubtotal = subtotal ?? fetchedSubtotal ?? effectiveOrderTotal

  // Don't render if not open
  if (!isOpen) return null

  // Show loading while fetching order
  if (loadingOrder) {
    return (
      <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
        <div className="bg-white rounded-lg p-8 text-center">
          <div className="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
          <p className="text-gray-600">Loading order...</p>
        </div>
      </div>
    )
  }

  // Calculate amounts
  const alreadyPaid = existingPayments.reduce((sum, p) => sum + p.totalAmount, 0)
  const pendingTotal = pendingPayments.reduce((sum, p) => sum + p.amount + p.tipAmount, 0)
  const remainingBeforeTip = effectiveOrderTotal - alreadyPaid - pendingTotal

  // Apply dual pricing - card price is displayed, cash gets discount
  const discountPercent = dualPricing.cashDiscountPercent || 4.0
  const cashTotal = remainingBeforeTip  // Original/stored price
  const cardTotal = dualPricing.enabled
    ? calculateCardPrice(remainingBeforeTip, discountPercent)
    : remainingBeforeTip

  const currentTotal = selectedMethod === 'cash' ? cashTotal : cardTotal
  const totalWithTip = currentTotal + tipAmount

  // Quick cash amounts
  const quickAmounts = getQuickCashAmounts(totalWithTip)

  const handleSelectMethod = (method: 'cash' | 'credit' | 'debit' | 'gift_card' | 'house_account') => {
    setSelectedMethod(method)
    setTipAmount(0)
    setCustomTip('')
    setError(null)

    if (method === 'gift_card') {
      setGiftCardNumber('')
      setGiftCardInfo(null)
      setGiftCardError(null)
      setStep('gift_card')
    } else if (method === 'house_account') {
      setSelectedHouseAccount(null)
      setHouseAccountSearch('')
      loadHouseAccounts()
      setStep('house_account')
    } else if (tipSettings.enabled) {
      setStep('tip')
    } else if (method === 'cash') {
      setStep('cash')
    } else {
      // All card payments go through Datacap (simulated or real)
      setStep('datacap_card')
    }
  }

  const loadHouseAccounts = async () => {
    setHouseAccountsLoading(true)
    try {
      const response = await fetch(`/api/house-accounts?locationId=${orderId?.split('-')[0] || ''}&status=active`)
      if (response.ok) {
        const data = await response.json()
        setHouseAccounts(data)
      }
    } catch {
      console.error('Failed to load house accounts')
    } finally {
      setHouseAccountsLoading(false)
    }
  }

  const lookupGiftCard = async () => {
    if (!giftCardNumber.trim()) {
      setGiftCardError('Please enter a gift card number')
      return
    }

    setGiftCardLoading(true)
    setGiftCardError(null)

    try {
      const response = await fetch(`/api/gift-cards/${giftCardNumber.trim().toUpperCase()}`)
      if (!response.ok) {
        const data = await response.json()
        setGiftCardError(data.error || 'Gift card not found')
        setGiftCardInfo(null)
        return
      }

      const data = await response.json()
      if (data.status !== 'active') {
        setGiftCardError(`Gift card is ${data.status}`)
        setGiftCardInfo(null)
        return
      }

      setGiftCardInfo(data)
    } catch {
      setGiftCardError('Failed to lookup gift card')
      setGiftCardInfo(null)
    } finally {
      setGiftCardLoading(false)
    }
  }

  const handleGiftCardPayment = () => {
    if (!giftCardInfo) return

    const maxAmount = Math.min(giftCardInfo.currentBalance, totalWithTip)

    const payment: PendingPayment = {
      method: 'gift_card',
      amount: maxAmount,
      tipAmount: 0, // Tips handled separately
      giftCardId: giftCardInfo.id,
      giftCardNumber: giftCardInfo.cardNumber,
    }
    setPendingPayments([...pendingPayments, payment])
    processPayments([...pendingPayments, payment])
  }

  const handleHouseAccountPayment = () => {
    if (!selectedHouseAccount) return

    const payment: PendingPayment = {
      method: 'house_account',
      amount: currentTotal,
      tipAmount,
      houseAccountId: selectedHouseAccount.id,
    }
    setPendingPayments([...pendingPayments, payment])
    processPayments([...pendingPayments, payment])
  }

  const handleSelectTip = (percent: number | null) => {
    if (percent === null) {
      setTipAmount(0)
    } else {
      const tip = calculateTip(effectiveSubtotal, percent, tipSettings.calculateOn, effectiveOrderTotal)
      setTipAmount(tip)
    }
    setCustomTip('')
  }

  const handleCustomTip = () => {
    const tip = parseFloat(customTip) || 0
    setTipAmount(tip)
  }

  const handleContinueFromTip = () => {
    if (selectedMethod === 'cash') {
      setStep('cash')
    } else {
      // All card payments go through Datacap (simulated or real)
      setStep('datacap_card')
    }
  }

  const handleCashPayment = (tendered: number) => {
    const payment: PendingPayment = {
      method: 'cash',
      amount: currentTotal,
      tipAmount,
      amountTendered: tendered,
    }
    setPendingPayments([...pendingPayments, payment])
    processPayments([...pendingPayments, payment])
  }

  // Handle Datacap payment success
  const handleDatacapSuccess = (result: DatacapResult & { tipAmount: number }) => {
    // Guard: ensure selectedMethod is a valid card type
    const method = (selectedMethod === 'credit' || selectedMethod === 'debit') ? selectedMethod : 'credit'
    const payment: PendingPayment = {
      method,
      amount: currentTotal,
      tipAmount: result.tipAmount,
      cardBrand: result.cardBrand || 'card',
      cardLast4: result.cardLast4 || '****',
    }
    setPendingPayments([...pendingPayments, payment])
    processPayments([...pendingPayments, payment])
  }

  const processPayments = async (payments: PendingPayment[]) => {
    setIsProcessing(true)
    setError(null)

    try {
      const response = await fetch(`/api/orders/${orderId}/pay`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          payments: payments.map(p => ({
            method: p.method,
            amount: p.amount,
            tipAmount: p.tipAmount,
            amountTendered: p.amountTendered,
            cardBrand: p.cardBrand,
            cardLast4: p.cardLast4,
            giftCardId: p.giftCardId,
            giftCardNumber: p.giftCardNumber,
            houseAccountId: p.houseAccountId,
          })),
          employeeId,
        }),
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Payment failed')
      }

      const result = await response.json()

      if (result.orderStatus === 'paid') {
        onPaymentComplete()
      } else {
        // Partial payment - reset for more payments
        setStep('method')
        setSelectedMethod(null)
        setTipAmount(0)
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Payment failed')
    } finally {
      setIsProcessing(false)
    }
  }

  const removePendingPayment = (index: number) => {
    setPendingPayments(pendingPayments.filter((_, i) => i !== index))
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-hidden flex flex-col">
        {/* Header */}
        <div className="p-4 border-b bg-gray-50 flex items-center justify-between">
          <h2 className="text-xl font-bold">Pay Order</h2>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4">
          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
              {error}
            </div>
          )}

          {/* Order Summary */}
          <div className="mb-4 p-3 bg-gray-50 rounded-lg">
            <div className="flex justify-between text-sm">
              <span>Order Total</span>
              <span className="font-medium">{formatCurrency(effectiveOrderTotal)}</span>
            </div>
            {alreadyPaid > 0 && (
              <div className="flex justify-between text-sm text-green-600">
                <span>Already Paid</span>
                <span>-{formatCurrency(alreadyPaid)}</span>
              </div>
            )}
            {pendingPayments.length > 0 && (
              <div className="flex justify-between text-sm text-blue-600">
                <span>Pending</span>
                <span>-{formatCurrency(pendingTotal)}</span>
              </div>
            )}
            <div className="flex justify-between font-bold mt-2 pt-2 border-t">
              <span>Remaining</span>
              <span>{formatCurrency(remainingBeforeTip)}</span>
            </div>
          </div>

          {/* Step: Select Payment Method */}
          {step === 'method' && (
            <div className="space-y-3">
              <h3 className="font-medium mb-2">Select Payment Method</h3>

              {dualPricing.enabled && (
                <div className="text-sm text-gray-600 mb-3 p-2 bg-green-50 rounded">
                  <span className="text-green-700 font-medium">Cash: {formatCurrency(cashTotal)}</span>
                  <span className="mx-2">|</span>
                  <span>Card: {formatCurrency(cardTotal)}</span>
                </div>
              )}

              {paymentSettings.acceptCash && (
                <Button
                  variant="outline"
                  className="w-full h-16 text-lg justify-start gap-4"
                  onClick={() => handleSelectMethod('cash')}
                >
                  <span className="text-2xl">💵</span>
                  <div className="text-left">
                    <div>Cash</div>
                    <div className="text-sm text-green-600 font-normal">
                      {formatCurrency(cashTotal)}
                      {dualPricing.enabled && dualPricing.showSavingsMessage && (
                        <span className="ml-2">Save {formatCurrency(cardTotal - cashTotal)}</span>
                      )}
                    </div>
                  </div>
                </Button>
              )}

              {paymentSettings.acceptCredit && (
                <Button
                  variant="outline"
                  className="w-full h-16 text-lg justify-start gap-4"
                  onClick={() => handleSelectMethod('credit')}
                >
                  <span className="text-2xl">💳</span>
                  <div className="text-left">
                    <div>Credit Card</div>
                    <div className="text-sm text-gray-500 font-normal">
                      {formatCurrency(cardTotal)}
                    </div>
                  </div>
                </Button>
              )}

              {paymentSettings.acceptDebit && (
                <Button
                  variant="outline"
                  className="w-full h-16 text-lg justify-start gap-4"
                  onClick={() => handleSelectMethod('debit')}
                >
                  <span className="text-2xl">💳</span>
                  <div className="text-left">
                    <div>Debit Card</div>
                    <div className="text-sm text-gray-500 font-normal">
                      {formatCurrency(cardTotal)}
                    </div>
                  </div>
                </Button>
              )}

              {paymentSettings.acceptGiftCards && (
                <Button
                  variant="outline"
                  className="w-full h-16 text-lg justify-start gap-4"
                  onClick={() => handleSelectMethod('gift_card')}
                >
                  <span className="text-2xl">🎁</span>
                  <div className="text-left">
                    <div>Gift Card</div>
                    <div className="text-sm text-gray-500 font-normal">
                      Enter gift card number
                    </div>
                  </div>
                </Button>
              )}

              {paymentSettings.acceptHouseAccounts && (
                <Button
                  variant="outline"
                  className="w-full h-16 text-lg justify-start gap-4"
                  onClick={() => handleSelectMethod('house_account')}
                >
                  <span className="text-2xl">🏢</span>
                  <div className="text-left">
                    <div>House Account</div>
                    <div className="text-sm text-gray-500 font-normal">
                      Charge to account
                    </div>
                  </div>
                </Button>
              )}
            </div>
          )}

          {/* Step: Tip Selection */}
          {step === 'tip' && (
            <div className="space-y-3">
              <h3 className="font-medium mb-2">Add Tip</h3>
              <p className="text-sm text-gray-500 mb-3">
                Paying with {selectedMethod === 'cash' ? 'Cash' : 'Card'}: {formatCurrency(currentTotal)}
              </p>

              <div className="grid grid-cols-4 gap-2">
                {tipSettings.suggestedPercentages.map(percent => {
                  const tipForPercent = calculateTip(effectiveSubtotal, percent, tipSettings.calculateOn, effectiveOrderTotal)
                  return (
                    <Button
                      key={percent}
                      variant={tipAmount === tipForPercent ? 'primary' : 'outline'}
                      className="flex-col h-16"
                      onClick={() => handleSelectTip(percent)}
                    >
                      <span className="font-bold">{percent}%</span>
                      <span className="text-xs">{formatCurrency(tipForPercent)}</span>
                    </Button>
                  )
                })}
              </div>

              <div className="flex gap-2 mt-3">
                <Button
                  variant={tipAmount === 0 && !customTip ? 'primary' : 'outline'}
                  className="flex-1"
                  onClick={() => handleSelectTip(null)}
                >
                  No Tip
                </Button>
                <div className="flex-1 flex gap-2">
                  <div className="relative flex-1">
                    <span className="absolute left-3 top-2.5 text-gray-500">$</span>
                    <input
                      type="number"
                      value={customTip}
                      onChange={(e) => setCustomTip(e.target.value)}
                      onBlur={handleCustomTip}
                      className="w-full pl-7 pr-3 py-2 border rounded-lg"
                      placeholder="Custom"
                      step="0.01"
                      min="0"
                    />
                  </div>
                </div>
              </div>

              <div className="mt-4 p-3 bg-blue-50 rounded-lg">
                <div className="flex justify-between font-bold">
                  <span>Total with Tip</span>
                  <span>{formatCurrency(totalWithTip)}</span>
                </div>
              </div>

              <div className="flex gap-2 mt-4">
                <Button variant="outline" className="flex-1" onClick={() => setStep('method')}>
                  Back
                </Button>
                <Button variant="primary" className="flex-1" onClick={handleContinueFromTip}>
                  Continue
                </Button>
              </div>
            </div>
          )}

          {/* Step: Cash Payment */}
          {step === 'cash' && (
            <div className="space-y-3">
              <h3 className="font-medium mb-2">Cash Payment</h3>
              <div className="p-3 bg-green-50 rounded-lg mb-3">
                <div className="flex justify-between font-bold text-lg">
                  <span>Amount Due</span>
                  <span className="text-green-700">{formatCurrency(totalWithTip)}</span>
                </div>
              </div>

              <p className="text-sm text-gray-600 mb-2">Quick amounts:</p>
              <div className="grid grid-cols-4 gap-2">
                {quickAmounts.map(amount => (
                  <Button
                    key={amount}
                    variant="outline"
                    onClick={() => handleCashPayment(amount)}
                    disabled={isProcessing}
                  >
                    {formatCurrency(amount)}
                  </Button>
                ))}
              </div>

              <div className="mt-4">
                <label className="text-sm text-gray-600">Custom amount:</label>
                <div className="flex gap-2 mt-1">
                  <div className="relative flex-1">
                    <span className="absolute left-3 top-2.5 text-gray-500">$</span>
                    <input
                      type="number"
                      value={customCashAmount}
                      onChange={(e) => setCustomCashAmount(e.target.value)}
                      className="w-full pl-7 pr-3 py-2 border rounded-lg"
                      placeholder="0.00"
                      step="0.01"
                      min={totalWithTip}
                    />
                  </div>
                  <Button
                    variant="primary"
                    onClick={() => handleCashPayment(parseFloat(customCashAmount) || totalWithTip)}
                    disabled={isProcessing || !customCashAmount}
                  >
                    Accept
                  </Button>
                </div>
              </div>

              {customCashAmount && parseFloat(customCashAmount) > totalWithTip && (
                <div className="mt-3 p-3 bg-yellow-50 rounded-lg">
                  <div className="flex justify-between font-bold">
                    <span>Change Due</span>
                    <span>{formatCurrency(calculateChange(totalWithTip, parseFloat(customCashAmount)))}</span>
                  </div>
                </div>
              )}

              <Button
                variant="outline"
                className="w-full mt-4"
                onClick={() => setStep(tipSettings.enabled ? 'tip' : 'method')}
              >
                Back
              </Button>
            </div>
          )}

          {/* Step: Datacap Direct Card Payment */}
          {step === 'datacap_card' && orderId && !terminalId && (
            <div className="text-center py-8">
              <p className="text-red-500 font-bold mb-2">Terminal Not Configured</p>
              <p className="text-gray-500 text-sm mb-4">No terminal ID assigned. Card payments require a configured terminal.</p>
              <Button onClick={() => setStep('method')} variant="outline">Back</Button>
            </div>
          )}
          {step === 'datacap_card' && orderId && terminalId && (
            <DatacapPaymentProcessor
              orderId={orderId}
              amount={currentTotal}
              subtotal={effectiveSubtotal}
              tipSettings={tipSettings}
              terminalId={terminalId}
              employeeId={employeeId || 'unknown'}
              onSuccess={handleDatacapSuccess}
              onCancel={() => setStep('method')}
            />
          )}

          {/* Step: Gift Card Payment */}
          {step === 'gift_card' && (
            <div className="space-y-3">
              <h3 className="font-medium mb-2">Gift Card Payment</h3>

              <div className="p-3 bg-purple-50 rounded-lg mb-3">
                <div className="flex justify-between font-bold text-lg">
                  <span>Amount Due</span>
                  <span>{formatCurrency(totalWithTip)}</span>
                </div>
              </div>

              <div>
                <label className="text-sm text-gray-600 block mb-1">Gift Card Number</label>
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={giftCardNumber}
                    onChange={(e) => setGiftCardNumber(e.target.value.toUpperCase())}
                    className="flex-1 px-3 py-2 border rounded-lg uppercase"
                    placeholder="GC-XXXX-XXXX-XXXX"
                  />
                  <Button
                    variant="outline"
                    onClick={lookupGiftCard}
                    disabled={giftCardLoading || !giftCardNumber.trim()}
                  >
                    {giftCardLoading ? 'Looking...' : 'Lookup'}
                  </Button>
                </div>
              </div>

              {giftCardError && (
                <div className="p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
                  {giftCardError}
                </div>
              )}

              {giftCardInfo && (
                <div className="p-4 bg-green-50 border border-green-200 rounded-lg">
                  <div className="text-sm text-gray-600 mb-1">Card: {giftCardInfo.cardNumber}</div>
                  <div className="flex justify-between items-center">
                    <span className="font-medium">Available Balance:</span>
                    <span className="text-xl font-bold text-green-600">
                      {formatCurrency(giftCardInfo.currentBalance)}
                    </span>
                  </div>
                  {giftCardInfo.currentBalance < totalWithTip && (
                    <div className="mt-2 text-sm text-amber-600">
                      Partial payment of {formatCurrency(giftCardInfo.currentBalance)} will be applied.
                      Remaining: {formatCurrency(totalWithTip - giftCardInfo.currentBalance)}
                    </div>
                  )}
                </div>
              )}

              <div className="flex gap-2 mt-4">
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={() => setStep('method')}
                  disabled={isProcessing}
                >
                  Back
                </Button>
                <Button
                  variant="primary"
                  className="flex-1"
                  onClick={handleGiftCardPayment}
                  disabled={isProcessing || !giftCardInfo || giftCardInfo.currentBalance === 0}
                >
                  {isProcessing ? 'Processing...' : giftCardInfo && giftCardInfo.currentBalance >= totalWithTip
                    ? 'Pay Full Amount'
                    : giftCardInfo
                      ? `Pay ${formatCurrency(Math.min(giftCardInfo.currentBalance, totalWithTip))}`
                      : 'Apply Gift Card'}
                </Button>
              </div>
            </div>
          )}

          {/* Step: House Account Payment */}
          {step === 'house_account' && (
            <div className="space-y-3">
              <h3 className="font-medium mb-2">House Account</h3>

              <div className="p-3 bg-blue-50 rounded-lg mb-3">
                <div className="flex justify-between font-bold text-lg">
                  <span>Amount to Charge</span>
                  <span>{formatCurrency(totalWithTip)}</span>
                </div>
              </div>

              <div>
                <label className="text-sm text-gray-600 block mb-1">Search Account</label>
                <input
                  type="text"
                  value={houseAccountSearch}
                  onChange={(e) => setHouseAccountSearch(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                  placeholder="Search by name..."
                />
              </div>

              {houseAccountsLoading ? (
                <div className="text-center py-4 text-gray-500">Loading accounts...</div>
              ) : (
                <div className="max-h-48 overflow-y-auto border rounded-lg divide-y">
                  {houseAccounts
                    .filter(acc =>
                      !houseAccountSearch ||
                      acc.name.toLowerCase().includes(houseAccountSearch.toLowerCase())
                    )
                    .map(account => {
                      const availableCredit = account.creditLimit > 0
                        ? account.creditLimit - account.currentBalance
                        : Infinity
                      const canCharge = availableCredit >= totalWithTip

                      return (
                        <button
                          key={account.id}
                          className={`w-full p-3 text-left hover:bg-gray-50 ${
                            selectedHouseAccount?.id === account.id ? 'bg-blue-50' : ''
                          } ${!canCharge ? 'opacity-50' : ''}`}
                          onClick={() => canCharge && setSelectedHouseAccount(account)}
                          disabled={!canCharge}
                        >
                          <div className="font-medium">{account.name}</div>
                          <div className="text-sm text-gray-500 flex justify-between">
                            <span>Balance: {formatCurrency(account.currentBalance)}</span>
                            <span>
                              {account.creditLimit > 0
                                ? `Limit: ${formatCurrency(account.creditLimit)}`
                                : 'No limit'}
                            </span>
                          </div>
                          {!canCharge && (
                            <div className="text-xs text-red-500 mt-1">
                              Insufficient credit available
                            </div>
                          )}
                        </button>
                      )
                    })}
                  {houseAccounts.length === 0 && (
                    <div className="p-4 text-center text-gray-500">
                      No house accounts available
                    </div>
                  )}
                </div>
              )}

              {selectedHouseAccount && (
                <div className="p-3 bg-green-50 border border-green-200 rounded-lg">
                  <div className="font-medium">{selectedHouseAccount.name}</div>
                  <div className="text-sm text-gray-600">
                    Current balance: {formatCurrency(selectedHouseAccount.currentBalance)}
                    {selectedHouseAccount.creditLimit > 0 && (
                      <span className="ml-2">
                        (Available: {formatCurrency(selectedHouseAccount.creditLimit - selectedHouseAccount.currentBalance)})
                      </span>
                    )}
                  </div>
                </div>
              )}

              <div className="flex gap-2 mt-4">
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={() => setStep('method')}
                  disabled={isProcessing}
                >
                  Back
                </Button>
                <Button
                  variant="primary"
                  className="flex-1"
                  onClick={handleHouseAccountPayment}
                  disabled={isProcessing || !selectedHouseAccount}
                >
                  {isProcessing ? 'Processing...' : 'Charge to Account'}
                </Button>
              </div>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t bg-gray-50">
          <Button variant="outline" className="w-full" onClick={onClose} disabled={isProcessing}>
            Cancel
          </Button>
        </div>
      </div>
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/QuickPayButton.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { formatCurrency } from '@/lib/utils'
import { toast } from '@/stores/toast-store'
import { TipPromptSelector } from './TipPromptSelector'
import type { PaymentSettings } from '@/lib/settings'

interface QuickPayButtonProps {
  orderId: string
  orderTotal: number
  subtotal: number
  readerId: string
  employeeId: string
  locationId: string
  paymentSettings: PaymentSettings
  onPaymentComplete: (result: QuickPayResult) => void
  disabled?: boolean
  className?: string
}

interface QuickPayResult {
  success: boolean
  authCode?: string
  cardType?: string
  cardLast4?: string
  tipAmount: number
  totalAmount: number
  recordNo?: string
}

type QuickPayStep = 'idle' | 'tip' | 'processing' | 'done' | 'error'

/**
 * Quick Pay — fastest single-transaction flow.
 *
 * 1. Bartender taps Quick Pay button
 * 2. Tip prompt shows ($ or % based on threshold)
 * 3. Customer taps/dips card
 * 4. EMVSale processes with tip included
 * 5. Done — no tab created
 */
export function QuickPayButton({
  orderId,
  orderTotal,
  subtotal,
  readerId,
  employeeId,
  locationId,
  paymentSettings,
  onPaymentComplete,
  disabled = false,
  className = '',
}: QuickPayButtonProps) {
  const [step, setStep] = useState<QuickPayStep>('idle')
  const [tipAmount, setTipAmount] = useState(0)
  const [errorMessage, setErrorMessage] = useState('')

  const handleTipSelected = useCallback(async (selectedTip: number) => {
    setTipAmount(selectedTip)
    setStep('processing')

    try {
      const response = await fetch('/api/datacap/sale', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          readerId,
          orderId,
          employeeId,
          invoiceNo: orderId,
          amount: subtotal,
          tipAmount: selectedTip,
          tipMode: 'included',
        }),
      })

      const result = await response.json()

      if (!response.ok) {
        throw new Error(result.error || 'Payment failed')
      }

      const data = result.data

      if (data.approved) {
        setStep('done')
        toast.success(`Payment approved — ${formatCurrency(subtotal + selectedTip)}`)

        // Now complete the order payment via the pay API
        await fetch(`/api/orders/${orderId}/pay`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            locationId,
            employeeId,
            payments: [{
              method: 'credit',
              amount: subtotal,
              tipAmount: selectedTip,
              totalAmount: subtotal + selectedTip,
              cardBrand: data.cardType,
              cardLast4: data.cardLast4,
              authCode: data.authCode,
              datacapRefNumber: data.refNo,
              datacapRecordNo: data.recordNo,
              datacapSequenceNo: data.sequenceNo,
              entryMethod: data.entryMethod,
              amountAuthorized: parseFloat(data.amountAuthorized) || (subtotal + selectedTip),
            }],
          }),
        })

        onPaymentComplete({
          success: true,
          authCode: data.authCode,
          cardType: data.cardType,
          cardLast4: data.cardLast4,
          tipAmount: selectedTip,
          totalAmount: subtotal + selectedTip,
          recordNo: data.recordNo,
        })
      } else {
        const errMsg = data.error?.message || 'Card declined'
        setStep('error')
        setErrorMessage(errMsg)
        toast.error(errMsg)
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Payment failed'
      setStep('error')
      setErrorMessage(msg)
      toast.error(msg)
    }
  }, [locationId, readerId, orderId, employeeId, subtotal, onPaymentComplete])

  const handleReset = () => {
    setStep('idle')
    setTipAmount(0)
    setErrorMessage('')
  }

  // Idle state — just the button
  if (step === 'idle') {
    return (
      <Button
        variant="primary"
        className={`font-semibold ${className}`}
        onClick={() => setStep('tip')}
        disabled={disabled || !paymentSettings.quickPayEnabled}
      >
        Quick Pay {formatCurrency(orderTotal)}
      </Button>
    )
  }

  // Tip selection step
  if (step === 'tip') {
    return (
      <div className="bg-white rounded-lg shadow-lg border p-2">
        <TipPromptSelector
          orderAmount={subtotal}
          tipDollarAmountThreshold={paymentSettings.tipDollarAmountThreshold}
          tipDollarSuggestions={paymentSettings.tipDollarSuggestions}
          tipPercentSuggestions={paymentSettings.tipPercentSuggestions}
          requireCustomForZeroTip={paymentSettings.requireCustomForZeroTip}
          onSelectTip={handleTipSelected}
          onCancel={handleReset}
        />
      </div>
    )
  }

  // Processing
  if (step === 'processing') {
    return (
      <div className="bg-white rounded-lg shadow-lg border p-6 text-center">
        <div className="w-12 h-12 mx-auto mb-3 rounded-full bg-blue-100 flex items-center justify-center">
          <svg className="w-6 h-6 text-blue-600 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
          </svg>
        </div>
        <p className="font-semibold">Processing Payment...</p>
        <p className="text-sm text-gray-500 mt-1">
          {formatCurrency(subtotal + tipAmount)}
          {tipAmount > 0 && (
            <span className="text-gray-400"> (includes {formatCurrency(tipAmount)} tip)</span>
          )}
        </p>
      </div>
    )
  }

  // Done
  if (step === 'done') {
    return (
      <div className="bg-white rounded-lg shadow-lg border p-6 text-center">
        <div className="w-12 h-12 mx-auto mb-3 rounded-full bg-green-100 flex items-center justify-center">
          <svg className="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M5 13l4 4L19 7" />
          </svg>
        </div>
        <p className="font-semibold text-green-700">Payment Complete</p>
        <p className="text-lg font-bold mt-1">{formatCurrency(subtotal + tipAmount)}</p>
      </div>
    )
  }

  // Error
  return (
    <div className="bg-white rounded-lg shadow-lg border p-6 text-center">
      <div className="w-12 h-12 mx-auto mb-3 rounded-full bg-red-100 flex items-center justify-center">
        <svg className="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </div>
      <p className="font-semibold text-red-700">Payment Failed</p>
      <p className="text-sm text-gray-500 mt-1">{errorMessage}</p>
      <div className="flex gap-2 justify-center mt-4">
        <Button variant="ghost" onClick={handleReset}>Cancel</Button>
        <Button variant="primary" onClick={() => setStep('tip')}>Try Again</Button>
      </div>
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/ReaderStatusIndicator.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import type { PaymentReader, DatacapProcessingStatus } from '@/hooks/useDatacap'

interface ReaderStatusIndicatorProps {
  reader: PaymentReader | null
  isOnline: boolean
  processingStatus: DatacapProcessingStatus
  onSwapClick: () => void
  canSwap: boolean
}

export function ReaderStatusIndicator({
  reader,
  isOnline,
  processingStatus,
  onSwapClick,
  canSwap,
}: ReaderStatusIndicatorProps) {
  if (!reader) {
    return (
      <div className="flex items-center justify-between p-4 bg-red-900/20 rounded-2xl border border-red-800">
        <div className="flex items-center gap-3">
          <div className="w-2 h-2 rounded-full bg-red-500" />
          <div>
            <p className="text-xs font-bold text-red-400 uppercase tracking-tight">
              No Reader Configured
            </p>
            <p className="text-[10px] text-red-500">
              Go to Settings → Hardware → Terminals to bind a reader
            </p>
          </div>
        </div>
      </div>
    )
  }

  const isActive = processingStatus === 'waiting_card' || processingStatus === 'authorizing'

  return (
    <div className="flex items-center justify-between p-4 bg-slate-900/50 rounded-2xl border border-slate-800">
      <div className="flex items-center gap-3">
        {/* Status Indicator */}
        <div
          className={`w-2 h-2 rounded-full ${
            isActive
              ? 'bg-amber-500 animate-ping'
              : isOnline
              ? 'bg-emerald-500'
              : 'bg-red-500'
          }`}
        />
        <div>
          <p className="text-xs font-bold text-white uppercase tracking-tight">
            {reader.name}
          </p>
          <p className="text-[10px] font-mono text-slate-500">
            {reader.ipAddress}:{reader.port}
          </p>
        </div>
      </div>

      {/* Status Badge */}
      <div className="flex items-center gap-3">
        {!isOnline && (
          <span className="px-2 py-1 text-[10px] font-bold uppercase bg-red-500/20 text-red-400 rounded">
            Offline
          </span>
        )}
        {isOnline && !isActive && (
          <span className="px-2 py-1 text-[10px] font-bold uppercase bg-emerald-500/20 text-emerald-400 rounded">
            Ready
          </span>
        )}
        {isActive && (
          <span className="px-2 py-1 text-[10px] font-bold uppercase bg-amber-500/20 text-amber-400 rounded animate-pulse">
            Active
          </span>
        )}

        {/* Swap Button */}
        {canSwap && (
          <button
            onClick={onSwapClick}
            className="text-[10px] font-black text-cyan-500 uppercase tracking-widest hover:text-cyan-400 transition-colors"
          >
            Swap
          </button>
        )}
      </div>
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/SignatureCapture.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useRef, useState, useCallback, useEffect } from 'react'
import { Button } from '@/components/ui/button'

interface SignatureCaptureProps {
  onCapture: (signatureData: string) => void  // Base64 PNG
  onSkip?: () => void
  width?: number
  height?: number
  lineColor?: string
  lineWidth?: number
}

/**
 * POS-screen signature capture canvas.
 * Supports touch and mouse drawing. Returns base64 PNG data URL.
 * Used for chargeback defense when reader doesn't support GetSignature.
 */
export function SignatureCapture({
  onCapture,
  onSkip,
  width = 400,
  height = 200,
  lineColor = '#000000',
  lineWidth = 2,
}: SignatureCaptureProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [isDrawing, setIsDrawing] = useState(false)
  const [hasDrawn, setHasDrawn] = useState(false)
  const lastPoint = useRef<{ x: number; y: number } | null>(null)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Set up canvas with white background
    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, width, height)

    // Draw signature line
    ctx.strokeStyle = '#e5e7eb'
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(20, height - 40)
    ctx.lineTo(width - 20, height - 40)
    ctx.stroke()

    // Draw "X" mark
    ctx.fillStyle = '#9ca3af'
    ctx.font = '14px sans-serif'
    ctx.fillText('X', 20, height - 45)
  }, [width, height])

  const getPoint = useCallback((e: React.TouchEvent | React.MouseEvent) => {
    const canvas = canvasRef.current
    if (!canvas) return null

    const rect = canvas.getBoundingClientRect()
    const scaleX = canvas.width / rect.width
    const scaleY = canvas.height / rect.height

    if ('touches' in e) {
      const touch = e.touches[0]
      return {
        x: (touch.clientX - rect.left) * scaleX,
        y: (touch.clientY - rect.top) * scaleY,
      }
    }

    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY,
    }
  }, [])

  const startDrawing = useCallback((e: React.TouchEvent | React.MouseEvent) => {
    e.preventDefault()
    const point = getPoint(e)
    if (!point) return

    setIsDrawing(true)
    setHasDrawn(true)
    lastPoint.current = point
  }, [getPoint])

  const draw = useCallback((e: React.TouchEvent | React.MouseEvent) => {
    e.preventDefault()
    if (!isDrawing) return

    const canvas = canvasRef.current
    const ctx = canvas?.getContext('2d')
    if (!ctx || !lastPoint.current) return

    const point = getPoint(e)
    if (!point) return

    ctx.strokeStyle = lineColor
    ctx.lineWidth = lineWidth
    ctx.lineCap = 'round'
    ctx.lineJoin = 'round'

    ctx.beginPath()
    ctx.moveTo(lastPoint.current.x, lastPoint.current.y)
    ctx.lineTo(point.x, point.y)
    ctx.stroke()

    lastPoint.current = point
  }, [isDrawing, getPoint, lineColor, lineWidth])

  const stopDrawing = useCallback(() => {
    setIsDrawing(false)
    lastPoint.current = null
  }, [])

  const handleClear = () => {
    const canvas = canvasRef.current
    const ctx = canvas?.getContext('2d')
    if (!ctx) return

    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, width, height)

    // Redraw signature line
    ctx.strokeStyle = '#e5e7eb'
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(20, height - 40)
    ctx.lineTo(width - 20, height - 40)
    ctx.stroke()

    ctx.fillStyle = '#9ca3af'
    ctx.font = '14px sans-serif'
    ctx.fillText('X', 20, height - 45)

    setHasDrawn(false)
  }

  const handleAccept = () => {
    const canvas = canvasRef.current
    if (!canvas) return

    const dataUrl = canvas.toDataURL('image/png')
    onCapture(dataUrl)
  }

  return (
    <div className="flex flex-col items-center gap-3">
      <p className="text-sm font-medium text-gray-700">Please sign below</p>

      <div className="border-2 border-gray-300 rounded-lg overflow-hidden touch-none">
        <canvas
          ref={canvasRef}
          width={width}
          height={height}
          style={{ width: `${width}px`, height: `${height}px` }}
          onMouseDown={startDrawing}
          onMouseMove={draw}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
          onTouchStart={startDrawing}
          onTouchMove={draw}
          onTouchEnd={stopDrawing}
        />
      </div>

      <div className="flex gap-2">
        {onSkip && (
          <Button variant="ghost" onClick={onSkip}>
            Skip
          </Button>
        )}
        <Button variant="ghost" onClick={handleClear} disabled={!hasDrawn}>
          Clear
        </Button>
        <Button variant="primary" onClick={handleAccept} disabled={!hasDrawn}>
          Accept Signature
        </Button>
      </div>
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/SplitCheckModal.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { formatCurrency } from '@/lib/utils'

interface OrderItem {
  id: string
  name: string
  quantity: number
  price: number
  itemTotal: number
  seatNumber?: number | null
  sourceTableId?: string | null  // For virtual combined tables - T-S notation
  sourceTableName?: string | null  // Display name for the source table
  modifiers?: { name: string; price: number }[]
}

interface SplitCheckModalProps {
  isOpen: boolean
  onClose: () => void
  orderId: string
  orderNumber: number
  orderTotal: number
  paidAmount: number
  items: OrderItem[]
  onSplitComplete: (result: SplitResult) => void
  onNavigateToSplit?: (splitOrderId: string) => void
}

interface SplitResult {
  type: 'even' | 'by_item' | 'by_seat' | 'by_table' | 'custom_amount' | 'split_item'
  originalOrderId: string
  // For even split
  splits?: { splitNumber: number; amount: number }[]
  // For by_item split
  newOrderId?: string
  newOrderNumber?: number
  // For by_seat split
  seatSplits?: { seatNumber: number; total: number; splitOrderId: string }[]
  // For by_table split (virtual combined tables)
  tableSplits?: { tableId: string; tableName: string; total: number; splitOrderId: string }[]
  // For custom amount
  splitAmount?: number
  // For split item
  itemSplits?: { itemId: string; itemName: string; splitNumber: number; amount: number }[]
}

type SplitMode = 'select' | 'even' | 'by_seat' | 'by_table' | 'by_item' | 'custom' | 'split_item' | 'navigate_splits'

interface SplitOrderInfo {
  id: string
  orderNumber: number
  splitIndex: number | null
  displayNumber: string
  total: number
  paidAmount: number
  isPaid: boolean
  itemCount: number
  isParent: boolean
}

export function SplitCheckModal({
  isOpen,
  onClose,
  orderId,
  orderNumber,
  orderTotal,
  paidAmount,
  items,
  onSplitComplete,
  onNavigateToSplit,
}: SplitCheckModalProps) {
  const [mode, setMode] = useState<SplitMode>('select')
  const [isProcessing, setIsProcessing] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Split navigation state
  const [existingSplits, setExistingSplits] = useState<SplitOrderInfo[]>([])
  const [currentSplitId, setCurrentSplitId] = useState<string | null>(null)

  // Even split state
  const [numWays, setNumWays] = useState(2)
  const [evenSplitResult, setEvenSplitResult] = useState<{ splits: { splitNumber: number; amount: number }[] } | null>(null)

  // By item split state
  const [selectedItemIds, setSelectedItemIds] = useState<string[]>([])

  // Custom amount state
  const [customAmount, setCustomAmount] = useState('')

  // Split item state
  const [selectedItemForSplit, setSelectedItemForSplit] = useState<OrderItem | null>(null)
  const [itemSplitWays, setItemSplitWays] = useState(2)
  const [itemSplitResult, setItemSplitResult] = useState<{ itemId: string; itemName: string; splits: { splitNumber: number; amount: number }[] } | null>(null)

  // Split by seat state
  const [seatSplitResult, setSeatSplitResult] = useState<{
    splits: { seatNumber: number; total: number; splitOrderId: string; displayNumber: string; itemCount: number }[]
    hasUnassignedItems: boolean
    unassignedTotal: number
  } | null>(null)

  // Split by table state (for virtual combined tables)
  const [tableSplitResult, setTableSplitResult] = useState<{
    splits: { tableId: string; tableName: string; total: number; splitOrderId: string; displayNumber: string; itemCount: number }[]
    hasUnassignedItems: boolean
    unassignedTotal: number
  } | null>(null)

  const remainingBalance = orderTotal - paidAmount

  // Check if items have seat assignments
  const seatsWithItems = items.reduce((acc, item) => {
    if (item.seatNumber !== null && item.seatNumber !== undefined) {
      acc.add(item.seatNumber)
    }
    return acc
  }, new Set<number>())
  const canSplitBySeat = seatsWithItems.size >= 2

  // Check if items have source table assignments (from virtual combined tables)
  const tablesWithItems = items.reduce((acc, item) => {
    if (item.sourceTableId) {
      acc.set(item.sourceTableId, item.sourceTableName || `Table ${item.sourceTableId.slice(0, 4)}`)
    }
    return acc
  }, new Map<string, string>())
  const canSplitByTable = tablesWithItems.size >= 2

  // Fetch existing splits
  const fetchExistingSplits = async () => {
    try {
      const response = await fetch(`/api/orders/${orderId}/split`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'get_splits' }),
      })
      if (response.ok) {
        const data = await response.json()
        if (data.splits && data.splits.length > 1) {
          setExistingSplits(data.splits)
          setCurrentSplitId(data.currentSplitId)
          setMode('navigate_splits')
          return true
        }
      }
    } catch {
      // Ignore errors, just use normal split flow
    }
    return false
  }

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setMode('select')
      setNumWays(2)
      setEvenSplitResult(null)
      setSelectedItemIds([])
      setCustomAmount('')
      setSelectedItemForSplit(null)
      setItemSplitWays(2)
      setItemSplitResult(null)
      setSeatSplitResult(null)
      setTableSplitResult(null)
      setError(null)
      setExistingSplits([])
      setCurrentSplitId(null)
      // Check if order already has splits
      fetchExistingSplits()
    }
  }, [isOpen, orderId])

  if (!isOpen) return null

  const handleEvenSplit = async () => {
    if (numWays < 2) return

    setIsProcessing(true)
    setError(null)

    try {
      const response = await fetch(`/api/orders/${orderId}/split`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'even',
          numWays,
        }),
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Failed to calculate split')
      }

      const result = await response.json()
      setEvenSplitResult(result)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to calculate split')
    } finally {
      setIsProcessing(false)
    }
  }

  const handleConfirmEvenSplit = () => {
    if (!evenSplitResult) return
    onSplitComplete({
      type: 'even',
      originalOrderId: orderId,
      splits: evenSplitResult.splits,
    })
  }

  const handleByItemSplit = async () => {
    if (selectedItemIds.length === 0) {
      setError('Please select at least one item')
      return
    }

    setIsProcessing(true)
    setError(null)

    try {
      const response = await fetch(`/api/orders/${orderId}/split`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'by_item',
          itemIds: selectedItemIds,
        }),
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Failed to split order')
      }

      const result = await response.json()
      onSplitComplete({
        type: 'by_item',
        originalOrderId: orderId,
        newOrderId: result.newOrder.id,
        newOrderNumber: result.newOrder.orderNumber,
      })
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to split order')
    } finally {
      setIsProcessing(false)
    }
  }

  const handleCustomAmount = async () => {
    const amount = parseFloat(customAmount)
    if (!amount || amount <= 0 || amount > remainingBalance) {
      setError(`Please enter a valid amount between $0.01 and ${formatCurrency(remainingBalance)}`)
      return
    }

    onSplitComplete({
      type: 'custom_amount',
      originalOrderId: orderId,
      splitAmount: amount,
    })
  }

  const handleSeatSplit = async () => {
    setIsProcessing(true)
    setError(null)

    try {
      const response = await fetch(`/api/orders/${orderId}/split`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'by_seat' }),
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Failed to split by seat')
      }

      const result = await response.json()
      setSeatSplitResult({
        splits: result.splits,
        hasUnassignedItems: result.parentOrder.hasUnassignedItems,
        unassignedTotal: result.parentOrder.total,
      })
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to split by seat')
    } finally {
      setIsProcessing(false)
    }
  }

  const handleConfirmSeatSplit = () => {
    if (!seatSplitResult) return
    onSplitComplete({
      type: 'by_seat',
      originalOrderId: orderId,
      seatSplits: seatSplitResult.splits.map(s => ({
        seatNumber: s.seatNumber,
        total: s.total,
        splitOrderId: s.splitOrderId,
      })),
    })
  }

  const handleTableSplit = async () => {
    setIsProcessing(true)
    setError(null)

    try {
      const response = await fetch(`/api/orders/${orderId}/split`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'by_table' }),
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Failed to split by table')
      }

      const result = await response.json()
      setTableSplitResult({
        splits: result.splits,
        hasUnassignedItems: result.parentOrder.hasUnassignedItems,
        unassignedTotal: result.parentOrder.total,
      })
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to split by table')
    } finally {
      setIsProcessing(false)
    }
  }

  const handleConfirmTableSplit = () => {
    if (!tableSplitResult) return
    onSplitComplete({
      type: 'by_table',
      originalOrderId: orderId,
      tableSplits: tableSplitResult.splits.map(s => ({
        tableId: s.tableId,
        tableName: s.tableName,
        total: s.total,
        splitOrderId: s.splitOrderId,
      })),
    })
  }

  const toggleItemSelection = (itemId: string) => {
    setSelectedItemIds(prev =>
      prev.includes(itemId)
        ? prev.filter(id => id !== itemId)
        : [...prev, itemId]
    )
  }

  const calculateSelectedTotal = () => {
    return items
      .filter(item => selectedItemIds.includes(item.id))
      .reduce((sum, item) => sum + item.itemTotal, 0)
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-hidden flex flex-col">
        {/* Header */}
        <div className="p-4 border-b bg-gray-50 flex items-center justify-between">
          <div>
            <h2 className="text-xl font-bold">Split Check</h2>
            <p className="text-sm text-gray-500">Order #{orderNumber}</p>
          </div>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4">
          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
              {error}
            </div>
          )}

          {/* Order Summary */}
          <div className="mb-4 p-3 bg-gray-50 rounded-lg">
            <div className="flex justify-between text-sm">
              <span>Order Total</span>
              <span className="font-medium">{formatCurrency(orderTotal)}</span>
            </div>
            {paidAmount > 0 && (
              <div className="flex justify-between text-sm text-green-600">
                <span>Already Paid</span>
                <span>-{formatCurrency(paidAmount)}</span>
              </div>
            )}
            <div className="flex justify-between font-bold mt-2 pt-2 border-t">
              <span>Remaining</span>
              <span>{formatCurrency(remainingBalance)}</span>
            </div>
          </div>

          {/* Mode Selection */}
          {mode === 'select' && (
            <div className="space-y-3">
              <h3 className="font-medium mb-2">How would you like to split?</h3>

              <Button
                variant="outline"
                className="w-full h-16 text-lg justify-start gap-4"
                onClick={() => setMode('even')}
              >
                <span className="text-2xl">➗</span>
                <div className="text-left">
                  <div>Split Evenly</div>
                  <div className="text-sm text-gray-500 font-normal">
                    Divide the check equally among guests
                  </div>
                </div>
              </Button>

              <Button
                variant="outline"
                className={`w-full h-16 text-lg justify-start gap-4 ${!canSplitBySeat ? 'opacity-50' : ''}`}
                onClick={() => setMode('by_seat')}
                disabled={!canSplitBySeat}
              >
                <span className="text-2xl">🪑</span>
                <div className="text-left">
                  <div>Split by Seat</div>
                  <div className="text-sm text-gray-500 font-normal">
                    {canSplitBySeat
                      ? `Each seat gets its own check (${seatsWithItems.size} seats)`
                      : 'Requires items assigned to seats'}
                  </div>
                </div>
              </Button>

              <Button
                variant="outline"
                className={`w-full h-16 text-lg justify-start gap-4 ${!canSplitByTable ? 'opacity-50' : ''}`}
                onClick={() => setMode('by_table')}
                disabled={!canSplitByTable}
              >
                <span className="text-2xl">🔗</span>
                <div className="text-left">
                  <div>Split by Table</div>
                  <div className="text-sm text-gray-500 font-normal">
                    {canSplitByTable
                      ? `Each table gets its own check (${tablesWithItems.size} tables)`
                      : 'Only for combined table groups'}
                  </div>
                </div>
              </Button>

              <Button
                variant="outline"
                className="w-full h-16 text-lg justify-start gap-4"
                onClick={() => setMode('by_item')}
              >
                <span className="text-2xl">📋</span>
                <div className="text-left">
                  <div>Split by Item</div>
                  <div className="text-sm text-gray-500 font-normal">
                    Move specific items to a new check
                  </div>
                </div>
              </Button>

              <Button
                variant="outline"
                className="w-full h-16 text-lg justify-start gap-4"
                onClick={() => setMode('split_item')}
              >
                <span className="text-2xl">🍕</span>
                <div className="text-left">
                  <div>Split Single Item</div>
                  <div className="text-sm text-gray-500 font-normal">
                    Divide one item&apos;s cost among guests
                  </div>
                </div>
              </Button>

              <Button
                variant="outline"
                className="w-full h-16 text-lg justify-start gap-4"
                onClick={() => setMode('custom')}
              >
                <span className="text-2xl">💰</span>
                <div className="text-left">
                  <div>Pay Custom Amount</div>
                  <div className="text-sm text-gray-500 font-normal">
                    Pay a specific dollar amount
                  </div>
                </div>
              </Button>
            </div>
          )}

          {/* Navigate Splits Mode - Shows when order already has splits */}
          {mode === 'navigate_splits' && (
            <div className="space-y-4">
              <h3 className="font-medium">Order Has Been Split</h3>
              <p className="text-sm text-gray-500">
                This order has {existingSplits.length} split checks. Select one to view or pay.
              </p>

              <div className="space-y-2 max-h-64 overflow-y-auto">
                {existingSplits.map((split) => (
                  <Card
                    key={split.id}
                    className={`p-3 cursor-pointer transition-colors ${
                      split.id === currentSplitId
                        ? 'bg-blue-50 border-blue-500'
                        : split.isPaid
                        ? 'bg-green-50 border-green-300'
                        : 'hover:bg-gray-50'
                    }`}
                    onClick={() => {
                      if (onNavigateToSplit && split.id !== currentSplitId) {
                        onNavigateToSplit(split.id)
                        onClose()
                      }
                    }}
                  >
                    <div className="flex justify-between items-center">
                      <div>
                        <div className="font-medium flex items-center gap-2">
                          <span>Check #{split.displayNumber}</span>
                          {split.isParent && (
                            <span className="text-xs bg-gray-200 px-2 py-0.5 rounded">Original</span>
                          )}
                          {split.id === currentSplitId && (
                            <span className="text-xs bg-blue-200 text-blue-700 px-2 py-0.5 rounded">Current</span>
                          )}
                          {split.isPaid && (
                            <span className="text-xs bg-green-200 text-green-700 px-2 py-0.5 rounded">Paid</span>
                          )}
                        </div>
                        <div className="text-sm text-gray-500">
                          {split.itemCount > 0 ? `${split.itemCount} items` : 'Split portion'}
                        </div>
                      </div>
                      <div className="text-right">
                        <div className="text-lg font-bold">{formatCurrency(split.total)}</div>
                        {split.paidAmount > 0 && !split.isPaid && (
                          <div className="text-sm text-green-600">
                            {formatCurrency(split.paidAmount)} paid
                          </div>
                        )}
                      </div>
                    </div>
                  </Card>
                ))}
              </div>

              <div className="p-3 bg-gray-50 rounded-lg">
                <div className="flex justify-between text-sm">
                  <span>Total Paid:</span>
                  <span className="font-medium text-green-600">
                    {formatCurrency(existingSplits.reduce((sum, s) => sum + s.paidAmount, 0))}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Total Remaining:</span>
                  <span className="font-medium">
                    {formatCurrency(existingSplits.reduce((sum, s) => sum + (s.total - s.paidAmount), 0))}
                  </span>
                </div>
              </div>

              <div className="flex gap-2 mt-4">
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={onClose}
                >
                  Close
                </Button>
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={() => {
                    setExistingSplits([])
                    setMode('select')
                  }}
                >
                  Split Further
                </Button>
              </div>
            </div>
          )}

          {/* Even Split Mode */}
          {mode === 'even' && (
            <div className="space-y-4">
              <h3 className="font-medium">Split Evenly</h3>

              {!evenSplitResult ? (
                <>
                  <div>
                    <label className="text-sm text-gray-600 block mb-2">
                      How many ways to split?
                    </label>
                    <div className="flex items-center gap-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setNumWays(Math.max(2, numWays - 1))}
                        disabled={numWays <= 2}
                      >
                        -
                      </Button>
                      <span className="text-2xl font-bold w-12 text-center">{numWays}</span>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setNumWays(numWays + 1)}
                      >
                        +
                      </Button>
                    </div>
                  </div>

                  <div className="p-3 bg-blue-50 rounded-lg">
                    <div className="flex justify-between text-sm">
                      <span>Each person pays approximately:</span>
                      <span className="font-bold">
                        {formatCurrency(remainingBalance / numWays)}
                      </span>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => setMode('select')}
                    >
                      Back
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={handleEvenSplit}
                      disabled={isProcessing}
                    >
                      {isProcessing ? 'Calculating...' : 'Calculate Split'}
                    </Button>
                  </div>
                </>
              ) : (
                <>
                  <div className="space-y-2">
                    {evenSplitResult.splits.map((split, idx) => (
                      <Card key={idx} className="p-3">
                        <div className="flex justify-between items-center">
                          <span className="font-medium">Guest {split.splitNumber}</span>
                          <span className="text-lg font-bold">{formatCurrency(split.amount)}</span>
                        </div>
                      </Card>
                    ))}
                  </div>

                  <p className="text-sm text-gray-500 text-center">
                    Click &quot;Confirm&quot; to use these amounts for separate payments
                  </p>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => setEvenSplitResult(null)}
                    >
                      Recalculate
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={handleConfirmEvenSplit}
                    >
                      Confirm Split
                    </Button>
                  </div>
                </>
              )}
            </div>
          )}

          {/* By Seat Mode */}
          {mode === 'by_seat' && (
            <div className="space-y-4">
              <h3 className="font-medium">Split by Seat</h3>

              {!seatSplitResult ? (
                <>
                  <p className="text-sm text-gray-500">
                    Each seat will get its own check with their items.
                  </p>

                  {/* Preview items by seat */}
                  <div className="space-y-3 max-h-64 overflow-y-auto">
                    {Array.from(seatsWithItems).sort((a, b) => a - b).map(seatNum => {
                      const seatItems = items.filter(item => item.seatNumber === seatNum)
                      const seatTotal = seatItems.reduce((sum, item) => sum + item.itemTotal, 0)
                      return (
                        <Card key={seatNum} className="p-3">
                          <div className="flex justify-between items-center mb-2">
                            <span className="font-medium flex items-center gap-2">
                              <span className="text-lg">🪑</span> Seat {seatNum}
                            </span>
                            <span className="font-bold">{formatCurrency(seatTotal)}</span>
                          </div>
                          <div className="text-sm text-gray-500">
                            {seatItems.map(item => (
                              <div key={item.id} className="flex justify-between">
                                <span>{item.quantity > 1 && `${item.quantity}x `}{item.name}</span>
                                <span>{formatCurrency(item.itemTotal)}</span>
                              </div>
                            ))}
                          </div>
                        </Card>
                      )
                    })}

                    {/* Show unassigned items if any */}
                    {items.some(item => item.seatNumber === null || item.seatNumber === undefined) && (
                      <Card className="p-3 bg-amber-50 border-amber-200">
                        <div className="flex justify-between items-center mb-2">
                          <span className="font-medium text-amber-700">Unassigned Items</span>
                          <span className="font-bold text-amber-700">
                            {formatCurrency(items.filter(i => i.seatNumber === null || i.seatNumber === undefined).reduce((sum, i) => sum + i.itemTotal, 0))}
                          </span>
                        </div>
                        <p className="text-xs text-amber-600">
                          These items will stay on the original check
                        </p>
                      </Card>
                    )}
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => setMode('select')}
                    >
                      Back
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={handleSeatSplit}
                      disabled={isProcessing}
                    >
                      {isProcessing ? 'Splitting...' : `Create ${seatsWithItems.size} Checks`}
                    </Button>
                  </div>
                </>
              ) : (
                <>
                  <p className="text-sm text-gray-500">
                    Checks have been created for each seat.
                  </p>

                  <div className="space-y-2 max-h-64 overflow-y-auto">
                    {seatSplitResult.splits.map((split) => (
                      <Card key={split.splitOrderId} className="p-3">
                        <div className="flex justify-between items-center">
                          <div>
                            <span className="font-medium flex items-center gap-2">
                              <span>🪑</span> Seat {split.seatNumber}
                            </span>
                            <div className="text-sm text-gray-500">
                              Check #{split.displayNumber} • {split.itemCount} items
                            </div>
                          </div>
                          <span className="text-lg font-bold">{formatCurrency(split.total)}</span>
                        </div>
                      </Card>
                    ))}

                    {seatSplitResult.hasUnassignedItems && (
                      <Card className="p-3 bg-amber-50 border-amber-200">
                        <div className="flex justify-between items-center">
                          <span className="font-medium text-amber-700">Original Check</span>
                          <span className="font-bold text-amber-700">{formatCurrency(seatSplitResult.unassignedTotal)}</span>
                        </div>
                        <p className="text-xs text-amber-600">Unassigned items remain here</p>
                      </Card>
                    )}
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={onClose}
                    >
                      Done
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={handleConfirmSeatSplit}
                    >
                      View Split Checks
                    </Button>
                  </div>
                </>
              )}
            </div>
          )}

          {/* By Table Mode - for virtual combined table groups */}
          {mode === 'by_table' && (
            <div className="space-y-4">
              <h3 className="font-medium">Split by Table</h3>

              {!tableSplitResult ? (
                <>
                  <p className="text-sm text-gray-500">
                    Each table in the group will get its own check with their items.
                  </p>

                  {/* Preview items by table */}
                  <div className="space-y-3 max-h-64 overflow-y-auto">
                    {Array.from(tablesWithItems.entries()).map(([tableId, tableName]) => {
                      const tableItems = items.filter(item => item.sourceTableId === tableId)
                      const tableTotal = tableItems.reduce((sum, item) => sum + item.itemTotal, 0)
                      return (
                        <Card key={tableId} className="p-3">
                          <div className="flex justify-between items-center mb-2">
                            <span className="font-medium flex items-center gap-2">
                              <span className="text-lg">🔗</span> {tableName}
                            </span>
                            <span className="font-bold">{formatCurrency(tableTotal)}</span>
                          </div>
                          <div className="text-sm text-gray-500">
                            {tableItems.map(item => (
                              <div key={item.id} className="flex justify-between">
                                <span>
                                  {item.quantity > 1 && `${item.quantity}x `}{item.name}
                                  {item.seatNumber && <span className="text-xs text-cyan-600 ml-1">(S{item.seatNumber})</span>}
                                </span>
                                <span>{formatCurrency(item.itemTotal)}</span>
                              </div>
                            ))}
                          </div>
                        </Card>
                      )
                    })}

                    {/* Show unassigned items if any */}
                    {items.some(item => !item.sourceTableId) && (
                      <Card className="p-3 bg-amber-50 border-amber-200">
                        <div className="flex justify-between items-center mb-2">
                          <span className="font-medium text-amber-700">Unassigned Items</span>
                          <span className="font-bold text-amber-700">
                            {formatCurrency(items.filter(i => !i.sourceTableId).reduce((sum, i) => sum + i.itemTotal, 0))}
                          </span>
                        </div>
                        <p className="text-xs text-amber-600">
                          These items will stay on the original check
                        </p>
                      </Card>
                    )}
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => setMode('select')}
                    >
                      Back
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={handleTableSplit}
                      disabled={isProcessing}
                    >
                      {isProcessing ? 'Splitting...' : `Create ${tablesWithItems.size} Checks`}
                    </Button>
                  </div>
                </>
              ) : (
                <>
                  <p className="text-sm text-gray-500">
                    Checks have been created for each table.
                  </p>

                  <div className="space-y-2 max-h-64 overflow-y-auto">
                    {tableSplitResult.splits.map((split) => (
                      <Card key={split.splitOrderId} className="p-3">
                        <div className="flex justify-between items-center">
                          <div>
                            <span className="font-medium flex items-center gap-2">
                              <span>🔗</span> {split.tableName}
                            </span>
                            <div className="text-sm text-gray-500">
                              Check #{split.displayNumber} • {split.itemCount} items
                            </div>
                          </div>
                          <span className="text-lg font-bold">{formatCurrency(split.total)}</span>
                        </div>
                      </Card>
                    ))}

                    {tableSplitResult.hasUnassignedItems && (
                      <Card className="p-3 bg-amber-50 border-amber-200">
                        <div className="flex justify-between items-center">
                          <span className="font-medium text-amber-700">Original Check</span>
                          <span className="font-bold text-amber-700">{formatCurrency(tableSplitResult.unassignedTotal)}</span>
                        </div>
                        <p className="text-xs text-amber-600">Unassigned items remain here</p>
                      </Card>
                    )}
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={onClose}
                    >
                      Done
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={handleConfirmTableSplit}
                    >
                      View Split Checks
                    </Button>
                  </div>
                </>
              )}
            </div>
          )}

          {/* By Item Mode */}
          {mode === 'by_item' && (
            <div className="space-y-4">
              <h3 className="font-medium">Select Items to Move</h3>
              <p className="text-sm text-gray-500">
                Selected items will be moved to a new check
              </p>

              <div className="space-y-2 max-h-64 overflow-y-auto">
                {items.map(item => (
                  <Card
                    key={item.id}
                    className={`p-3 cursor-pointer transition-colors ${
                      selectedItemIds.includes(item.id)
                        ? 'bg-blue-50 border-blue-500'
                        : 'hover:bg-gray-50'
                    }`}
                    onClick={() => toggleItemSelection(item.id)}
                  >
                    <div className="flex items-center gap-3">
                      <div className={`w-5 h-5 rounded border-2 flex items-center justify-center ${
                        selectedItemIds.includes(item.id)
                          ? 'bg-blue-600 border-blue-600'
                          : 'border-gray-300'
                      }`}>
                        {selectedItemIds.includes(item.id) && (
                          <svg className="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                          </svg>
                        )}
                      </div>
                      <div className="flex-1">
                        <div className="flex justify-between">
                          <span className="font-medium">
                            {item.quantity > 1 && `${item.quantity}x `}{item.name}
                          </span>
                          <span>{formatCurrency(item.itemTotal)}</span>
                        </div>
                        {item.modifiers && item.modifiers.length > 0 && (
                          <div className="text-sm text-gray-500">
                            {item.modifiers.map(m => m.name).join(', ')}
                          </div>
                        )}
                      </div>
                    </div>
                  </Card>
                ))}
              </div>

              {selectedItemIds.length > 0 && (
                <div className="p-3 bg-blue-50 rounded-lg">
                  <div className="flex justify-between font-medium">
                    <span>Selected Items Total:</span>
                    <span>{formatCurrency(calculateSelectedTotal())}</span>
                  </div>
                </div>
              )}

              <div className="flex gap-2 mt-4">
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={() => {
                    setMode('select')
                    setSelectedItemIds([])
                  }}
                >
                  Back
                </Button>
                <Button
                  variant="primary"
                  className="flex-1"
                  onClick={handleByItemSplit}
                  disabled={isProcessing || selectedItemIds.length === 0}
                >
                  {isProcessing ? 'Splitting...' : `Create New Check (${selectedItemIds.length})`}
                </Button>
              </div>
            </div>
          )}

          {/* Custom Amount Mode */}
          {mode === 'custom' && (
            <div className="space-y-4">
              <h3 className="font-medium">Pay Custom Amount</h3>
              <p className="text-sm text-gray-500">
                Enter the amount this guest wants to pay
              </p>

              <div>
                <label className="text-sm text-gray-600 block mb-2">
                  Amount to pay (max {formatCurrency(remainingBalance)})
                </label>
                <div className="relative">
                  <span className="absolute left-3 top-3 text-gray-500 text-lg">$</span>
                  <input
                    type="number"
                    value={customAmount}
                    onChange={(e) => setCustomAmount(e.target.value)}
                    className="w-full pl-8 pr-4 py-3 text-xl border rounded-lg"
                    placeholder="0.00"
                    step="0.01"
                    min="0.01"
                    max={remainingBalance}
                  />
                </div>
              </div>

              {customAmount && parseFloat(customAmount) > 0 && (
                <div className="p-3 bg-blue-50 rounded-lg space-y-1">
                  <div className="flex justify-between text-sm">
                    <span>This guest pays:</span>
                    <span className="font-medium">{formatCurrency(parseFloat(customAmount) || 0)}</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Remaining after:</span>
                    <span className="font-medium">
                      {formatCurrency(Math.max(0, remainingBalance - (parseFloat(customAmount) || 0)))}
                    </span>
                  </div>
                </div>
              )}

              <div className="flex gap-2 mt-4">
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={() => {
                    setMode('select')
                    setCustomAmount('')
                  }}
                >
                  Back
                </Button>
                <Button
                  variant="primary"
                  className="flex-1"
                  onClick={handleCustomAmount}
                  disabled={!customAmount || parseFloat(customAmount) <= 0}
                >
                  Pay {customAmount ? formatCurrency(parseFloat(customAmount)) : '$0.00'}
                </Button>
              </div>
            </div>
          )}

          {/* Split Item Mode */}
          {mode === 'split_item' && (
            <div className="space-y-4">
              <h3 className="font-medium">Split Single Item</h3>

              {!selectedItemForSplit ? (
                <>
                  <p className="text-sm text-gray-500">
                    Select an item to split among guests
                  </p>

                  <div className="space-y-2 max-h-64 overflow-y-auto">
                    {items.map(item => (
                      <Card
                        key={item.id}
                        className="p-3 cursor-pointer hover:bg-gray-50 transition-colors"
                        onClick={() => setSelectedItemForSplit(item)}
                      >
                        <div className="flex justify-between items-center">
                          <div>
                            <span className="font-medium">
                              {item.quantity > 1 && `${item.quantity}x `}{item.name}
                            </span>
                            {item.modifiers && item.modifiers.length > 0 && (
                              <div className="text-sm text-gray-500">
                                {item.modifiers.map(m => m.name).join(', ')}
                              </div>
                            )}
                          </div>
                          <span className="font-medium">{formatCurrency(item.itemTotal)}</span>
                        </div>
                      </Card>
                    ))}
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => setMode('select')}
                    >
                      Back
                    </Button>
                  </div>
                </>
              ) : !itemSplitResult ? (
                <>
                  <div className="p-3 bg-gray-50 rounded-lg mb-4">
                    <div className="flex justify-between">
                      <span className="font-medium">{selectedItemForSplit.name}</span>
                      <span>{formatCurrency(selectedItemForSplit.itemTotal)}</span>
                    </div>
                    {selectedItemForSplit.modifiers && selectedItemForSplit.modifiers.length > 0 && (
                      <div className="text-sm text-gray-500">
                        {selectedItemForSplit.modifiers.map(m => m.name).join(', ')}
                      </div>
                    )}
                  </div>

                  <div>
                    <label className="text-sm text-gray-600 block mb-2">
                      How many ways to split this item?
                    </label>
                    <div className="flex items-center gap-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setItemSplitWays(Math.max(2, itemSplitWays - 1))}
                        disabled={itemSplitWays <= 2}
                      >
                        -
                      </Button>
                      <span className="text-2xl font-bold w-12 text-center">{itemSplitWays}</span>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setItemSplitWays(itemSplitWays + 1)}
                      >
                        +
                      </Button>
                    </div>
                  </div>

                  <div className="p-3 bg-blue-50 rounded-lg">
                    <div className="flex justify-between text-sm">
                      <span>Each person pays:</span>
                      <span className="font-bold">
                        {formatCurrency(selectedItemForSplit.itemTotal / itemSplitWays)}
                      </span>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => {
                        setSelectedItemForSplit(null)
                        setItemSplitWays(2)
                      }}
                    >
                      Back
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={() => {
                        // Calculate the splits with proper rounding
                        const baseAmount = Math.floor((selectedItemForSplit.itemTotal / itemSplitWays) * 100) / 100
                        const splits: { splitNumber: number; amount: number }[] = []
                        let remaining = selectedItemForSplit.itemTotal

                        for (let i = 1; i <= itemSplitWays; i++) {
                          if (i === itemSplitWays) {
                            // Last person pays the remainder
                            splits.push({ splitNumber: i, amount: Math.round(remaining * 100) / 100 })
                          } else {
                            splits.push({ splitNumber: i, amount: baseAmount })
                            remaining -= baseAmount
                          }
                        }

                        setItemSplitResult({
                          itemId: selectedItemForSplit.id,
                          itemName: selectedItemForSplit.name,
                          splits,
                        })
                      }}
                    >
                      Calculate Split
                    </Button>
                  </div>
                </>
              ) : (
                <>
                  <div className="p-3 bg-gray-50 rounded-lg mb-4">
                    <p className="text-sm text-gray-600">Splitting: <span className="font-medium">{itemSplitResult.itemName}</span></p>
                  </div>

                  <div className="space-y-2">
                    {itemSplitResult.splits.map((split, idx) => (
                      <Card key={idx} className="p-3">
                        <div className="flex justify-between items-center">
                          <span className="font-medium">Guest {split.splitNumber}</span>
                          <span className="text-lg font-bold">{formatCurrency(split.amount)}</span>
                        </div>
                      </Card>
                    ))}
                  </div>

                  <p className="text-sm text-gray-500 text-center">
                    Click &quot;Confirm&quot; to collect payments sequentially
                  </p>

                  <div className="flex gap-2 mt-4">
                    <Button
                      variant="outline"
                      className="flex-1"
                      onClick={() => {
                        setItemSplitResult(null)
                        setItemSplitWays(2)
                      }}
                    >
                      Recalculate
                    </Button>
                    <Button
                      variant="primary"
                      className="flex-1"
                      onClick={() => {
                        onSplitComplete({
                          type: 'split_item',
                          originalOrderId: orderId,
                          itemSplits: [{
                            itemId: itemSplitResult.itemId,
                            itemName: itemSplitResult.itemName,
                            ...itemSplitResult.splits[0],
                          }],
                          splits: itemSplitResult.splits,
                        })
                      }}
                    >
                      Confirm Split
                    </Button>
                  </div>
                </>
              )}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t bg-gray-50">
          <Button variant="outline" className="w-full" onClick={onClose} disabled={isProcessing}>
            Cancel
          </Button>
        </div>
      </div>
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/SwapConfirmationModal.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState } from 'react'
import { SpeakerWaveIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
import type { PaymentReader } from '@/hooks/useDatacap'

interface SwapConfirmationModalProps {
  targetReader: PaymentReader
  onCancel: () => void
  onConfirm: () => void
  onBeep: () => Promise<void>
}

export function SwapConfirmationModal({
  targetReader,
  onCancel,
  onConfirm,
  onBeep,
}: SwapConfirmationModalProps) {
  const [isPinging, setIsPinging] = useState(false)
  const [beeped, setBeeped] = useState(false)

  const handleBeep = async () => {
    setIsPinging(true)
    try {
      await onBeep()
      setBeeped(true)
    } catch (err) {
      console.error('Failed to beep:', err)
    } finally {
      setIsPinging(false)
    }
  }

  // Show last 6 digits of serial number
  const serialDisplay = targetReader.serialNumber.length > 6
    ? `...${targetReader.serialNumber.slice(-6)}`
    : targetReader.serialNumber

  return (
    <div className="fixed inset-0 bg-black/95 flex items-center justify-center z-[300] p-6">
      <div className="bg-slate-900 border-2 border-amber-500 rounded-3xl p-8 w-full max-w-sm text-center shadow-2xl">
        {/* Header */}
        <h3 className="text-xl font-black text-white mb-2">VERIFY DEVICE</h3>
        <p className="text-slate-400 text-xs mb-6 uppercase tracking-widest">
          Match Serial Number on back of reader:
        </p>

        {/* Serial Number Display */}
        <div className="bg-slate-950 rounded-2xl p-6 mb-6 border border-slate-800">
          <span className="text-3xl font-mono font-bold text-cyan-400">
            SN: {serialDisplay}
          </span>
        </div>

        {/* Reader Info */}
        <div className="bg-slate-950/50 rounded-xl p-4 mb-6 text-left border border-slate-800">
          <div className="flex justify-between text-sm mb-2">
            <span className="text-slate-500">Reader Name:</span>
            <span className="text-white font-medium">{targetReader.name}</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-slate-500">IP Address:</span>
            <span className="text-slate-300 font-mono text-xs">
              {targetReader.ipAddress}:{targetReader.port}
            </span>
          </div>
        </div>

        {/* Ping/Beep Button */}
        <button
          onClick={handleBeep}
          disabled={isPinging}
          className={`w-full mb-3 py-3 rounded-xl font-bold text-xs uppercase tracking-wider transition-all flex items-center justify-center gap-2 ${
            beeped
              ? 'border-2 border-emerald-500 text-emerald-500 bg-emerald-500/10'
              : 'border-2 border-cyan-500 text-cyan-500 hover:bg-cyan-500/10'
          } ${isPinging ? 'opacity-50 cursor-not-allowed' : ''}`}
        >
          {isPinging ? (
            <>
              <div className="w-4 h-4 border-2 border-cyan-500 border-t-transparent rounded-full animate-spin" />
              PINGING...
            </>
          ) : beeped ? (
            <>
              <CheckCircleIcon className="w-5 h-5" />
              READER BEEPED
            </>
          ) : (
            <>
              <SpeakerWaveIcon className="w-5 h-5" />
              PING READER (BEEP)
            </>
          )}
        </button>

        {/* Confirm Button */}
        <button
          onClick={onConfirm}
          className="w-full py-4 bg-emerald-600 hover:bg-emerald-500 text-white font-black rounded-xl shadow-lg transition-all"
        >
          YES, I HAVE THIS READER
        </button>

        {/* Cancel Button */}
        <button
          onClick={onCancel}
          className="w-full mt-3 py-3 text-slate-400 hover:text-white text-sm font-bold transition-all"
        >
          Cancel
        </button>
      </div>
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/TipPromptSelector.tsx
────────────────────────────────────────────────────────────────────────────────
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { formatCurrency } from '@/lib/utils'

interface TipPromptSelectorProps {
  orderAmount: number
  tipDollarAmountThreshold: number   // Under this, show $ amounts (default: 15)
  tipDollarSuggestions: number[]     // e.g., [1, 2, 3]
  tipPercentSuggestions: number[]    // e.g., [18, 20, 25]
  requireCustomForZeroTip: boolean   // Must tap Custom → enter 0 to skip
  onSelectTip: (amount: number) => void
  onCancel?: () => void
}

/**
 * Tip Prompt Selector — smart tip buttons based on order amount.
 *
 * Under threshold ($15 default): Show dollar amounts ($1, $2, $3, Custom)
 * Over threshold: Show percentages (18%, 20%, 25%, Custom)
 * No "No Tip" button — customer must tap Custom → enter 0 to skip tip.
 */
export function TipPromptSelector({
  orderAmount,
  tipDollarAmountThreshold,
  tipDollarSuggestions,
  tipPercentSuggestions,
  requireCustomForZeroTip,
  onSelectTip,
  onCancel,
}: TipPromptSelectorProps) {
  const [showCustom, setShowCustom] = useState(false)
  const [customAmount, setCustomAmount] = useState('')

  const isUnderThreshold = orderAmount < tipDollarAmountThreshold

  const handleCustomSubmit = () => {
    const amount = parseFloat(customAmount) || 0
    onSelectTip(amount)
  }

  if (showCustom) {
    return (
      <div className="flex flex-col items-center gap-4 p-4">
        <p className="text-sm text-gray-600">Enter tip amount</p>
        <div className="relative w-48">
          <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-lg">$</span>
          <input
            type="number"
            inputMode="decimal"
            step="0.01"
            min="0"
            className="w-full pl-8 pr-3 py-3 text-2xl text-center border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            value={customAmount}
            onChange={(e) => setCustomAmount(e.target.value)}
            autoFocus
            placeholder="0.00"
          />
        </div>
        <div className="flex gap-2">
          <Button variant="ghost" onClick={() => setShowCustom(false)}>
            Back
          </Button>
          <Button variant="primary" onClick={handleCustomSubmit}>
            {parseFloat(customAmount) > 0
              ? `Add ${formatCurrency(parseFloat(customAmount))} Tip`
              : 'No Tip'}
          </Button>
        </div>
      </div>
    )
  }

  return (
    <div className="flex flex-col items-center gap-4 p-4">
      <div className="text-center mb-2">
        <p className="text-sm text-gray-500">Order Total</p>
        <p className="text-2xl font-bold">{formatCurrency(orderAmount)}</p>
      </div>

      <p className="text-sm font-medium text-gray-700">Add a tip?</p>

      <div className="grid grid-cols-2 gap-3 w-full max-w-xs">
        {isUnderThreshold ? (
          // Dollar amount buttons (under threshold)
          <>
            {tipDollarSuggestions.map((dollars) => (
              <Button
                key={dollars}
                variant="outline"
                className="py-6 text-lg font-semibold"
                onClick={() => onSelectTip(dollars)}
              >
                {formatCurrency(dollars)}
              </Button>
            ))}
            <Button
              variant="outline"
              className="py-6 text-lg font-semibold"
              onClick={() => setShowCustom(true)}
            >
              Custom
            </Button>
          </>
        ) : (
          // Percentage buttons (over threshold)
          <>
            {tipPercentSuggestions.map((percent) => {
              const tipAmount = Math.round(orderAmount * (percent / 100) * 100) / 100
              return (
                <Button
                  key={percent}
                  variant="outline"
                  className="py-6 flex flex-col items-center"
                  onClick={() => onSelectTip(tipAmount)}
                >
                  <span className="text-lg font-semibold">{percent}%</span>
                  <span className="text-xs text-gray-500">{formatCurrency(tipAmount)}</span>
                </Button>
              )
            })}
            <Button
              variant="outline"
              className="py-6 text-lg font-semibold"
              onClick={() => setShowCustom(true)}
            >
              Custom
            </Button>
          </>
        )}
      </div>

      {/* No "No Tip" button when requireCustomForZeroTip is true */}
      {!requireCustomForZeroTip && (
        <Button
          variant="ghost"
          className="text-sm text-gray-400"
          onClick={() => onSelectTip(0)}
        >
          No Tip
        </Button>
      )}

      {onCancel && (
        <Button variant="ghost" className="text-sm" onClick={onCancel}>
          Cancel
        </Button>
      )}
    </div>
  )
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/index.ts
────────────────────────────────────────────────────────────────────────────────
/**
 * Payment Components
 *
 * Export all payment-related components and types
 */

export { PaymentModal } from './PaymentModal'
export { GroupSummary } from './GroupSummary'
export type { GroupTableFinancials } from './GroupSummary'

// Datacap Direct Integration
export { DatacapPaymentProcessor } from './DatacapPaymentProcessor'
export { SwapConfirmationModal } from './SwapConfirmationModal'
export { ReaderStatusIndicator } from './ReaderStatusIndicator'

// Quick Pay & Tip
export { QuickPayButton } from './QuickPayButton'
export { TipPromptSelector } from './TipPromptSelector'
export { SignatureCapture } from './SignatureCapture'

export * from './types'


────────────────────────────────────────────────────────────────────────────────
FILE: src/components/payment/types.ts
────────────────────────────────────────────────────────────────────────────────
/**
 * Shared types for payment components
 *
 * These types are extracted to enable future component splitting.
 * The PaymentModal can be refactored into smaller sub-components:
 * - PaymentMethodSelector
 * - TipSelector
 * - CashPaymentStep
 * - CardPaymentStep
 * - GiftCardPaymentStep
 * - HouseAccountPaymentStep
 * - PaymentConfirmation
 */

import type { DualPricingSettings, TipSettings, PaymentSettings } from '@/lib/settings'

export type PaymentMethod = 'cash' | 'credit' | 'debit' | 'gift_card' | 'house_account'
export type PaymentStep = 'method' | 'cash' | 'card' | 'tip' | 'confirm' | 'gift_card' | 'house_account'

export interface PendingPayment {
  method: PaymentMethod
  amount: number
  tipAmount: number
  amountTendered?: number
  cardBrand?: string
  cardLast4?: string
  giftCardId?: string
  giftCardNumber?: string
  houseAccountId?: string
}

export interface GiftCardInfo {
  id: string
  cardNumber: string
  currentBalance: number
  status: string
}

export interface HouseAccountInfo {
  id: string
  name: string
  currentBalance: number
  creditLimit: number
  status: string
}

export interface PaymentContextValue {
  orderId: string | null
  orderTotal: number
  remainingBalance: number
  subtotal: number
  dualPricing: DualPricingSettings
  tipSettings: TipSettings
  paymentSettings: PaymentSettings
  cashTotal: number
  cardTotal: number
}

export interface PaymentMethodSelectorProps {
  dualPricing: DualPricingSettings
  paymentSettings: PaymentSettings
  cashTotal: number
  cardTotal: number
  onSelectMethod: (method: PaymentMethod) => void
}

export interface TipSelectorProps {
  selectedMethod: PaymentMethod | null
  currentTotal: number
  subtotal: number
  orderTotal: number
  tipSettings: TipSettings
  tipAmount: number
  customTip: string
  onSelectTip: (percent: number | null) => void
  onCustomTipChange: (value: string) => void
  onCustomTipBlur: () => void
  onBack: () => void
  onContinue: () => void
}

export interface CashPaymentStepProps {
  totalWithTip: number
  quickAmounts: number[]
  customCashAmount: string
  isProcessing: boolean
  tipEnabled: boolean
  onCashPayment: (amount: number) => void
  onCustomAmountChange: (value: string) => void
  onBack: () => void
}

export interface CardPaymentStepProps {
  totalWithTip: number
  cardLast4: string
  cardBrand: string
  isProcessing: boolean
  tipEnabled: boolean
  onCardLast4Change: (value: string) => void
  onCardBrandChange: (value: string) => void
  onSubmit: () => void
  onBack: () => void
}

// Default tip settings constant
export const DEFAULT_TIP_SETTINGS: TipSettings = {
  enabled: true,
  suggestedPercentages: [15, 18, 20, 25],
  calculateOn: 'subtotal',
}

// Virtual Group Checkout Types
export interface GroupTableItem {
  id: string
  name: string
  quantity: number
  price: number
  modifierTotal?: number
  itemTotal?: number
  seatNumber?: number
}

export interface GroupTableFinancials {
  tableId: string
  tableName: string
  tableAbbreviation?: string
  isPrimary: boolean
  sectionId?: string
  sectionName?: string
  itemCount: number
  subtotal: number
  tax: number
  total: number
  paid: number
  remaining: number
  items: GroupTableItem[]
}

export interface VirtualGroupCheckoutData {
  virtualGroupId: string
  groupColor: string
  createdAt?: string
  primaryTableId: string
  primaryTableName: string
  tableCount: number
  order: {
    id: string
    orderNumber: number
    displayNumber?: string
    status: string
  } | null
  totals: {
    subtotal: number
    tax: number
    total: number
    paid: number
    remaining: number
    itemCount: number
  }
  financials: GroupTableFinancials[]
}


================================================================================
SECTION 4: TYPE DEFINITIONS
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/types/payment.ts
────────────────────────────────────────────────────────────────────────────────
// Payment Types
// Types for payment processing and Datacap card reader integration

import type { CardType } from '@/lib/mock-cards'

/**
 * Result from simulated card reader (tap or chip)
 * Used by the simulated Datacap reader API routes
 */
export interface SimulatedPaymentResult {
  success: boolean
  error?: string
  authCode?: string
  cardType?: CardType
  lastFour?: string
  customerName?: string  // Only available from chip card reads
}

/**
 * Card read method type
 */
export type CardReadMethod = 'tap' | 'chip' | 'swipe'

/**
 * Processing state for card reader
 */
export type CardReaderState = 'idle' | 'processing' | 'success' | 'declined'


================================================================================
SECTION 5: DATACAP API ROUTES
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/adjust/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface AdjustRequest {
  locationId: string
  readerId: string
  recordNo: string
  purchaseAmount: number
  gratuityAmount: number
  employeeId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<AdjustRequest>(request)
    const { locationId, readerId, recordNo, purchaseAmount, gratuityAmount, employeeId } = body

    if (!locationId || !readerId || !recordNo || purchaseAmount === undefined || gratuityAmount === undefined) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, recordNo, purchaseAmount, gratuityAmount' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.adjustGratuity(readerId, {
      recordNo,
      purchaseAmount,
      gratuityAmount,
    })

    const error = parseError(response)

    console.log(`[Datacap Adjust] RecordNo=${recordNo} Employee=${employeeId} Status=${response.cmdStatus} Purchase=${purchaseAmount} Tip=${gratuityAmount}`)

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        adjustedAmount: response.authorize,
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/batch/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')
    const readerId = searchParams.get('readerId')

    if (!locationId || !readerId) {
      return Response.json({ error: 'Missing required params: locationId, readerId' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.batchSummary(readerId)
    const error = parseError(response)

    return Response.json({
      data: {
        success: response.cmdStatus === 'Success',
        batchNo: response.batchNo,
        transactionCount: response.batchItemCount,
        error: error ? { code: error.code, message: error.text } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}

interface BatchCloseRequest {
  locationId: string
  readerId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json() as BatchCloseRequest
    const { locationId, readerId } = body

    if (!locationId || !readerId) {
      return Response.json({ error: 'Missing required fields: locationId, readerId' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.batchClose(readerId)
    const error = parseError(response)

    console.log(`[Datacap Batch Close] Reader=${readerId} Status=${response.cmdStatus} BatchNo=${response.batchNo || 'N/A'}`)

    return Response.json({
      data: {
        success: response.cmdStatus === 'Success',
        batchNo: response.batchNo,
        error: error ? { code: error.code, message: error.text } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/capture/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface CaptureRequest {
  locationId: string
  readerId: string
  recordNo: string
  purchaseAmount: number
  gratuityAmount?: number
  employeeId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<CaptureRequest>(request)
    const { locationId, readerId, recordNo, purchaseAmount, gratuityAmount, employeeId } = body

    if (!locationId || !readerId || !recordNo || purchaseAmount === undefined) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, recordNo, purchaseAmount' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.preAuthCapture(readerId, {
      recordNo,
      purchaseAmount,
      gratuityAmount,
    })

    const error = parseError(response)

    console.log(`[Datacap Capture] RecordNo=${recordNo} Employee=${employeeId} Status=${response.cmdStatus} Amount=${purchaseAmount}${gratuityAmount ? ` Tip=${gratuityAmount}` : ''}`)

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        authCode: response.authCode,
        amountAuthorized: response.authorize,
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/collect-card/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface CollectCardRequest {
  locationId: string
  readerId: string
  placeholderAmount?: number
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<CollectCardRequest>(request)
    const { locationId, readerId, placeholderAmount } = body

    if (!locationId || !readerId) {
      return Response.json({ error: 'Missing required fields: locationId, readerId' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.collectCardData(readerId, { placeholderAmount })

    const error = parseError(response)

    console.log(`[Datacap CollectCard] Reader=${readerId} Status=${response.cmdStatus} Name=${response.cardholderName || 'N/A'} Card=${response.cardType || 'N/A'} ...${response.cardLast4 || 'N/A'}`)

    return Response.json({
      data: {
        success: response.cmdStatus === 'Success' || response.cmdStatus === 'Approved',
        cardholderName: response.cardholderName,
        cardType: response.cardType,
        cardLast4: response.cardLast4,
        cardholderIdHash: response.cardholderIdHash,
        entryMethod: response.entryMethod,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/device-prompt/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'

interface DevicePromptRequest {
  locationId: string
  readerId: string
  promptType: 'tip' | 'yesno' | 'signature' | 'choice'
  promptText?: string
  suggestions?: number[]
  buttonLabels?: string[]
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<DevicePromptRequest>(request)
    const { locationId, readerId, promptType, promptText, suggestions, buttonLabels } = body

    if (!locationId || !readerId || !promptType) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, promptType' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    let response
    switch (promptType) {
      case 'tip':
        response = await client.getSuggestiveTip(readerId, suggestions)
        break
      case 'yesno':
        response = await client.getYesNo(readerId, promptText || 'Confirm?')
        break
      case 'signature':
        response = await client.getSignature(readerId)
        break
      case 'choice':
        response = await client.getMultipleChoice(
          readerId,
          promptText || 'Select option:',
          buttonLabels || ['Option 1', 'Option 2']
        )
        break
      default:
        return Response.json({ error: `Invalid promptType: ${promptType}` }, { status: 400 })
    }

    return Response.json({
      data: {
        success: response.cmdStatus === 'Success',
        response: response.textResponse,
        gratuity: response.gratuityAmount,
        signatureData: response.signatureData,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/increment/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface IncrementRequest {
  locationId: string
  readerId: string
  recordNo: string
  additionalAmount: number
  employeeId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<IncrementRequest>(request)
    const { locationId, readerId, recordNo, additionalAmount, employeeId } = body

    if (!locationId || !readerId || !recordNo || !additionalAmount) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, recordNo, additionalAmount' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.incrementalAuth(readerId, {
      recordNo,
      additionalAmount,
    })

    const error = parseError(response)

    console.log(`[Datacap Increment] RecordNo=${recordNo} Employee=${employeeId} Status=${response.cmdStatus} AddAmount=${additionalAmount}`)

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        newAuthorizedAmount: response.authorize,
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/pad-reset/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'

interface PadResetRequest {
  locationId: string
  readerId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<PadResetRequest>(request)
    const { locationId, readerId } = body

    if (!locationId || !readerId) {
      return Response.json({ error: 'Missing required fields: locationId, readerId' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.padReset(readerId)

    return Response.json({
      data: {
        success: response.cmdStatus === 'Success',
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/param-download/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'

interface ParamDownloadRequest {
  locationId: string
  readerId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<ParamDownloadRequest>(request)
    const { locationId, readerId } = body

    if (!locationId || !readerId) {
      return Response.json({ error: 'Missing required fields: locationId, readerId' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.paramDownload(readerId)

    console.log(`[Datacap ParamDownload] Reader=${readerId} Status=${response.cmdStatus}`)

    return Response.json({
      data: {
        success: response.cmdStatus === 'Success',
        textResponse: response.textResponse,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/preauth/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface PreAuthRequest {
  locationId: string
  readerId: string
  orderId: string
  amount: number
  employeeId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<PreAuthRequest>(request)
    const { locationId, readerId, orderId, amount, employeeId } = body

    if (!locationId || !readerId || !orderId || !amount) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, orderId, amount' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.preAuth(readerId, {
      invoiceNo: orderId,
      amount,
      requestRecordNo: true,
    })

    const error = parseError(response)

    console.log(`[Datacap PreAuth] Order=${orderId} Employee=${employeeId} Status=${response.cmdStatus} Amount=${amount} RecordNo=${response.recordNo || 'N/A'}`)

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        authCode: response.authCode,
        recordNo: response.recordNo,
        cardType: response.cardType,
        cardLast4: response.cardLast4,
        cardholderName: response.cardholderName,
        entryMethod: response.entryMethod,
        amountAuthorized: response.authorize,
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/return/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface ReturnRequest {
  locationId: string
  readerId: string
  recordNo?: string
  amount: number
  cardPresent: boolean
  employeeId: string
  invoiceNo?: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<ReturnRequest>(request)
    const { locationId, readerId, recordNo, amount, cardPresent, employeeId, invoiceNo } = body

    if (!locationId || !readerId || !amount) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, amount' }, { status: 400 })
    }

    if (!cardPresent && !recordNo) {
      return Response.json({ error: 'recordNo required for card-not-present returns' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.emvReturn(readerId, {
      amount,
      recordNo,
      cardPresent,
      invoiceNo,
    })

    const error = parseError(response)

    console.log(`[Datacap Return] Employee=${employeeId} Status=${response.cmdStatus} Amount=${amount} CardPresent=${cardPresent}`)

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        refNumber: response.refNo,
        recordNo: response.recordNo,
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/sale/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface SaleRequest {
  locationId: string
  readerId: string
  invoiceNo: string
  amount: number
  tipAmount?: number
  tipMode?: 'suggestive' | 'prompt' | 'included' | 'none'
  tipSuggestions?: number[]
  employeeId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<SaleRequest>(request)
    const { locationId, readerId, invoiceNo, amount, tipAmount, tipMode, tipSuggestions, employeeId } = body

    if (!locationId || !readerId || !invoiceNo || !amount) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, invoiceNo, amount' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.sale(readerId, {
      invoiceNo,
      amounts: {
        purchase: amount,
        gratuity: tipMode === 'included' ? tipAmount : undefined,
      },
      tipMode: tipMode || 'none',
      tipSuggestions,
      requestRecordNo: true,
      allowPartialAuth: true,
    })

    const error = parseError(response)

    console.log(`[Datacap Sale] Invoice=${invoiceNo} Employee=${employeeId} Status=${response.cmdStatus} Auth=${response.authCode || 'N/A'}`)

    // Fire-and-forget: card recognition (Phase 8)
    if (response.cmdStatus === 'Approved' && response.cardholderIdHash) {
      fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/card-profiles`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          cardholderIdHash: response.cardholderIdHash,
          cardType: response.cardType || 'unknown',
          cardLast4: response.cardLast4 || '????',
          cardholderName: response.cardholderName,
          spendAmount: parseFloat(response.authorize || '0') || amount,
        }),
      }).catch(err => console.warn('[Card Recognition] Background update failed:', err))
    }

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        authCode: response.authCode,
        recordNo: response.recordNo,
        cardType: response.cardType,
        cardLast4: response.cardLast4,
        cardholderName: response.cardholderName,
        entryMethod: response.entryMethod,
        amountAuthorized: response.authorize,
        isPartialApproval: response.isPartialApproval,
        gratuity: response.gratuityAmount,
        printData: response.printData,
        cvm: response.cvm,
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/void/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest } from 'next/server'
import { requireDatacapClient, validateReader, parseBody, datacapErrorResponse } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'

interface VoidRequest {
  locationId: string
  readerId: string
  recordNo: string
  employeeId: string
}

export async function POST(request: NextRequest) {
  try {
    const body = await parseBody<VoidRequest>(request)
    const { locationId, readerId, recordNo, employeeId } = body

    if (!locationId || !readerId || !recordNo) {
      return Response.json({ error: 'Missing required fields: locationId, readerId, recordNo' }, { status: 400 })
    }

    await validateReader(readerId, locationId)
    const client = await requireDatacapClient(locationId)

    const response = await client.voidSale(readerId, { recordNo })

    const error = parseError(response)

    console.log(`[Datacap Void] RecordNo=${recordNo} Employee=${employeeId} Status=${response.cmdStatus}`)

    return Response.json({
      data: {
        approved: response.cmdStatus === 'Approved',
        sequenceNo: response.sequenceNo,
        error: error ? { code: error.code, message: error.text, isRetryable: error.isRetryable } : null,
      },
    })
  } catch (err) {
    return datacapErrorResponse(err)
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/datacap/walkout-retry/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { requireDatacapClient, validateReader } from '@/lib/datacap/helpers'
import { parseError } from '@/lib/datacap/xml-parser'
import { parseSettings } from '@/lib/settings'

// POST - Retry capture for a walkout tab (manual trigger)
// Also used by cron/scheduler for auto-retry
export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}))
    const { walkoutRetryId, employeeId } = body

    if (!walkoutRetryId) {
      return NextResponse.json({ error: 'Missing walkoutRetryId' }, { status: 400 })
    }

    const retry = await db.walkoutRetry.findFirst({
      where: { id: walkoutRetryId, deletedAt: null, status: 'pending' },
    })

    if (!retry) {
      return NextResponse.json({ error: 'Walkout retry not found or already resolved' }, { status: 404 })
    }

    // Get the order card to retry against
    const orderCard = await db.orderCard.findFirst({
      where: { id: retry.orderCardId, deletedAt: null },
    })

    if (!orderCard) {
      return NextResponse.json({ error: 'Order card not found' }, { status: 404 })
    }

    const locationId = retry.locationId
    const settings = parseSettings(
      (await db.location.findUnique({ where: { id: locationId }, select: { settings: true } }))?.settings
    )
    const { walkoutRetryFrequencyDays, walkoutMaxRetryDays } = settings.payments

    try {
      await validateReader(orderCard.readerId, locationId)
      const client = await requireDatacapClient(locationId)

      const response = await client.preAuthCapture(orderCard.readerId, {
        recordNo: orderCard.recordNo,
        purchaseAmount: Number(retry.amount),
      })

      const error = parseError(response)
      const approved = response.cmdStatus === 'Approved'
      const now = new Date()

      if (approved) {
        // Update retry as collected
        await db.$transaction([
          db.walkoutRetry.update({
            where: { id: walkoutRetryId },
            data: {
              status: 'collected',
              collectedAt: now,
              lastRetryAt: now,
              retryCount: retry.retryCount + 1,
            },
          }),
          db.orderCard.update({
            where: { id: orderCard.id },
            data: {
              status: 'captured',
              capturedAmount: Number(retry.amount),
              capturedAt: now,
            },
          }),
        ])

        console.log(`[Walkout Retry] COLLECTED RetryId=${walkoutRetryId} Amount=$${retry.amount} Card=...${orderCard.cardLast4}`)

        return NextResponse.json({
          data: {
            success: true,
            status: 'collected',
            amount: Number(retry.amount),
            authCode: response.authCode,
          },
        })
      } else {
        // Calculate next retry
        const nextRetry = new Date(now)
        nextRetry.setDate(nextRetry.getDate() + walkoutRetryFrequencyDays)

        const createdAt = new Date(retry.createdAt)
        const maxDate = new Date(createdAt)
        maxDate.setDate(maxDate.getDate() + walkoutMaxRetryDays)

        const exhausted = nextRetry > maxDate

        await db.walkoutRetry.update({
          where: { id: walkoutRetryId },
          data: {
            retryCount: retry.retryCount + 1,
            lastRetryAt: now,
            lastRetryError: error?.text || response.textResponse || 'Declined',
            status: exhausted ? 'exhausted' : 'pending',
            nextRetryAt: exhausted ? retry.nextRetryAt : nextRetry,
          },
        })

        console.log(`[Walkout Retry] DECLINED RetryId=${walkoutRetryId} Attempt=${retry.retryCount + 1} ${exhausted ? '(EXHAUSTED)' : `NextRetry=${nextRetry.toISOString()}`}`)

        return NextResponse.json({
          data: {
            success: false,
            status: exhausted ? 'exhausted' : 'pending',
            retryCount: retry.retryCount + 1,
            nextRetryAt: exhausted ? null : nextRetry.toISOString(),
            error: error ? { code: error.code, message: error.text } : null,
          },
        })
      }
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Retry failed'

      await db.walkoutRetry.update({
        where: { id: walkoutRetryId },
        data: {
          retryCount: retry.retryCount + 1,
          lastRetryAt: new Date(),
          lastRetryError: errorMsg,
        },
      })

      return NextResponse.json({
        data: { success: false, error: errorMsg },
      })
    }
  } catch (error) {
    console.error('Failed to process walkout retry:', error)
    return NextResponse.json({ error: 'Failed to process walkout retry' }, { status: 500 })
  }
}

// GET - List walkout retries for a location
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')
    const status = searchParams.get('status') // pending | collected | exhausted | written_off

    if (!locationId) {
      return NextResponse.json({ error: 'Missing locationId' }, { status: 400 })
    }

    const where: Record<string, unknown> = { locationId, deletedAt: null }
    if (status) where.status = status

    const retries = await db.walkoutRetry.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: 100,
    })

    // Enrich with order card info
    const orderCardIds = [...new Set(retries.map(r => r.orderCardId))]
    const orderCards = await db.orderCard.findMany({
      where: { id: { in: orderCardIds } },
      select: { id: true, cardType: true, cardLast4: true, cardholderName: true, orderId: true },
    })
    const cardMap = new Map(orderCards.map(c => [c.id, c]))

    return NextResponse.json({
      data: retries.map(r => {
        const card = cardMap.get(r.orderCardId)
        return {
          id: r.id,
          orderId: card?.orderId,
          amount: Number(r.amount),
          status: r.status,
          retryCount: r.retryCount,
          maxRetries: r.maxRetries,
          nextRetryAt: r.nextRetryAt?.toISOString(),
          lastRetryAt: r.lastRetryAt?.toISOString(),
          lastRetryError: r.lastRetryError,
          collectedAt: r.collectedAt?.toISOString(),
          writtenOffAt: r.writtenOffAt?.toISOString(),
          cardType: card?.cardType,
          cardLast4: card?.cardLast4,
          cardholderName: card?.cardholderName,
          createdAt: r.createdAt.toISOString(),
        }
      }),
    })
  } catch (error) {
    console.error('Failed to list walkout retries:', error)
    return NextResponse.json({ error: 'Failed to list walkout retries' }, { status: 500 })
  }
}


================================================================================
SECTION 6: PAYMENT API ROUTES
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/orders/[id]/pay/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import {
  generateFakeAuthCode,
  generateFakeTransactionId,
  calculateRoundingAdjustment,
  roundAmount,
} from '@/lib/payment'
import { parseSettings } from '@/lib/settings'
import { processLiquorInventory } from '@/lib/liquor-inventory'
import { deductInventoryForOrder } from '@/lib/inventory-calculations'
import { tableEvents } from '@/lib/realtime/table-events'

interface PaymentInput {
  method: 'cash' | 'credit' | 'debit' | 'gift_card' | 'house_account' | 'loyalty_points'
  amount: number
  tipAmount?: number
  // Cash specific
  amountTendered?: number
  // Card specific
  cardBrand?: string
  cardLast4?: string
  // Gift card specific
  giftCardId?: string
  giftCardNumber?: string
  // House account specific
  houseAccountId?: string
  // Loyalty points specific
  pointsUsed?: number
  // Datacap Direct fields
  datacapRecordNo?: string
  datacapRefNumber?: string
  datacapSequenceNo?: string
  authCode?: string
  entryMethod?: string
  signatureData?: string
  amountAuthorized?: number
  // Simulated - will be replaced with real processor
  simulate?: boolean
}

// POST - Process payment for order
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: orderId } = await params
    const body = await request.json()
    const { payments, employeeId } = body as {
      payments: PaymentInput[]
      employeeId?: string
    }

    if (!payments || !Array.isArray(payments) || payments.length === 0) {
      return NextResponse.json(
        { error: 'At least one payment is required' },
        { status: 400 }
      )
    }

    // Get the order with customer for loyalty
    const order = await db.order.findUnique({
      where: { id: orderId },
      include: {
        payments: true,
        location: true,
        customer: true,
      },
    })

    if (!order) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      )
    }

    if (order.status === 'paid' || order.status === 'closed') {
      return NextResponse.json(
        { error: 'Order is already paid' },
        { status: 400 }
      )
    }

    // Get settings for rounding
    const settings = parseSettings(order.location.settings)

    // Calculate how much is already paid
    const alreadyPaid = order.payments
      .filter(p => p.status === 'completed')
      .reduce((sum, p) => sum + Number(p.totalAmount), 0)

    const orderTotal = Number(order.total)
    const remaining = orderTotal - alreadyPaid

    // Calculate total being paid now
    const paymentTotal = payments.reduce((sum, p) => sum + p.amount + (p.tipAmount || 0), 0)

    if (paymentTotal < remaining - 0.01) {
      // Allow small rounding differences
      return NextResponse.json(
        { error: `Payment amount ($${paymentTotal.toFixed(2)}) is less than remaining balance ($${remaining.toFixed(2)})` },
        { status: 400 }
      )
    }

    // Process each payment
    const createdPayments = []
    let totalTips = 0

    for (const payment of payments) {
      let paymentRecord: {
        locationId: string
        orderId: string
        employeeId: string | null
        amount: number
        tipAmount: number
        totalAmount: number
        paymentMethod: string
        amountTendered?: number
        changeGiven?: number
        roundingAdjustment?: number
        cardBrand?: string
        cardLast4?: string
        authCode?: string
        transactionId?: string
        datacapRecordNo?: string
        datacapRefNumber?: string
        datacapSequenceNo?: string
        entryMethod?: string
        signatureData?: string
        amountAuthorized?: number
        amountRequested?: number
        status: string
      } = {
        locationId: order.locationId,
        orderId,
        employeeId: employeeId || null,
        amount: payment.amount,
        tipAmount: payment.tipAmount || 0,
        totalAmount: payment.amount + (payment.tipAmount || 0),
        paymentMethod: payment.method,
        status: 'completed',
      }

      if (payment.method === 'cash') {
        // Apply rounding if enabled
        let finalAmount = payment.amount
        let roundingAdjustment = 0

        if (settings.payments.cashRounding !== 'none') {
          roundingAdjustment = calculateRoundingAdjustment(
            payment.amount,
            settings.payments.cashRounding,
            settings.payments.roundingDirection
          )
          finalAmount = roundAmount(
            payment.amount,
            settings.payments.cashRounding,
            settings.payments.roundingDirection
          )
        }

        const amountTendered = payment.amountTendered || finalAmount + (payment.tipAmount || 0)
        const changeGiven = Math.max(0, amountTendered - finalAmount - (payment.tipAmount || 0))

        paymentRecord = {
          ...paymentRecord,
          amount: finalAmount,
          totalAmount: finalAmount + (payment.tipAmount || 0),
          amountTendered,
          changeGiven,
          roundingAdjustment: roundingAdjustment !== 0 ? roundingAdjustment : undefined,
        }
      } else if (payment.method === 'credit' || payment.method === 'debit') {
        if (!payment.cardLast4 || !/^\d{4}$/.test(payment.cardLast4)) {
          return NextResponse.json(
            { error: 'Valid card last 4 digits required' },
            { status: 400 }
          )
        }

        // Use real Datacap fields when available, fall back to simulated
        const isDatacap = !!payment.datacapRecordNo || !!payment.datacapRefNumber
        paymentRecord = {
          ...paymentRecord,
          cardBrand: payment.cardBrand || 'visa',
          cardLast4: payment.cardLast4,
          authCode: isDatacap ? payment.authCode : generateFakeAuthCode(),
          transactionId: isDatacap ? payment.datacapRefNumber : generateFakeTransactionId(),
          ...(isDatacap && {
            datacapRecordNo: payment.datacapRecordNo,
            datacapRefNumber: payment.datacapRefNumber,
            datacapSequenceNo: payment.datacapSequenceNo,
            entryMethod: payment.entryMethod,
            signatureData: payment.signatureData,
            amountAuthorized: payment.amountAuthorized,
            amountRequested: payment.amount,
          }),
        }
      } else if (payment.method === 'loyalty_points') {
        // Loyalty points redemption
        if (!settings.loyalty.enabled || !settings.loyalty.redemptionEnabled) {
          return NextResponse.json(
            { error: 'Loyalty points redemption is not enabled' },
            { status: 400 }
          )
        }

        if (!order.customer) {
          return NextResponse.json(
            { error: 'Customer is required to redeem loyalty points' },
            { status: 400 }
          )
        }

        const pointsNeeded = Math.ceil(payment.amount * settings.loyalty.pointsPerDollarRedemption)

        if (!payment.pointsUsed || payment.pointsUsed < pointsNeeded) {
          return NextResponse.json(
            { error: `${pointsNeeded} points required for $${payment.amount.toFixed(2)} redemption` },
            { status: 400 }
          )
        }

        if (order.customer.loyaltyPoints < payment.pointsUsed) {
          return NextResponse.json(
            { error: `Insufficient points. Customer has ${order.customer.loyaltyPoints} points.` },
            { status: 400 }
          )
        }

        // Check minimum redemption
        if (payment.pointsUsed < settings.loyalty.minimumRedemptionPoints) {
          return NextResponse.json(
            { error: `Minimum ${settings.loyalty.minimumRedemptionPoints} points required for redemption` },
            { status: 400 }
          )
        }

        // Check maximum redemption percentage
        const maxRedemptionAmount = orderTotal * (settings.loyalty.maximumRedemptionPercent / 100)
        if (payment.amount > maxRedemptionAmount) {
          return NextResponse.json(
            { error: `Maximum ${settings.loyalty.maximumRedemptionPercent}% of order can be paid with points` },
            { status: 400 }
          )
        }

        // Deduct points from customer
        await db.customer.update({
          where: { id: order.customer.id },
          data: {
            loyaltyPoints: { decrement: payment.pointsUsed },
          },
        })

        // Store points used in payment record metadata
        paymentRecord = {
          ...paymentRecord,
          // Use transactionId to store points info for now
          transactionId: `LOYALTY:${payment.pointsUsed}pts`,
        }
      } else if (payment.method === 'gift_card') {
        // Gift card payment
        if (!settings.payments.acceptGiftCards) {
          return NextResponse.json(
            { error: 'Gift cards are not accepted' },
            { status: 400 }
          )
        }

        const giftCardLookup = payment.giftCardId || payment.giftCardNumber
        if (!giftCardLookup) {
          return NextResponse.json(
            { error: 'Gift card ID or number is required' },
            { status: 400 }
          )
        }

        // Find the gift card
        let giftCard = await db.giftCard.findUnique({
          where: { id: payment.giftCardId || '' }
        })

        if (!giftCard && payment.giftCardNumber) {
          giftCard = await db.giftCard.findUnique({
            where: { cardNumber: payment.giftCardNumber.toUpperCase() }
          })
        }

        if (!giftCard) {
          return NextResponse.json(
            { error: 'Gift card not found' },
            { status: 404 }
          )
        }

        if (giftCard.status !== 'active') {
          return NextResponse.json(
            { error: `Gift card is ${giftCard.status}` },
            { status: 400 }
          )
        }

        // Check expiration
        if (giftCard.expiresAt && new Date() > giftCard.expiresAt) {
          await db.giftCard.update({
            where: { id: giftCard.id },
            data: { status: 'expired' }
          })
          return NextResponse.json(
            { error: 'Gift card has expired' },
            { status: 400 }
          )
        }

        const cardBalance = Number(giftCard.currentBalance)
        const paymentAmount = payment.amount + (payment.tipAmount || 0)

        if (paymentAmount > cardBalance) {
          return NextResponse.json(
            { error: `Insufficient gift card balance. Available: $${cardBalance.toFixed(2)}`, currentBalance: cardBalance },
            { status: 400 }
          )
        }

        // Deduct from gift card
        const newBalance = cardBalance - paymentAmount

        await db.giftCard.update({
          where: { id: giftCard.id },
          data: {
            currentBalance: newBalance,
            status: newBalance === 0 ? 'depleted' : 'active',
            transactions: {
              create: {
                locationId: order.locationId,
                type: 'redemption',
                amount: -paymentAmount,
                balanceBefore: cardBalance,
                balanceAfter: newBalance,
                orderId,
                employeeId: employeeId || null,
                notes: `Payment for order #${order.orderNumber}`,
              }
            }
          }
        })

        paymentRecord = {
          ...paymentRecord,
          transactionId: `GC:${giftCard.cardNumber}`,
          cardLast4: giftCard.cardNumber.slice(-4),
        }
      } else if (payment.method === 'house_account') {
        // House account payment
        if (!settings.payments.acceptHouseAccounts) {
          return NextResponse.json(
            { error: 'House accounts are not accepted' },
            { status: 400 }
          )
        }

        if (!payment.houseAccountId) {
          return NextResponse.json(
            { error: 'House account ID is required' },
            { status: 400 }
          )
        }

        const houseAccount = await db.houseAccount.findUnique({
          where: { id: payment.houseAccountId }
        })

        if (!houseAccount) {
          return NextResponse.json(
            { error: 'House account not found' },
            { status: 404 }
          )
        }

        if (houseAccount.status !== 'active') {
          return NextResponse.json(
            { error: `House account is ${houseAccount.status}` },
            { status: 400 }
          )
        }

        const paymentAmount = payment.amount + (payment.tipAmount || 0)
        const currentBalance = Number(houseAccount.currentBalance)
        const creditLimit = Number(houseAccount.creditLimit)
        const newBalance = currentBalance + paymentAmount

        // Check credit limit (0 = unlimited)
        if (creditLimit > 0 && newBalance > creditLimit) {
          return NextResponse.json(
            {
              error: 'Charge would exceed credit limit',
              currentBalance,
              creditLimit,
              availableCredit: Math.max(0, creditLimit - currentBalance),
            },
            { status: 400 }
          )
        }

        // Calculate due date
        const dueDate = new Date()
        dueDate.setDate(dueDate.getDate() + (houseAccount.paymentTerms ?? 30))

        // Charge to house account
        await db.houseAccount.update({
          where: { id: houseAccount.id },
          data: {
            currentBalance: newBalance,
            transactions: {
              create: {
                locationId: order.locationId,
                type: 'charge',
                amount: paymentAmount,
                balanceBefore: currentBalance,
                balanceAfter: newBalance,
                orderId,
                employeeId: employeeId || null,
                notes: `Order #${order.orderNumber}`,
                dueDate,
              }
            }
          }
        })

        paymentRecord = {
          ...paymentRecord,
          transactionId: `HA:${houseAccount.id}`,
          // Store account name info for receipt
          authCode: houseAccount.name,
        }
      }

      const created = await db.payment.create({
        data: paymentRecord,
      })

      createdPayments.push(created)
      totalTips += payment.tipAmount || 0
    }

    // Update order status and tip total
    const newTipTotal = Number(order.tipTotal) + totalTips
    const newPaidTotal = alreadyPaid + paymentTotal

    const updateData: {
      tipTotal: number
      primaryPaymentMethod?: string
      status?: string
      paidAt?: Date
      closedAt?: Date
    } = {
      tipTotal: newTipTotal,
    }

    // Set primary payment method based on first/largest payment
    if (!order.primaryPaymentMethod) {
      const primaryMethod = payments[0].method
      updateData.primaryPaymentMethod = primaryMethod === 'cash' ? 'cash' : 'card'
    }

    // Mark as paid if fully paid
    if (newPaidTotal >= orderTotal - 0.01) {
      updateData.status = 'paid'
      updateData.paidAt = new Date()
      updateData.closedAt = new Date()
    }

    await db.order.update({
      where: { id: orderId },
      data: updateData,
    })

    // If order is fully paid, reset entertainment items and cleanup virtual groups
    if (updateData.status === 'paid') {
      await db.menuItem.updateMany({
        where: {
          currentOrderId: orderId,
          itemType: 'timed_rental',
        },
        data: {
          entertainmentStatus: 'available',
          currentOrderId: null,
          currentOrderItemId: null,
        },
      })

      // Process liquor inventory deductions for cocktails with recipes
      // This tracks pour usage and creates inventory transactions
      await processLiquorInventory(orderId, employeeId)

      // Deduct general food/ingredient inventory (fire-and-forget to not block payment)
      // This processes MenuItemRecipes and ModifierInventoryLinks
      deductInventoryForOrder(orderId, employeeId).catch(err => {
        console.error('Background inventory deduction failed:', err)
      })

      // Clean up virtual group if this order belongs to one
      // Find the table associated with this order
      const orderTable = await db.table.findFirst({
        where: {
          orders: {
            some: { id: orderId },
          },
        },
      })

      if (orderTable?.virtualGroupId) {
        const virtualGroupId = orderTable.virtualGroupId

        // Find all tables in the group before clearing
        const groupTables = await db.table.findMany({
          where: {
            virtualGroupId,
            locationId: order.locationId,
          },
          select: { id: true },
        })

        // Dissolve the virtual group when the order is paid
        await db.table.updateMany({
          where: {
            virtualGroupId,
            locationId: order.locationId,
          },
          data: {
            virtualGroupId: null,
            virtualGroupPrimary: false,
            virtualGroupColor: null,
            virtualGroupCreatedAt: null,
            status: 'available',
          },
        })

        // Create audit log for virtual group dissolution
        await db.auditLog.create({
          data: {
            locationId: order.locationId,
            employeeId: employeeId || null,
            action: 'virtual_group_dissolved',
            entityType: 'order',
            entityId: orderId,
            details: {
              virtualGroupId,
              reason: 'Order paid',
              primaryTableId: orderTable.id,
            },
          },
        })

        // Emit real-time event for UI updates
        tableEvents.virtualGroupDissolved?.({
          virtualGroupId,
          tableIds: groupTables.map(t => t.id),
          locationId: order.locationId,
          timestamp: new Date().toISOString(),
          triggeredBy: employeeId,
        })
      } else if (order.tableId) {
        // Regular table (not virtual group) - just reset status
        await db.table.update({
          where: { id: order.tableId },
          data: { status: 'available' },
        })
      }
    }

    // Award loyalty points if order is fully paid and has a customer
    let pointsEarned = 0
    if (updateData.status === 'paid' && order.customer && settings.loyalty.enabled) {
      // Calculate earning base (subtotal or total based on settings)
      let earningBase = settings.loyalty.earnOnSubtotal
        ? Number(order.subtotal)
        : Number(order.total)

      // Add tips if configured
      if (settings.loyalty.earnOnTips) {
        earningBase += newTipTotal
      }

      // Check minimum earning amount
      if (earningBase >= settings.loyalty.minimumEarnAmount) {
        // Calculate points (1 point per dollar by default)
        pointsEarned = Math.floor(earningBase * settings.loyalty.pointsPerDollar)

        if (pointsEarned > 0) {
          // Update customer loyalty points and stats
          await db.customer.update({
            where: { id: order.customer.id },
            data: {
              loyaltyPoints: { increment: pointsEarned },
              totalSpent: { increment: Number(order.total) },
              totalOrders: { increment: 1 },
              lastVisit: new Date(),
              averageTicket: {
                set: await db.customer.findUnique({
                  where: { id: order.customer.id },
                }).then(c => {
                  if (!c) return Number(order.total)
                  const newTotal = Number(c.totalSpent) + Number(order.total)
                  const newOrders = c.totalOrders + 1
                  return newTotal / newOrders
                }),
              },
            },
          })
        }
      }
    }

    // If this is a split order that was just paid, check if all siblings are paid
    // and mark the parent as paid if so
    if (updateData.status === 'paid' && order.parentOrderId) {
      const allSiblings = await db.order.findMany({
        where: { parentOrderId: order.parentOrderId },
        select: { status: true },
      })

      const allSiblingsPaid = allSiblings.every(s => s.status === 'paid')

      if (allSiblingsPaid) {
        // Mark parent order as paid
        await db.order.update({
          where: { id: order.parentOrderId },
          data: {
            status: 'paid',
            paidAt: new Date(),
            closedAt: new Date(),
          },
        })
      }
    }

    // Return response
    return NextResponse.json({
      success: true,
      payments: createdPayments.map(p => ({
        id: p.id,
        method: p.paymentMethod,
        amount: Number(p.amount),
        tipAmount: Number(p.tipAmount),
        totalAmount: Number(p.totalAmount),
        amountTendered: p.amountTendered ? Number(p.amountTendered) : null,
        changeGiven: p.changeGiven ? Number(p.changeGiven) : null,
        roundingAdjustment: p.roundingAdjustment ? Number(p.roundingAdjustment) : null,
        cardBrand: p.cardBrand,
        cardLast4: p.cardLast4,
        authCode: p.authCode,
        status: p.status,
      })),
      orderStatus: newPaidTotal >= orderTotal - 0.01 ? 'paid' : 'partial',
      remainingBalance: Math.max(0, orderTotal - newPaidTotal),
      // Loyalty info
      loyaltyPointsEarned: pointsEarned,
      customerId: order.customer?.id || null,
    })
  } catch (error) {
    console.error('Failed to process payment:', error)
    return NextResponse.json(
      { error: 'Failed to process payment' },
      { status: 500 }
    )
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/orders/[id]/payments/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

// GET - List all payments for an order
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: orderId } = await params

    const order = await db.order.findUnique({
      where: { id: orderId },
      include: {
        payments: {
          orderBy: { processedAt: 'asc' },
        },
      },
    })

    if (!order) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      )
    }

    const orderTotal = Number(order.total)
    const paidAmount = order.payments
      .filter(p => p.status === 'completed')
      .reduce((sum, p) => sum + Number(p.totalAmount), 0)

    return NextResponse.json({
      orderId: order.id,
      orderTotal,
      paidAmount,
      remainingBalance: Math.max(0, orderTotal - paidAmount),
      isFullyPaid: paidAmount >= orderTotal - 0.01,
      payments: order.payments.map(p => ({
        id: p.id,
        method: p.paymentMethod,
        amount: Number(p.amount),
        tipAmount: Number(p.tipAmount),
        totalAmount: Number(p.totalAmount),
        amountTendered: p.amountTendered ? Number(p.amountTendered) : null,
        changeGiven: p.changeGiven ? Number(p.changeGiven) : null,
        roundingAdjustment: p.roundingAdjustment ? Number(p.roundingAdjustment) : null,
        cardBrand: p.cardBrand,
        cardLast4: p.cardLast4,
        authCode: p.authCode,
        transactionId: p.transactionId,
        status: p.status,
        refundedAmount: Number(p.refundedAmount),
        processedAt: p.processedAt.toISOString(),
      })),
    })
  } catch (error) {
    console.error('Failed to fetch payments:', error)
    return NextResponse.json(
      { error: 'Failed to fetch payments' },
      { status: 500 }
    )
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/payments/sync/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

const DEFAULT_LOCATION_ID = 'loc-1'

/**
 * POST /api/payments/sync
 *
 * Syncs an offline-captured payment to the server.
 * These payments were authorized while online, but captured while offline.
 * They need special handling for reconciliation.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      intentId,
      orderId,
      localOrderId,
      amount,
      tipAmount = 0,
      paymentMethod,
      cardToken,
      cardBrand,
      cardLast4,
      gatewayTransactionId,
      authorizationCode,
      isOfflineCapture,
      offlineCapturedAt,
      terminalId,
      employeeId,
    } = body

    // Validate required fields
    if (!orderId && !localOrderId) {
      return NextResponse.json(
        { error: 'Order ID or Local Order ID is required' },
        { status: 400 }
      )
    }

    if (!amount || !employeeId) {
      return NextResponse.json(
        { error: 'Amount and employee ID are required' },
        { status: 400 }
      )
    }

    // Check for duplicate sync (idempotency via intentId)
    if (intentId) {
      const existingPayment = await db.payment.findFirst({
        where: {
          offlineIntentId: intentId,
        },
      })

      if (existingPayment) {
        return NextResponse.json(
          {
            message: 'Payment already synced',
            paymentId: existingPayment.id,
            payment: existingPayment,
          },
          { status: 409 }
        )
      }
    }

    // Resolve the order ID
    let resolvedOrderId = orderId

    // If we only have localOrderId, find the synced order
    if (!resolvedOrderId && localOrderId) {
      const syncedOrder = await db.order.findFirst({
        where: {
          offlineLocalId: localOrderId,
        },
      })

      if (!syncedOrder) {
        return NextResponse.json(
          { error: 'Order not found - please sync the order first' },
          { status: 400 }
        )
      }

      resolvedOrderId = syncedOrder.id
    }

    // Verify the order exists
    const order = await db.order.findUnique({
      where: { id: resolvedOrderId },
      include: {
        location: true,
      },
    })

    if (!order) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Verify employee exists
    const employee = await db.employee.findUnique({
      where: { id: employeeId },
    })

    if (!employee) {
      return NextResponse.json({ error: 'Employee not found' }, { status: 400 })
    }

    // Map payment method to schema format
    const paymentMethodString = paymentMethod === 'card' ? 'credit' : paymentMethod

    // Create the payment in a transaction
    const payment = await db.$transaction(async (tx) => {
      // Create the payment record
      const newPayment = await tx.payment.create({
        data: {
          locationId: order.locationId,
          orderId: resolvedOrderId,
          employeeId,
          paymentMethod: paymentMethodString,
          amount,
          tipAmount,
          totalAmount: amount, // Total includes tip
          status: 'completed',
          // Card details (if card payment)
          cardBrand: cardBrand || null,
          cardLast4: cardLast4 || null,
          authCode: authorizationCode || null,
          transactionId: gatewayTransactionId || null,
          // Offline tracking
          offlineIntentId: intentId || null,
          isOfflineCapture: isOfflineCapture || false,
          offlineCapturedAt: offlineCapturedAt ? new Date(offlineCapturedAt) : null,
          offlineTerminalId: terminalId || null,
          // Flag for reconciliation if offline
          needsReconciliation: isOfflineCapture || false,
        },
      })

      // Update order totals
      const orderPayments = await tx.payment.findMany({
        where: { orderId: resolvedOrderId, status: 'completed' },
      })

      const totalPaid = orderPayments.reduce(
        (sum, p) => sum + Number(p.amount),
        0
      )
      const totalTips = orderPayments.reduce(
        (sum, p) => sum + Number(p.tipAmount || 0),
        0
      )

      // Check if fully paid
      const orderTotal = Number(order.total)
      const isFullyPaid = totalPaid >= orderTotal

      await tx.order.update({
        where: { id: resolvedOrderId },
        data: {
          tipTotal: totalTips,
          status: isFullyPaid ? 'paid' : order.status,
          paidAt: isFullyPaid ? new Date() : order.paidAt,
        },
      })

      return newPayment
    })

    // Fetch complete payment with relations
    const completePayment = await db.payment.findUnique({
      where: { id: payment.id },
    })

    return NextResponse.json({
      success: true,
      paymentId: payment.id,
      payment: completePayment,
      isOfflineCapture,
      message: isOfflineCapture
        ? 'Offline payment synced successfully - flagged for reconciliation'
        : 'Payment synced successfully',
    })
  } catch (error) {
    console.error('Failed to sync payment:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to sync payment' },
      { status: 500 }
    )
  }
}

/**
 * GET /api/payments/sync
 *
 * Get payments that need reconciliation (offline-captured)
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId') || DEFAULT_LOCATION_ID
    const dateStr = searchParams.get('date') // YYYY-MM-DD format
    const needsReconciliation = searchParams.get('needsReconciliation') === 'true'

    // Build date filter
    let dateFilter = {}
    if (dateStr) {
      const date = new Date(dateStr)
      const nextDay = new Date(date)
      nextDay.setDate(nextDay.getDate() + 1)
      dateFilter = {
        createdAt: {
          gte: date,
          lt: nextDay,
        },
      }
    }

    // Query payments
    const payments = await db.payment.findMany({
      where: {
        locationId,
        isOfflineCapture: true,
        ...(needsReconciliation ? { needsReconciliation: true } : {}),
        ...dateFilter,
      },
      include: {
        order: {
          select: {
            id: true,
            orderNumber: true,
            total: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    })

    // Calculate summary
    const summary = {
      totalCount: payments.length,
      totalAmount: payments.reduce((sum, p) => sum + Number(p.amount), 0),
      needingReconciliation: payments.filter((p) => p.needsReconciliation).length,
      reconciled: payments.filter((p) => !p.needsReconciliation).length,
    }

    return NextResponse.json({
      payments,
      summary,
    })
  } catch (error) {
    console.error('Failed to fetch offline payments:', error)
    return NextResponse.json(
      { error: 'Failed to fetch payments' },
      { status: 500 }
    )
  }
}

/**
 * PATCH /api/payments/sync
 *
 * Mark payments as reconciled
 */
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json()
    const { paymentIds, reconciledBy } = body

    if (!paymentIds || !Array.isArray(paymentIds) || paymentIds.length === 0) {
      return NextResponse.json(
        { error: 'Payment IDs are required' },
        { status: 400 }
      )
    }

    // Update all specified payments
    const result = await db.payment.updateMany({
      where: {
        id: { in: paymentIds },
      },
      data: {
        needsReconciliation: false,
        reconciledAt: new Date(),
        reconciledBy: reconciledBy || null,
      },
    })

    return NextResponse.json({
      success: true,
      count: result.count,
      message: `${result.count} payment(s) marked as reconciled`,
    })
  } catch (error) {
    console.error('Failed to reconcile payments:', error)
    return NextResponse.json(
      { error: 'Failed to reconcile payments' },
      { status: 500 }
    )
  }
}


================================================================================
SECTION 7: HARDWARE PAYMENT READER API ROUTES
================================================================================


================================================================================
SECTION 7: HARDWARE PAYMENT READER API ROUTES
================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/hardware/payment-readers/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

const DEFAULT_LOCATION_ID = 'loc-1'

// GET all payment readers for a location
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId') || DEFAULT_LOCATION_ID
    const activeOnly = searchParams.get('activeOnly') === 'true'

    const readers = await db.paymentReader.findMany({
      where: {
        locationId,
        deletedAt: null,
        ...(activeOnly && { isActive: true }),
      },
      include: {
        terminals: {
          select: {
            id: true,
            name: true,
            category: true,
          },
        },
      },
      orderBy: [{ sortOrder: 'asc' }, { name: 'asc' }],
    })

    return NextResponse.json({
      readers: readers.map((r) => ({
        ...r,
        avgResponseTime: r.avgResponseTime,
        successRate: r.successRate ? Number(r.successRate) : null,
        // Mask serial number for security (show last 6)
        serialNumberMasked: r.serialNumber.length > 6
          ? `...${r.serialNumber.slice(-6)}`
          : r.serialNumber,
      })),
    })
  } catch (error) {
    console.error('Failed to fetch payment readers:', error)
    return NextResponse.json({ error: 'Failed to fetch payment readers' }, { status: 500 })
  }
}

// POST create a new payment reader
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      locationId = DEFAULT_LOCATION_ID,
      name,
      serialNumber,
      ipAddress,
      port = 8080,
      verificationType = 'SERIAL_HANDSHAKE',
      merchantId,
      terminalId,
    } = body

    // Validate required fields
    if (!name || !serialNumber || !ipAddress) {
      return NextResponse.json(
        { error: 'Name, serial number, and IP address are required' },
        { status: 400 }
      )
    }

    // Validate IP address format
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/
    if (!ipv4Regex.test(ipAddress)) {
      return NextResponse.json({ error: 'Invalid IP address format' }, { status: 400 })
    }

    // Validate port range
    if (port < 1 || port > 65535) {
      return NextResponse.json({ error: 'Port must be between 1 and 65535' }, { status: 400 })
    }

    // Check for duplicate serial number
    const existingSerial = await db.paymentReader.findFirst({
      where: { serialNumber, deletedAt: null },
    })
    if (existingSerial) {
      return NextResponse.json(
        { error: 'A reader with this serial number already exists' },
        { status: 400 }
      )
    }

    // Check for duplicate IP at this location
    const existingIp = await db.paymentReader.findFirst({
      where: { locationId, ipAddress, deletedAt: null },
    })
    if (existingIp) {
      return NextResponse.json(
        { error: 'A reader with this IP address already exists at this location' },
        { status: 400 }
      )
    }

    const reader = await db.paymentReader.create({
      data: {
        locationId,
        name,
        serialNumber,
        ipAddress,
        port,
        verificationType,
        merchantId,
        terminalId,
        isActive: true,
        isOnline: false,
      },
    })

    return NextResponse.json({ reader })
  } catch (error) {
    console.error('Failed to create payment reader:', error)
    if (error instanceof Error && error.message.includes('Unique constraint')) {
      return NextResponse.json(
        { error: 'A reader with this name or IP already exists at this location' },
        { status: 400 }
      )
    }
    return NextResponse.json({ error: 'Failed to create payment reader' }, { status: 500 })
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/hardware/payment-readers/[id]/ping/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { getDatacapClient } from '@/lib/datacap/helpers'

// POST - Ping payment reader to check connectivity
// Uses EMVPadReset via DatacapClient — fast (2-3s) and confirms device is alive
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params

    const reader = await db.paymentReader.findFirst({
      where: { id, deletedAt: null },
      include: { location: { select: { id: true } } },
    })

    if (!reader) {
      return NextResponse.json({ error: 'Payment reader not found' }, { status: 404 })
    }

    const startTime = Date.now()

    try {
      const client = await getDatacapClient(reader.locationId)
      const response = await client.padReset(id)

      const responseTime = Date.now() - startTime
      const isOnline = response.cmdStatus === 'Success'

      // Update reader status
      await db.paymentReader.update({
        where: { id },
        data: {
          isOnline,
          lastSeenAt: isOnline ? new Date() : reader.lastSeenAt,
          avgResponseTime: responseTime,
          ...(isOnline && { lastError: null, lastErrorAt: null }),
        },
      })

      return NextResponse.json({
        success: isOnline,
        isOnline,
        responseTimeMs: responseTime,
      })
    } catch (fetchError) {
      const responseTime = Date.now() - startTime
      const errorMessage = fetchError instanceof Error ? fetchError.message : 'Connection failed'

      // Update reader as offline
      await db.paymentReader.update({
        where: { id },
        data: {
          isOnline: false,
          lastError: errorMessage,
          lastErrorAt: new Date(),
        },
      })

      return NextResponse.json({
        success: false,
        isOnline: false,
        error: errorMessage,
        responseTimeMs: responseTime,
      })
    }
  } catch (error) {
    console.error('Failed to ping payment reader:', error)
    return NextResponse.json({ error: 'Failed to ping payment reader' }, { status: 500 })
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/hardware/payment-readers/[id]/verify/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { getDatacapClient } from '@/lib/datacap/helpers'

// POST - Verify payment reader identity via EMVPadReset + optional beep
// EMVPadReset confirms the device is alive and responds to Datacap protocol
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json().catch(() => ({}))
    const { triggerBeep = false } = body

    const reader = await db.paymentReader.findFirst({
      where: { id, deletedAt: null },
    })

    if (!reader) {
      return NextResponse.json({ error: 'Payment reader not found' }, { status: 404 })
    }

    const startTime = Date.now()

    try {
      const client = await getDatacapClient(reader.locationId)
      const response = await client.padReset(id)

      const responseTime = Date.now() - startTime
      const isOnline = response.cmdStatus === 'Success'

      // Update reader status
      await db.paymentReader.update({
        where: { id },
        data: {
          isOnline,
          lastSeenAt: isOnline ? new Date() : reader.lastSeenAt,
          avgResponseTime: responseTime,
          lastError: isOnline ? null : response.textResponse || 'Verification failed',
          lastErrorAt: isOnline ? null : new Date(),
        },
      })

      // Trigger beep via a second pad reset (harmless, causes device activity)
      if (triggerBeep && isOnline) {
        try {
          await client.padReset(id)
        } catch {
          // Beep is optional
        }
      }

      return NextResponse.json({
        verified: isOnline,
        isOnline,
        responseTimeMs: responseTime,
        serialNumber: reader.serialNumber,
        beepTriggered: triggerBeep && isOnline,
      })
    } catch (fetchError) {
      const responseTime = Date.now() - startTime
      const errorMessage = fetchError instanceof Error ? fetchError.message : 'Connection failed'

      await db.paymentReader.update({
        where: { id },
        data: {
          isOnline: false,
          lastError: errorMessage,
          lastErrorAt: new Date(),
        },
      })

      return NextResponse.json({
        verified: false,
        isOnline: false,
        error: errorMessage,
        responseTimeMs: responseTime,
      })
    }
  } catch (error) {
    console.error('Failed to verify payment reader:', error)
    return NextResponse.json({ error: 'Failed to verify payment reader' }, { status: 500 })
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: src/app/api/hardware/payment-readers/[id]/route.ts
────────────────────────────────────────────────────────────────────────────────
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

// GET single payment reader
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params

    const reader = await db.paymentReader.findFirst({
      where: { id, deletedAt: null },
      include: {
        terminals: {
          select: {
            id: true,
            name: true,
            category: true,
          },
        },
        backupFor: {
          select: {
            id: true,
            name: true,
            category: true,
          },
        },
      },
    })

    if (!reader) {
      return NextResponse.json({ error: 'Payment reader not found' }, { status: 404 })
    }

    return NextResponse.json({
      reader: {
        ...reader,
        successRate: reader.successRate ? Number(reader.successRate) : null,
      },
    })
  } catch (error) {
    console.error('Failed to fetch payment reader:', error)
    return NextResponse.json({ error: 'Failed to fetch payment reader' }, { status: 500 })
  }
}

// PUT update payment reader
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()

    const existing = await db.paymentReader.findFirst({
      where: { id, deletedAt: null },
    })

    if (!existing) {
      return NextResponse.json({ error: 'Payment reader not found' }, { status: 404 })
    }

    const {
      name,
      serialNumber,
      ipAddress,
      port,
      verificationType,
      merchantId,
      terminalId,
      isActive,
      isOnline,
      lastSeenAt,
      lastError,
      lastErrorAt,
      firmwareVersion,
      avgResponseTime,
      successRate,
      sortOrder,
    } = body

    // Validate IP address format if provided
    if (ipAddress) {
      const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/
      if (!ipv4Regex.test(ipAddress)) {
        return NextResponse.json({ error: 'Invalid IP address format' }, { status: 400 })
      }
    }

    // Check for duplicate serial number (if changing)
    if (serialNumber && serialNumber !== existing.serialNumber) {
      const duplicateSerial = await db.paymentReader.findFirst({
        where: { serialNumber, deletedAt: null, id: { not: id } },
      })
      if (duplicateSerial) {
        return NextResponse.json(
          { error: 'A reader with this serial number already exists' },
          { status: 400 }
        )
      }
    }

    // Check for duplicate IP at this location (if changing)
    if (ipAddress && ipAddress !== existing.ipAddress) {
      const duplicateIp = await db.paymentReader.findFirst({
        where: { locationId: existing.locationId, ipAddress, deletedAt: null, id: { not: id } },
      })
      if (duplicateIp) {
        return NextResponse.json(
          { error: 'A reader with this IP address already exists at this location' },
          { status: 400 }
        )
      }
    }

    const reader = await db.paymentReader.update({
      where: { id },
      data: {
        ...(name !== undefined && { name }),
        ...(serialNumber !== undefined && { serialNumber }),
        ...(ipAddress !== undefined && { ipAddress }),
        ...(port !== undefined && { port }),
        ...(verificationType !== undefined && { verificationType }),
        ...(merchantId !== undefined && { merchantId }),
        ...(terminalId !== undefined && { terminalId }),
        ...(isActive !== undefined && { isActive }),
        ...(isOnline !== undefined && { isOnline }),
        ...(lastSeenAt !== undefined && { lastSeenAt: lastSeenAt ? new Date(lastSeenAt) : null }),
        ...(lastError !== undefined && { lastError }),
        ...(lastErrorAt !== undefined && { lastErrorAt: lastErrorAt ? new Date(lastErrorAt) : null }),
        ...(firmwareVersion !== undefined && { firmwareVersion }),
        ...(avgResponseTime !== undefined && { avgResponseTime }),
        ...(successRate !== undefined && { successRate }),
        ...(sortOrder !== undefined && { sortOrder }),
      },
    })

    return NextResponse.json({
      reader: {
        ...reader,
        successRate: reader.successRate ? Number(reader.successRate) : null,
      },
    })
  } catch (error) {
    console.error('Failed to update payment reader:', error)
    return NextResponse.json({ error: 'Failed to update payment reader' }, { status: 500 })
  }
}

// DELETE payment reader (soft delete)
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params

    const reader = await db.paymentReader.findFirst({
      where: { id, deletedAt: null },
      include: {
        terminals: true,
        backupFor: true,
      },
    })

    if (!reader) {
      return NextResponse.json({ error: 'Payment reader not found' }, { status: 404 })
    }

    // Check if reader is bound to any terminals
    if (reader.terminals.length > 0) {
      return NextResponse.json(
        { error: 'Cannot delete reader that is bound to terminals. Unbind first.' },
        { status: 400 }
      )
    }

    // Check if reader is backup for any terminals
    if (reader.backupFor.length > 0) {
      return NextResponse.json(
        { error: 'Cannot delete reader that is set as backup for terminals. Remove backup assignment first.' },
        { status: 400 }
      )
    }

    // Soft delete
    await db.paymentReader.update({
      where: { id },
      data: { deletedAt: new Date() },
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to delete payment reader:', error)
    return NextResponse.json({ error: 'Failed to delete payment reader' }, { status: 500 })
  }
}


================================================================================
END OF REVIEW DOCUMENT
================================================================================

SUMMARY OF FILES INCLUDED:

Datacap Library Files:
- src/lib/datacap/client.ts
- src/lib/datacap/constants.ts
- src/lib/datacap/discovery.ts
- src/lib/datacap/helpers.ts
- src/lib/datacap/sequence.ts
- src/lib/datacap/simulator.ts
- src/lib/datacap/types.ts
- src/lib/datacap/xml-builder.ts
- src/lib/datacap/xml-parser.ts

Payment Library Files:
- src/lib/payment.ts
- src/lib/payment-intent-manager.ts

Payment Components:
- All files in src/components/payment/

Type Definitions:
- src/types/payment.ts

Datacap API Routes:
- src/app/api/datacap/*/route.ts (all endpoints)

Payment API Routes:
- src/app/api/orders/[id]/pay/route.ts
- src/app/api/orders/[id]/payments/route.ts
- src/app/api/payments/sync/route.ts

Hardware API Routes:
- src/app/api/hardware/payment-readers/route.ts
- src/app/api/hardware/payment-readers/[id]/route.ts
- src/app/api/hardware/payment-readers/[id]/ping/route.ts
- src/app/api/hardware/payment-readers/[id]/verify/route.ts

================================================================================
