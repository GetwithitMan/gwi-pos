================================================================================
FLOOR PLAN CODE REVIEW - 2026-02-04
================================================================================

This file contains all Floor Plan domain code extracted for review.

TABLE OF CONTENTS:
- API Routes (13 files)
- Domain Components - Admin/Editor (7 files)
- Domain Components - Canvas (3 files)
- Domain Components - Groups (2 files)
- FOH View (2 files)
- Lib/Utils (2 files)
- Types (1 file)
- Prisma Schema Models

================================================================================
API ROUTES
================================================================================

================================================================================
FILE: /src/app/api/tables/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
     4	
     5	// Table status validation
     6	const VALID_STATUSES = ['available', 'occupied', 'dirty', 'reserved'] as const
     7	type TableStatus = typeof VALID_STATUSES[number]
     8	
     9	function isValidStatus(s: string | null): s is TableStatus {
    10	  return s !== null && VALID_STATUSES.includes(s as TableStatus)
    11	}
    12	
    13	// GET - List all tables for a location
    14	export async function GET(request: NextRequest) {
    15	  try {
    16	    const searchParams = request.nextUrl.searchParams
    17	    const locationId = searchParams.get('locationId')
    18	    const sectionId = searchParams.get('sectionId')
    19	    const rawStatus = searchParams.get('status')
    20	    const includeSeats = searchParams.get('includeSeats') === 'true'
    21	    const includeOrders = searchParams.get('includeOrders') === 'true'
    22	    const includeOrderItems = searchParams.get('includeOrderItems') === 'true'
    23	
    24	    if (!locationId) {
    25	      return NextResponse.json(
    26	        { error: 'Location ID is required' },
    27	        { status: 400 }
    28	      )
    29	    }
    30	
    31	    // Validate status parameter
    32	    const status = isValidStatus(rawStatus) ? rawStatus : undefined
    33	
    34	    const tables = await db.table.findMany({
    35	      where: {
    36	        locationId,
    37	        isActive: true,
    38	        deletedAt: null,
    39	        ...(sectionId ? { sectionId } : {}),
    40	        ...(status ? { status } : {}),
    41	      },
    42	      include: {
    43	        section: {
    44	          select: { id: true, name: true, color: true },
    45	        },
    46	        // Always include count (lightweight)
    47	        _count: {
    48	          select: {
    49	            seats: { where: { isActive: true, deletedAt: null } },
    50	          },
    51	        },
    52	        // Conditionally include orders
    53	        ...(includeOrders ? {
    54	          orders: {
    55	            where: { status: 'open', deletedAt: null },
    56	            select: {
    57	              id: true,
    58	              orderNumber: true,
    59	              guestCount: true,
    60	              total: true,
    61	              createdAt: true,
    62	              employee: {
    63	                select: { displayName: true, firstName: true, lastName: true },
    64	              },
    65	              ...(includeOrderItems ? {
    66	                items: {
    67	                  where: { deletedAt: null },
    68	                  select: {
    69	                    id: true,
    70	                    name: true,
    71	                    quantity: true,
    72	                    price: true,
    73	                  },
    74	                  orderBy: { createdAt: 'asc' as const },
    75	                  take: 10, // Limit for performance
    76	                },
    77	              } : {}),
    78	            },
    79	          },
    80	        } : {}),
    81	        // Conditionally include seats
    82	        ...(includeSeats ? {
    83	          seats: {
    84	            where: { isActive: true, deletedAt: null },
    85	            select: {
    86	              id: true,
    87	              label: true,
    88	              seatNumber: true,
    89	              relativeX: true,
    90	              relativeY: true,
    91	              angle: true,
    92	              seatType: true,
    93	            },
    94	            orderBy: { seatNumber: 'asc' },
    95	          },
    96	        } : {}),
    97	      },
    98	      orderBy: [
    99	        { section: { name: 'asc' } },
   100	        { name: 'asc' },
   101	      ],
   102	    })
   103	
   104	    return NextResponse.json({
   105	      tables: tables.map(table => ({
   106	        id: table.id,
   107	        name: table.name,
   108	        abbreviation: table.abbreviation,
   109	        capacity: table.capacity,
   110	        // Seat count from _count (always included, lightweight)
   111	        seatCount: table._count.seats,
   112	        posX: table.posX,
   113	        posY: table.posY,
   114	        width: table.width,
   115	        height: table.height,
   116	        rotation: table.rotation,
   117	        shape: table.shape,
   118	        seatPattern: table.seatPattern,
   119	        status: table.status,
   120	        section: table.section,
   121	        // Combine fields (Skill 106/107)
   122	        combinedWithId: table.combinedWithId,
   123	        combinedTableIds: table.combinedTableIds as string[] | null,
   124	        originalName: table.originalName,
   125	        // Original position for reset-to-default (T017)
   126	        originalPosX: table.originalPosX,
   127	        originalPosY: table.originalPosY,
   128	        // Locked status (T019) - bolted down furniture
   129	        isLocked: table.isLocked,
   130	        // Virtual combine fields
   131	        virtualGroupId: table.virtualGroupId,
   132	        virtualGroupPrimary: table.virtualGroupPrimary,
   133	        virtualGroupColor: table.virtualGroupColor,
   134	        // Seats (if requested)
   135	        seats: includeSeats && 'seats' in table ? table.seats : [],
   136	        // Current order info (if orders included)
   137	        currentOrder: (includeOrders && 'orders' in table && table.orders[0]) ? {
   138	          id: table.orders[0].id,
   139	          orderNumber: table.orders[0].orderNumber,
   140	          guestCount: table.orders[0].guestCount,
   141	          total: Number(table.orders[0].total),
   142	          openedAt: table.orders[0].createdAt.toISOString(),
   143	          server: (table.orders[0] as any).employee?.displayName ||
   144	            `${(table.orders[0] as any).employee?.firstName || ''} ${(table.orders[0] as any).employee?.lastName || ''}`.trim(),
   145	          // Order items for info panel (if requested)
   146	          items: includeOrderItems && 'items' in table.orders[0]
   147	            ? ((table.orders[0] as any).items as Array<{ id: string; name: string; quantity: number; price: unknown }>).map((item) => ({
   148	                id: item.id,
   149	                name: item.name,
   150	                quantity: item.quantity,
   151	                price: Number(item.price),
   152	              }))
   153	            : undefined,
   154	        } : null,
   155	      })),
   156	    })
   157	  } catch (error) {
   158	    console.error('Failed to fetch tables:', error)
   159	    return NextResponse.json(
   160	      { error: 'Failed to fetch tables' },
   161	      { status: 500 }
   162	    )
   163	  }
   164	}
   165	
   166	// POST - Create a new table
   167	export async function POST(request: NextRequest) {
   168	  try {
   169	    const body = await request.json()
   170	    const {
   171	      locationId,
   172	      sectionId,
   173	      name,
   174	      abbreviation,
   175	      capacity,
   176	      posX,
   177	      posY,
   178	      width,
   179	      height,
   180	      rotation,
   181	      shape,
   182	      seatPattern,
   183	    } = body
   184	
   185	    if (!locationId || !name) {
   186	      return NextResponse.json(
   187	        { error: 'Location ID and name are required' },
   188	        { status: 400 }
   189	      )
   190	    }
   191	
   192	    const tableCapacity = capacity ?? 4
   193	    const tableWidth = width ?? 100
   194	    const tableHeight = height ?? 100
   195	    const tableShape = shape ?? 'rectangle'
   196	    const tableSeatPattern = seatPattern ?? 'all_around'
   197	    const tableRotation = rotation ?? 0
   198	    const tablePosX = posX ?? 0
   199	    const tablePosY = posY ?? 0
   200	
   201	    // Create the table
   202	    const table = await db.table.create({
   203	      data: {
   204	        locationId,
   205	        sectionId: sectionId ?? null,
   206	        name,
   207	        abbreviation: abbreviation ?? null,
   208	        capacity: tableCapacity,
   209	        posX: tablePosX,
   210	        posY: tablePosY,
   211	        width: tableWidth,
   212	        height: tableHeight,
   213	        rotation: tableRotation,
   214	        shape: tableShape,
   215	        seatPattern: tableSeatPattern,
   216	      },
   217	      include: {
   218	        section: {
   219	          select: { id: true, name: true, color: true },
   220	        },
   221	        _count: {
   222	          select: {
   223	            seats: { where: { isActive: true, deletedAt: null } },
   224	          },
   225	        },
   226	      },
   227	    })
   228	
   229	    // Notify POS terminals of floor plan update
   230	    dispatchFloorPlanUpdate(locationId, { async: true })
   231	
   232	    return NextResponse.json({
   233	      table: {
   234	        id: table.id,
   235	        name: table.name,
   236	        abbreviation: table.abbreviation,
   237	        capacity: table.capacity,
   238	        seatCount: table._count.seats,
   239	        posX: table.posX,
   240	        posY: table.posY,
   241	        width: table.width,
   242	        height: table.height,
   243	        rotation: table.rotation,
   244	        shape: table.shape,
   245	        seatPattern: table.seatPattern,
   246	        status: table.status,
   247	        section: table.section,
   248	        combinedWithId: null,
   249	        combinedTableIds: null,
   250	        originalName: null,
   251	        originalPosX: null,
   252	        originalPosY: null,
   253	        isLocked: false,
   254	        currentOrder: null,
   255	      },
   256	    })
   257	  } catch (error) {
   258	    console.error('Failed to create table:', error)
   259	    return NextResponse.json(
   260	      { error: 'Failed to create table' },
   261	      { status: 500 }
   262	    )
   263	  }
   264	}

================================================================================
FILE: /src/app/api/tables/[id]/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
     4	import { softDeleteData } from '@/lib/floorplan/queries'
     5	import { Prisma } from '@prisma/client'
     6	
     7	// GET - Get a single table
     8	export async function GET(
     9	  request: NextRequest,
    10	  { params }: { params: Promise<{ id: string }> }
    11	) {
    12	  try {
    13	    const { id } = await params
    14	
    15	    const table = await db.table.findUnique({
    16	      where: { id },
    17	      include: {
    18	        section: {
    19	          select: { id: true, name: true, color: true },
    20	        },
    21	        orders: {
    22	          where: { status: 'open' },
    23	          include: {
    24	            employee: {
    25	              select: { displayName: true, firstName: true, lastName: true },
    26	            },
    27	            items: {
    28	              include: { modifiers: true },
    29	            },
    30	          },
    31	        },
    32	      },
    33	    })
    34	
    35	    if (!table) {
    36	      return NextResponse.json(
    37	        { error: 'Table not found' },
    38	        { status: 404 }
    39	      )
    40	    }
    41	
    42	    return NextResponse.json({
    43	      table: {
    44	        id: table.id,
    45	        name: table.name,
    46	        abbreviation: table.abbreviation,
    47	        capacity: table.capacity,
    48	        posX: table.posX,
    49	        posY: table.posY,
    50	        width: table.width,
    51	        height: table.height,
    52	        rotation: table.rotation,
    53	        shape: table.shape,
    54	        status: table.status,
    55	        section: table.section,
    56	        currentOrder: table.orders[0] ? {
    57	          id: table.orders[0].id,
    58	          orderNumber: table.orders[0].orderNumber,
    59	          guestCount: table.orders[0].guestCount,
    60	          total: Number(table.orders[0].total),
    61	          openedAt: table.orders[0].createdAt.toISOString(),
    62	          server: table.orders[0].employee?.displayName ||
    63	            `${table.orders[0].employee?.firstName || ''} ${table.orders[0].employee?.lastName || ''}`.trim(),
    64	          items: table.orders[0].items.map(item => ({
    65	            id: item.id,
    66	            name: item.name,
    67	            quantity: item.quantity,
    68	            price: Number(item.price),
    69	            modifiers: item.modifiers.map(m => ({
    70	              name: m.name,
    71	              price: Number(m.price),
    72	            })),
    73	          })),
    74	        } : null,
    75	      },
    76	    })
    77	  } catch (error) {
    78	    console.error('Failed to fetch table:', error)
    79	    return NextResponse.json(
    80	      { error: 'Failed to fetch table' },
    81	      { status: 500 }
    82	    )
    83	  }
    84	}
    85	
    86	// PUT - Update a table
    87	export async function PUT(
    88	  request: NextRequest,
    89	  { params }: { params: Promise<{ id: string }> }
    90	) {
    91	  try {
    92	    const { id } = await params
    93	    const body = await request.json()
    94	    const {
    95	      name,
    96	      abbreviation,
    97	      sectionId,
    98	      capacity,
    99	      posX,
   100	      posY,
   101	      width,
   102	      height,
   103	      rotation,
   104	      shape,
   105	      seatPattern,
   106	      status,
   107	    } = body
   108	
   109	    // Build type-safe update data
   110	    const updateData: Prisma.TableUpdateInput = {}
   111	
   112	    if (name !== undefined) updateData.name = name
   113	    if (abbreviation !== undefined) updateData.abbreviation = abbreviation ?? null
   114	    if (sectionId !== undefined) {
   115	      updateData.section = sectionId ? { connect: { id: sectionId } } : { disconnect: true }
   116	    }
   117	    if (capacity !== undefined) updateData.capacity = capacity
   118	    if (posX !== undefined) updateData.posX = posX
   119	    if (posY !== undefined) updateData.posY = posY
   120	    if (width !== undefined) updateData.width = width
   121	    if (height !== undefined) updateData.height = height
   122	    if (rotation !== undefined) updateData.rotation = rotation
   123	    if (shape !== undefined) updateData.shape = shape
   124	    if (seatPattern !== undefined) updateData.seatPattern = seatPattern
   125	    if (status !== undefined) updateData.status = status
   126	
   127	    // Update table (will throw P2025 if not found)
   128	    const table = await db.table.update({
   129	      where: { id },
   130	      data: updateData,
   131	      include: {
   132	        section: {
   133	          select: { id: true, name: true, color: true },
   134	        },
   135	        _count: {
   136	          select: {
   137	            seats: { where: { isActive: true, deletedAt: null } },
   138	          },
   139	        },
   140	      },
   141	    })
   142	
   143	    // Notify POS terminals of floor plan update
   144	    dispatchFloorPlanUpdate(table.locationId, { async: true })
   145	
   146	    return NextResponse.json({
   147	      table: {
   148	        id: table.id,
   149	        name: table.name,
   150	        abbreviation: table.abbreviation,
   151	        capacity: table.capacity,
   152	        seatCount: table._count.seats,
   153	        posX: table.posX,
   154	        posY: table.posY,
   155	        width: table.width,
   156	        height: table.height,
   157	        rotation: table.rotation,
   158	        shape: table.shape,
   159	        seatPattern: table.seatPattern,
   160	        status: table.status,
   161	        section: table.section,
   162	      },
   163	    })
   164	  } catch (error) {
   165	    // Handle Prisma P2025 error (record not found)
   166	    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
   167	      return NextResponse.json({ error: 'Table not found' }, { status: 404 })
   168	    }
   169	    console.error('Failed to update table:', error)
   170	    return NextResponse.json(
   171	      { error: 'Failed to update table' },
   172	      { status: 500 }
   173	    )
   174	  }
   175	}
   176	
   177	// DELETE - Delete (deactivate) a table
   178	export async function DELETE(
   179	  request: NextRequest,
   180	  { params }: { params: Promise<{ id: string }> }
   181	) {
   182	  try {
   183	    const { id } = await params
   184	
   185	    // Check for open orders
   186	    const openOrders = await db.order.count({
   187	      where: { tableId: id, status: 'open' },
   188	    })
   189	
   190	    if (openOrders > 0) {
   191	      return NextResponse.json(
   192	        { error: 'Cannot delete table with open orders' },
   193	        { status: 400 }
   194	      )
   195	    }
   196	
   197	    // Soft delete and get locationId for socket dispatch
   198	    const table = await db.table.update({
   199	      where: { id },
   200	      data: softDeleteData(),
   201	      select: { locationId: true },
   202	    })
   203	
   204	    // Notify POS terminals of floor plan update
   205	    dispatchFloorPlanUpdate(table.locationId, { async: true })
   206	
   207	    return NextResponse.json({ success: true })
   208	  } catch (error) {
   209	    console.error('Failed to delete table:', error)
   210	    return NextResponse.json(
   211	      { error: 'Failed to delete table' },
   212	      { status: 500 }
   213	    )
   214	  }
   215	}

================================================================================
FILE: /src/app/api/tables/[id]/seats/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
     4	
     5	// GET - List all seats for a table
     6	export async function GET(
     7	  request: NextRequest,
     8	  { params }: { params: Promise<{ id: string }> }
     9	) {
    10	  try {
    11	    const { id: tableId } = await params
    12	    const searchParams = request.nextUrl.searchParams
    13	    const includeInactive = searchParams.get('includeInactive') === 'true'
    14	
    15	    // Verify table exists
    16	    const table = await db.table.findUnique({
    17	      where: { id: tableId },
    18	      select: { id: true, name: true, shape: true, capacity: true, locationId: true },
    19	    })
    20	
    21	    if (!table) {
    22	      return NextResponse.json(
    23	        { error: 'Table not found' },
    24	        { status: 404 }
    25	      )
    26	    }
    27	
    28	    const seats = await db.seat.findMany({
    29	      where: {
    30	        tableId,
    31	        deletedAt: null,
    32	        ...(includeInactive ? {} : { isActive: true }),
    33	      },
    34	      orderBy: { seatNumber: 'asc' },
    35	    })
    36	
    37	    return NextResponse.json({
    38	      seats: seats.map(seat => ({
    39	        id: seat.id,
    40	        tableId: seat.tableId,
    41	        label: seat.label,
    42	        seatNumber: seat.seatNumber,
    43	        relativeX: seat.relativeX,
    44	        relativeY: seat.relativeY,
    45	        angle: seat.angle,
    46	        originalRelativeX: seat.originalRelativeX,
    47	        originalRelativeY: seat.originalRelativeY,
    48	        originalAngle: seat.originalAngle,
    49	        seatType: seat.seatType,
    50	        isActive: seat.isActive,
    51	      })),
    52	      table: {
    53	        id: table.id,
    54	        name: table.name,
    55	        shape: table.shape,
    56	        capacity: table.capacity,
    57	      },
    58	    })
    59	  } catch (error) {
    60	    console.error('Failed to fetch seats:', error)
    61	    return NextResponse.json(
    62	      { error: 'Failed to fetch seats' },
    63	      { status: 500 }
    64	    )
    65	  }
    66	}
    67	
    68	// POST - Add a seat to table
    69	export async function POST(
    70	  request: NextRequest,
    71	  { params }: { params: Promise<{ id: string }> }
    72	) {
    73	  try {
    74	    const { id: tableId } = await params
    75	    const body = await request.json()
    76	    const {
    77	      label,
    78	      seatNumber,
    79	      relativeX,
    80	      relativeY,
    81	      angle,
    82	      seatType,
    83	      insertAt,
    84	    } = body
    85	
    86	    // Verify table exists and get locationId
    87	    const table = await db.table.findUnique({
    88	      where: { id: tableId },
    89	      select: { id: true, locationId: true },
    90	    })
    91	
    92	    if (!table) {
    93	      return NextResponse.json(
    94	        { error: 'Table not found' },
    95	        { status: 404 }
    96	      )
    97	    }
    98	
    99	    // If insertAt is provided, renumber existing seats >= insertAt
   100	    if (insertAt !== undefined && insertAt > 0) {
   101	      await db.seat.updateMany({
   102	        where: {
   103	          tableId,
   104	          seatNumber: { gte: insertAt },
   105	          deletedAt: null,
   106	        },
   107	        data: {
   108	          seatNumber: { increment: 1 },
   109	        },
   110	      })
   111	    }
   112	
   113	    // Determine final seat number
   114	    let finalSeatNumber = seatNumber ?? insertAt
   115	    if (!finalSeatNumber) {
   116	      const maxSeat = await db.seat.findFirst({
   117	        where: { tableId, deletedAt: null },
   118	        orderBy: { seatNumber: 'desc' },
   119	        select: { seatNumber: true },
   120	      })
   121	      finalSeatNumber = (maxSeat?.seatNumber ?? 0) + 1
   122	    }
   123	
   124	    // Calculate final positions
   125	    const finalRelativeX = relativeX ?? 0
   126	    const finalRelativeY = relativeY ?? 0
   127	    const finalAngle = angle ?? 0
   128	
   129	    const seat = await db.seat.create({
   130	      data: {
   131	        locationId: table.locationId,
   132	        tableId,
   133	        label: label ?? String(finalSeatNumber),
   134	        seatNumber: finalSeatNumber,
   135	        relativeX: finalRelativeX,
   136	        relativeY: finalRelativeY,
   137	        angle: finalAngle,
   138	        seatType: seatType ?? 'standard',
   139	        // Save initial position as the "builder default" for restore after combine/split
   140	        originalRelativeX: finalRelativeX,
   141	        originalRelativeY: finalRelativeY,
   142	        originalAngle: finalAngle,
   143	      },
   144	    })
   145	
   146	    // Fetch all seats for UI update
   147	    const allSeats = await db.seat.findMany({
   148	      where: { tableId, deletedAt: null, isActive: true },
   149	      orderBy: { seatNumber: 'asc' },
   150	    })
   151	
   152	    // Notify POS terminals of floor plan update
   153	    dispatchFloorPlanUpdate(table.locationId, { async: true })
   154	
   155	    return NextResponse.json({
   156	      seat: {
   157	        id: seat.id,
   158	        tableId: seat.tableId,
   159	        label: seat.label,
   160	        seatNumber: seat.seatNumber,
   161	        relativeX: seat.relativeX,
   162	        relativeY: seat.relativeY,
   163	        angle: seat.angle,
   164	        seatType: seat.seatType,
   165	        isActive: seat.isActive,
   166	      },
   167	      seats: allSeats.map(s => ({
   168	        id: s.id,
   169	        label: s.label,
   170	        seatNumber: s.seatNumber,
   171	        relativeX: s.relativeX,
   172	        relativeY: s.relativeY,
   173	        angle: s.angle,
   174	        seatType: s.seatType,
   175	        isActive: s.isActive,
   176	      })),
   177	    })
   178	  } catch (error) {
   179	    console.error('Failed to create seat:', error)
   180	    return NextResponse.json(
   181	      { error: 'Failed to create seat' },
   182	      { status: 500 }
   183	    )
   184	  }
   185	}

================================================================================
FILE: /src/app/api/tables/[id]/seats/[seatId]/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	import { softDeleteData } from '@/lib/floorplan/queries'
     4	import { Prisma } from '@prisma/client'
     5	
     6	// GET - Get a single seat
     7	export async function GET(
     8	  request: NextRequest,
     9	  { params }: { params: Promise<{ id: string; seatId: string }> }
    10	) {
    11	  try {
    12	    const { id: tableId, seatId } = await params
    13	
    14	    const seat = await db.seat.findFirst({
    15	      where: {
    16	        id: seatId,
    17	        tableId,
    18	        isActive: true,
    19	        deletedAt: null,
    20	      },
    21	    })
    22	
    23	    if (!seat) {
    24	      return NextResponse.json(
    25	        { error: 'Seat not found' },
    26	        { status: 404 }
    27	      )
    28	    }
    29	
    30	    return NextResponse.json({
    31	      seat: {
    32	        id: seat.id,
    33	        tableId: seat.tableId,
    34	        label: seat.label,
    35	        seatNumber: seat.seatNumber,
    36	        relativeX: seat.relativeX,
    37	        relativeY: seat.relativeY,
    38	        angle: seat.angle,
    39	        seatType: seat.seatType,
    40	      },
    41	    })
    42	  } catch (error) {
    43	    console.error('Failed to fetch seat:', error)
    44	    return NextResponse.json(
    45	      { error: 'Failed to fetch seat' },
    46	      { status: 500 }
    47	    )
    48	  }
    49	}
    50	
    51	// PUT - Update a seat
    52	export async function PUT(
    53	  request: NextRequest,
    54	  { params }: { params: Promise<{ id: string; seatId: string }> }
    55	) {
    56	  try {
    57	    const { id: tableId, seatId } = await params
    58	    const body = await request.json()
    59	    const {
    60	      label,
    61	      seatNumber,
    62	      relativeX,
    63	      relativeY,
    64	      angle,
    65	      seatType,
    66	      updateOriginal = false, // If true, also update the "builder default" position
    67	    } = body
    68	
    69	    // Verify seat exists and belongs to this table
    70	    // Also check if table is part of a combined group
    71	    const existingSeat = await db.seat.findFirst({
    72	      where: {
    73	        id: seatId,
    74	        tableId,
    75	        isActive: true,
    76	        deletedAt: null,
    77	      },
    78	      include: {
    79	        table: {
    80	          select: {
    81	            combinedWithId: true,
    82	            combinedTableIds: true,
    83	          },
    84	        },
    85	      },
    86	    })
    87	
    88	    if (!existingSeat) {
    89	      return NextResponse.json(
    90	        { error: 'Seat not found' },
    91	        { status: 404 }
    92	      )
    93	    }
    94	
    95	    // Determine if we should update original positions
    96	    // Update originals if:
    97	    // 1. Explicitly requested (updateOriginal = true)
    98	    // 2. OR if the table is NOT combined (we're in the floor plan builder)
    99	    const isTableCombined = existingSeat.table.combinedWithId ||
   100	      (existingSeat.table.combinedTableIds && (existingSeat.table.combinedTableIds as string[]).length > 0)
   101	
   102	    const shouldUpdateOriginal = updateOriginal || !isTableCombined
   103	
   104	    // Build type-safe update data
   105	    const updateData: Prisma.SeatUpdateInput = {}
   106	
   107	    if (label !== undefined) updateData.label = label
   108	    if (seatNumber !== undefined) updateData.seatNumber = seatNumber
   109	    if (relativeX !== undefined) {
   110	      updateData.relativeX = relativeX
   111	      if (shouldUpdateOriginal) updateData.originalRelativeX = relativeX
   112	    }
   113	    if (relativeY !== undefined) {
   114	      updateData.relativeY = relativeY
   115	      if (shouldUpdateOriginal) updateData.originalRelativeY = relativeY
   116	    }
   117	    if (angle !== undefined) {
   118	      updateData.angle = angle
   119	      if (shouldUpdateOriginal) updateData.originalAngle = angle
   120	    }
   121	    if (seatType !== undefined) updateData.seatType = seatType
   122	
   123	    const seat = await db.seat.update({
   124	      where: { id: seatId },
   125	      data: updateData,
   126	    })
   127	
   128	    return NextResponse.json({
   129	      seat: {
   130	        id: seat.id,
   131	        tableId: seat.tableId,
   132	        label: seat.label,
   133	        seatNumber: seat.seatNumber,
   134	        relativeX: seat.relativeX,
   135	        relativeY: seat.relativeY,
   136	        angle: seat.angle,
   137	        seatType: seat.seatType,
   138	      },
   139	    })
   140	  } catch (error) {
   141	    console.error('Failed to update seat:', error)
   142	    return NextResponse.json(
   143	      { error: 'Failed to update seat' },
   144	      { status: 500 }
   145	    )
   146	  }
   147	}
   148	
   149	// DELETE - Delete (deactivate) a seat
   150	export async function DELETE(
   151	  request: NextRequest,
   152	  { params }: { params: Promise<{ id: string; seatId: string }> }
   153	) {
   154	  try {
   155	    const { id: tableId, seatId } = await params
   156	    const { searchParams } = new URL(request.url)
   157	    const employeeId = searchParams.get('employeeId')
   158	
   159	    // Verify seat exists and belongs to this table (with table info for logging)
   160	    const existingSeat = await db.seat.findFirst({
   161	      where: {
   162	        id: seatId,
   163	        tableId,
   164	        isActive: true,
   165	      },
   166	      include: {
   167	        table: {
   168	          select: { locationId: true, name: true },
   169	        },
   170	      },
   171	    })
   172	
   173	    if (!existingSeat) {
   174	      return NextResponse.json(
   175	        { error: 'Seat not found' },
   176	        { status: 404 }
   177	      )
   178	    }
   179	
   180	    // Check if seat has any active tickets (sold, held, or checked in)
   181	    const activeTickets = await db.ticket.count({
   182	      where: {
   183	        seatId,
   184	        status: { in: ['sold', 'held', 'checked_in'] },
   185	      },
   186	    })
   187	
   188	    if (activeTickets > 0) {
   189	      return NextResponse.json(
   190	        { error: 'Cannot delete seat with active tickets' },
   191	        { status: 400 }
   192	      )
   193	    }
   194	
   195	    // Use transaction to soft delete and log
   196	    await db.$transaction(async (tx) => {
   197	      // Soft delete
   198	      await tx.seat.update({
   199	        where: { id: seatId },
   200	        data: { isActive: false, deletedAt: new Date() },
   201	      })
   202	
   203	      // Audit log
   204	      await tx.auditLog.create({
   205	        data: {
   206	          locationId: existingSeat.table.locationId,
   207	          employeeId: employeeId || null,
   208	          action: 'seat_deleted',
   209	          entityType: 'seat',
   210	          entityId: seatId,
   211	          details: {
   212	            tableId,
   213	            tableName: existingSeat.table.name,
   214	            seatNumber: existingSeat.seatNumber,
   215	            seatLabel: existingSeat.label,
   216	          },
   217	        },
   218	      })
   219	    })
   220	
   221	    console.log(`[Seats] Deleted seat ${existingSeat.seatNumber} from table ${existingSeat.table.name}`)
   222	
   223	    return NextResponse.json({ success: true })
   224	  } catch (error) {
   225	    console.error('Failed to delete seat:', error)
   226	    return NextResponse.json(
   227	      { error: 'Failed to delete seat' },
   228	      { status: 500 }
   229	    )
   230	  }
   231	}

================================================================================
FILE: /src/app/api/tables/[id]/seats/auto-generate/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	import {
     4	  SEAT_RADIUS,
     5	  SEAT_DEFAULT_OFFSET,
     6	  SEAT_MIN_OFFSET,
     7	  SEAT_MAX_OFFSET,
     8	  ANGLE
     9	} from '@/lib/floorplan/constants'
    10	
    11	type SeatPattern = 'all_around' | 'front_only' | 'three_sides' | 'two_sides' | 'inside'
    12	type LabelPattern = 'numeric' | 'alpha' | 'alphanumeric'
    13	
    14	interface SeatPosition {
    15	  seatNumber: number
    16	  label: string
    17	  relativeX: number
    18	  relativeY: number
    19	  angle: number
    20	}
    21	
    22	function getLabel(index: number, pattern: LabelPattern): string {
    23	  switch (pattern) {
    24	    case 'alpha':
    25	      return String.fromCharCode(65 + index) // A, B, C...
    26	    case 'alphanumeric':
    27	      return `S${index + 1}` // S1, S2, S3...
    28	    default:
    29	      return String(index + 1) // 1, 2, 3...
    30	  }
    31	}
    32	
    33	// Available space interface
    34	interface AvailableSpace {
    35	  top?: number;
    36	  bottom?: number;
    37	  left?: number;
    38	  right?: number;
    39	}
    40	
    41	// Calculate dynamic offset based on available space
    42	function getDynamicOffset(availableSpace: number | undefined, baseOffset: number = SEAT_DEFAULT_OFFSET): number {
    43	  if (availableSpace === undefined) return baseOffset;
    44	
    45	  // Compress offset if space is limited
    46	  return Math.max(SEAT_MIN_OFFSET, Math.min(baseOffset, availableSpace - SEAT_RADIUS));
    47	}
    48	
    49	// Generate seats distributed around all 4 sides of a rectangle
    50	function generateSeatsAllAround(
    51	  tableWidth: number,
    52	  tableHeight: number,
    53	  count: number,
    54	  labelPattern: LabelPattern = 'numeric',
    55	  availableSpace?: AvailableSpace
    56	): SeatPosition[] {
    57	  const seats: SeatPosition[] = []
    58	  const baseOffset = 8; // Base distance from table edge
    59	
    60	  // Calculate dynamic offsets for each side
    61	  const topOffset = getDynamicOffset(availableSpace?.top, baseOffset);
    62	  const bottomOffset = getDynamicOffset(availableSpace?.bottom, baseOffset);
    63	  const leftOffset = getDynamicOffset(availableSpace?.left, baseOffset);
    64	  const rightOffset = getDynamicOffset(availableSpace?.right, baseOffset);
    65	
    66	  const perimeter = 2 * (tableWidth + tableHeight)
    67	  const spacing = perimeter / count
    68	
    69	  let currentDist = 0 // Start at top-left corner (was spacing/2 which centered on top edge)
    70	
    71	  for (let i = 0; i < count; i++) {
    72	    let x = 0, y = 0, angle = 0
    73	
    74	    if (currentDist < tableWidth) {
    75	      // Top side
    76	      x = -tableWidth / 2 + currentDist
    77	      y = -tableHeight / 2 - topOffset
    78	      angle = 180 // Facing down
    79	    } else if (currentDist < tableWidth + tableHeight) {
    80	      // Right side
    81	      const sideDist = currentDist - tableWidth
    82	      x = tableWidth / 2 + rightOffset
    83	      y = -tableHeight / 2 + sideDist
    84	      angle = 270 // Facing left
    85	    } else if (currentDist < 2 * tableWidth + tableHeight) {
    86	      // Bottom side
    87	      const sideDist = currentDist - tableWidth - tableHeight
    88	      x = tableWidth / 2 - sideDist
    89	      y = tableHeight / 2 + bottomOffset
    90	      angle = 0 // Facing up
    91	    } else {
    92	      // Left side
    93	      const sideDist = currentDist - 2 * tableWidth - tableHeight
    94	      x = -tableWidth / 2 - leftOffset
    95	      y = tableHeight / 2 - sideDist
    96	      angle = 90 // Facing right
    97	    }
    98	
    99	    seats.push({
   100	      seatNumber: i + 1,
   101	      label: getLabel(i, labelPattern),
   102	      relativeX: Math.round(x),
   103	      relativeY: Math.round(y),
   104	      angle,
   105	    })
   106	
   107	    currentDist += spacing
   108	    if (currentDist > perimeter) currentDist -= perimeter
   109	  }
   110	
   111	  return seats
   112	}
   113	
   114	// Generate seats in a row on front/bottom side only (for bar seating)
   115	function generateSeatsFrontOnly(
   116	  tableWidth: number,
   117	  tableHeight: number,
   118	  count: number,
   119	  labelPattern: LabelPattern = 'numeric',
   120	  availableSpace?: AvailableSpace
   121	): SeatPosition[] {
   122	  const seats: SeatPosition[] = []
   123	  const baseOffset = 8;
   124	  const bottomOffset = getDynamicOffset(availableSpace?.bottom, baseOffset);
   125	  const spacing = tableWidth / (count + 1)
   126	
   127	  for (let i = 0; i < count; i++) {
   128	    seats.push({
   129	      seatNumber: i + 1,
   130	      label: getLabel(i, labelPattern),
   131	      relativeX: Math.round(-tableWidth / 2 + spacing * (i + 1)),
   132	      relativeY: tableHeight / 2 + bottomOffset,
   133	      angle: ANGLE.UP, // Facing up toward the bar
   134	    })
   135	  }
   136	
   137	  return seats
   138	}
   139	
   140	// Generate seats on 3 sides (against wall - no back seats)
   141	function generateSeatsThreeSides(
   142	  tableWidth: number,
   143	  tableHeight: number,
   144	  count: number,
   145	  labelPattern: LabelPattern = 'numeric',
   146	  availableSpace?: AvailableSpace
   147	): SeatPosition[] {
   148	  const seats: SeatPosition[] = []
   149	  const baseOffset = 8;
   150	
   151	  // Calculate dynamic offsets for each side
   152	  const leftOffset = getDynamicOffset(availableSpace?.left, baseOffset);
   153	  const bottomOffset = getDynamicOffset(availableSpace?.bottom, baseOffset);
   154	  const rightOffset = getDynamicOffset(availableSpace?.right, baseOffset);
   155	
   156	  // Distribute: front gets more, sides split the rest
   157	  const frontSeats = Math.ceil(count / 2)
   158	  const sideSeatsTotal = count - frontSeats
   159	  const leftSeats = Math.floor(sideSeatsTotal / 2)
   160	  const rightSeats = sideSeatsTotal - leftSeats
   161	
   162	  let seatNum = 0
   163	
   164	  // Left side (facing right)
   165	  for (let i = 0; i < leftSeats; i++) {
   166	    const y = -tableHeight / 2 + (tableHeight / (leftSeats + 1)) * (i + 1)
   167	    seats.push({
   168	      seatNumber: seatNum + 1,
   169	      label: getLabel(seatNum, labelPattern),
   170	      relativeX: -tableWidth / 2 - leftOffset,
   171	      relativeY: Math.round(y),
   172	      angle: ANGLE.RIGHT,
   173	    })
   174	    seatNum++
   175	  }
   176	
   177	  // Front/bottom (facing up)
   178	  for (let i = 0; i < frontSeats; i++) {
   179	    const x = -tableWidth / 2 + (tableWidth / (frontSeats + 1)) * (i + 1)
   180	    seats.push({
   181	      seatNumber: seatNum + 1,
   182	      label: getLabel(seatNum, labelPattern),
   183	      relativeX: Math.round(x),
   184	      relativeY: tableHeight / 2 + bottomOffset,
   185	      angle: ANGLE.UP,
   186	    })
   187	    seatNum++
   188	  }
   189	
   190	  // Right side (facing left)
   191	  for (let i = 0; i < rightSeats; i++) {
   192	    const y = -tableHeight / 2 + (tableHeight / (rightSeats + 1)) * (i + 1)
   193	    seats.push({
   194	      seatNumber: seatNum + 1,
   195	      label: getLabel(seatNum, labelPattern),
   196	      relativeX: tableWidth / 2 + rightOffset,
   197	      relativeY: Math.round(y),
   198	      angle: ANGLE.LEFT,
   199	    })
   200	    seatNum++
   201	  }
   202	
   203	  return seats
   204	}
   205	
   206	// Generate seats on 2 adjacent sides (corner booth)
   207	function generateSeatsTwoSides(
   208	  tableWidth: number,
   209	  tableHeight: number,
   210	  count: number,
   211	  labelPattern: LabelPattern = 'numeric',
   212	  availableSpace?: AvailableSpace
   213	): SeatPosition[] {
   214	  const seats: SeatPosition[] = []
   215	  const baseOffset = 8;
   216	
   217	  // Calculate dynamic offsets for each side
   218	  const bottomOffset = getDynamicOffset(availableSpace?.bottom, baseOffset);
   219	  const rightOffset = getDynamicOffset(availableSpace?.right, baseOffset);
   220	
   221	  // Split between front and right sides
   222	  const frontSeats = Math.ceil(count / 2)
   223	  const rightSeats = count - frontSeats
   224	
   225	  let seatNum = 0
   226	
   227	  // Front/bottom (facing up)
   228	  for (let i = 0; i < frontSeats; i++) {
   229	    const x = -tableWidth / 2 + (tableWidth / (frontSeats + 1)) * (i + 1)
   230	    seats.push({
   231	      seatNumber: seatNum + 1,
   232	      label: getLabel(seatNum, labelPattern),
   233	      relativeX: Math.round(x),
   234	      relativeY: tableHeight / 2 + bottomOffset,
   235	      angle: ANGLE.UP,
   236	    })
   237	    seatNum++
   238	  }
   239	
   240	  // Right side (facing left)
   241	  for (let i = 0; i < rightSeats; i++) {
   242	    const y = -tableHeight / 2 + (tableHeight / (rightSeats + 1)) * (i + 1)
   243	    seats.push({
   244	      seatNumber: seatNum + 1,
   245	      label: getLabel(seatNum, labelPattern),
   246	      relativeX: tableWidth / 2 + rightOffset,
   247	      relativeY: Math.round(y),
   248	      angle: ANGLE.LEFT,
   249	    })
   250	    seatNum++
   251	  }
   252	
   253	  return seats
   254	}
   255	
   256	// Generate seats inside the table (booth interior)
   257	function generateSeatsInside(
   258	  tableWidth: number,
   259	  tableHeight: number,
   260	  count: number,
   261	  labelPattern: LabelPattern = 'numeric',
   262	  availableSpace?: AvailableSpace
   263	): SeatPosition[] {
   264	  const seats: SeatPosition[] = []
   265	  const innerPadding = 8
   266	
   267	  // Two rows: back and front of booth
   268	  const backSeats = Math.ceil(count / 2)
   269	  const frontSeats = count - backSeats
   270	
   271	  let seatNum = 0
   272	
   273	  // Back row (facing forward/down)
   274	  for (let i = 0; i < backSeats; i++) {
   275	    const x = -tableWidth / 2 + innerPadding + ((tableWidth - innerPadding * 2) / (backSeats + 1)) * (i + 1)
   276	    seats.push({
   277	      seatNumber: seatNum + 1,
   278	      label: getLabel(seatNum, labelPattern),
   279	      relativeX: Math.round(x),
   280	      relativeY: -tableHeight / 4, // Upper portion
   281	      angle: ANGLE.DOWN,
   282	    })
   283	    seatNum++
   284	  }
   285	
   286	  // Front row (facing back/up)
   287	  for (let i = 0; i < frontSeats; i++) {
   288	    const x = -tableWidth / 2 + innerPadding + ((tableWidth - innerPadding * 2) / (frontSeats + 1)) * (i + 1)
   289	    seats.push({
   290	      seatNumber: seatNum + 1,
   291	      label: getLabel(seatNum, labelPattern),
   292	      relativeX: Math.round(x),
   293	      relativeY: tableHeight / 4, // Lower portion
   294	      angle: ANGLE.UP,
   295	    })
   296	    seatNum++
   297	  }
   298	
   299	  return seats
   300	}
   301	
   302	// Generate seat positions based on pattern
   303	function generateSeatPositions(
   304	  tableWidth: number,
   305	  tableHeight: number,
   306	  count: number,
   307	  pattern: SeatPattern,
   308	  labelPattern: LabelPattern = 'numeric',
   309	  availableSpace?: AvailableSpace
   310	): SeatPosition[] {
   311	  switch (pattern) {
   312	    case 'front_only':
   313	      return generateSeatsFrontOnly(tableWidth, tableHeight, count, labelPattern, availableSpace)
   314	    case 'three_sides':
   315	      return generateSeatsThreeSides(tableWidth, tableHeight, count, labelPattern, availableSpace)
   316	    case 'two_sides':
   317	      return generateSeatsTwoSides(tableWidth, tableHeight, count, labelPattern, availableSpace)
   318	    case 'inside':
   319	      return generateSeatsInside(tableWidth, tableHeight, count, labelPattern, availableSpace)
   320	    case 'all_around':
   321	    default:
   322	      return generateSeatsAllAround(tableWidth, tableHeight, count, labelPattern, availableSpace)
   323	  }
   324	}
   325	
   326	// Collision detection constants
   327	const COLLISION_PADDING = 5 // Extra padding for collision checks
   328	
   329	interface CollisionResult {
   330	  hasCollisions: boolean
   331	  collisions: {
   332	    seatNumber: number
   333	    collidedWith: string // 'table:T1' or 'fixture:Wall' or 'seat:T2-S3'
   334	    type: 'table' | 'fixture' | 'seat'
   335	  }[]
   336	}
   337	
   338	// Check if a point collides with a rectangle (with rotation support)
   339	function pointInRotatedRect(
   340	  px: number,
   341	  py: number,
   342	  rectX: number,
   343	  rectY: number,
   344	  rectW: number,
   345	  rectH: number,
   346	  rectRotation: number = 0
   347	): boolean {
   348	  // Get rect center
   349	  const cx = rectX + rectW / 2
   350	  const cy = rectY + rectH / 2
   351	
   352	  // Translate point to rect's local space
   353	  const dx = px - cx
   354	  const dy = py - cy
   355	
   356	  // Rotate point in opposite direction
   357	  const rad = (-rectRotation * Math.PI) / 180
   358	  const cos = Math.cos(rad)
   359	  const sin = Math.sin(rad)
   360	  const localX = dx * cos - dy * sin
   361	  const localY = dx * sin + dy * cos
   362	
   363	  // Check if local point is within rect bounds (with padding for seat radius)
   364	  const halfW = rectW / 2 + SEAT_RADIUS + COLLISION_PADDING
   365	  const halfH = rectH / 2 + SEAT_RADIUS + COLLISION_PADDING
   366	
   367	  return Math.abs(localX) <= halfW && Math.abs(localY) <= halfH
   368	}
   369	
   370	// POST - Auto-generate seats for a table based on capacity and pattern
   371	export async function POST(
   372	  request: NextRequest,
   373	  { params }: { params: Promise<{ id: string }> }
   374	) {
   375	  try {
   376	    const { id: tableId } = await params
   377	    const body = await request.json()
   378	    const {
   379	      count,
   380	      seatPattern,
   381	      labelPattern = 'numeric',
   382	      replaceExisting = true,
   383	      updateTablePattern = true, // Also update table's seatPattern field
   384	      employeeId, // For audit logging
   385	      checkCollisions = true, // New: whether to check for collisions
   386	      forceGenerate = false, // New: generate even if collisions detected
   387	      availableSpace, // Optional: space available around table (for dynamic compression)
   388	    } = body
   389	
   390	    // Verify table exists and get details
   391	    const table = await db.table.findUnique({
   392	      where: { id: tableId },
   393	      select: {
   394	        id: true,
   395	        name: true,
   396	        locationId: true,
   397	        capacity: true,
   398	        width: true,
   399	        height: true,
   400	        posX: true,
   401	        posY: true,
   402	        rotation: true,
   403	        shape: true,
   404	        seatPattern: true,
   405	      },
   406	    })
   407	
   408	    if (!table) {
   409	      return NextResponse.json(
   410	        { error: 'Table not found' },
   411	        { status: 404 }
   412	      )
   413	    }
   414	
   415	    const seatCount = count || table.capacity
   416	
   417	    // Use provided pattern, or infer from table shape, or use table's existing pattern
   418	    let pattern: SeatPattern = seatPattern || (table.seatPattern as SeatPattern) || 'all_around'
   419	
   420	    // Auto-infer pattern from shape if not explicitly set
   421	    if (!seatPattern && table.seatPattern === 'all_around') {
   422	      if (table.shape === 'bar') pattern = 'front_only'
   423	      else if (table.shape === 'booth') pattern = 'inside'
   424	    }
   425	
   426	    // Generate seat positions based on pattern
   427	    const seatPositions = generateSeatPositions(
   428	      table.width,
   429	      table.height,
   430	      seatCount,
   431	      pattern,
   432	      labelPattern as LabelPattern,
   433	      availableSpace // Pass through optional available space for dynamic compression
   434	    )
   435	
   436	    // Check for collisions if requested
   437	    let collisionResult: CollisionResult = { hasCollisions: false, collisions: [] }
   438	
   439	    if (checkCollisions) {
   440	      // Skip collision checks if table hasn't been positioned yet
   441	      if (table.posX == null || table.posY == null) {
   442	        console.warn('[Seats] Skipping collision check - table has no position yet')
   443	        // Generate seats without collision checking
   444	      } else {
   445	        // Get all other tables in the location (for collision detection)
   446	        const otherTables = await db.table.findMany({
   447	          where: {
   448	            locationId: table.locationId,
   449	            id: { not: tableId },
   450	            isActive: true,
   451	            deletedAt: null,
   452	          },
   453	          select: {
   454	            id: true,
   455	            name: true,
   456	            posX: true,
   457	            posY: true,
   458	            width: true,
   459	            height: true,
   460	            rotation: true,
   461	            seats: {
   462	              where: { isActive: true, deletedAt: null },
   463	              select: {
   464	                id: true,
   465	                seatNumber: true,
   466	                relativeX: true,
   467	                relativeY: true,
   468	              },
   469	            },
   470	          },
   471	        })
   472	
   473	        // Get all fixtures (walls, bars) in the location
   474	        const fixtures = await db.floorPlanElement.findMany({
   475	          where: {
   476	            locationId: table.locationId,
   477	            deletedAt: null,
   478	          },
   479	          select: {
   480	            id: true,
   481	            name: true,
   482	            elementType: true,
   483	            posX: true,
   484	            posY: true,
   485	            width: true,
   486	            height: true,
   487	            rotation: true,
   488	          },
   489	        })
   490	
   491	        // Calculate table center for seat absolute positions
   492	        const tableCenterX = (table.posX ?? 0) + table.width / 2
   493	        const tableCenterY = (table.posY ?? 0) + table.height / 2
   494	        const tableRotation = (table.rotation ?? 0) * Math.PI / 180
   495	        const cos = Math.cos(tableRotation)
   496	        const sin = Math.sin(tableRotation)
   497	
   498	        // Check each generated seat for collisions
   499	        for (const seat of seatPositions) {
   500	          // Calculate absolute seat position (applying table rotation)
   501	          const rotatedX = seat.relativeX * cos - seat.relativeY * sin
   502	          const rotatedY = seat.relativeX * sin + seat.relativeY * cos
   503	          const seatAbsX = tableCenterX + rotatedX
   504	          const seatAbsY = tableCenterY + rotatedY
   505	
   506	          // Check against other tables
   507	          for (const otherTable of otherTables) {
   508	            // Skip tables with invalid positions
   509	            if (otherTable.posX == null || otherTable.posY == null) continue
   510	
   511	            if (pointInRotatedRect(
   512	              seatAbsX, seatAbsY,
   513	              otherTable.posX, otherTable.posY,
   514	              otherTable.width, otherTable.height,
   515	              otherTable.rotation ?? 0
   516	            )) {
   517	              collisionResult.hasCollisions = true
   518	              collisionResult.collisions.push({
   519	                seatNumber: seat.seatNumber,
   520	                collidedWith: `table:${otherTable.name || otherTable.id}`,
   521	                type: 'table',
   522	              })
   523	            }
   524	
   525	            // Check against seats of other tables
   526	            const otherTableCenterX = otherTable.posX + otherTable.width / 2
   527	            const otherTableCenterY = otherTable.posY + otherTable.height / 2
   528	            const otherRotation = (otherTable.rotation ?? 0) * Math.PI / 180
   529	            const otherCos = Math.cos(otherRotation)
   530	            const otherSin = Math.sin(otherRotation)
   531	
   532	            for (const otherSeat of otherTable.seats) {
   533	              const otherRotatedX = otherSeat.relativeX * otherCos - otherSeat.relativeY * otherSin
   534	              const otherRotatedY = otherSeat.relativeX * otherSin + otherSeat.relativeY * otherCos
   535	              const otherSeatAbsX = otherTableCenterX + otherRotatedX
   536	              const otherSeatAbsY = otherTableCenterY + otherRotatedY
   537	
   538	              const distance = Math.hypot(seatAbsX - otherSeatAbsX, seatAbsY - otherSeatAbsY)
   539	              if (distance < (SEAT_RADIUS * 2 + COLLISION_PADDING)) {
   540	                collisionResult.hasCollisions = true
   541	                collisionResult.collisions.push({
   542	                  seatNumber: seat.seatNumber,
   543	                  collidedWith: `seat:${otherTable.name || otherTable.id}-S${otherSeat.seatNumber}`,
   544	                  type: 'seat',
   545	                })
   546	              }
   547	            }
   548	          }
   549	
   550	          // Check against fixtures (walls, bars, etc.)
   551	          for (const fixture of fixtures) {
   552	            // Skip fixtures with invalid positions
   553	            if (fixture.posX == null || fixture.posY == null) continue
   554	
   555	            if (pointInRotatedRect(
   556	              seatAbsX, seatAbsY,
   557	              fixture.posX, fixture.posY,
   558	              fixture.width, fixture.height,
   559	              fixture.rotation ?? 0
   560	            )) {
   561	              collisionResult.hasCollisions = true
   562	              collisionResult.collisions.push({
   563	                seatNumber: seat.seatNumber,
   564	                collidedWith: `fixture:${fixture.name || fixture.elementType}`,
   565	                type: 'fixture',
   566	              })
   567	            }
   568	          }
   569	        }
   570	
   571	        // Log collisions but proceed anyway - let the user arrange tables as needed
   572	        if (collisionResult.hasCollisions) {
   573	          console.warn(`[Seats] Detected ${collisionResult.collisions.length} potential collisions, proceeding anyway`)
   574	        }
   575	      } // End else block (table has valid position)
   576	    } // End if (checkCollisions)
   577	
   578	    // Use transaction to replace existing seats and optionally update table pattern
   579	    const result = await db.$transaction(async (tx) => {
   580	      let deletedCount = 0
   581	
   582	      if (replaceExisting) {
   583	        // Hard delete existing seats to avoid unique constraint violation
   584	        // (tableId + seatNumber must be unique, soft delete doesn't clear this)
   585	        const deleted = await tx.seat.deleteMany({
   586	          where: { tableId },
   587	        })
   588	        deletedCount = deleted.count
   589	      }
   590	
   591	      // Update table's seatPattern if requested
   592	      if (updateTablePattern && seatPattern) {
   593	        await tx.table.update({
   594	          where: { id: tableId },
   595	          data: { seatPattern: pattern },
   596	        })
   597	      }
   598	
   599	      // Create new seats with original positions saved as "builder defaults"
   600	      const createdSeats = await Promise.all(
   601	        seatPositions.map(pos =>
   602	          tx.seat.create({
   603	            data: {
   604	              locationId: table.locationId,
   605	              tableId,
   606	              label: pos.label,
   607	              seatNumber: pos.seatNumber,
   608	              relativeX: pos.relativeX,
   609	              relativeY: pos.relativeY,
   610	              angle: pos.angle,
   611	              seatType: 'standard',
   612	              // Save as "builder default" for restore after combine/split
   613	              originalRelativeX: pos.relativeX,
   614	              originalRelativeY: pos.relativeY,
   615	              originalAngle: pos.angle,
   616	            },
   617	          })
   618	        )
   619	      )
   620	
   621	      // Audit log the seat regeneration
   622	      await tx.auditLog.create({
   623	        data: {
   624	          locationId: table.locationId,
   625	          employeeId: employeeId || null,
   626	          action: 'seats_regenerated',
   627	          entityType: 'table',
   628	          entityId: tableId,
   629	          details: {
   630	            tableName: table.name || tableId,
   631	            previousSeatsDeleted: deletedCount,
   632	            newSeatsCreated: createdSeats.length,
   633	            seatPattern: pattern,
   634	            labelPattern,
   635	          },
   636	        },
   637	      })
   638	
   639	      console.log(`[Seats] Regenerated ${createdSeats.length} seats for table (deleted ${deletedCount} previous)`)
   640	
   641	      return createdSeats
   642	    })
   643	
   644	    return NextResponse.json({
   645	      seats: result.map(seat => ({
   646	        id: seat.id,
   647	        tableId: seat.tableId,
   648	        label: seat.label,
   649	        seatNumber: seat.seatNumber,
   650	        relativeX: seat.relativeX,
   651	        relativeY: seat.relativeY,
   652	        angle: seat.angle,
   653	        seatType: seat.seatType,
   654	      })),
   655	      generated: result.length,
   656	      seatPattern: pattern,
   657	      // Include collision warning if seats were forced despite collisions
   658	      ...(collisionResult.hasCollisions ? {
   659	        warning: 'Seats generated with collisions (forceGenerate was true)',
   660	        collisions: collisionResult.collisions,
   661	      } : {}),
   662	    })
   663	  } catch (error) {
   664	    console.error('Failed to auto-generate seats:', error)
   665	    // Return detailed error for debugging
   666	    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
   667	    const errorStack = error instanceof Error ? error.stack : undefined
   668	    return NextResponse.json(
   669	      {
   670	        error: 'Failed to auto-generate seats',
   671	        details: errorMessage,
   672	        stack: process.env.NODE_ENV === 'development' ? errorStack : undefined
   673	      },
   674	      { status: 500 }
   675	    )
   676	  }
   677	}

================================================================================
FILE: /src/app/api/tables/[id]/seats/generate/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server';
     2	import { db } from '@/lib/db';
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';
     4	import { generateSeatPositions, type SeatPattern } from '@/lib/seat-generation';
     5	
     6	// POST - Generate/regenerate default seat layout
     7	export async function POST(
     8	  request: NextRequest,
     9	  { params }: { params: Promise<{ id: string }> }
    10	) {
    11	  try {
    12	    const { id: tableId } = await params;
    13	    const body = await request.json();
    14	    const {
    15	      pattern,
    16	      count,
    17	      saveAsDefault = false,
    18	    } = body;
    19	
    20	    // Get table details
    21	    const table = await db.table.findUnique({
    22	      where: { id: tableId },
    23	      select: {
    24	        id: true,
    25	        locationId: true,
    26	        name: true,
    27	        width: true,
    28	        height: true,
    29	        shape: true,
    30	        capacity: true,
    31	        seatPattern: true,
    32	      },
    33	    });
    34	
    35	    if (!table) {
    36	      return NextResponse.json(
    37	        { error: 'Table not found' },
    38	        { status: 404 }
    39	      );
    40	    }
    41	
    42	    // Use defaults from table if not provided
    43	    const finalPattern = (pattern || table.seatPattern || 'all_around') as SeatPattern;
    44	    const finalCount = count || table.capacity;
    45	
    46	    // Generate seat positions using params object
    47	    const seatPositions = generateSeatPositions({
    48	      shape: (table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth') || 'rectangle',
    49	      pattern: finalPattern,
    50	      capacity: finalCount,
    51	      width: table.width,
    52	      height: table.height,
    53	    });
    54	
    55	    // Hard delete existing seats to avoid unique constraint violation
    56	    // (tableId + seatNumber must be unique, soft delete doesn't clear this)
    57	    await db.seat.deleteMany({
    58	      where: { tableId },
    59	    });
    60	
    61	    // Create new seats
    62	    const createdSeats = await Promise.all(
    63	      seatPositions.map((pos) =>
    64	        db.seat.create({
    65	          data: {
    66	            locationId: table.locationId,
    67	            tableId,
    68	            seatNumber: pos.seatNumber,
    69	            label: String(pos.seatNumber), // Generate label from seat number
    70	            relativeX: pos.relativeX,
    71	            relativeY: pos.relativeY,
    72	            angle: pos.angle,
    73	            seatType: 'standard',
    74	            // If saveAsDefault, set original positions for restore capability
    75	            ...(saveAsDefault
    76	              ? {
    77	                  originalRelativeX: pos.relativeX,
    78	                  originalRelativeY: pos.relativeY,
    79	                  originalAngle: pos.angle,
    80	                }
    81	              : {}),
    82	          },
    83	        })
    84	      )
    85	    );
    86	
    87	    // Notify POS terminals of floor plan update
    88	    dispatchFloorPlanUpdate(table.locationId, { async: true });
    89	
    90	    return NextResponse.json({
    91	      seats: createdSeats.map((s) => ({
    92	        id: s.id,
    93	        label: s.label,
    94	        seatNumber: s.seatNumber,
    95	        relativeX: s.relativeX,
    96	        relativeY: s.relativeY,
    97	        angle: s.angle,
    98	        seatType: s.seatType,
    99	        isActive: s.isActive,
   100	      })),
   101	    });
   102	  } catch (error) {
   103	    console.error('Failed to generate seats:', error);
   104	    return NextResponse.json(
   105	      { error: 'Failed to generate seats' },
   106	      { status: 500 }
   107	    );
   108	  }
   109	}

================================================================================
FILE: /src/app/api/tables/[id]/seats/reflow/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server';
     2	import { db } from '@/lib/db';
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';
     4	
     5	// POST - Reflow seats when table is resized
     6	export async function POST(
     7	  request: NextRequest,
     8	  { params }: { params: Promise<{ id: string }> }
     9	) {
    10	  try {
    11	    const { id: tableId } = await params;
    12	    const body = await request.json();
    13	    const { oldWidth, oldHeight, newWidth, newHeight, availableSpace } = body;
    14	
    15	    if (!oldWidth || !oldHeight || !newWidth || !newHeight) {
    16	      return NextResponse.json(
    17	        { error: 'Missing dimension parameters' },
    18	        { status: 400 }
    19	      );
    20	    }
    21	
    22	    // Helper to calculate dynamic clearance based on available space
    23	    const getDynamicClearance = (availableSpace: number | undefined, baseClearance: number = 25): number => {
    24	      const SEAT_RADIUS = 20;
    25	      const MIN_CLEARANCE = 10;
    26	      const MAX_CLEARANCE = 50;
    27	
    28	      if (availableSpace === undefined) return baseClearance;
    29	
    30	      // Compress clearance if space is limited
    31	      return Math.max(MIN_CLEARANCE, Math.min(baseClearance, availableSpace - SEAT_RADIUS));
    32	    };
    33	
    34	    // Get table and its active seats
    35	    const table = await db.table.findUnique({
    36	      where: { id: tableId },
    37	      include: {
    38	        seats: {
    39	          where: { isActive: true, deletedAt: null },
    40	          orderBy: { seatNumber: 'asc' },
    41	        },
    42	      },
    43	    });
    44	
    45	    if (!table) {
    46	      return NextResponse.json(
    47	        { error: 'Table not found' },
    48	        { status: 404 }
    49	      );
    50	    }
    51	
    52	    // Calculate dynamic clearance for each side
    53	    const baseClearance = 25;
    54	    const topClearance = getDynamicClearance(availableSpace?.top, baseClearance);
    55	    const bottomClearance = getDynamicClearance(availableSpace?.bottom, baseClearance);
    56	    const leftClearance = getDynamicClearance(availableSpace?.left, baseClearance);
    57	    const rightClearance = getDynamicClearance(availableSpace?.right, baseClearance);
    58	
    59	    // Handle round/oval tables differently
    60	    const isRoundTable = table.shape === 'round' || table.shape === 'oval';
    61	
    62	    // Update each seat's position using edge-relative positioning
    63	    const updatedSeats = await Promise.all(
    64	      table.seats.map((seat) => {
    65	        const oldHalfW = oldWidth / 2;
    66	        const oldHalfH = oldHeight / 2;
    67	        const newHalfW = newWidth / 2;
    68	        const newHalfH = newHeight / 2;
    69	
    70	        let newRelX: number;
    71	        let newRelY: number;
    72	
    73	        if (isRoundTable) {
    74	          // For round/oval tables: maintain radial distance from center
    75	          // Calculate current angle and distance from center
    76	          const currentAngle = Math.atan2(seat.relativeY, seat.relativeX);
    77	
    78	          // Use average clearance for round tables (simplified)
    79	          const avgClearance = (topClearance + bottomClearance + leftClearance + rightClearance) / 4;
    80	
    81	          // For oval, use ellipse formula; for round, use circle
    82	          let newRadius: number;
    83	          if (table.shape === 'oval') {
    84	            // Ellipse: maintain position on ellipse perimeter + clearance
    85	            newRadius = Math.sqrt(
    86	              Math.pow(newHalfW * Math.cos(currentAngle), 2) +
    87	              Math.pow(newHalfH * Math.sin(currentAngle), 2)
    88	            ) + avgClearance;
    89	          } else {
    90	            // Circle: use smaller dimension as radius
    91	            newRadius = Math.min(newHalfW, newHalfH) + avgClearance;
    92	          }
    93	
    94	          newRelX = newRadius * Math.cos(currentAngle);
    95	          newRelY = newRadius * Math.sin(currentAngle);
    96	        } else {
    97	          // For rectangular tables: determine which edge the seat belongs to
    98	          const absX = Math.abs(seat.relativeX);
    99	          const absY = Math.abs(seat.relativeY);
   100	
   101	          // Normalize to see which edge dominates
   102	          const normalizedX = absX / oldHalfW;  // 0 = center, 1 = edge
   103	          const normalizedY = absY / oldHalfH;
   104	
   105	          if (normalizedY >= normalizedX) {
   106	            // Seat is on top or bottom edge
   107	            // Use dynamic clearance based on side
   108	            const direction = seat.relativeY >= 0 ? 1 : -1;
   109	            const clearance = direction > 0 ? bottomClearance : topClearance;
   110	            newRelY = direction * (newHalfH + clearance);
   111	
   112	            // Scale X position proportionally along the edge
   113	            newRelX = seat.relativeX * (newWidth / oldWidth);
   114	          } else {
   115	            // Seat is on left or right edge
   116	            // Use dynamic clearance based on side
   117	            const direction = seat.relativeX >= 0 ? 1 : -1;
   118	            const clearance = direction > 0 ? rightClearance : leftClearance;
   119	            newRelX = direction * (newHalfW + clearance);
   120	
   121	            // Scale Y position proportionally along the edge
   122	            newRelY = seat.relativeY * (newHeight / oldHeight);
   123	          }
   124	        }
   125	
   126	        // Update seat position
   127	        return db.seat.update({
   128	          where: { id: seat.id },
   129	          data: {
   130	            relativeX: Math.round(newRelX),
   131	            relativeY: Math.round(newRelY),
   132	          },
   133	        });
   134	      })
   135	    );
   136	
   137	    // Notify POS terminals of floor plan update
   138	    dispatchFloorPlanUpdate(table.locationId, { async: true });
   139	
   140	    return NextResponse.json({
   141	      seats: updatedSeats.map((s) => ({
   142	        id: s.id,
   143	        seatNumber: s.seatNumber,
   144	        label: s.label,
   145	        relativeX: s.relativeX,
   146	        relativeY: s.relativeY,
   147	        angle: s.angle,
   148	      })),
   149	      message: `Reflowed ${updatedSeats.length} seats`,
   150	    });
   151	  } catch (error) {
   152	    console.error('Failed to reflow seats:', error);
   153	    return NextResponse.json(
   154	      { error: 'Failed to reflow seats' },
   155	      { status: 500 }
   156	    );
   157	  }
   158	}

================================================================================
FILE: /src/app/api/tables/virtual-combine/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	import { tableEvents } from '@/lib/realtime/table-events'
     4	import {
     5	  calculateVirtualSeatNumbers,
     6	  type TableWithSeats,
     7	} from '@/lib/virtual-group-seats'
     8	
     9	// Color palette for virtual groups (distinct from physical combine)
    10	const VIRTUAL_GROUP_COLORS = [
    11	  '#06b6d4', // cyan
    12	  '#84cc16', // lime
    13	  '#f472b6', // pink
    14	  '#a855f7', // purple
    15	  '#fb923c', // orange
    16	  '#34d399', // emerald
    17	  '#60a5fa', // blue
    18	  '#fbbf24', // amber
    19	]
    20	
    21	/**
    22	 * Get a consistent color for a virtual group based on its ID
    23	 */
    24	function getVirtualGroupColor(groupId: string): string {
    25	  let hash = 0
    26	  for (let i = 0; i < groupId.length; i++) {
    27	    hash = ((hash << 5) - hash) + groupId.charCodeAt(i)
    28	    hash = hash & hash // Convert to 32bit integer
    29	  }
    30	  return VIRTUAL_GROUP_COLORS[Math.abs(hash) % VIRTUAL_GROUP_COLORS.length]
    31	}
    32	
    33	/**
    34	 * POST /api/tables/virtual-combine
    35	 *
    36	 * Create a virtual group from selected tables:
    37	 * - Tables remain in their physical positions (no movement)
    38	 * - Each table keeps its own seat numbers (T2-S1 notation)
    39	 * - Tables share a single order on the primary table
    40	 * - All tables get matching pulsing glow color
    41	 *
    42	 * If any tables have existing orders, returns requiresAction=true
    43	 * with the list of orders that need to be handled (merge or close)
    44	 */
    45	export async function POST(request: NextRequest) {
    46	  try {
    47	    const body = await request.json()
    48	    const {
    49	      tableIds,
    50	      primaryTableId,
    51	      locationId,
    52	      employeeId,
    53	      existingOrderActions, // Optional: { orderId, action: 'merge' | 'close' }[]
    54	    } = body
    55	
    56	    if (!tableIds || !Array.isArray(tableIds) || tableIds.length < 2) {
    57	      return NextResponse.json(
    58	        { error: 'At least 2 table IDs are required' },
    59	        { status: 400 }
    60	      )
    61	    }
    62	
    63	    if (!primaryTableId || !tableIds.includes(primaryTableId)) {
    64	      return NextResponse.json(
    65	        { error: 'primaryTableId must be one of the selected tables' },
    66	        { status: 400 }
    67	      )
    68	    }
    69	
    70	    if (!locationId) {
    71	      return NextResponse.json(
    72	        { error: 'locationId is required' },
    73	        { status: 400 }
    74	      )
    75	    }
    76	
    77	    // Fetch all selected tables
    78	    const tables = await db.table.findMany({
    79	      where: {
    80	        id: { in: tableIds },
    81	        locationId,
    82	        deletedAt: null,
    83	      },
    84	      include: {
    85	        orders: {
    86	          where: { status: 'open', deletedAt: null },
    87	          include: {
    88	            items: {
    89	              where: { deletedAt: null },
    90	              select: { id: true, name: true, price: true, quantity: true },
    91	            },
    92	          },
    93	        },
    94	      },
    95	    })
    96	
    97	    if (tables.length !== tableIds.length) {
    98	      return NextResponse.json(
    99	        { error: 'One or more tables not found' },
   100	        { status: 404 }
   101	      )
   102	    }
   103	
   104	    // Check if any table is already in a virtual group
   105	    const alreadyGrouped = tables.find(t => t.virtualGroupId)
   106	    if (alreadyGrouped) {
   107	      return NextResponse.json(
   108	        { error: `Table "${alreadyGrouped.name}" is already in a virtual group` },
   109	        { status: 400 }
   110	      )
   111	    }
   112	
   113	    // Check if any table is already physically combined
   114	    const alreadyCombined = tables.find(t => t.combinedWithId || (t.combinedTableIds && (t.combinedTableIds as string[]).length > 0))
   115	    if (alreadyCombined) {
   116	      return NextResponse.json(
   117	        { error: `Table "${alreadyCombined.name}" is already physically combined` },
   118	        { status: 400 }
   119	      )
   120	    }
   121	
   122	    // Check for existing orders that need handling
   123	    const tablesWithOrders = tables.filter(t => t.orders.length > 0)
   124	    const secondaryTablesWithOrders = tablesWithOrders.filter(t => t.id !== primaryTableId)
   125	
   126	    // If there are secondary tables with orders and no actions provided, return requiresAction
   127	    if (secondaryTablesWithOrders.length > 0 && !existingOrderActions) {
   128	      return NextResponse.json({
   129	        requiresAction: true,
   130	        existingOrders: secondaryTablesWithOrders.map(t => ({
   131	          tableId: t.id,
   132	          tableName: t.name,
   133	          orderId: t.orders[0].id,
   134	          orderNumber: t.orders[0].orderNumber,
   135	          itemCount: t.orders[0].items.length,
   136	          total: Number(t.orders[0].total),
   137	        })),
   138	        message: 'Some tables have open orders that need to be handled',
   139	      })
   140	    }
   141	
   142	    // Generate virtual group ID and color
   143	    const virtualGroupId = crypto.randomUUID()
   144	    const virtualGroupColor = getVirtualGroupColor(virtualGroupId)
   145	    const virtualGroupCreatedAt = new Date()
   146	
   147	    // Start transaction
   148	    const result = await db.$transaction(async (tx) => {
   149	      const primaryTable = tables.find(t => t.id === primaryTableId)!
   150	      const primaryOrder = primaryTable.orders[0]
   151	
   152	      // Handle existing orders on secondary tables
   153	      if (existingOrderActions && Array.isArray(existingOrderActions)) {
   154	        for (const action of existingOrderActions) {
   155	          const { orderId, action: orderAction } = action
   156	          const table = tables.find(t => t.orders.some(o => o.id === orderId))
   157	
   158	          if (!table || table.id === primaryTableId) continue
   159	
   160	          const order = table.orders.find(o => o.id === orderId)
   161	          if (!order) continue
   162	
   163	          if (orderAction === 'merge') {
   164	            // Merge items into primary order
   165	            if (primaryOrder) {
   166	              // Move items to primary order, setting sourceTableId
   167	              await tx.orderItem.updateMany({
   168	                where: {
   169	                  orderId: order.id,
   170	                  locationId,
   171	                  deletedAt: null,
   172	                },
   173	                data: {
   174	                  orderId: primaryOrder.id,
   175	                  sourceTableId: table.id, // Track which table this came from
   176	                },
   177	              })
   178	
   179	              // Update primary order totals
   180	              const newGuestCount = primaryOrder.guestCount + order.guestCount
   181	              const combinedSubtotal = Number(primaryOrder.subtotal) + Number(order.subtotal)
   182	              const combinedTax = Number(primaryOrder.taxTotal) + Number(order.taxTotal)
   183	              const combinedTotal = Number(primaryOrder.total) + Number(order.total)
   184	
   185	              await tx.order.update({
   186	                where: { id: primaryOrder.id },
   187	                data: {
   188	                  guestCount: newGuestCount,
   189	                  subtotal: combinedSubtotal,
   190	                  taxTotal: combinedTax,
   191	                  total: combinedTotal,
   192	                  notes: primaryOrder.notes
   193	                    ? `${primaryOrder.notes}\n[Merged from ${table.name}]`
   194	                    : `[Merged from ${table.name}]`,
   195	                },
   196	              })
   197	
   198	              // Mark original order as merged (prevents double-counting in EOD)
   199	              await tx.order.update({
   200	                where: { id: order.id },
   201	                data: {
   202	                  status: 'merged',
   203	                  notes: `Merged into order #${primaryOrder.orderNumber} (virtual group)`,
   204	                },
   205	              })
   206	            } else {
   207	              // No primary order - reassign this order to primary table
   208	              // and set sourceTableId on items
   209	              await tx.orderItem.updateMany({
   210	                where: {
   211	                  orderId: order.id,
   212	                  locationId,
   213	                  deletedAt: null,
   214	                },
   215	                data: {
   216	                  sourceTableId: table.id,
   217	                },
   218	              })
   219	
   220	              await tx.order.update({
   221	                where: { id: order.id },
   222	                data: {
   223	                  tableId: primaryTableId,
   224	                },
   225	              })
   226	            }
   227	          }
   228	          // 'close' action would redirect to payment flow - handled by frontend
   229	        }
   230	      }
   231	
   232	      // Update all tables with virtual group info
   233	      for (const table of tables) {
   234	        await tx.table.update({
   235	          where: { id: table.id },
   236	          data: {
   237	            virtualGroupId,
   238	            virtualGroupPrimary: table.id === primaryTableId,
   239	            virtualGroupColor,
   240	            virtualGroupCreatedAt,
   241	            // Update status to occupied if any table has an order
   242	            status: tablesWithOrders.length > 0 ? 'occupied' : table.status,
   243	          },
   244	        })
   245	      }
   246	
   247	      // Handle seat renumbering for virtual group
   248	      // Fetch all seats for the tables in the group
   249	      const allSeats = await tx.seat.findMany({
   250	        where: {
   251	          tableId: { in: tableIds },
   252	          isActive: true,
   253	          deletedAt: null,
   254	        },
   255	        select: {
   256	          id: true,
   257	          tableId: true,
   258	          seatNumber: true,
   259	          label: true,
   260	          relativeX: true,
   261	          relativeY: true,
   262	        },
   263	        orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
   264	      })
   265	
   266	      if (allSeats.length > 0) {
   267	        // Prepare table data for virtual seat calculation
   268	        const tablesWithSeats: TableWithSeats[] = tables.map((table) => ({
   269	          id: table.id,
   270	          name: table.name,
   271	          posX: table.posX,
   272	          posY: table.posY,
   273	          seats: allSeats
   274	            .filter((seat) => seat.tableId === table.id)
   275	            .map((seat) => ({
   276	              id: seat.id,
   277	              seatNumber: seat.seatNumber,
   278	              label: seat.label,
   279	              relativeX: seat.relativeX,
   280	              relativeY: seat.relativeY,
   281	            })),
   282	        }))
   283	
   284	        // Calculate virtual seat numbers (primary table first, then others clockwise)
   285	        const virtualSeatInfo = calculateVirtualSeatNumbers(
   286	          primaryTableId,
   287	          tablesWithSeats
   288	        )
   289	
   290	        // Update each seat with virtual label (e.g., "T1-3")
   291	        for (const seatInfo of virtualSeatInfo) {
   292	          await tx.seat.update({
   293	            where: { id: seatInfo.seatId },
   294	            data: {
   295	              label: seatInfo.virtualLabel, // Store "TableName-SeatNum" format
   296	            },
   297	          })
   298	        }
   299	      }
   300	
   301	      // Create audit log
   302	      await tx.auditLog.create({
   303	        data: {
   304	          locationId,
   305	          employeeId: employeeId || null,
   306	          action: 'virtual_group_created',
   307	          entityType: 'table',
   308	          entityId: primaryTableId,
   309	          details: {
   310	            virtualGroupId,
   311	            primaryTableId,
   312	            memberTableIds: tableIds,
   313	            tableNames: tables.map(t => t.name),
   314	            groupColor: virtualGroupColor,
   315	            ordersHandled: existingOrderActions?.length || 0,
   316	            seatsRenumbered: allSeats.length,
   317	          },
   318	        },
   319	      })
   320	
   321	      // Fetch updated tables for response
   322	      const updatedTables = await tx.table.findMany({
   323	        where: { id: { in: tableIds } },
   324	        include: {
   325	          section: { select: { id: true, name: true, color: true } },
   326	          orders: {
   327	            where: { status: 'open', deletedAt: null },
   328	            select: {
   329	              id: true,
   330	              orderNumber: true,
   331	              guestCount: true,
   332	              total: true,
   333	              createdAt: true,
   334	            },
   335	          },
   336	        },
   337	      })
   338	
   339	      return updatedTables
   340	    })
   341	
   342	    // Emit real-time event
   343	    tableEvents.virtualGroupCreated?.({
   344	      virtualGroupId,
   345	      primaryTableId,
   346	      tableIds,
   347	      groupColor: virtualGroupColor,
   348	      locationId,
   349	      timestamp: new Date().toISOString(),
   350	      triggeredBy: employeeId,
   351	    })
   352	
   353	    return NextResponse.json({
   354	      data: {
   355	        virtualGroupId,
   356	        groupColor: virtualGroupColor,
   357	        primaryTableId,
   358	        memberTableIds: tableIds,
   359	        tables: result.map(t => ({
   360	          id: t.id,
   361	          name: t.name,
   362	          virtualGroupId: t.virtualGroupId,
   363	          virtualGroupPrimary: t.virtualGroupPrimary,
   364	          virtualGroupColor: t.virtualGroupColor,
   365	          status: t.status,
   366	          section: t.section,
   367	          currentOrder: t.orders[0]
   368	            ? {
   369	                id: t.orders[0].id,
   370	                orderNumber: t.orders[0].orderNumber,
   371	                guestCount: t.orders[0].guestCount,
   372	                total: Number(t.orders[0].total),
   373	                openedAt: t.orders[0].createdAt.toISOString(),
   374	              }
   375	            : null,
   376	        })),
   377	        message: `Virtual group created with ${tableIds.length} tables`,
   378	      },
   379	    })
   380	  } catch (error) {
   381	    console.error('[VirtualCombine] Failed:', error)
   382	    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
   383	    return NextResponse.json(
   384	      { error: 'Failed to create virtual group', details: errorMessage },
   385	      { status: 500 }
   386	    )
   387	  }
   388	}
   389	
   390	/**
   391	 * GET /api/tables/virtual-combine?locationId=xxx
   392	 *
   393	 * List all active virtual groups for a location
   394	 */
   395	export async function GET(request: NextRequest) {
   396	  try {
   397	    const { searchParams } = new URL(request.url)
   398	    const locationId = searchParams.get('locationId')
   399	
   400	    if (!locationId) {
   401	      return NextResponse.json(
   402	        { error: 'locationId is required' },
   403	        { status: 400 }
   404	      )
   405	    }
   406	
   407	    // Find all tables that are in virtual groups
   408	    const groupedTables = await db.table.findMany({
   409	      where: {
   410	        locationId,
   411	        virtualGroupId: { not: null },
   412	        deletedAt: null,
   413	      },
   414	      select: {
   415	        id: true,
   416	        name: true,
   417	        virtualGroupId: true,
   418	        virtualGroupPrimary: true,
   419	        virtualGroupColor: true,
   420	        virtualGroupCreatedAt: true,
   421	      },
   422	      orderBy: { virtualGroupCreatedAt: 'desc' },
   423	    })
   424	
   425	    // Group by virtualGroupId
   426	    const groups = new Map<string, typeof groupedTables>()
   427	    for (const table of groupedTables) {
   428	      const groupId = table.virtualGroupId!
   429	      if (!groups.has(groupId)) {
   430	        groups.set(groupId, [])
   431	      }
   432	      groups.get(groupId)!.push(table)
   433	    }
   434	
   435	    // Format response
   436	    const virtualGroups = Array.from(groups.entries()).map(([groupId, tables]) => {
   437	      const primary = tables.find(t => t.virtualGroupPrimary)
   438	      return {
   439	        virtualGroupId: groupId,
   440	        primaryTableId: primary?.id,
   441	        groupColor: primary?.virtualGroupColor,
   442	        createdAt: primary?.virtualGroupCreatedAt,
   443	        tables: tables.map(t => ({
   444	          id: t.id,
   445	          name: t.name,
   446	          isPrimary: t.virtualGroupPrimary,
   447	        })),
   448	      }
   449	    })
   450	
   451	    return NextResponse.json({ data: virtualGroups })
   452	  } catch (error) {
   453	    console.error('[VirtualCombine] GET failed:', error)
   454	    return NextResponse.json(
   455	      { error: 'Failed to list virtual groups' },
   456	      { status: 500 }
   457	    )
   458	  }
   459	}

================================================================================
FILE: /src/app/api/seats/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server';
     2	import { db } from '@/lib/db';
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';
     4	
     5	// GET - List seats with filters
     6	export async function GET(request: NextRequest) {
     7	  try {
     8	    const searchParams = request.nextUrl.searchParams;
     9	    const locationId = searchParams.get('locationId');
    10	    const tableId = searchParams.get('tableId');
    11	    const virtualGroupId = searchParams.get('virtualGroupId');
    12	    const status = searchParams.get('status');
    13	
    14	    if (!locationId) {
    15	      return NextResponse.json(
    16	        { error: 'Location ID is required' },
    17	        { status: 400 }
    18	      );
    19	    }
    20	
    21	    const seats = await db.seat.findMany({
    22	      where: {
    23	        locationId,
    24	        deletedAt: null,
    25	        ...(tableId ? { tableId } : {}),
    26	        ...(status ? { isActive: status === 'active' } : {}),
    27	      },
    28	      include: {
    29	        table: {
    30	          select: {
    31	            id: true,
    32	            name: true,
    33	            shape: true,
    34	            virtualGroupId: true,
    35	          },
    36	        },
    37	      },
    38	      orderBy: [
    39	        { tableId: 'asc' },
    40	        { seatNumber: 'asc' },
    41	      ],
    42	    });
    43	
    44	    // Filter by virtualGroupId if provided (on related table)
    45	    const filteredSeats = virtualGroupId
    46	      ? seats.filter((s) => s.table.virtualGroupId === virtualGroupId)
    47	      : seats;
    48	
    49	    return NextResponse.json({
    50	      seats: filteredSeats.map((seat) => ({
    51	        id: seat.id,
    52	        locationId: seat.locationId,
    53	        tableId: seat.tableId,
    54	        tableName: seat.table.name,
    55	        label: seat.label,
    56	        seatNumber: seat.seatNumber,
    57	        relativeX: seat.relativeX,
    58	        relativeY: seat.relativeY,
    59	        angle: seat.angle,
    60	        seatType: seat.seatType,
    61	        isActive: seat.isActive,
    62	      })),
    63	    });
    64	  } catch (error) {
    65	    console.error('Failed to fetch seats:', error);
    66	    return NextResponse.json(
    67	      { error: 'Failed to fetch seats' },
    68	      { status: 500 }
    69	    );
    70	  }
    71	}
    72	
    73	// POST - Create a single seat
    74	export async function POST(request: NextRequest) {
    75	  try {
    76	    const body = await request.json();
    77	    const {
    78	      locationId,
    79	      tableId,
    80	      seatNumber,
    81	      label,
    82	      relativeX,
    83	      relativeY,
    84	      angle,
    85	      seatType,
    86	    } = body;
    87	
    88	    if (!locationId || !tableId) {
    89	      return NextResponse.json(
    90	        { error: 'Location ID and Table ID are required' },
    91	        { status: 400 }
    92	      );
    93	    }
    94	
    95	    // Auto-increment seat number if not provided
    96	    let finalSeatNumber = seatNumber;
    97	    if (!finalSeatNumber) {
    98	      const maxSeat = await db.seat.findFirst({
    99	        where: { tableId, deletedAt: null },
   100	        orderBy: { seatNumber: 'desc' },
   101	      });
   102	      finalSeatNumber = (maxSeat?.seatNumber || 0) + 1;
   103	    }
   104	
   105	    const seat = await db.seat.create({
   106	      data: {
   107	        locationId,
   108	        tableId,
   109	        seatNumber: finalSeatNumber,
   110	        label: label || String(finalSeatNumber),
   111	        relativeX: relativeX || 0,
   112	        relativeY: relativeY || 0,
   113	        angle: angle || 0,
   114	        seatType: seatType || 'standard',
   115	      },
   116	    });
   117	
   118	    // Notify POS terminals of floor plan update
   119	    dispatchFloorPlanUpdate(locationId, { async: true });
   120	
   121	    return NextResponse.json({
   122	      seat: {
   123	        id: seat.id,
   124	        locationId: seat.locationId,
   125	        tableId: seat.tableId,
   126	        label: seat.label,
   127	        seatNumber: seat.seatNumber,
   128	        relativeX: seat.relativeX,
   129	        relativeY: seat.relativeY,
   130	        angle: seat.angle,
   131	        seatType: seat.seatType,
   132	        isActive: seat.isActive,
   133	      },
   134	    });
   135	  } catch (error) {
   136	    console.error('Failed to create seat:', error);
   137	    return NextResponse.json(
   138	      { error: 'Failed to create seat' },
   139	      { status: 500 }
   140	    );
   141	  }
   142	}

================================================================================
FILE: /src/app/api/sections/route.ts
================================================================================
     1	import { NextRequest, NextResponse } from 'next/server'
     2	import { db } from '@/lib/db'
     3	
     4	// GET - List all sections for a location
     5	export async function GET(request: NextRequest) {
     6	  try {
     7	    const searchParams = request.nextUrl.searchParams
     8	    const locationId = searchParams.get('locationId')
     9	
    10	    if (!locationId) {
    11	      return NextResponse.json(
    12	        { error: 'Location ID is required' },
    13	        { status: 400 }
    14	      )
    15	    }
    16	
    17	    const sections = await db.section.findMany({
    18	      where: { locationId, deletedAt: null },
    19	      include: {
    20	        tables: {
    21	          where: { isActive: true, deletedAt: null },
    22	          select: { id: true },
    23	        },
    24	        assignments: {
    25	          where: { unassignedAt: null, deletedAt: null },
    26	          include: {
    27	            employee: {
    28	              select: { id: true, displayName: true, firstName: true, lastName: true },
    29	            },
    30	          },
    31	        },
    32	      },
    33	      orderBy: { sortOrder: 'asc' },
    34	    })
    35	
    36	    return NextResponse.json({
    37	      sections: sections.map(section => ({
    38	        id: section.id,
    39	        name: section.name,
    40	        color: section.color,
    41	        sortOrder: section.sortOrder,
    42	        posX: section.posX,
    43	        posY: section.posY,
    44	        width: section.width,
    45	        height: section.height,
    46	        widthFeet: section.widthFeet,
    47	        heightFeet: section.heightFeet,
    48	        gridSizeFeet: section.gridSizeFeet,
    49	        tableCount: section.tables.length,
    50	        assignedEmployees: section.assignments.map(a => ({
    51	          id: a.employee.id,
    52	          name: a.employee.displayName ||
    53	            `${a.employee.firstName} ${a.employee.lastName}`,
    54	        })),
    55	      })),
    56	    })
    57	  } catch (error) {
    58	    console.error('Failed to fetch sections:', error)
    59	    return NextResponse.json(
    60	      { error: 'Failed to fetch sections' },
    61	      { status: 500 }
    62	    )
    63	  }
    64	}
    65	
    66	// POST - Create a new section
    67	export async function POST(request: NextRequest) {
    68	  try {
    69	    const body = await request.json()
    70	    const { locationId, name, color, widthFeet, heightFeet, gridSizeFeet } = body
    71	
    72	    if (!locationId || !name) {
    73	      return NextResponse.json(
    74	        { error: 'Location ID and name are required' },
    75	        { status: 400 }
    76	      )
    77	    }
    78	
    79	    // Get highest sortOrder to place new section at end
    80	    const lastSection = await db.section.findFirst({
    81	      where: { locationId, deletedAt: null },
    82	      orderBy: { sortOrder: 'desc' },
    83	      select: { sortOrder: true },
    84	    })
    85	
    86	    const newSortOrder = (lastSection?.sortOrder ?? -1) + 1
    87	
    88	    const section = await db.section.create({
    89	      data: {
    90	        locationId,
    91	        name,
    92	        color: color || '#6366f1',
    93	        sortOrder: newSortOrder,
    94	        widthFeet: widthFeet ?? 40,
    95	        heightFeet: heightFeet ?? 30,
    96	        gridSizeFeet: gridSizeFeet ?? 0.25,
    97	      },
    98	    })
    99	
   100	    return NextResponse.json({
   101	      section: {
   102	        id: section.id,
   103	        name: section.name,
   104	        color: section.color,
   105	        sortOrder: section.sortOrder,
   106	        posX: section.posX,
   107	        posY: section.posY,
   108	        width: section.width,
   109	        height: section.height,
   110	        widthFeet: section.widthFeet,
   111	        heightFeet: section.heightFeet,
   112	        gridSizeFeet: section.gridSizeFeet,
   113	        tableCount: 0,
   114	        assignedEmployees: [],
   115	      },
   116	    })
   117	  } catch (error) {
   118	    console.error('Failed to create section:', error)
   119	    return NextResponse.json(
   120	      { error: 'Failed to create section' },
   121	      { status: 500 }
   122	    )
   123	  }
   124	}

================================================================================
FILE: /src/app/api/floor-plan/route.ts
================================================================================
     1	// src/app/api/floor-plan/route.ts
     2	import { NextRequest, NextResponse } from 'next/server'
     3	import { db } from '@/lib/db'
     4	
     5	/**
     6	 * GET /api/floor-plan?locationId=xxx&sectionId=yyy
     7	 *
     8	 * Returns tables and seats for the floor plan view.
     9	 * Used by FloorPlanHome to load initial data.
    10	 */
    11	export async function GET(request: NextRequest) {
    12	  const { searchParams } = new URL(request.url)
    13	  const locationId = searchParams.get('locationId')
    14	  const sectionId = searchParams.get('sectionId')
    15	
    16	  if (!locationId) {
    17	    return NextResponse.json(
    18	      { error: 'locationId is required' },
    19	      { status: 400 }
    20	    )
    21	  }
    22	
    23	  try {
    24	    // Build where clause for tables
    25	    const tableWhere: {
    26	      locationId: string
    27	      deletedAt: null
    28	      sectionId?: string
    29	    } = {
    30	      locationId,
    31	      deletedAt: null,
    32	    }
    33	
    34	    if (sectionId) {
    35	      tableWhere.sectionId = sectionId
    36	    }
    37	
    38	    // Fetch tables with section info
    39	    const tables = await db.table.findMany({
    40	      where: tableWhere,
    41	      select: {
    42	        id: true,
    43	        name: true,
    44	        sectionId: true,
    45	        posX: true,
    46	        posY: true,
    47	        width: true,
    48	        height: true,
    49	        status: true,
    50	        capacity: true,
    51	        combinedWithId: true,
    52	        combinedTableIds: true,
    53	        virtualGroupId: true,
    54	        virtualGroupPrimary: true,
    55	        virtualGroupColor: true,
    56	        section: {
    57	          select: {
    58	            id: true,
    59	            name: true,
    60	            color: true,
    61	          },
    62	        },
    63	      },
    64	      orderBy: { name: 'asc' },
    65	    })
    66	
    67	    // Get all table IDs for seat and order queries
    68	    const tableIds = tables.map(t => t.id)
    69	
    70	    // Fetch seats for these tables
    71	    const seats = await db.seat.findMany({
    72	      where: {
    73	        tableId: { in: tableIds },
    74	        isActive: true,
    75	        deletedAt: null,
    76	      },
    77	      select: {
    78	        id: true,
    79	        tableId: true,
    80	        label: true,
    81	        seatNumber: true,
    82	        relativeX: true,
    83	        relativeY: true,
    84	        angle: true,
    85	      },
    86	      orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
    87	    })
    88	
    89	    // Fetch open orders for these tables (status = open or in_progress)
    90	    const openOrders = await db.order.findMany({
    91	      where: {
    92	        tableId: { in: tableIds },
    93	        status: { in: ['open', 'in_progress'] },
    94	        deletedAt: null,
    95	      },
    96	      select: {
    97	        id: true,
    98	        orderNumber: true,
    99	        tableId: true,
   100	        status: true,
   101	        total: true,
   102	        createdAt: true,
   103	        employee: {
   104	          select: {
   105	            firstName: true,
   106	            lastName: true,
   107	          },
   108	        },
   109	      },
   110	      orderBy: { createdAt: 'desc' },
   111	    })
   112	
   113	    // Create a map of tableId -> currentOrder (most recent open order)
   114	    const ordersByTable = new Map<string, {
   115	      id: string
   116	      orderNumber: number
   117	      total: number
   118	      openedAt: string
   119	      server: string
   120	    }>()
   121	
   122	    for (const order of openOrders) {
   123	      if (order.tableId && !ordersByTable.has(order.tableId)) {
   124	        ordersByTable.set(order.tableId, {
   125	          id: order.id,
   126	          orderNumber: order.orderNumber,
   127	          total: Number(order.total),
   128	          openedAt: order.createdAt.toISOString(),
   129	          server: order.employee
   130	            ? `${order.employee.firstName} ${order.employee.lastName || ''}`.trim()
   131	            : 'Unknown',
   132	        })
   133	      }
   134	    }
   135	
   136	    // Format tables to match store shape (with currentOrder)
   137	    const formattedTables = tables.map(t => ({
   138	      id: t.id,
   139	      name: t.name,
   140	      sectionId: t.sectionId,
   141	      posX: t.posX,
   142	      posY: t.posY,
   143	      width: t.width,
   144	      height: t.height,
   145	      status: t.status as 'available' | 'occupied' | 'dirty' | 'reserved',
   146	      capacity: t.capacity,
   147	      combinedWithId: t.combinedWithId,
   148	      combinedTableIds: t.combinedTableIds as string[] | null,
   149	      virtualGroupId: t.virtualGroupId,
   150	      virtualGroupPrimary: t.virtualGroupPrimary,
   151	      virtualGroupColor: t.virtualGroupColor,
   152	      currentOrder: ordersByTable.get(t.id) || null,
   153	    }))
   154	
   155	    // Format seats to match store shape
   156	    const formattedSeats = seats.map(s => ({
   157	      id: s.id,
   158	      tableId: s.tableId,
   159	      label: s.label,
   160	      seatNumber: s.seatNumber,
   161	      relativeX: s.relativeX,
   162	      relativeY: s.relativeY,
   163	      angle: s.angle,
   164	    }))
   165	
   166	    return NextResponse.json({
   167	      tables: formattedTables,
   168	      seats: formattedSeats,
   169	    })
   170	  } catch (error) {
   171	    const msg = error instanceof Error ? error.message : 'Unknown error'
   172	    console.error('[FloorPlan API] Error:', msg)
   173	
   174	    return NextResponse.json(
   175	      { error: 'Failed to load floor plan', details: msg },
   176	      { status: 500 }
   177	    )
   178	  }
   179	}

================================================================================
FILE: /src/app/api/floor-plan-elements/route.ts
================================================================================
     1	import { db } from '@/lib/db'
     2	import { NextResponse } from 'next/server'
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
     4	
     5	// GET - List all floor plan elements for a location (optionally filtered by section)
     6	export async function GET(req: Request) {
     7	  const { searchParams } = new URL(req.url)
     8	  const locationId = searchParams.get('locationId')
     9	  const sectionId = searchParams.get('sectionId')
    10	
    11	  if (!locationId) {
    12	    return NextResponse.json({ error: 'locationId required' }, { status: 400 })
    13	  }
    14	
    15	  try {
    16	    const elements = await db.floorPlanElement.findMany({
    17	      where: {
    18	        locationId,
    19	        deletedAt: null,
    20	        ...(sectionId && { sectionId }),
    21	      },
    22	      include: {
    23	        linkedMenuItem: {
    24	          select: {
    25	            id: true,
    26	            name: true,
    27	            price: true,
    28	            itemType: true,
    29	            entertainmentStatus: true,
    30	            blockTimeMinutes: true,
    31	          },
    32	        },
    33	        section: {
    34	          select: {
    35	            id: true,
    36	            name: true,
    37	            color: true,
    38	          },
    39	        },
    40	        waitlistEntries: {
    41	          where: { status: 'waiting', deletedAt: null },
    42	          orderBy: { position: 'asc' },
    43	          select: {
    44	            id: true,
    45	            customerName: true,
    46	            partySize: true,
    47	            requestedAt: true,
    48	            tableId: true,
    49	          },
    50	        },
    51	      },
    52	      orderBy: { sortOrder: 'asc' },
    53	    })
    54	
    55	    return NextResponse.json({
    56	      elements: elements.map((el) => ({
    57	        id: el.id,
    58	        name: el.name,
    59	        abbreviation: el.abbreviation,
    60	        elementType: el.elementType,
    61	        visualType: el.visualType,
    62	        linkedMenuItemId: el.linkedMenuItemId,
    63	        linkedMenuItem: el.linkedMenuItem,
    64	        sectionId: el.sectionId,
    65	        section: el.section,
    66	        posX: el.posX,
    67	        posY: el.posY,
    68	        width: el.width,
    69	        height: el.height,
    70	        rotation: el.rotation,
    71	        geometry: el.geometry,
    72	        thickness: el.thickness,
    73	        fillColor: el.fillColor,
    74	        strokeColor: el.strokeColor,
    75	        opacity: el.opacity,
    76	        status: el.status,
    77	        currentOrderId: el.currentOrderId,
    78	        sessionStartedAt: el.sessionStartedAt,
    79	        sessionExpiresAt: el.sessionExpiresAt,
    80	        isLocked: el.isLocked,
    81	        isVisible: el.isVisible,
    82	        waitlistCount: el.waitlistEntries.length,
    83	        waitlistEntries: el.waitlistEntries,
    84	      })),
    85	    })
    86	  } catch (error) {
    87	    console.error('[floor-plan-elements] GET error:', error)
    88	    return NextResponse.json({ error: 'Failed to fetch elements' }, { status: 500 })
    89	  }
    90	}
    91	
    92	// POST - Create a new floor plan element
    93	export async function POST(req: Request) {
    94	  try {
    95	    const body = await req.json()
    96	    console.log('[floor-plan-elements] POST body:', body)
    97	
    98	    const {
    99	      locationId,
   100	      sectionId,
   101	      name,
   102	      abbreviation,
   103	      elementType = 'entertainment',
   104	      visualType,
   105	      linkedMenuItemId,
   106	      posX = 100,
   107	      posY = 100,
   108	      width,
   109	      height,
   110	      rotation = 0,
   111	      geometry,
   112	      thickness = 0.5,
   113	      fillColor,
   114	      strokeColor,
   115	      opacity = 1.0,
   116	    } = body
   117	
   118	    if (!locationId || !name || !visualType) {
   119	      return NextResponse.json(
   120	        { error: `Missing required fields: ${!locationId ? 'locationId ' : ''}${!name ? 'name ' : ''}${!visualType ? 'visualType' : ''}` },
   121	        { status: 400 }
   122	      )
   123	    }
   124	
   125	    // Verify linkedMenuItemId exists if provided
   126	    if (linkedMenuItemId) {
   127	      const menuItem = await db.menuItem.findUnique({
   128	        where: { id: linkedMenuItemId },
   129	        select: { id: true },
   130	      })
   131	      if (!menuItem) {
   132	        return NextResponse.json(
   133	          { error: `Menu item not found: ${linkedMenuItemId}` },
   134	          { status: 400 }
   135	        )
   136	      }
   137	    }
   138	
   139	    // Verify sectionId exists if provided
   140	    if (sectionId) {
   141	      const section = await db.section.findUnique({
   142	        where: { id: sectionId },
   143	        select: { id: true },
   144	      })
   145	      if (!section) {
   146	        return NextResponse.json(
   147	          { error: `Section not found: ${sectionId}` },
   148	          { status: 400 }
   149	        )
   150	      }
   151	    }
   152	
   153	    // Get highest sortOrder to place new element at end
   154	    const lastElement = await db.floorPlanElement.findFirst({
   155	      where: { locationId, deletedAt: null },
   156	      orderBy: { sortOrder: 'desc' },
   157	      select: { sortOrder: true },
   158	    })
   159	
   160	    console.log('[floor-plan-elements] Creating element...')
   161	
   162	    const element = await db.floorPlanElement.create({
   163	      data: {
   164	        locationId,
   165	        sectionId: sectionId || null,
   166	        name,
   167	        abbreviation,
   168	        elementType,
   169	        visualType,
   170	        linkedMenuItemId: linkedMenuItemId || null,
   171	        posX,
   172	        posY,
   173	        width: width || 100,
   174	        height: height || 100,
   175	        rotation,
   176	        geometry: geometry || null,
   177	        thickness,
   178	        fillColor,
   179	        strokeColor,
   180	        opacity,
   181	        sortOrder: (lastElement?.sortOrder ?? -1) + 1,
   182	      },
   183	      include: {
   184	        linkedMenuItem: {
   185	          select: {
   186	            id: true,
   187	            name: true,
   188	            price: true,
   189	            itemType: true,
   190	            entertainmentStatus: true,
   191	            blockTimeMinutes: true,
   192	          },
   193	        },
   194	        section: {
   195	          select: {
   196	            id: true,
   197	            name: true,
   198	            color: true,
   199	          },
   200	        },
   201	      },
   202	    })
   203	
   204	    console.log('[floor-plan-elements] Created element:', element.id)
   205	
   206	    // Notify POS terminals of floor plan update
   207	    dispatchFloorPlanUpdate(locationId, { async: true })
   208	
   209	    return NextResponse.json({ element })
   210	  } catch (error) {
   211	    console.error('[floor-plan-elements] POST error:', error)
   212	    const message = error instanceof Error ? error.message : 'Unknown error'
   213	    return NextResponse.json({ error: `Failed to create element: ${message}` }, { status: 500 })
   214	  }
   215	}

================================================================================
FILE: /src/app/api/floor-plan-elements/[id]/route.ts
================================================================================
     1	import { db } from '@/lib/db'
     2	import { NextResponse } from 'next/server'
     3	import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
     4	
     5	// GET - Get a single floor plan element
     6	export async function GET(
     7	  req: Request,
     8	  { params }: { params: Promise<{ id: string }> }
     9	) {
    10	  const { id } = await params
    11	
    12	  try {
    13	    const element = await db.floorPlanElement.findFirst({
    14	      where: { id, deletedAt: null },
    15	      include: {
    16	        linkedMenuItem: {
    17	          select: {
    18	            id: true,
    19	            name: true,
    20	            price: true,
    21	            itemType: true,
    22	            entertainmentStatus: true,
    23	            blockTimeMinutes: true,
    24	            currentOrderId: true,
    25	          },
    26	        },
    27	        section: {
    28	          select: {
    29	            id: true,
    30	            name: true,
    31	            color: true,
    32	          },
    33	        },
    34	        waitlistEntries: {
    35	          where: { status: 'waiting', deletedAt: null },
    36	          orderBy: { position: 'asc' },
    37	          include: {
    38	            table: {
    39	              select: {
    40	                id: true,
    41	                name: true,
    42	              },
    43	            },
    44	          },
    45	        },
    46	      },
    47	    })
    48	
    49	    if (!element) {
    50	      return NextResponse.json({ error: 'Element not found' }, { status: 404 })
    51	    }
    52	
    53	    return NextResponse.json({ element })
    54	  } catch (error) {
    55	    console.error('[floor-plan-elements/[id]] GET error:', error)
    56	    return NextResponse.json({ error: 'Failed to fetch element' }, { status: 500 })
    57	  }
    58	}
    59	
    60	// PUT - Update a floor plan element
    61	export async function PUT(
    62	  req: Request,
    63	  { params }: { params: Promise<{ id: string }> }
    64	) {
    65	  const { id } = await params
    66	
    67	  try {
    68	    const body = await req.json()
    69	    const {
    70	      name,
    71	      abbreviation,
    72	      sectionId,
    73	      visualType,
    74	      linkedMenuItemId,
    75	      posX,
    76	      posY,
    77	      width,
    78	      height,
    79	      rotation,
    80	      geometry,
    81	      thickness,
    82	      fillColor,
    83	      strokeColor,
    84	      opacity,
    85	      status,
    86	      currentOrderId,
    87	      sessionStartedAt,
    88	      sessionExpiresAt,
    89	      isLocked,
    90	      isVisible,
    91	    } = body
    92	
    93	    const element = await db.floorPlanElement.update({
    94	      where: { id },
    95	      data: {
    96	        ...(name !== undefined && { name }),
    97	        ...(abbreviation !== undefined && { abbreviation }),
    98	        ...(sectionId !== undefined && { sectionId: sectionId || null }),
    99	        ...(visualType !== undefined && { visualType }),
   100	        ...(linkedMenuItemId !== undefined && { linkedMenuItemId: linkedMenuItemId || null }),
   101	        ...(posX !== undefined && { posX }),
   102	        ...(posY !== undefined && { posY }),
   103	        ...(width !== undefined && { width }),
   104	        ...(height !== undefined && { height }),
   105	        ...(rotation !== undefined && { rotation }),
   106	        ...(geometry !== undefined && { geometry }),
   107	        ...(thickness !== undefined && { thickness }),
   108	        ...(fillColor !== undefined && { fillColor }),
   109	        ...(strokeColor !== undefined && { strokeColor }),
   110	        ...(opacity !== undefined && { opacity }),
   111	        ...(status !== undefined && { status }),
   112	        ...(currentOrderId !== undefined && { currentOrderId }),
   113	        ...(sessionStartedAt !== undefined && { sessionStartedAt: sessionStartedAt ? new Date(sessionStartedAt) : null }),
   114	        ...(sessionExpiresAt !== undefined && { sessionExpiresAt: sessionExpiresAt ? new Date(sessionExpiresAt) : null }),
   115	        ...(isLocked !== undefined && { isLocked }),
   116	        ...(isVisible !== undefined && { isVisible }),
   117	      },
   118	      include: {
   119	        linkedMenuItem: {
   120	          select: {
   121	            id: true,
   122	            name: true,
   123	            price: true,
   124	            itemType: true,
   125	            entertainmentStatus: true,
   126	            blockTimeMinutes: true,
   127	          },
   128	        },
   129	        section: {
   130	          select: {
   131	            id: true,
   132	            name: true,
   133	            color: true,
   134	          },
   135	        },
   136	      },
   137	    })
   138	
   139	    // Notify POS terminals of floor plan update
   140	    dispatchFloorPlanUpdate(element.locationId, { async: true })
   141	
   142	    return NextResponse.json({ element })
   143	  } catch (error) {
   144	    console.error('[floor-plan-elements/[id]] PUT error:', error)
   145	    return NextResponse.json({ error: 'Failed to update element' }, { status: 500 })
   146	  }
   147	}
   148	
   149	// DELETE - Soft delete a floor plan element
   150	export async function DELETE(
   151	  req: Request,
   152	  { params }: { params: Promise<{ id: string }> }
   153	) {
   154	  const { id } = await params
   155	
   156	  try {
   157	    const element = await db.floorPlanElement.update({
   158	      where: { id },
   159	      data: { deletedAt: new Date() },
   160	      select: { locationId: true },
   161	    })
   162	
   163	    // Notify POS terminals of floor plan update
   164	    dispatchFloorPlanUpdate(element.locationId, { async: true })
   165	
   166	    return NextResponse.json({ success: true })
   167	  } catch (error) {
   168	    console.error('[floor-plan-elements/[id]] DELETE error:', error)
   169	    return NextResponse.json({ error: 'Failed to delete element' }, { status: 500 })
   170	  }
   171	}

================================================================================
DOMAIN COMPONENTS - ADMIN/EDITOR
================================================================================

================================================================================
FILE: /src/domains/floor-plan/admin/EditorCanvas.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Editor Canvas Component
     6	 *
     7	 * Canvas with drawing and editing interactions for floor plan fixtures.
     8	 */
     9	
    10	import React, { useRef, useState, useCallback, useEffect } from 'react';
    11	import { FloorCanvasAPI } from '../canvas';
    12	import type { Fixture, Point, FixtureGeometry } from '../shared/types';
    13	import type { EditorToolMode, FixtureType, EditorTable, TableShape, EditorSeat } from './types';
    14	import { getFixtureTypeMetadata, getTableShapeMetadata } from './types';
    15	import { TableRenderer, type ResizeHandle } from './TableRenderer';
    16	import { SeatRenderer } from './SeatRenderer';
    17	import {
    18	  SEAT_RADIUS,
    19	  SEAT_HIT_RADIUS,
    20	  SEAT_COLLISION_RADIUS,
    21	  SEAT_BOUNDARY_DISTANCE,
    22	  SEAT_MIN_DISTANCE,
    23	  // Canvas constants
    24	  CANVAS_WIDTH,
    25	  CANVAS_HEIGHT,
    26	  ZOOM_MIN,
    27	  ZOOM_MAX,
    28	  ZOOM_DEFAULT,
    29	  ZOOM_STEP,
    30	  GRID_SIZE,
    31	} from '@/lib/floorplan/constants';
    32	
    33	// =============================================================================
    34	// TYPES
    35	// =============================================================================
    36	
    37	// Virtual floor plan for database mode (created from Section data)
    38	interface VirtualFloorPlan {
    39	  id: string;
    40	  name: string;
    41	  widthFeet: number;
    42	  heightFeet: number;
    43	  gridSizeFeet: number;
    44	}
    45	
    46	// Available space around a table (in pixels)
    47	interface AvailableSpace {
    48	  top: number;    // pixels to nearest obstacle above
    49	  bottom: number; // pixels to nearest obstacle below
    50	  left: number;   // pixels to nearest obstacle left
    51	  right: number;  // pixels to nearest obstacle right
    52	}
    53	
    54	interface EditorCanvasProps {
    55	  roomId: string;
    56	  toolMode: EditorToolMode;
    57	  fixtureType: FixtureType;
    58	  tableShape?: TableShape;
    59	  selectedFixtureId: string | null;
    60	  selectedTableId: string | null;
    61	  refreshKey: number;
    62	  onFixtureSelect: (fixtureId: string | null) => void;
    63	  onFixtureUpdate: (fixtureId: string, updates: Partial<Fixture>) => void;
    64	  onFixtureCreate: (fixture: Omit<Fixture, 'id'>) => void;
    65	  onFixtureDelete: (fixtureId: string) => void;
    66	  // Table handling
    67	  onTableSelect?: (tableId: string | null) => void;
    68	  onTableCreate?: (table: Omit<EditorTable, 'id'>) => void;
    69	  onTableUpdate?: (tableId: string, updates: Partial<EditorTable>) => void;
    70	  onTableDelete?: (tableId: string) => void;
    71	  // Seat handling
    72	  dbSeats?: EditorSeat[];
    73	  onSeatSelect?: (seatId: string | null) => void;
    74	  onSeatUpdate?: (seatId: string, updates: { relativeX?: number; relativeY?: number }) => void;
    75	  onSeatsReflow?: (tableId: string, dimensions: {
    76	    oldWidth: number;
    77	    oldHeight: number;
    78	    newWidth: number;
    79	    newHeight: number;
    80	  }) => void;
    81	  // Database mode props
    82	  useDatabase?: boolean;
    83	  dbFixtures?: Fixture[];
    84	  dbTables?: EditorTable[];
    85	  dbFloorPlan?: VirtualFloorPlan; // Section data for database mode
    86	  // Zoom control callbacks (optional - parent can use these)
    87	  onZoomChange?: (zoom: number) => void;
    88	  zoomControlRef?: React.MutableRefObject<{
    89	    fitToScreen: () => void;
    90	    resetZoom: () => void;
    91	    setZoom: (z: number) => void;
    92	    zoom: number;
    93	  } | null>;
    94	}
    95	
    96	// =============================================================================
    97	// COMPONENT
    98	// =============================================================================
    99	
   100	export function EditorCanvas({
   101	  roomId,
   102	  toolMode,
   103	  fixtureType,
   104	  tableShape = 'rectangle',
   105	  selectedFixtureId,
   106	  selectedTableId,
   107	  refreshKey,
   108	  onFixtureSelect,
   109	  onFixtureUpdate,
   110	  onFixtureCreate,
   111	  onFixtureDelete,
   112	  onTableSelect,
   113	  onTableCreate,
   114	  onTableUpdate,
   115	  onTableDelete,
   116	  dbSeats,
   117	  onSeatSelect,
   118	  onSeatUpdate,
   119	  onSeatsReflow,
   120	  useDatabase = false,
   121	  dbFixtures,
   122	  dbTables,
   123	  dbFloorPlan,
   124	  onZoomChange,
   125	  zoomControlRef,
   126	}: EditorCanvasProps) {
   127	  const canvasRef = useRef<HTMLDivElement>(null);
   128	  // In database mode, use the dbFloorPlan prop; otherwise use in-memory API
   129	  const [floorPlan, setFloorPlan] = useState(
   130	    useDatabase && dbFloorPlan ? dbFloorPlan : FloorCanvasAPI.getFloorPlan(roomId)
   131	  );
   132	  const [fixtures, setFixtures] = useState<Fixture[]>([]);
   133	  const [tables, setTables] = useState<EditorTable[]>([]);
   134	  const [seats, setSeats] = useState<EditorSeat[]>([]);
   135	
   136	  // Drawing state
   137	  const [startPoint, setStartPoint] = useState<Point | null>(null);
   138	  const [currentPoint, setCurrentPoint] = useState<Point | null>(null);
   139	  const [isDrawing, setIsDrawing] = useState(false);
   140	
   141	  // Dragging state (for fixtures)
   142	  const [isDragging, setIsDragging] = useState(false);
   143	  const [dragOffset, setDragOffset] = useState<Point | null>(null);
   144	
   145	  // Dragging state (for tables)
   146	  const [isDraggingTable, setIsDraggingTable] = useState(false);
   147	  const [tableDragOffset, setTableDragOffset] = useState<Point | null>(null);
   148	
   149	  // Resizing state (for tables)
   150	  const [isResizingTable, setIsResizingTable] = useState(false);
   151	  const [resizeHandle, setResizeHandle] = useState<string | null>(null);
   152	  const [resizeStartDimensions, setResizeStartDimensions] = useState<{width: number, height: number} | null>(null);
   153	  const [resizeStartPos, setResizeStartPos] = useState<{x: number, y: number} | null>(null);
   154	  const [resizeStartMousePos, setResizeStartMousePos] = useState<Point | null>(null);
   155	
   156	  // Rotation state (for tables)
   157	  const [isRotatingTable, setIsRotatingTable] = useState(false);
   158	  const [rotationStartAngle, setRotationStartAngle] = useState(0);
   159	  const [rotationStartMouseAngle, setRotationStartMouseAngle] = useState(0);
   160	
   161	  // Dragging state (for seats)
   162	  const [isDraggingSeat, setIsDraggingSeat] = useState(false);
   163	  const [draggedSeatId, setDraggedSeatId] = useState<string | null>(null);
   164	  const [seatDragOffset, setSeatDragOffset] = useState<Point | null>(null);
   165	  const [originalSeatPos, setOriginalSeatPos] = useState<Point | null>(null);
   166	  const [seatDragPreview, setSeatDragPreview] = useState<{ id: string; relativeX: number; relativeY: number } | null>(null);
   167	
   168	  // Auto-offset for new fixtures to prevent stacking
   169	  const [placementOffset, setPlacementOffset] = useState(0);
   170	
   171	  // Debug mode for boundary visualization (toggle with keyboard)
   172	  const [showBoundaryDebug, setShowBoundaryDebug] = useState(false);
   173	
   174	  // Zoom and pan state
   175	  const [zoom, setZoom] = useState(ZOOM_DEFAULT);
   176	  const [panOffset, setPanOffset] = useState<Point>({ x: 0, y: 0 });
   177	  const [isPanning, setIsPanning] = useState(false);
   178	  const [lastPanPoint, setLastPanPoint] = useState<Point | null>(null);
   179	
   180	  // Constants imported from @/lib/floorplan/constants
   181	
   182	  // Check if a table would collide with any fixture
   183	  const checkTableFixtureCollision = useCallback((
   184	    tablePosX: number,  // in pixels
   185	    tablePosY: number,  // in pixels
   186	    tableWidth: number, // in pixels
   187	    tableHeight: number // in pixels
   188	  ): boolean => {
   189	    const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;
   190	
   191	    for (const fixture of fixtureList) {
   192	      if (fixture.geometry.type === 'rectangle') {
   193	        // Convert fixture position from feet to pixels
   194	        const fx = FloorCanvasAPI.feetToPixels(fixture.geometry.position.x);
   195	        const fy = FloorCanvasAPI.feetToPixels(fixture.geometry.position.y);
   196	        const fw = FloorCanvasAPI.feetToPixels(fixture.geometry.width);
   197	        const fh = FloorCanvasAPI.feetToPixels(fixture.geometry.height);
   198	
   199	        // AABB collision check
   200	        if (tablePosX < fx + fw &&
   201	            tablePosX + tableWidth > fx &&
   202	            tablePosY < fy + fh &&
   203	            tablePosY + tableHeight > fy) {
   204	          return true;
   205	        }
   206	      } else if (fixture.geometry.type === 'circle') {
   207	        // Convert circle center and radius from feet to pixels
   208	        const cx = FloorCanvasAPI.feetToPixels(fixture.geometry.center.x);
   209	        const cy = FloorCanvasAPI.feetToPixels(fixture.geometry.center.y);
   210	        const cr = FloorCanvasAPI.feetToPixels(fixture.geometry.radius);
   211	
   212	        // Simple bounding box check for circle
   213	        if (tablePosX < cx + cr &&
   214	            tablePosX + tableWidth > cx - cr &&
   215	            tablePosY < cy + cr &&
   216	            tablePosY + tableHeight > cy - cr) {
   217	          return true;
   218	        }
   219	      }
   220	    }
   221	    return false;
   222	  }, [useDatabase, dbFixtures, fixtures]);
   223	
   224	  // Check if a table would collide with any other table
   225	  const checkTableCollision = useCallback((
   226	    tablePosX: number,   // in pixels
   227	    tablePosY: number,   // in pixels
   228	    tableWidth: number,  // in pixels
   229	    tableHeight: number, // in pixels
   230	    excludeTableId?: string  // Table being moved (exclude from collision check)
   231	  ): boolean => {
   232	    const tableList = useDatabase ? (dbTables || []) : tables;
   233	
   234	    for (const table of tableList) {
   235	      // Skip the table being moved
   236	      if (excludeTableId && table.id === excludeTableId) {
   237	        continue;
   238	      }
   239	
   240	      // AABB collision check
   241	      if (tablePosX < table.posX + table.width &&
   242	          tablePosX + tableWidth > table.posX &&
   243	          tablePosY < table.posY + table.height &&
   244	          tablePosY + tableHeight > table.posY) {
   245	        return true; // Collision detected
   246	      }
   247	    }
   248	    return false;
   249	  }, [useDatabase, dbTables, tables]);
   250	
   251	  // Check if a seat position collides with other seats
   252	  const checkSeatCollision = useCallback((
   253	    posX: number,
   254	    posY: number,
   255	    tableId: string,
   256	    excludeSeatId?: string
   257	  ): boolean => {
   258	    const tableSeats = seats.filter(s => s.tableId === tableId && s.id !== excludeSeatId);
   259	    const table = tables.find(t => t.id === tableId);
   260	    if (!table) return false;
   261	
   262	    const tableCenterX = table.posX + table.width / 2;
   263	    const tableCenterY = table.posY + table.height / 2;
   264	
   265	    for (const seat of tableSeats) {
   266	      // Calculate absolute position of existing seat
   267	      const seatAbsX = tableCenterX + seat.relativeX;
   268	      const seatAbsY = tableCenterY + seat.relativeY;
   269	
   270	      // Check distance between seat centers
   271	      const distance = Math.hypot(posX - seatAbsX, posY - seatAbsY);
   272	
   273	      // Collision if distance < 2 * SEAT_COLLISION_RADIUS (seats touching)
   274	      if (distance < SEAT_COLLISION_RADIUS * 2 + 4) { // Using smaller collision radius
   275	        return true;
   276	      }
   277	    }
   278	    return false;
   279	  }, [seats, tables, SEAT_COLLISION_RADIUS]);
   280	
   281	  // Check if any seat of a table would collide with obstacles at a given table position
   282	  const checkSeatsObstacleCollision = useCallback((
   283	    tableId: string,
   284	    newTablePosX: number,
   285	    newTablePosY: number,
   286	    tableWidth: number,
   287	    tableHeight: number,
   288	    tableRotation: number = 0
   289	  ): boolean => {
   290	    // Get seats for this table
   291	    const tableSeats = seats.filter(s => s.tableId === tableId);
   292	    if (tableSeats.length === 0) return false;
   293	
   294	    const tableCenterX = newTablePosX + tableWidth / 2;
   295	    const tableCenterY = newTablePosY + tableHeight / 2;
   296	    const rotation = tableRotation * Math.PI / 180;
   297	    const cos = Math.cos(rotation);
   298	    const sin = Math.sin(rotation);
   299	
   300	    // Check each seat against all obstacles
   301	    for (const seat of tableSeats) {
   302	      // Calculate absolute seat position at the new table location
   303	      const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
   304	      const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
   305	      const seatAbsX = tableCenterX + rotatedX;
   306	      const seatAbsY = tableCenterY + rotatedY;
   307	
   308	      // Check against other tables (exclude current table)
   309	      const tableList = useDatabase ? (dbTables || []) : tables;
   310	      for (const otherTable of tableList) {
   311	        if (otherTable.id === tableId) continue;
   312	
   313	        // Simple AABB check with seat radius
   314	        if (seatAbsX + SEAT_RADIUS > otherTable.posX &&
   315	            seatAbsX - SEAT_RADIUS < otherTable.posX + otherTable.width &&
   316	            seatAbsY + SEAT_RADIUS > otherTable.posY &&
   317	            seatAbsY - SEAT_RADIUS < otherTable.posY + otherTable.height) {
   318	          return true; // Collision with another table
   319	        }
   320	
   321	        // Check against seats of other tables
   322	        const otherTableSeats = seats.filter(s => s.tableId === otherTable.id);
   323	        const otherTableCenterX = otherTable.posX + otherTable.width / 2;
   324	        const otherTableCenterY = otherTable.posY + otherTable.height / 2;
   325	        const otherRotation = (otherTable.rotation || 0) * Math.PI / 180;
   326	        const otherCos = Math.cos(otherRotation);
   327	        const otherSin = Math.sin(otherRotation);
   328	
   329	        for (const otherSeat of otherTableSeats) {
   330	          const otherRotatedX = otherSeat.relativeX * otherCos - otherSeat.relativeY * otherSin;
   331	          const otherRotatedY = otherSeat.relativeX * otherSin + otherSeat.relativeY * otherCos;
   332	          const otherSeatAbsX = otherTableCenterX + otherRotatedX;
   333	          const otherSeatAbsY = otherTableCenterY + otherRotatedY;
   334	
   335	          const distance = Math.hypot(seatAbsX - otherSeatAbsX, seatAbsY - otherSeatAbsY);
   336	          if (distance < SEAT_COLLISION_RADIUS * 2 + 4) {
   337	            return true; // Collision with seat from another table
   338	          }
   339	        }
   340	      }
   341	
   342	      // Check against fixtures
   343	      const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;
   344	      for (const fixture of fixtureList) {
   345	        if (fixture.geometry.type === 'rectangle') {
   346	          const fx = FloorCanvasAPI.feetToPixels(fixture.geometry.position.x);
   347	          const fy = FloorCanvasAPI.feetToPixels(fixture.geometry.position.y);
   348	          const fw = FloorCanvasAPI.feetToPixels(fixture.geometry.width);
   349	          const fh = FloorCanvasAPI.feetToPixels(fixture.geometry.height);
   350	
   351	          if (seatAbsX + SEAT_RADIUS > fx &&
   352	              seatAbsX - SEAT_RADIUS < fx + fw &&
   353	              seatAbsY + SEAT_RADIUS > fy &&
   354	              seatAbsY - SEAT_RADIUS < fy + fh) {
   355	            return true; // Collision with fixture
   356	          }
   357	        } else if (fixture.geometry.type === 'circle') {
   358	          const cx = FloorCanvasAPI.feetToPixels(fixture.geometry.center.x);
   359	          const cy = FloorCanvasAPI.feetToPixels(fixture.geometry.center.y);
   360	          const cr = FloorCanvasAPI.feetToPixels(fixture.geometry.radius);
   361	
   362	          const dist = Math.hypot(seatAbsX - cx, seatAbsY - cy);
   363	          if (dist < cr + SEAT_RADIUS) {
   364	            return true; // Collision with circular fixture
   365	          }
   366	        }
   367	        // Lines (walls) - simplified bounding box check
   368	        else if (fixture.geometry.type === 'line') {
   369	          const { start, end } = fixture.geometry;
   370	          const thickness = fixture.thickness || 0.5;
   371	          const x1 = FloorCanvasAPI.feetToPixels(Math.min(start.x, end.x) - thickness);
   372	          const x2 = FloorCanvasAPI.feetToPixels(Math.max(start.x, end.x) + thickness);
   373	          const y1 = FloorCanvasAPI.feetToPixels(Math.min(start.y, end.y) - thickness);
   374	          const y2 = FloorCanvasAPI.feetToPixels(Math.max(start.y, end.y) + thickness);
   375	
   376	          if (seatAbsX + SEAT_RADIUS > x1 &&
   377	              seatAbsX - SEAT_RADIUS < x2 &&
   378	              seatAbsY + SEAT_RADIUS > y1 &&
   379	              seatAbsY - SEAT_RADIUS < y2) {
   380	            return true; // Collision with wall
   381	          }
   382	        }
   383	      }
   384	    }
   385	
   386	    return false; // No collisions
   387	  }, [seats, tables, fixtures, useDatabase, dbTables, dbFixtures, SEAT_RADIUS]);
   388	
   389	  // Calculate available space around a table (in pixels)
   390	  const calculateAvailableSpace = useCallback((
   391	    tableId: string,
   392	    tablePosX: number,
   393	    tablePosY: number,
   394	    tableWidth: number,
   395	    tableHeight: number,
   396	    tableRotation: number = 0
   397	  ): AvailableSpace => {
   398	    // Default to maximum boundary if no obstacles nearby
   399	    const defaultSpace = SEAT_BOUNDARY_DISTANCE + SEAT_RADIUS;
   400	    let topSpace = defaultSpace;
   401	    let bottomSpace = defaultSpace;
   402	    let leftSpace = defaultSpace;
   403	    let rightSpace = defaultSpace;
   404	
   405	    const tableList = useDatabase ? (dbTables || []) : tables;
   406	    const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;
   407	
   408	    // For simplicity, assume rectangular bounding box (ignore rotation for obstacle distance)
   409	    const tableTop = tablePosY;
   410	    const tableBottom = tablePosY + tableHeight;
   411	    const tableLeft = tablePosX;
   412	    const tableRight = tablePosX + tableWidth;
   413	
   414	    // Check distance to other tables
   415	    for (const otherTable of tableList) {
   416	      if (otherTable.id === tableId) continue;
   417	
   418	      const otherTop = otherTable.posY;
   419	      const otherBottom = otherTable.posY + otherTable.height;
   420	      const otherLeft = otherTable.posX;
   421	      const otherRight = otherTable.posX + otherTable.width;
   422	
   423	      // Check if tables are aligned horizontally (check top/bottom space)
   424	      if (!(tableRight < otherLeft || tableLeft > otherRight)) {
   425	        // Tables overlap horizontally, check vertical distance
   426	        if (otherBottom <= tableTop) {
   427	          // Other table is above
   428	          const distance = tableTop - otherBottom;
   429	          topSpace = Math.min(topSpace, distance);
   430	        } else if (otherTop >= tableBottom) {
   431	          // Other table is below
   432	          const distance = otherTop - tableBottom;
   433	          bottomSpace = Math.min(bottomSpace, distance);
   434	        }
   435	      }
   436	
   437	      // Check if tables are aligned vertically (check left/right space)
   438	      if (!(tableBottom < otherTop || tableTop > otherBottom)) {
   439	        // Tables overlap vertically, check horizontal distance
   440	        if (otherRight <= tableLeft) {
   441	          // Other table is to the left
   442	          const distance = tableLeft - otherRight;
   443	          leftSpace = Math.min(leftSpace, distance);
   444	        } else if (otherLeft >= tableRight) {
   445	          // Other table is to the right
   446	          const distance = otherLeft - tableRight;
   447	          rightSpace = Math.min(rightSpace, distance);
   448	        }
   449	      }
   450	    }
   451	
   452	    // Check distance to fixtures
   453	    for (const fixture of fixtureList) {
   454	      if (fixture.geometry.type === 'rectangle') {
   455	        const fx = FloorCanvasAPI.feetToPixels(fixture.geometry.position.x);
   456	        const fy = FloorCanvasAPI.feetToPixels(fixture.geometry.position.y);
   457	        const fw = FloorCanvasAPI.feetToPixels(fixture.geometry.width);
   458	        const fh = FloorCanvasAPI.feetToPixels(fixture.geometry.height);
   459	
   460	        const fixtureTop = fy;
   461	        const fixtureBottom = fy + fh;
   462	        const fixtureLeft = fx;
   463	        const fixtureRight = fx + fw;
   464	
   465	        // Check horizontal alignment
   466	        if (!(tableRight < fixtureLeft || tableLeft > fixtureRight)) {
   467	          if (fixtureBottom <= tableTop) {
   468	            const distance = tableTop - fixtureBottom;
   469	            topSpace = Math.min(topSpace, distance);
   470	          } else if (fixtureTop >= tableBottom) {
   471	            const distance = fixtureTop - tableBottom;
   472	            bottomSpace = Math.min(bottomSpace, distance);
   473	          }
   474	        }
   475	
   476	        // Check vertical alignment
   477	        if (!(tableBottom < fixtureTop || tableTop > fixtureBottom)) {
   478	          if (fixtureRight <= tableLeft) {
   479	            const distance = tableLeft - fixtureRight;
   480	            leftSpace = Math.min(leftSpace, distance);
   481	          } else if (fixtureLeft >= tableRight) {
   482	            const distance = fixtureLeft - tableRight;
   483	            rightSpace = Math.min(rightSpace, distance);
   484	          }
   485	        }
   486	      }
   487	      // Simplified: treat circles and lines as not affecting space for now
   488	      // (more complex geometry would require more sophisticated calculations)
   489	    }
   490	
   491	    return {
   492	      top: Math.max(0, topSpace),
   493	      bottom: Math.max(0, bottomSpace),
   494	      left: Math.max(0, leftSpace),
   495	      right: Math.max(0, rightSpace),
   496	    };
   497	  }, [tables, fixtures, useDatabase, dbTables, dbFixtures, SEAT_BOUNDARY_DISTANCE, SEAT_RADIUS]);
   498	
   499	  // Compress seats to fit within available space
   500	  const compressSeatsToFit = useCallback((
   501	    tableId: string,
   502	    tableSeats: EditorSeat[],
   503	    table: EditorTable,
   504	    availableSpace: AvailableSpace
   505	  ): EditorSeat[] => {
   506	    if (tableSeats.length === 0) return tableSeats;
   507	
   508	    const halfWidth = table.width / 2;
   509	    const halfHeight = table.height / 2;
   510	
   511	    return tableSeats.map((seat) => {
   512	      const absX = Math.abs(seat.relativeX);
   513	      const absY = Math.abs(seat.relativeY);
   514	
   515	      // Determine which side the seat is on
   516	      const normalizedX = absX / halfWidth;
   517	      const normalizedY = absY / halfHeight;
   518	
   519	      let newRelativeX = seat.relativeX;
   520	      let newRelativeY = seat.relativeY;
   521	
   522	      // Calculate dynamic offset for each side based on available space
   523	      const baseOffset = 25; // Default offset from table edge
   524	
   525	      if (normalizedY >= normalizedX) {
   526	        // Seat is on top or bottom edge
   527	        const direction = seat.relativeY >= 0 ? 1 : -1;
   528	        const availableOnSide = direction > 0 ? availableSpace.bottom : availableSpace.top;
   529	
   530	        // Calculate dynamic offset (compressed if space is tight)
   531	        const dynamicOffset = Math.max(
   532	          SEAT_MIN_DISTANCE,
   533	          Math.min(baseOffset, availableOnSide - SEAT_RADIUS)
   534	        );
   535	
   536	        // Apply dynamic offset
   537	        newRelativeY = direction * (halfHeight + dynamicOffset);
   538	      } else {
   539	        // Seat is on left or right edge
   540	        const direction = seat.relativeX >= 0 ? 1 : -1;
   541	        const availableOnSide = direction > 0 ? availableSpace.right : availableSpace.left;
   542	
   543	        // Calculate dynamic offset (compressed if space is tight)
   544	        const dynamicOffset = Math.max(
   545	          SEAT_MIN_DISTANCE,
   546	          Math.min(baseOffset, availableOnSide - SEAT_RADIUS)
   547	        );
   548	
   549	        // Apply dynamic offset
   550	        newRelativeX = direction * (halfWidth + dynamicOffset);
   551	      }
   552	
   553	      return {
   554	        ...seat,
   555	        relativeX: Math.round(newRelativeX),
   556	        relativeY: Math.round(newRelativeY),
   557	      };
   558	    });
   559	  }, [SEAT_MIN_DISTANCE, SEAT_RADIUS]);
   560	
   561	  // Check if position is valid for a seat (boundary + not inside table)
   562	  const isValidSeatPosition = useCallback((
   563	    absoluteX: number,
   564	    absoluteY: number,
   565	    table: EditorTable,
   566	    excludeSeatId?: string
   567	  ): boolean => {
   568	    const tableCenterX = table.posX + table.width / 2;
   569	    const tableCenterY = table.posY + table.height / 2;
   570	
   571	    // If table is rotated, transform the check point to table-local coordinates
   572	    const rotation = (table.rotation || 0) * Math.PI / 180;
   573	    const cos = Math.cos(-rotation);
   574	    const sin = Math.sin(-rotation);
   575	
   576	    // Translate to table center, rotate, translate back
   577	    const dx = absoluteX - tableCenterX;
   578	    const dy = absoluteY - tableCenterY;
   579	    const localX = dx * cos - dy * sin;
   580	    const localY = dx * sin + dy * cos;
   581	
   582	    // Now check against unrotated table bounds
   583	    const halfWidth = table.width / 2;
   584	    const halfHeight = table.height / 2;
   585	
   586	    // Outer boundary (can't go beyond this)
   587	    const outerHalfWidth = halfWidth + SEAT_BOUNDARY_DISTANCE;
   588	    const outerHalfHeight = halfHeight + SEAT_BOUNDARY_DISTANCE;
   589	
   590	    if (Math.abs(localX) > outerHalfWidth || Math.abs(localY) > outerHalfHeight) {
   591	      return false; // Outside boundary
   592	    }
   593	
   594	    // Inner boundary (can't be inside table)
   595	    const innerHalfWidth = halfWidth - SEAT_MIN_DISTANCE;
   596	    const innerHalfHeight = halfHeight - SEAT_MIN_DISTANCE;
   597	
   598	    if (Math.abs(localX) < innerHalfWidth && Math.abs(localY) < innerHalfHeight) {
   599	      return false; // Inside table
   600	    }
   601	
   602	    // Check seat-to-seat collision
   603	    if (checkSeatCollision(absoluteX, absoluteY, table.id, excludeSeatId)) {
   604	      return false; // Collides with another seat
   605	    }
   606	
   607	    return true;
   608	  }, [checkSeatCollision, SEAT_BOUNDARY_DISTANCE, SEAT_MIN_DISTANCE]);
   609	
   610	  // Load floor plan and fixtures
   611	  useEffect(() => {
   612	    if (useDatabase && dbFloorPlan) {
   613	      // Database mode: use the dbFloorPlan prop
   614	      setFloorPlan(dbFloorPlan);
   615	    } else if (!useDatabase) {
   616	      // In-memory mode: use FloorCanvasAPI
   617	      const fp = FloorCanvasAPI.getFloorPlan(roomId);
   618	      setFloorPlan(fp);
   619	      if (fp) {
   620	        const fixtureList = FloorCanvasAPI.getFixtures(fp.id);
   621	        setFixtures(fixtureList);
   622	      }
   623	    }
   624	  }, [roomId, useDatabase, dbFloorPlan]);
   625	
   626	  // Update fixtures from dbFixtures prop when in database mode
   627	  useEffect(() => {
   628	    if (useDatabase && dbFixtures) {
   629	      setFixtures(dbFixtures);
   630	    }
   631	  }, [useDatabase, dbFixtures, refreshKey]);
   632	
   633	  // Update tables from dbTables prop when in database mode
   634	  useEffect(() => {
   635	    if (useDatabase && dbTables) {
   636	      setTables(dbTables);
   637	    }
   638	  }, [useDatabase, dbTables, refreshKey]);
   639	
   640	  // Update seats from dbSeats prop when in database mode
   641	  useEffect(() => {
   642	    if (useDatabase && dbSeats) {
   643	      setSeats(dbSeats);
   644	
   645	      // Clear any stale seat references that no longer exist in the new seats array
   646	      const seatIds = new Set(dbSeats.map(s => s.id));
   647	
   648	      if (draggedSeatId && !seatIds.has(draggedSeatId)) {
   649	        setDraggedSeatId(null);
   650	        setIsDraggingSeat(false);
   651	        setSeatDragOffset(null);
   652	        setOriginalSeatPos(null);
   653	        setSeatDragPreview(null);
   654	
   655	        // Notify parent that selected seat should be cleared
   656	        if (onSeatSelect) {
   657	          onSeatSelect(null);
   658	        }
   659	      }
   660	    }
   661	  }, [useDatabase, dbSeats, refreshKey, draggedSeatId, onSeatSelect]);
   662	
   663	  // Refresh fixtures when they change (in-memory mode only)
   664	  const refreshFixtures = useCallback(() => {
   665	    if (useDatabase) {
   666	      // In database mode, parent handles refresh
   667	      return;
   668	    }
   669	    if (floorPlan) {
   670	      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
   671	      setFixtures(fixtureList);
   672	    }
   673	  }, [floorPlan, useDatabase]);
   674	
   675	  // Immediate refresh on refreshKey change (eliminates lag) - in-memory mode only
   676	  useEffect(() => {
   677	    if (useDatabase) return; // Database mode handled by dbFixtures prop
   678	    if (floorPlan) {
   679	      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
   680	      setFixtures(fixtureList);
   681	    }
   682	  }, [refreshKey, floorPlan, useDatabase]);
   683	
   684	  // Refresh fixtures when a selected fixture might have been updated - in-memory mode only
   685	  useEffect(() => {
   686	    if (useDatabase) return; // Database mode handled by dbFixtures prop
   687	    if (selectedFixtureId && floorPlan) {
   688	      // Refresh to pick up property changes from the Properties panel
   689	      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
   690	      setFixtures(fixtureList);
   691	    }
   692	  }, [selectedFixtureId, floorPlan, useDatabase]);
   693	
   694	  // Fast polling to catch any external updates - in-memory mode only
   695	  useEffect(() => {
   696	    if (useDatabase) return; // Database mode doesn't need polling
   697	    if (!floorPlan) return;
   698	
   699	    const intervalId = setInterval(() => {
   700	      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
   701	      setFixtures(fixtureList);
   702	    }, 100); // Refresh every 100ms for smoother updates
   703	
   704	    return () => clearInterval(intervalId);
   705	  }, [floorPlan, useDatabase]);
   706	
   707	  // Reset placement offset when tool mode changes
   708	  useEffect(() => {
   709	    setPlacementOffset(0);
   710	  }, [toolMode]);
   711	
   712	  // ESC to cancel seat drag
   713	  useEffect(() => {
   714	    const handleKeyDown = (e: KeyboardEvent) => {
   715	      if (e.key === 'Escape' && isDraggingSeat && originalSeatPos) {
   716	        // Cancel drag, revert to original position
   717	        setSeatDragPreview(null);
   718	        setIsDraggingSeat(false);
   719	        setDraggedSeatId(null);
   720	        setSeatDragOffset(null);
   721	        setOriginalSeatPos(null);
   722	      }
   723	      if (e.key === 'b' && e.ctrlKey) {
   724	        setShowBoundaryDebug(prev => !prev);
   725	      }
   726	    };
   727	
   728	    window.addEventListener('keydown', handleKeyDown);
   729	    return () => window.removeEventListener('keydown', handleKeyDown);
   730	  }, [isDraggingSeat, originalSeatPos]);
   731	
   732	  // Get canvas dimensions - FIXED size for stable coordinates (no drift on zoom/pan/combine)
   733	  const canvasDimensions = {
   734	    widthPx: CANVAS_WIDTH,
   735	    heightPx: CANVAS_HEIGHT,
   736	  };
   737	
   738	  // Calculate angle from table center to mouse position
   739	  const calculateAngle = useCallback((tableCenter: Point, mousePos: Point): number => {
   740	    const dx = mousePos.x - tableCenter.x;
   741	    const dy = mousePos.y - tableCenter.y;
   742	    return Math.atan2(dy, dx) * (180 / Math.PI) + 90; // 0 degrees = up
   743	  }, []);
   744	
   745	  // Convert screen position to floor position (feet)
   746	  const screenToFloor = useCallback(
   747	    (screenX: number, screenY: number): Point => {
   748	      if (!canvasRef.current) return { x: 0, y: 0 };
   749	      const rect = canvasRef.current.getBoundingClientRect();
   750	      // Account for zoom when converting screen coords to canvas coords
   751	      const x = (screenX - rect.left) / zoom;
   752	      const y = (screenY - rect.top) / zoom;
   753	      const position: Point = {
   754	        x: FloorCanvasAPI.pixelsToFeet(x),
   755	        y: FloorCanvasAPI.pixelsToFeet(y),
   756	      };
   757	      // Snap to grid
   758	      if (floorPlan) {
   759	        return FloorCanvasAPI.snapToGrid(position, floorPlan.gridSizeFeet);
   760	      }
   761	      return position;
   762	    },
   763	    [floorPlan, zoom]
   764	  );
   765	
   766	  // Handle resize start for tables
   767	  const handleResizeStart = useCallback(
   768	    (handle: ResizeHandle) => {
   769	      if (!selectedTableId) return;
   770	      const table = tables.find(t => t.id === selectedTableId);
   771	      if (!table) return;
   772	
   773	      setIsResizingTable(true);
   774	      setResizeHandle(handle);
   775	      setResizeStartDimensions({ width: table.width, height: table.height });
   776	      setResizeStartPos({ x: table.posX, y: table.posY });
   777	      // Mouse position will be captured in the next mouse move
   778	    },
   779	    [selectedTableId, tables]
   780	  );
   781	
   782	  // Handle mouse down
   783	  const handleMouseDown = useCallback(
   784	    (event: React.MouseEvent) => {
   785	      if (!floorPlan) return;
   786	
   787	      const point = screenToFloor(event.clientX, event.clientY);
   788	
   789	      // SELECT mode: Check if clicking on a seat to drag
   790	      if (toolMode === 'SELECT') {
   791	        const pointPx = {
   792	          x: FloorCanvasAPI.feetToPixels(point.x),
   793	          y: FloorCanvasAPI.feetToPixels(point.y),
   794	        };
   795	
   796	        // Check if clicking on any seat
   797	        for (const seat of seats) {
   798	          const table = tables.find(t => t.id === seat.tableId);
   799	          if (!table) continue;
   800	
   801	          const tableCenterX = table.posX + table.width / 2;
   802	          const tableCenterY = table.posY + table.height / 2;
   803	
   804	          // Calculate absolute seat position
   805	          const rotation = (table.rotation || 0) * Math.PI / 180;
   806	          const cos = Math.cos(rotation);
   807	          const sin = Math.sin(rotation);
   808	          const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
   809	          const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
   810	
   811	          const seatAbsX = tableCenterX + rotatedX;
   812	          const seatAbsY = tableCenterY + rotatedY;
   813	
   814	          // Check if click is within seat radius
   815	          const distance = Math.hypot(pointPx.x - seatAbsX, pointPx.y - seatAbsY);
   816	          if (distance <= SEAT_HIT_RADIUS) {
   817	            // Start dragging seat
   818	            setIsDraggingSeat(true);
   819	            setDraggedSeatId(seat.id);
   820	            setSeatDragOffset({ x: pointPx.x - seatAbsX, y: pointPx.y - seatAbsY });
   821	            setOriginalSeatPos({ x: seat.relativeX, y: seat.relativeY });
   822	            if (onSeatSelect) {
   823	              onSeatSelect(seat.id);
   824	            }
   825	            return; // Early return to prevent selecting table/fixture
   826	          }
   827	        }
   828	      }
   829	
   830	      // SELECT mode: Check if clicking on a fixture to drag
   831	      if (toolMode === 'SELECT' && selectedFixtureId) {
   832	        const fixture = fixtures.find((f) => f.id === selectedFixtureId);
   833	        if (fixture) {
   834	          // Calculate if click is on this fixture
   835	          let isOnFixture = false;
   836	          if (fixture.geometry.type === 'rectangle') {
   837	            const { position, width, height } = fixture.geometry;
   838	            isOnFixture =
   839	              point.x >= position.x &&
   840	              point.x <= position.x + width &&
   841	              point.y >= position.y &&
   842	              point.y <= position.y + height;
   843	            if (isOnFixture) {
   844	              setIsDragging(true);
   845	              setDragOffset({ x: point.x - position.x, y: point.y - position.y });
   846	              return; // Early return to prevent re-selection
   847	            }
   848	          } else if (fixture.geometry.type === 'circle') {
   849	            const { center, radius } = fixture.geometry;
   850	            const dist = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
   851	            isOnFixture = dist <= radius;
   852	            if (isOnFixture) {
   853	              setIsDragging(true);
   854	              setDragOffset({ x: point.x - center.x, y: point.y - center.y });
   855	              return; // Early return to prevent re-selection
   856	            }
   857	          }
   858	        }
   859	      }
   860	
   861	      // WALL mode: Start drawing
   862	      if (toolMode === 'WALL') {
   863	        if (!startPoint) {
   864	          // Snap start point to existing wall endpoints
   865	          const snapDistance = 0.5; // feet
   866	          let snappedStart = point;
   867	
   868	          fixtures.forEach((f) => {
   869	            if (f.geometry.type === 'line') {
   870	              const { start, end } = f.geometry;
   871	              // Check distance to start point
   872	              if (Math.hypot(point.x - start.x, point.y - start.y) < snapDistance) {
   873	                snappedStart = start;
   874	              }
   875	              // Check distance to end point
   876	              if (Math.hypot(point.x - end.x, point.y - end.y) < snapDistance) {
   877	                snappedStart = end;
   878	              }
   879	            }
   880	          });
   881	
   882	          setStartPoint(snappedStart);
   883	        } else {
   884	          // Snap end point to existing wall endpoints
   885	          const snapDistance = 0.5; // feet
   886	          let snappedEnd = point;
   887	
   888	          fixtures.forEach((f) => {
   889	            if (f.geometry.type === 'line') {
   890	              const { start, end } = f.geometry;
   891	              // Check distance to start point
   892	              if (Math.hypot(point.x - start.x, point.y - start.y) < snapDistance) {
   893	                snappedEnd = start;
   894	              }
   895	              // Check distance to end point
   896	              if (Math.hypot(point.x - end.x, point.y - end.y) < snapDistance) {
   897	                snappedEnd = end;
   898	              }
   899	            }
   900	          });
   901	
   902	          // Complete the wall
   903	          const metadata = getFixtureTypeMetadata('wall');
   904	          onFixtureCreate({
   905	            floorPlanId: floorPlan.id,
   906	            roomId: floorPlan.id,
   907	            type: 'wall',
   908	            category: metadata.category,
   909	            label: metadata.label,
   910	            geometry: { type: 'line', start: startPoint, end: snappedEnd },
   911	            color: metadata.defaultColor,
   912	            opacity: 1,
   913	            thickness: metadata.defaultThickness,
   914	            height: 'full',
   915	            blocksPlacement: true,
   916	            blocksMovement: true,
   917	            snapTarget: false,
   918	            isActive: true,
   919	          });
   920	          setStartPoint(null);
   921	          refreshFixtures();
   922	        }
   923	        return;
   924	      }
   925	
   926	      // RECTANGLE mode: Start drawing
   927	      if (toolMode === 'RECTANGLE') {
   928	        setStartPoint(point);
   929	        setIsDrawing(true);
   930	        return;
   931	      }
   932	
   933	      // CIRCLE mode: Place circle
   934	      if (toolMode === 'CIRCLE') {
   935	        // Apply auto-offset to prevent stacking
   936	        const offsetCenter = {
   937	          x: point.x + (placementOffset * 0.5),
   938	          y: point.y + (placementOffset * 0.5),
   939	        };
   940	        setPlacementOffset((prev) => (prev + 1) % 10); // Reset after 10
   941	
   942	        const metadata = getFixtureTypeMetadata(fixtureType);
   943	        onFixtureCreate({
   944	          floorPlanId: floorPlan.id,
   945	          roomId: floorPlan.id,
   946	          type: fixtureType,
   947	          category: metadata.category,
   948	          label: metadata.label,
   949	          geometry: { type: 'circle', center: offsetCenter, radius: 1 },
   950	          color: metadata.defaultColor,
   951	          opacity: metadata.category === 'zone' ? 0.3 : 1,
   952	          thickness: metadata.defaultThickness,
   953	          height: 'full',
   954	          blocksPlacement: true,
   955	          blocksMovement: true,
   956	          snapTarget: false,
   957	          isActive: true,
   958	        });
   959	        refreshFixtures();
   960	        return;
   961	      }
   962	
   963	      // TABLE mode: Place table
   964	      if (toolMode === 'TABLE' && onTableCreate) {
   965	        const shapeMetadata = getTableShapeMetadata(tableShape);
   966	
   967	        // Convert click position to pixels (tables stored in pixels in DB)
   968	        const posX = FloorCanvasAPI.feetToPixels(point.x) - shapeMetadata.defaultWidth / 2;
   969	        const posY = FloorCanvasAPI.feetToPixels(point.y) - shapeMetadata.defaultHeight / 2;
   970	
   971	        // Check for collision with fixtures
   972	        if (checkTableFixtureCollision(posX, posY, shapeMetadata.defaultWidth, shapeMetadata.defaultHeight)) {
   973	          console.log('[EditorCanvas] Cannot place table: collision with fixture');
   974	          return;
   975	        }
   976	
   977	        // Check for collision with other tables
   978	        if (checkTableCollision(posX, posY, shapeMetadata.defaultWidth, shapeMetadata.defaultHeight)) {
   979	          console.log('[EditorCanvas] Cannot place table: collision with another table');
   980	          return;
   981	        }
   982	
   983	        // Generate table name
   984	        const existingTableCount = tables.length;
   985	        const tableName = `Table ${existingTableCount + 1}`;
   986	        const abbrev = `T${existingTableCount + 1}`;
   987	
   988	        onTableCreate({
   989	          name: tableName,
   990	          abbreviation: abbrev,
   991	          capacity: shapeMetadata.defaultCapacity,
   992	          posX,
   993	          posY,
   994	          width: shapeMetadata.defaultWidth,
   995	          height: shapeMetadata.defaultHeight,
   996	          rotation: 0,
   997	          shape: tableShape,
   998	          seatPattern: shapeMetadata.defaultSeatPattern,
   999	          sectionId: roomId,
  1000	          status: 'available',
  1001	          isLocked: false,
  1002	        });
  1003	        return;
  1004	      }
  1005	
  1006	      // DELETE mode: Delete fixture or table
  1007	      if (toolMode === 'DELETE') {
  1008	        // Convert point to pixels for table comparison
  1009	        const pointPx = {
  1010	          x: FloorCanvasAPI.feetToPixels(point.x),
  1011	          y: FloorCanvasAPI.feetToPixels(point.y),
  1012	        };
  1013	
  1014	        // First check if clicking on a table
  1015	        const tableToDelete = tables.find((t) => {
  1016	          return (
  1017	            pointPx.x >= t.posX &&
  1018	            pointPx.x <= t.posX + t.width &&
  1019	            pointPx.y >= t.posY &&
  1020	            pointPx.y <= t.posY + t.height
  1021	          );
  1022	        });
  1023	
  1024	        if (tableToDelete && onTableDelete) {
  1025	          onTableDelete(tableToDelete.id);
  1026	          return;
  1027	        }
  1028	
  1029	        // Find fixture at this point
  1030	        const fixtureToDelete = fixtures.find((f) => {
  1031	          if (f.geometry.type === 'rectangle') {
  1032	            const { position, width, height } = f.geometry;
  1033	            return (
  1034	              point.x >= position.x &&
  1035	              point.x <= position.x + width &&
  1036	              point.y >= position.y &&
  1037	              point.y <= position.y + height
  1038	            );
  1039	          }
  1040	          if (f.geometry.type === 'circle') {
  1041	            const { center, radius } = f.geometry;
  1042	            const dist = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
  1043	            return dist <= radius;
  1044	          }
  1045	          if (f.geometry.type === 'line') {
  1046	            // Simplified: check if point is near line
  1047	            const { start, end } = f.geometry;
  1048	            const thickness = f.thickness || 0.5;
  1049	            const minX = Math.min(start.x, end.x) - thickness;
  1050	            const maxX = Math.max(start.x, end.x) + thickness;
  1051	            const minY = Math.min(start.y, end.y) - thickness;
  1052	            const maxY = Math.max(start.y, end.y) + thickness;
  1053	            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
  1054	          }
  1055	          return false;
  1056	        });
  1057	
  1058	        if (fixtureToDelete) {
  1059	          onFixtureDelete(fixtureToDelete.id);
  1060	          refreshFixtures();
  1061	        }
  1062	        return;
  1063	      }
  1064	
  1065	      // SELECT mode: Select fixture or table
  1066	      if (toolMode === 'SELECT') {
  1067	        // Convert point to pixels for table comparison
  1068	        const pointPx = {
  1069	          x: FloorCanvasAPI.feetToPixels(point.x),
  1070	          y: FloorCanvasAPI.feetToPixels(point.y),
  1071	        };
  1072	
  1073	        // First check if clicking on a table
  1074	        const clickedTable = tables.find((t) => {
  1075	          return (
  1076	            pointPx.x >= t.posX &&
  1077	            pointPx.x <= t.posX + t.width &&
  1078	            pointPx.y >= t.posY &&
  1079	            pointPx.y <= t.posY + t.height
  1080	          );
  1081	        });
  1082	
  1083	        if (clickedTable) {
  1084	          onFixtureSelect(null); // Deselect fixture
  1085	          if (onTableSelect) {
  1086	            onTableSelect(clickedTable.id);
  1087	            // Start dragging table if not locked
  1088	            if (!clickedTable.isLocked) {
  1089	              setIsDraggingTable(true);
  1090	              setTableDragOffset({
  1091	                x: pointPx.x - clickedTable.posX,
  1092	                y: pointPx.y - clickedTable.posY,
  1093	              });
  1094	            }
  1095	          }
  1096	          return;
  1097	        }
  1098	
  1099	        // Then check fixtures
  1100	        const clickedFixture = fixtures.find((f) => {
  1101	          if (f.geometry.type === 'rectangle') {
  1102	            const { position, width, height } = f.geometry;
  1103	            return (
  1104	              point.x >= position.x &&
  1105	              point.x <= position.x + width &&
  1106	              point.y >= position.y &&
  1107	              point.y <= position.y + height
  1108	            );
  1109	          }
  1110	          if (f.geometry.type === 'circle') {
  1111	            const { center, radius } = f.geometry;
  1112	            const dist = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
  1113	            return dist <= radius;
  1114	          }
  1115	          if (f.geometry.type === 'line') {
  1116	            const { start, end } = f.geometry;
  1117	            const thickness = f.thickness || 0.5;
  1118	            const minX = Math.min(start.x, end.x) - thickness;
  1119	            const maxX = Math.max(start.x, end.x) + thickness;
  1120	            const minY = Math.min(start.y, end.y) - thickness;
  1121	            const maxY = Math.max(start.y, end.y) + thickness;
  1122	            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
  1123	          }
  1124	          return false;
  1125	        });
  1126	
  1127	        if (onTableSelect) {
  1128	          onTableSelect(null); // Deselect table
  1129	        }
  1130	        onFixtureSelect(clickedFixture ? clickedFixture.id : null);
  1131	      }
  1132	    },
  1133	    [
  1134	      floorPlan,
  1135	      toolMode,
  1136	      fixtureType,
  1137	      tableShape,
  1138	      selectedFixtureId,
  1139	      selectedTableId,
  1140	      startPoint,
  1141	      fixtures,
  1142	      tables,
  1143	      seats,
  1144	      screenToFloor,
  1145	      onFixtureSelect,
  1146	      onFixtureCreate,
  1147	      onFixtureDelete,
  1148	      onTableSelect,
  1149	      onTableCreate,
  1150	      onTableDelete,
  1151	      onSeatSelect,
  1152	      refreshFixtures,
  1153	      checkTableFixtureCollision,
  1154	      checkTableCollision,
  1155	      placementOffset,
  1156	      SEAT_RADIUS,
  1157	    ]
  1158	  );
  1159	
  1160	  // Handle mouse move
  1161	  const handleMouseMove = useCallback(
  1162	    (event: React.MouseEvent) => {
  1163	      if (!floorPlan) return;
  1164	
  1165	      const point = screenToFloor(event.clientX, event.clientY);
  1166	      setCurrentPoint(point);
  1167	
  1168	      // Handle seat dragging
  1169	      if (isDraggingSeat && draggedSeatId && seatDragOffset) {
  1170	        const seat = seats.find(s => s.id === draggedSeatId);
  1171	        if (!seat) return;
  1172	
  1173	        const table = tables.find(t => t.id === seat.tableId);
  1174	        if (!table) return;
  1175	
  1176	        const tableCenterX = table.posX + table.width / 2;
  1177	        const tableCenterY = table.posY + table.height / 2;
  1178	
  1179	        // Calculate new absolute position
  1180	        const pointPx = {
  1181	          x: FloorCanvasAPI.feetToPixels(point.x),
  1182	          y: FloorCanvasAPI.feetToPixels(point.y),
  1183	        };
  1184	        let absoluteX = pointPx.x - seatDragOffset.x;
  1185	        let absoluteY = pointPx.y - seatDragOffset.y;
  1186	
  1187	        // CLAMP to valid zone instead of rejecting
  1188	        // Transform to table-local coordinates for boundary check
  1189	        const rotation = (table.rotation || 0) * Math.PI / 180;
  1190	        const cos = Math.cos(-rotation);
  1191	        const sin = Math.sin(-rotation);
  1192	        const dx = absoluteX - tableCenterX;
  1193	        const dy = absoluteY - tableCenterY;
  1194	        let localX = dx * cos - dy * sin;
  1195	        let localY = dx * sin + dy * cos;
  1196	
  1197	        const halfWidth = table.width / 2;
  1198	        const halfHeight = table.height / 2;
  1199	
  1200	        // Clamp to outer boundary
  1201	        const outerHalfWidth = halfWidth + SEAT_BOUNDARY_DISTANCE;
  1202	        const outerHalfHeight = halfHeight + SEAT_BOUNDARY_DISTANCE;
  1203	        localX = Math.max(-outerHalfWidth, Math.min(outerHalfWidth, localX));
  1204	        localY = Math.max(-outerHalfHeight, Math.min(outerHalfHeight, localY));
  1205	
  1206	        // Push out of table body if seat is inside
  1207	        // Seat is "inside" if BOTH x and y are within table bounds
  1208	        const SEAT_CLEARANCE = 25; // Distance from table edge to seat center
  1209	        if (Math.abs(localX) < halfWidth && Math.abs(localY) < halfHeight) {
  1210	          // Seat center is INSIDE the table - push to nearest edge with clearance
  1211	          const distToLeftRight = halfWidth - Math.abs(localX);
  1212	          const distToTopBottom = halfHeight - Math.abs(localY);
  1213	
  1214	          if (distToLeftRight < distToTopBottom) {
  1215	            // Closer to left/right edge - push horizontally
  1216	            localX = localX >= 0 ? (halfWidth + SEAT_CLEARANCE) : -(halfWidth + SEAT_CLEARANCE);
  1217	          } else {
  1218	            // Closer to top/bottom edge - push vertically
  1219	            localY = localY >= 0 ? (halfHeight + SEAT_CLEARANCE) : -(halfHeight + SEAT_CLEARANCE);
  1220	          }
  1221	        }
  1222	
  1223	        // Use clamped local coordinates as the new relative position
  1224	        const newRelativeX = localX;
  1225	        const newRelativeY = localY;
  1226	
  1227	        // Update local state immediately for smooth dragging
  1228	        setSeatDragPreview({ id: draggedSeatId, relativeX: newRelativeX, relativeY: newRelativeY });
  1229	        return;
  1230	      }
  1231	
  1232	      // Handle table rotation
  1233	      if (isRotatingTable && selectedTableId && onTableUpdate) {
  1234	        const currentTable = tables.find(t => t.id === selectedTableId);
  1235	        if (!currentTable) return;
  1236	
  1237	        // Convert point to pixels for angle calculation
  1238	        const pointPx = {
  1239	          x: FloorCanvasAPI.feetToPixels(point.x),
  1240	          y: FloorCanvasAPI.feetToPixels(point.y),
  1241	        };
  1242	
  1243	        // Calculate table center in pixels
  1244	        const tableCenter = {
  1245	          x: currentTable.posX + currentTable.width / 2,
  1246	          y: currentTable.posY + currentTable.height / 2,
  1247	        };
  1248	
  1249	        // Calculate current mouse angle
  1250	        const currentMouseAngle = calculateAngle(tableCenter, pointPx);
  1251	        const deltaAngle = currentMouseAngle - rotationStartMouseAngle;
  1252	        let newRotation = rotationStartAngle + deltaAngle;
  1253	
  1254	        // Snap to 15 increments when holding Shift
  1255	        if (event.shiftKey) {
  1256	          newRotation = Math.round(newRotation / 15) * 15;
  1257	        }
  1258	
  1259	        // Normalize to 0-360
  1260	        newRotation = ((newRotation % 360) + 360) % 360;
  1261	
  1262	        // Allow rotation - collision detection is only for awareness, not blocking
  1263	        onTableUpdate(selectedTableId, { rotation: newRotation });
  1264	        return;
  1265	      }
  1266	
  1267	      // Handle table dragging
  1268	      // Handle table resizing
  1269	      if (isResizingTable && selectedTableId && resizeHandle && resizeStartDimensions && resizeStartPos && onTableUpdate) {
  1270	        const currentTable = tables.find(t => t.id === selectedTableId);
  1271	        if (!currentTable) return;
  1272	
  1273	        const pointPx = {
  1274	          x: FloorCanvasAPI.feetToPixels(point.x),
  1275	          y: FloorCanvasAPI.feetToPixels(point.y),
  1276	        };
  1277	
  1278	        if (!resizeStartMousePos) {
  1279	          setResizeStartMousePos(pointPx);
  1280	          return;
  1281	        }
  1282	
  1283	        // Shape-specific minimum sizes
  1284	        const getMinimumSize = (shape: TableShape): { minWidth: number; minHeight: number } => {
  1285	          switch (shape) {
  1286	            case 'bar':
  1287	              return { minWidth: 80, minHeight: 30 };  // Wide and short
  1288	            case 'booth':
  1289	              return { minWidth: 60, minHeight: 80 };  // Taller than wide
  1290	            case 'round':
  1291	            case 'square':
  1292	              return { minWidth: 50, minHeight: 50 };  // Equal dimensions
  1293	            case 'oval':
  1294	              return { minWidth: 60, minHeight: 40 };  // Slightly wide
  1295	            case 'rectangle':
  1296	            default:
  1297	              return { minWidth: 60, minHeight: 40 };
  1298	          }
  1299	        };
  1300	
  1301	        const gridPx = FloorCanvasAPI.feetToPixels(floorPlan.gridSizeFeet);
  1302	        const { minWidth, minHeight } = getMinimumSize(currentTable.shape as TableShape);
  1303	        const deltaX = pointPx.x - resizeStartMousePos.x;
  1304	        const deltaY = pointPx.y - resizeStartMousePos.y;
  1305	
  1306	        let newWidth = resizeStartDimensions.width;
  1307	        let newHeight = resizeStartDimensions.height;
  1308	        let newPosX = resizeStartPos.x;
  1309	        let newPosY = resizeStartPos.y;
  1310	
  1311	        const maintainAspect = currentTable.shape === 'round' || currentTable.shape === 'square';
  1312	
  1313	        switch (resizeHandle) {
  1314	          case 'se':
  1315	            // Southeast corner - change both dimensions
  1316	            newWidth = Math.max(minWidth, resizeStartDimensions.width + deltaX);
  1317	            newHeight = Math.max(minHeight, resizeStartDimensions.height + deltaY);
  1318	            if (maintainAspect) {
  1319	              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
  1320	              newWidth = size;
  1321	              newHeight = size;
  1322	            }
  1323	            break;
  1324	          case 'sw':
  1325	            // Southwest corner - change both dimensions
  1326	            newWidth = Math.max(minWidth, resizeStartDimensions.width - deltaX);
  1327	            newHeight = Math.max(minHeight, resizeStartDimensions.height + deltaY);
  1328	            newPosX = resizeStartPos.x + (resizeStartDimensions.width - newWidth);
  1329	            if (maintainAspect) {
  1330	              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
  1331	              newWidth = size;
  1332	              newHeight = size;
  1333	              newPosX = resizeStartPos.x + (resizeStartDimensions.width - size);
  1334	            }
  1335	            break;
  1336	          case 'ne':
  1337	            // Northeast corner - change both dimensions
  1338	            newWidth = Math.max(minWidth, resizeStartDimensions.width + deltaX);
  1339	            newHeight = Math.max(minHeight, resizeStartDimensions.height - deltaY);
  1340	            newPosY = resizeStartPos.y + (resizeStartDimensions.height - newHeight);
  1341	            if (maintainAspect) {
  1342	              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
  1343	              newWidth = size;
  1344	              newHeight = size;
  1345	              newPosY = resizeStartPos.y + (resizeStartDimensions.height - size);
  1346	            }
  1347	            break;
  1348	          case 'nw':
  1349	            // Northwest corner - change both dimensions
  1350	            newWidth = Math.max(minWidth, resizeStartDimensions.width - deltaX);
  1351	            newHeight = Math.max(minHeight, resizeStartDimensions.height - deltaY);
  1352	            newPosX = resizeStartPos.x + (resizeStartDimensions.width - newWidth);
  1353	            newPosY = resizeStartPos.y + (resizeStartDimensions.height - newHeight);
  1354	            if (maintainAspect) {
  1355	              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
  1356	              newWidth = size;
  1357	              newHeight = size;
  1358	              newPosX = resizeStartPos.x + (resizeStartDimensions.width - size);
  1359	              newPosY = resizeStartPos.y + (resizeStartDimensions.height - size);
  1360	            }
  1361	            break;
  1362	          case 'e':
  1363	            // East edge - only change width
  1364	            newWidth = Math.max(minWidth, resizeStartDimensions.width + deltaX);
  1365	            newHeight = resizeStartDimensions.height; // Don't change height
  1366	            if (maintainAspect) {
  1367	              newHeight = newWidth; // For round/square, height matches width
  1368	            }
  1369	            break;
  1370	          case 'w':
  1371	            // West edge - only change width
  1372	            newWidth = Math.max(minWidth, resizeStartDimensions.width - deltaX);
  1373	            newHeight = resizeStartDimensions.height; // Don't change height
  1374	            newPosX = resizeStartPos.x + (resizeStartDimensions.width - newWidth);
  1375	            if (maintainAspect) {
  1376	              newHeight = newWidth; // For round/square, height matches width
  1377	            }
  1378	            break;
  1379	          case 's':
  1380	            // South edge - only change height
  1381	            newWidth = resizeStartDimensions.width; // Don't change width
  1382	            newHeight = Math.max(minHeight, resizeStartDimensions.height + deltaY);
  1383	            if (maintainAspect) {
  1384	              newWidth = newHeight; // For round/square, width matches height
  1385	            }
  1386	            break;
  1387	          case 'n':
  1388	            // North edge - only change height
  1389	            newWidth = resizeStartDimensions.width; // Don't change width
  1390	            newHeight = Math.max(minHeight, resizeStartDimensions.height - deltaY);
  1391	            newPosY = resizeStartPos.y + (resizeStartDimensions.height - newHeight);
  1392	            if (maintainAspect) {
  1393	              newWidth = newHeight; // For round/square, width matches height
  1394	            }
  1395	            break;
  1396	        }
  1397	
  1398	        newWidth = Math.round(newWidth / gridPx) * gridPx;
  1399	        newHeight = Math.round(newHeight / gridPx) * gridPx;
  1400	        newPosX = Math.round(newPosX / gridPx) * gridPx;
  1401	        newPosY = Math.round(newPosY / gridPx) * gridPx;
  1402	
  1403	        if (checkTableFixtureCollision(newPosX, newPosY, newWidth, newHeight)) return;
  1404	        if (checkTableCollision(newPosX, newPosY, newWidth, newHeight, selectedTableId)) return;
  1405	
  1406	        // Note: After resize, seats are reflowed. Check if reflowed positions would collide.
  1407	        // For simplicity, check if expanded table footprint + seat boundary would hit obstacles
  1408	        const expandedWidth = newWidth + SEAT_BOUNDARY_DISTANCE * 2;
  1409	        const expandedHeight = newHeight + SEAT_BOUNDARY_DISTANCE * 2;
  1410	        const expandedPosX = newPosX - SEAT_BOUNDARY_DISTANCE;
  1411	        const expandedPosY = newPosY - SEAT_BOUNDARY_DISTANCE;
  1412	
  1413	        if (checkTableFixtureCollision(expandedPosX, expandedPosY, expandedWidth, expandedHeight)) return;
  1414	        if (checkTableCollision(expandedPosX, expandedPosY, expandedWidth, expandedHeight, selectedTableId)) return;
  1415	
  1416	        onTableUpdate(selectedTableId, {
  1417	          width: newWidth,
  1418	          height: newHeight,
  1419	          posX: newPosX,
  1420	          posY: newPosY,
  1421	        });
  1422	        return;
  1423	      }
  1424	
  1425	      if (isDraggingTable && selectedTableId && tableDragOffset && onTableUpdate) {
  1426	        // Convert point to pixels for table positioning
  1427	        const pointPx = {
  1428	          x: FloorCanvasAPI.feetToPixels(point.x),
  1429	          y: FloorCanvasAPI.feetToPixels(point.y),
  1430	        };
  1431	
  1432	        // Snap to grid (convert grid size to pixels)
  1433	        const gridPx = FloorCanvasAPI.feetToPixels(floorPlan.gridSizeFeet);
  1434	        const newPosX = Math.round((pointPx.x - tableDragOffset.x) / gridPx) * gridPx;
  1435	        const newPosY = Math.round((pointPx.y - tableDragOffset.y) / gridPx) * gridPx;
  1436	
  1437	        // Get current table dimensions
  1438	        const currentTable = tables.find(t => t.id === selectedTableId);
  1439	        if (currentTable) {
  1440	          // Check for collision with fixtures
  1441	          if (checkTableFixtureCollision(newPosX, newPosY, currentTable.width, currentTable.height)) {
  1442	            // Don't update position if collision detected
  1443	            return;
  1444	          }
  1445	
  1446	          // Check for collision with other tables (exclude self)
  1447	          if (checkTableCollision(newPosX, newPosY, currentTable.width, currentTable.height, selectedTableId)) {
  1448	            // Don't allow table to overlap another table
  1449	            return;
  1450	          }
  1451	
  1452	          // Calculate available space at new position
  1453	          const availableSpace = calculateAvailableSpace(
  1454	            selectedTableId,
  1455	            newPosX,
  1456	            newPosY,
  1457	            currentTable.width,
  1458	            currentTable.height,
  1459	            currentTable.rotation || 0
  1460	          );
  1461	
  1462	          // Get current seats for this table
  1463	          const tableSeats = seats.filter(s => s.tableId === selectedTableId);
  1464	
  1465	          // Compress seats to fit available space (preview only, don't save yet)
  1466	          if (tableSeats.length > 0) {
  1467	            const compressedSeats = compressSeatsToFit(
  1468	              selectedTableId,
  1469	              tableSeats,
  1470	              { ...currentTable, posX: newPosX, posY: newPosY },
  1471	              availableSpace
  1472	            );
  1473	
  1474	            // Update local seat state for preview
  1475	            setSeats(prevSeats =>
  1476	              prevSeats.map(seat => {
  1477	                const compressed = compressedSeats.find(cs => cs.id === seat.id);
  1478	                return compressed || seat;
  1479	              })
  1480	            );
  1481	          }
  1482	        }
  1483	
  1484	        onTableUpdate(selectedTableId, {
  1485	          posX: newPosX,
  1486	          posY: newPosY,
  1487	        });
  1488	        return;
  1489	      }
  1490	
  1491	      // Handle fixture dragging
  1492	      if (isDragging && selectedFixtureId && dragOffset) {
  1493	        const fixture = fixtures.find((f) => f.id === selectedFixtureId);
  1494	        if (fixture && fixture.geometry.type === 'rectangle') {
  1495	          const newPosition = {
  1496	            x: point.x - dragOffset.x,
  1497	            y: point.y - dragOffset.y,
  1498	          };
  1499	          onFixtureUpdate(selectedFixtureId, {
  1500	            geometry: {
  1501	              ...fixture.geometry,
  1502	              position: newPosition,
  1503	            },
  1504	          });
  1505	        } else if (fixture && fixture.geometry.type === 'circle') {
  1506	          const newCenter = {
  1507	            x: point.x - dragOffset.x,
  1508	            y: point.y - dragOffset.y,
  1509	          };
  1510	          onFixtureUpdate(selectedFixtureId, {
  1511	            geometry: {
  1512	              ...fixture.geometry,
  1513	              center: newCenter,
  1514	            },
  1515	          });
  1516	        }
  1517	        refreshFixtures();
  1518	      }
  1519	    },
  1520	    [floorPlan, isDragging, isDraggingTable, isDraggingSeat, draggedSeatId, seatDragOffset, isRotatingTable, isResizingTable, resizeHandle, resizeStartDimensions, resizeStartPos, resizeStartMousePos, selectedFixtureId, selectedTableId, dragOffset, tableDragOffset, rotationStartAngle, rotationStartMouseAngle, fixtures, tables, seats, screenToFloor, calculateAngle, onFixtureUpdate, onTableUpdate, refreshFixtures, checkTableFixtureCollision, checkTableCollision, isValidSeatPosition]
  1521	  );
  1522	
  1523	  // Handle mouse up
  1524	  const handleMouseUp = useCallback(
  1525	    (event: React.MouseEvent) => {
  1526	      if (!floorPlan) return;
  1527	
  1528	      // Save seat position
  1529	      if (isDraggingSeat && draggedSeatId && seatDragPreview && onSeatUpdate) {
  1530	        const seat = seats.find(s => s.id === draggedSeatId);
  1531	        const table = seat ? tables.find(t => t.id === seat.tableId) : null;
  1532	
  1533	        if (seat && table) {
  1534	          const tableCenterX = table.posX + table.width / 2;
  1535	          const tableCenterY = table.posY + table.height / 2;
  1536	          const rotation = (table.rotation || 0) * Math.PI / 180;
  1537	
  1538	          // Calculate absolute position from preview
  1539	          let finalRelX = seatDragPreview.relativeX;
  1540	          let finalRelY = seatDragPreview.relativeY;
  1541	
  1542	          // Convert to absolute for collision check
  1543	          const absX = tableCenterX + (finalRelX * Math.cos(rotation) - finalRelY * Math.sin(rotation));
  1544	          const absY = tableCenterY + (finalRelX * Math.sin(rotation) + finalRelY * Math.cos(rotation));
  1545	
  1546	          // Check if final position collides with another seat
  1547	          if (checkSeatCollision(absX, absY, table.id, draggedSeatId)) {
  1548	            // Find the colliding seat
  1549	            const otherSeats = seats.filter(s => s.tableId === table.id && s.id !== draggedSeatId);
  1550	            let collidingSeat: typeof seat | undefined;
  1551	
  1552	            for (const other of otherSeats) {
  1553	              const otherAbsX = tableCenterX + (other.relativeX * Math.cos(rotation) - other.relativeY * Math.sin(rotation));
  1554	              const otherAbsY = tableCenterY + (other.relativeX * Math.sin(rotation) + other.relativeY * Math.cos(rotation));
  1555	              const dist = Math.hypot(absX - otherAbsX, absY - otherAbsY);
  1556	              if (dist < SEAT_COLLISION_RADIUS * 2 + 8) {
  1557	                collidingSeat = other;
  1558	                break;
  1559	              }
  1560	            }
  1561	
  1562	            if (collidingSeat) {
  1563	              // PUSH-SWAP: Move colliding seat to dragged seat's original position
  1564	              // This creates a natural "swap" effect
  1565	              if (originalSeatPos && onSeatUpdate) {
  1566	                onSeatUpdate(collidingSeat.id, {
  1567	                  relativeX: Math.round(originalSeatPos.x),
  1568	                  relativeY: Math.round(originalSeatPos.y),
  1569	                });
  1570	              }
  1571	            }
  1572	            // Use the preview position (where user dropped it)
  1573	            // The colliding seat was pushed to our old spot
  1574	          }
  1575	
  1576	          // Save final position
  1577	          onSeatUpdate(draggedSeatId, {
  1578	            relativeX: Math.round(finalRelX),
  1579	            relativeY: Math.round(finalRelY),
  1580	          });
  1581	        }
  1582	
  1583	        // Clear drag state
  1584	        setIsDraggingSeat(false);
  1585	        setDraggedSeatId(null);
  1586	        setSeatDragOffset(null);
  1587	        setOriginalSeatPos(null);
  1588	        setSeatDragPreview(null);
  1589	        return;
  1590	      }
  1591	
  1592	      // End table rotation
  1593	      if (isRotatingTable) {
  1594	        setIsRotatingTable(false);
  1595	        setRotationStartAngle(0);
  1596	        setRotationStartMouseAngle(0);
  1597	        return;
  1598	      }
  1599	
  1600	      // End table dragging
  1601	      // End table resizing
  1602	      if (isResizingTable) {
  1603	        // Trigger seat reflow if dimensions changed
  1604	        if (selectedTableId && resizeStartDimensions && onSeatsReflow) {
  1605	          const tableList = useDatabase ? (dbTables || []) : tables;
  1606	          const table = tableList.find(t => t.id === selectedTableId);
  1607	          if (table) {
  1608	            const widthChanged = table.width !== resizeStartDimensions.width;
  1609	            const heightChanged = table.height !== resizeStartDimensions.height;
  1610	
  1611	            if (widthChanged || heightChanged) {
  1612	              onSeatsReflow(selectedTableId, {
  1613	                oldWidth: resizeStartDimensions.width,
  1614	                oldHeight: resizeStartDimensions.height,
  1615	                newWidth: table.width,
  1616	                newHeight: table.height,
  1617	              });
  1618	            }
  1619	          }
  1620	        }
  1621	
  1622	        setIsResizingTable(false);
  1623	        setResizeHandle(null);
  1624	        setResizeStartDimensions(null);
  1625	        setResizeStartPos(null);
  1626	        setResizeStartMousePos(null);
  1627	        return;
  1628	      }
  1629	
  1630	      if (isDraggingTable && selectedTableId) {
  1631	        // Save compressed seat positions to database
  1632	        const currentTable = (useDatabase ? (dbTables || []) : tables).find(t => t.id === selectedTableId);
  1633	        if (currentTable && onSeatUpdate) {
  1634	          // Calculate available space at final position
  1635	          const availableSpace = calculateAvailableSpace(
  1636	            selectedTableId,
  1637	            currentTable.posX,
  1638	            currentTable.posY,
  1639	            currentTable.width,
  1640	            currentTable.height,
  1641	            currentTable.rotation || 0
  1642	          );
  1643	
  1644	          // Get current seats for this table
  1645	          const tableSeats = seats.filter(s => s.tableId === selectedTableId);
  1646	
  1647	          // Compress seats if needed
  1648	          if (tableSeats.length > 0) {
  1649	            const compressedSeats = compressSeatsToFit(
  1650	              selectedTableId,
  1651	              tableSeats,
  1652	              currentTable,
  1653	              availableSpace
  1654	            );
  1655	
  1656	            // Save compressed positions to database
  1657	            compressedSeats.forEach(seat => {
  1658	              // Only update if position changed
  1659	              const originalSeat = tableSeats.find(s => s.id === seat.id);
  1660	              if (originalSeat &&
  1661	                  (originalSeat.relativeX !== seat.relativeX || originalSeat.relativeY !== seat.relativeY)) {
  1662	                onSeatUpdate(seat.id, {
  1663	                  relativeX: seat.relativeX,
  1664	                  relativeY: seat.relativeY,
  1665	                });
  1666	              }
  1667	            });
  1668	          }
  1669	        }
  1670	
  1671	        setIsDraggingTable(false);
  1672	        setTableDragOffset(null);
  1673	        return;
  1674	      }
  1675	
  1676	      // End fixture dragging
  1677	      if (isDragging) {
  1678	        setIsDragging(false);
  1679	        setDragOffset(null);
  1680	        return;
  1681	      }
  1682	
  1683	      // RECTANGLE mode: Complete drawing
  1684	      if (toolMode === 'RECTANGLE' && isDrawing && startPoint) {
  1685	        const point = screenToFloor(event.clientX, event.clientY);
  1686	        const width = Math.abs(point.x - startPoint.x);
  1687	        const height = Math.abs(point.y - startPoint.y);
  1688	
  1689	        // Only create if has some size
  1690	        if (width > 0.5 && height > 0.5) {
  1691	          // Apply auto-offset to prevent stacking
  1692	          const basePosition = {
  1693	            x: Math.min(startPoint.x, point.x),
  1694	            y: Math.min(startPoint.y, point.y),
  1695	          };
  1696	          const position = {
  1697	            x: basePosition.x + (placementOffset * 0.5),
  1698	            y: basePosition.y + (placementOffset * 0.5),
  1699	          };
  1700	          setPlacementOffset((prev) => (prev + 1) % 10); // Reset after 10
  1701	
  1702	          const metadata = getFixtureTypeMetadata(fixtureType);
  1703	          onFixtureCreate({
  1704	            floorPlanId: floorPlan.id,
  1705	            roomId: floorPlan.id,
  1706	            type: fixtureType,
  1707	            category: metadata.category,
  1708	            label: metadata.label,
  1709	            geometry: { type: 'rectangle', position, width, height, rotation: 0 },
  1710	            color: metadata.defaultColor,
  1711	            opacity: metadata.category === 'zone' ? 0.3 : 1,
  1712	            thickness: metadata.defaultThickness,
  1713	            height: metadata.category === 'surface' ? 'counter' : null,
  1714	            blocksPlacement: true,
  1715	            blocksMovement: metadata.category !== 'zone',
  1716	            snapTarget: metadata.category === 'surface',
  1717	            isActive: true,
  1718	          });
  1719	          refreshFixtures();
  1720	        }
  1721	
  1722	        setStartPoint(null);
  1723	        setIsDrawing(false);
  1724	      }
  1725	    },
  1726	    [floorPlan, isDragging, isDraggingTable, isDraggingSeat, draggedSeatId, seatDragPreview, isRotatingTable, isResizingTable, toolMode, isDrawing, startPoint, fixtureType, placementOffset, screenToFloor, onFixtureCreate, onSeatUpdate, onSeatsReflow, selectedTableId, resizeStartDimensions, useDatabase, dbTables, tables, refreshFixtures]
  1727	  );
  1728	
  1729	  // Render preview for current drawing
  1730	  const renderPreview = () => {
  1731	    if (!currentPoint) return null;
  1732	
  1733	    // WALL mode: Preview line from start point to current
  1734	    if (toolMode === 'WALL' && startPoint) {
  1735	      const start = startPoint;
  1736	      const end = currentPoint;
  1737	      const dx = end.x - start.x;
  1738	      const dy = end.y - start.y;
  1739	      const length = Math.sqrt(dx * dx + dy * dy);
  1740	      const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  1741	
  1742	      return (
  1743	        <div
  1744	          style={{
  1745	            position: 'absolute',
  1746	            left: FloorCanvasAPI.feetToPixels(start.x),
  1747	            top: FloorCanvasAPI.feetToPixels(start.y - 0.25),
  1748	            width: FloorCanvasAPI.feetToPixels(length),
  1749	            height: FloorCanvasAPI.feetToPixels(0.5),
  1750	            backgroundColor: '#3498db',
  1751	            opacity: 0.5,
  1752	            transform: `rotate(${angle}deg)`,
  1753	            transformOrigin: 'left center',
  1754	            pointerEvents: 'none',
  1755	          }}
  1756	        />
  1757	      );
  1758	    }
  1759	
  1760	    // RECTANGLE mode: Preview rectangle
  1761	    if (toolMode === 'RECTANGLE' && isDrawing && startPoint) {
  1762	      const width = Math.abs(currentPoint.x - startPoint.x);
  1763	      const height = Math.abs(currentPoint.y - startPoint.y);
  1764	      const position = {
  1765	        x: Math.min(startPoint.x, currentPoint.x),
  1766	        y: Math.min(startPoint.y, currentPoint.y),
  1767	      };
  1768	
  1769	      return (
  1770	        <div
  1771	          style={{
  1772	            position: 'absolute',
  1773	            left: FloorCanvasAPI.feetToPixels(position.x),
  1774	            top: FloorCanvasAPI.feetToPixels(position.y),
  1775	            width: FloorCanvasAPI.feetToPixels(width),
  1776	            height: FloorCanvasAPI.feetToPixels(height),
  1777	            backgroundColor: getFixtureTypeMetadata(fixtureType).defaultColor,
  1778	            opacity: 0.5,
  1779	            border: '2px dashed #3498db',
  1780	            pointerEvents: 'none',
  1781	          }}
  1782	        />
  1783	      );
  1784	    }
  1785	
  1786	    return null;
  1787	  };
  1788	
  1789	  // =============================================================================
  1790	  // ZOOM AND PAN HANDLERS
  1791	  // =============================================================================
  1792	
  1793	  // Zoom handler (wheel event)
  1794	  const handleWheel = useCallback((e: React.WheelEvent) => {
  1795	    // Only zoom if Ctrl/Cmd is held
  1796	    if (e.ctrlKey || e.metaKey) {
  1797	      e.preventDefault();
  1798	      const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
  1799	      setZoom(prev => Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, prev + delta)));
  1800	    }
  1801	  }, []);
  1802	
  1803	  // Pan handlers (middle mouse or Alt+drag)
  1804	  const handlePanStart = useCallback((e: React.PointerEvent) => {
  1805	    // Middle mouse button OR Alt key held
  1806	    if (e.button === 1 || (e.button === 0 && e.altKey)) {
  1807	      e.preventDefault();
  1808	      setIsPanning(true);
  1809	      setLastPanPoint({ x: e.clientX, y: e.clientY });
  1810	      (e.target as HTMLElement).setPointerCapture(e.pointerId);
  1811	    }
  1812	  }, []);
  1813	
  1814	  const handlePanMove = useCallback((e: React.PointerEvent) => {
  1815	    if (!isPanning || !lastPanPoint) return;
  1816	
  1817	    const dx = e.clientX - lastPanPoint.x;
  1818	    const dy = e.clientY - lastPanPoint.y;
  1819	
  1820	    setPanOffset(prev => ({
  1821	      x: prev.x + dx,
  1822	      y: prev.y + dy,
  1823	    }));
  1824	    setLastPanPoint({ x: e.clientX, y: e.clientY });
  1825	  }, [isPanning, lastPanPoint]);
  1826	
  1827	  const handlePanEnd = useCallback((e: React.PointerEvent) => {
  1828	    if (isPanning) {
  1829	      setIsPanning(false);
  1830	      setLastPanPoint(null);
  1831	      (e.target as HTMLElement).releasePointerCapture(e.pointerId);
  1832	    }
  1833	  }, [isPanning]);
  1834	
  1835	  // Fit to screen - calculate zoom to fit canvas in viewport
  1836	  const fitToScreen = useCallback(() => {
  1837	    if (!canvasRef.current) return;
  1838	    const container = canvasRef.current.parentElement;
  1839	    if (!container) return;
  1840	
  1841	    const containerWidth = container.clientWidth - 48; // padding
  1842	    const containerHeight = container.clientHeight - 48;
  1843	
  1844	    const scaleX = containerWidth / CANVAS_WIDTH;
  1845	    const scaleY = containerHeight / CANVAS_HEIGHT;
  1846	    const newZoom = Math.min(scaleX, scaleY, ZOOM_MAX);
  1847	
  1848	    setZoom(Math.max(ZOOM_MIN, newZoom));
  1849	    setPanOffset({ x: 0, y: 0 });
  1850	  }, []);
  1851	
  1852	  // Reset zoom
  1853	  const resetZoom = useCallback(() => {
  1854	    setZoom(ZOOM_DEFAULT);
  1855	    setPanOffset({ x: 0, y: 0 });
  1856	  }, []);
  1857	
  1858	  // Expose zoom controls to parent
  1859	  useEffect(() => {
  1860	    if (zoomControlRef) {
  1861	      zoomControlRef.current = {
  1862	        fitToScreen,
  1863	        resetZoom,
  1864	        setZoom,
  1865	        zoom,
  1866	      };
  1867	    }
  1868	  }, [zoomControlRef, fitToScreen, resetZoom, zoom]);
  1869	
  1870	  // Notify parent of zoom changes
  1871	  useEffect(() => {
  1872	    onZoomChange?.(zoom);
  1873	  }, [zoom, onZoomChange]);
  1874	
  1875	  // =============================================================================
  1876	  // RENDER FUNCTIONS
  1877	  // =============================================================================
  1878	
  1879	  // Render fixtures with selection highlight
  1880	  const renderFixtures = () => {
  1881	    return fixtures.map((fixture) => {
  1882	      const isSelected = fixture.id === selectedFixtureId;
  1883	      const baseStyle: React.CSSProperties = {
  1884	        position: 'absolute',
  1885	        backgroundColor: fixture.color,
  1886	        opacity: fixture.opacity,
  1887	        cursor: toolMode === 'SELECT' ? 'move' : toolMode === 'DELETE' ? 'pointer' : 'default',
  1888	        border: isSelected ? '2px solid #3498db' : 'none',
  1889	        boxShadow: isSelected ? '0 0 8px rgba(52, 152, 219, 0.5)' : 'none',
  1890	      };
  1891	
  1892	      if (fixture.geometry.type === 'rectangle') {
  1893	        const { position, width, height, rotation } = fixture.geometry;
  1894	        return (
  1895	          <div
  1896	            key={fixture.id}
  1897	            style={{
  1898	              ...baseStyle,
  1899	              left: FloorCanvasAPI.feetToPixels(position.x),
  1900	              top: FloorCanvasAPI.feetToPixels(position.y),
  1901	              width: FloorCanvasAPI.feetToPixels(width),
  1902	              height: FloorCanvasAPI.feetToPixels(height),
  1903	              transform: `rotate(${rotation}deg)`,
  1904	              display: 'flex',
  1905	              alignItems: 'center',
  1906	              justifyContent: 'center',
  1907	            }}
  1908	            title={fixture.label}
  1909	          >
  1910	            <span
  1911	              style={{
  1912	                fontSize: 10,
  1913	                fontWeight: 600,
  1914	                color: '#fff',
  1915	                textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
  1916	                pointerEvents: 'none',
  1917	                whiteSpace: 'nowrap',
  1918	                overflow: 'hidden',
  1919	                textOverflow: 'ellipsis',
  1920	                maxWidth: '90%',
  1921	                textAlign: 'center',
  1922	              }}
  1923	            >
  1924	              {fixture.label}
  1925	            </span>
  1926	          </div>
  1927	        );
  1928	      }
  1929	
  1930	      if (fixture.geometry.type === 'circle') {
  1931	        const { center, radius } = fixture.geometry;
  1932	        return (
  1933	          <div
  1934	            key={fixture.id}
  1935	            style={{
  1936	              ...baseStyle,
  1937	              left: FloorCanvasAPI.feetToPixels(center.x - radius),
  1938	              top: FloorCanvasAPI.feetToPixels(center.y - radius),
  1939	              width: FloorCanvasAPI.feetToPixels(radius * 2),
  1940	              height: FloorCanvasAPI.feetToPixels(radius * 2),
  1941	              borderRadius: '50%',
  1942	              display: 'flex',
  1943	              alignItems: 'center',
  1944	              justifyContent: 'center',
  1945	            }}
  1946	            title={fixture.label}
  1947	          >
  1948	            <span
  1949	              style={{
  1950	                fontSize: 10,
  1951	                fontWeight: 600,
  1952	                color: '#fff',
  1953	                textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
  1954	                pointerEvents: 'none',
  1955	                whiteSpace: 'nowrap',
  1956	                textAlign: 'center',
  1957	              }}
  1958	            >
  1959	              {fixture.label}
  1960	            </span>
  1961	          </div>
  1962	        );
  1963	      }
  1964	
  1965	      if (fixture.geometry.type === 'line') {
  1966	        const { start, end } = fixture.geometry;
  1967	        const thickness = fixture.thickness || 0.5;
  1968	        const dx = end.x - start.x;
  1969	        const dy = end.y - start.y;
  1970	        const length = Math.sqrt(dx * dx + dy * dy);
  1971	        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  1972	
  1973	        return (
  1974	          <div
  1975	            key={fixture.id}
  1976	            style={{
  1977	              ...baseStyle,
  1978	              left: FloorCanvasAPI.feetToPixels(start.x),
  1979	              top: FloorCanvasAPI.feetToPixels(start.y - thickness / 2),
  1980	              width: FloorCanvasAPI.feetToPixels(length),
  1981	              height: FloorCanvasAPI.feetToPixels(thickness),
  1982	              transform: `rotate(${angle}deg)`,
  1983	              transformOrigin: 'left center',
  1984	              display: 'flex',
  1985	              alignItems: 'center',
  1986	              justifyContent: 'center',
  1987	            }}
  1988	            title={fixture.label}
  1989	          >
  1990	            <span
  1991	              style={{
  1992	                fontSize: 10,
  1993	                fontWeight: 600,
  1994	                color: '#fff',
  1995	                textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
  1996	                pointerEvents: 'none',
  1997	                whiteSpace: 'nowrap',
  1998	                backgroundColor: 'rgba(0,0,0,0.3)',
  1999	                padding: '2px 6px',
  2000	                borderRadius: 3,
  2001	              }}
  2002	            >
  2003	              {fixture.label}
  2004	            </span>
  2005	          </div>
  2006	        );
  2007	      }
  2008	
  2009	      return null;
  2010	    });
  2011	  };
  2012	
  2013	  // Render tables
  2014	  const renderTables = () => {
  2015	    return tables.map((table) => (
  2016	      <TableRenderer
  2017	        key={table.id}
  2018	        table={table}
  2019	        isSelected={table.id === selectedTableId}
  2020	        isDragging={isDraggingTable && table.id === selectedTableId}
  2021	        isRotating={isRotatingTable && table.id === selectedTableId}
  2022	        onSelect={() => {
  2023	          if (onTableSelect) {
  2024	            onTableSelect(table.id);
  2025	          }
  2026	        }}
  2027	        onRotateStart={(e) => {
  2028	          if (!onTableSelect || !onTableUpdate) return;
  2029	
  2030	          // Select this table
  2031	          onTableSelect(table.id);
  2032	
  2033	          // Start rotation
  2034	          setIsRotatingTable(true);
  2035	
  2036	          // Store initial rotation angle
  2037	          setRotationStartAngle(table.rotation);
  2038	
  2039	          // Calculate initial mouse angle relative to table center
  2040	          const pointFeet = screenToFloor(e.clientX, e.clientY);
  2041	          const pointPx = {
  2042	            x: FloorCanvasAPI.feetToPixels(pointFeet.x),
  2043	            y: FloorCanvasAPI.feetToPixels(pointFeet.y),
  2044	          };
  2045	          const tableCenter = {
  2046	            x: table.posX + table.width / 2,
  2047	            y: table.posY + table.height / 2,
  2048	          };
  2049	          const initialMouseAngle = calculateAngle(tableCenter, pointPx);
  2050	          setRotationStartMouseAngle(initialMouseAngle);
  2051	        }}
  2052	        isResizing={isResizingTable && table.id === selectedTableId}
  2053	        onResizeStart={handleResizeStart}
  2054	      />
  2055	    ));
  2056	  };
  2057	
  2058	  // Render seats
  2059	  const renderSeats = () => {
  2060	    return seats.map((seat) => {
  2061	      const table = tables.find(t => t.id === seat.tableId);
  2062	      if (!table) return null;
  2063	
  2064	      const tableCenterX = table.posX + table.width / 2;
  2065	      const tableCenterY = table.posY + table.height / 2;
  2066	
  2067	      // Use preview position if dragging this seat
  2068	      const seatData = (isDraggingSeat && draggedSeatId === seat.id && seatDragPreview)
  2069	        ? { ...seat, relativeX: seatDragPreview.relativeX, relativeY: seatDragPreview.relativeY }
  2070	        : seat;
  2071	
  2072	      // Calculate absolute position with table rotation
  2073	      const rotation = (table.rotation || 0) * Math.PI / 180;
  2074	      const cos = Math.cos(rotation);
  2075	      const sin = Math.sin(rotation);
  2076	      const rotatedX = seatData.relativeX * cos - seatData.relativeY * sin;
  2077	      const rotatedY = seatData.relativeX * sin + seatData.relativeY * cos;
  2078	
  2079	      const seatAbsX = tableCenterX + rotatedX;
  2080	      const seatAbsY = tableCenterY + rotatedY;
  2081	
  2082	      return (
  2083	        <div
  2084	          key={seat.id}
  2085	          style={{
  2086	            position: 'absolute',
  2087	            left: seatAbsX - 10, // Center the 20px SeatRenderer
  2088	            top: seatAbsY - 10,
  2089	            width: 20,  // Match SeatRenderer's seatSize (20px)
  2090	            height: 20,
  2091	            cursor: toolMode === 'SELECT' ? 'move' : 'default',
  2092	            pointerEvents: 'auto',
  2093	          }}
  2094	        >
  2095	          <SeatRenderer
  2096	            seat={seatData}
  2097	            tableRotation={table.rotation || 0}
  2098	            isSelected={draggedSeatId === seat.id}
  2099	            isHighlighted={false}
  2100	            hasItems={false}
  2101	          />
  2102	        </div>
  2103	      );
  2104	    });
  2105	  };
  2106	
  2107	  // Grid is now rendered via CSS backgroundImage on the canvas div
  2108	  // No SVG grid needed - this improves performance and avoids visual conflicts
  2109	
  2110	  if (!floorPlan) {
  2111	    return (
  2112	      <div style={{ padding: 24, textAlign: 'center', color: '#999' }}>
  2113	        No floor plan found. Please select a room.
  2114	      </div>
  2115	    );
  2116	  }
  2117	
  2118	  return (
  2119	    <div
  2120	      style={{
  2121	        width: '100%',
  2122	        height: 'calc(100vh - 280px)',
  2123	        overflow: 'auto',
  2124	        position: 'relative',
  2125	        backgroundColor: '#e9ecef',
  2126	        borderRadius: 8,
  2127	        cursor: isPanning ? 'grabbing' : 'default',
  2128	      }}
  2129	      onWheel={handleWheel}
  2130	    >
  2131	      <div
  2132	        style={{
  2133	          transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoom})`,
  2134	          transformOrigin: 'top left',
  2135	          transition: isPanning ? 'none' : 'transform 0.1s ease-out',
  2136	        }}
  2137	      >
  2138	        <div
  2139	          ref={canvasRef}
  2140	          onPointerDown={(e) => {
  2141	            // Check for pan first
  2142	            if (e.button === 1 || (e.button === 0 && e.altKey)) {
  2143	              handlePanStart(e);
  2144	              return;
  2145	            }
  2146	            handleMouseDown(e as unknown as React.MouseEvent);
  2147	          }}
  2148	          onPointerMove={(e) => {
  2149	            if (isPanning) {
  2150	              handlePanMove(e);
  2151	              return;
  2152	            }
  2153	            handleMouseMove(e as unknown as React.MouseEvent);
  2154	          }}
  2155	          onPointerUp={(e) => {
  2156	            if (isPanning) {
  2157	              handlePanEnd(e);
  2158	              return;
  2159	            }
  2160	            handleMouseUp(e as unknown as React.MouseEvent);
  2161	          }}
  2162	          style={{
  2163	            position: 'relative',
  2164	            width: CANVAS_WIDTH,
  2165	            height: CANVAS_HEIGHT,
  2166	            backgroundColor: '#f8f9fa',
  2167	            backgroundImage: `
  2168	              linear-gradient(rgba(0,0,0,0.08) 1px, transparent 1px),
  2169	              linear-gradient(90deg, rgba(0,0,0,0.08) 1px, transparent 1px)
  2170	            `,
  2171	            backgroundSize: `${GRID_SIZE}px ${GRID_SIZE}px`,
  2172	            border: '2px solid #ccc',
  2173	            borderRadius: 8,
  2174	            overflow: 'hidden',
  2175	            cursor: toolMode === 'SELECT' ? 'default' : 'crosshair',
  2176	            userSelect: 'none',
  2177	            WebkitUserSelect: 'none',
  2178	          }}
  2179	        >
  2180	      {/* Grid is rendered via CSS backgroundImage - no SVG needed */}
  2181	
  2182	      {/* Fixtures */}
  2183	      {renderFixtures()}
  2184	
  2185	      {/* Tables */}
  2186	      {renderTables()}
  2187	
  2188	      {/* Seats */}
  2189	      {renderSeats()}
  2190	
  2191	      {/* Boundary visualization when dragging a seat */}
  2192	      {isDraggingSeat && draggedSeatId && (() => {
  2193	        const seat = seats.find(s => s.id === draggedSeatId);
  2194	        const table = seat ? tables.find(t => t.id === seat.tableId) : null;
  2195	        if (!table) return null;
  2196	
  2197	        const tableCenterX = table.posX + table.width / 2;
  2198	        const tableCenterY = table.posY + table.height / 2;
  2199	        const halfW = table.width / 2;
  2200	        const halfH = table.height / 2;
  2201	        const rotation = table.rotation || 0;
  2202	
  2203	        // Get other seats on this table for collision zone visualization
  2204	        const otherSeats = seats.filter(s => s.tableId === table.id && s.id !== draggedSeatId);
  2205	
  2206	        return (
  2207	          <>
  2208	            {/* Inner boundary - table edge (red dashed) */}
  2209	            <div
  2210	              style={{
  2211	                position: 'absolute',
  2212	                left: table.posX,
  2213	                top: table.posY,
  2214	                width: table.width,
  2215	                height: table.height,
  2216	                border: '2px dashed rgba(239, 68, 68, 0.7)',
  2217	                borderRadius: table.shape === 'round' ? '50%' : 8,
  2218	                transform: `rotate(${rotation}deg)`,
  2219	                transformOrigin: 'center center',
  2220	                pointerEvents: 'none',
  2221	                zIndex: 998,
  2222	              }}
  2223	            />
  2224	
  2225	            {/* Outer boundary - max drag distance (blue dashed) */}
  2226	            <div
  2227	              style={{
  2228	                position: 'absolute',
  2229	                left: table.posX - SEAT_BOUNDARY_DISTANCE,
  2230	                top: table.posY - SEAT_BOUNDARY_DISTANCE,
  2231	                width: table.width + SEAT_BOUNDARY_DISTANCE * 2,
  2232	                height: table.height + SEAT_BOUNDARY_DISTANCE * 2,
  2233	                border: '2px dashed rgba(59, 130, 246, 0.5)',
  2234	                borderRadius: table.shape === 'round' ? '50%' : 12,
  2235	                transform: `rotate(${rotation}deg)`,
  2236	                transformOrigin: 'center center',
  2237	                pointerEvents: 'none',
  2238	                zIndex: 997,
  2239	              }}
  2240	            />
  2241	
  2242	            {/* Valid zone - between inner and outer (green fill) */}
  2243	            <div
  2244	              style={{
  2245	                position: 'absolute',
  2246	                left: table.posX - SEAT_BOUNDARY_DISTANCE,
  2247	                top: table.posY - SEAT_BOUNDARY_DISTANCE,
  2248	                width: table.width + SEAT_BOUNDARY_DISTANCE * 2,
  2249	                height: table.height + SEAT_BOUNDARY_DISTANCE * 2,
  2250	                backgroundColor: 'rgba(34, 197, 94, 0.1)',
  2251	                borderRadius: table.shape === 'round' ? '50%' : 12,
  2252	                transform: `rotate(${rotation}deg)`,
  2253	                transformOrigin: 'center center',
  2254	                pointerEvents: 'none',
  2255	                zIndex: 996,
  2256	              }}
  2257	            />
  2258	
  2259	            {/* Collision zones around other seats (orange circles) */}
  2260	            {otherSeats.map((otherSeat) => {
  2261	              const rot = rotation * Math.PI / 180;
  2262	              const cos = Math.cos(rot);
  2263	              const sin = Math.sin(rot);
  2264	              const rotatedX = otherSeat.relativeX * cos - otherSeat.relativeY * sin;
  2265	              const rotatedY = otherSeat.relativeX * sin + otherSeat.relativeY * cos;
  2266	              const seatAbsX = tableCenterX + rotatedX;
  2267	              const seatAbsY = tableCenterY + rotatedY;
  2268	              const collisionDiameter = SEAT_COLLISION_RADIUS * 2 + 4;
  2269	
  2270	              return (
  2271	                <div
  2272	                  key={`collision-${otherSeat.id}`}
  2273	                  style={{
  2274	                    position: 'absolute',
  2275	                    left: seatAbsX - collisionDiameter / 2,
  2276	                    top: seatAbsY - collisionDiameter / 2,
  2277	                    width: collisionDiameter,
  2278	                    height: collisionDiameter,
  2279	                    border: '2px dashed rgba(249, 115, 22, 0.6)',
  2280	                    borderRadius: '50%',
  2281	                    backgroundColor: 'rgba(249, 115, 22, 0.1)',
  2282	                    pointerEvents: 'none',
  2283	                    zIndex: 999,
  2284	                  }}
  2285	                />
  2286	              );
  2287	            })}
  2288	          </>
  2289	        );
  2290	      })()}
  2291	
  2292	      {/* Debug: Show all seat collision zones */}
  2293	      {showBoundaryDebug && seats.map((seat) => {
  2294	        const table = tables.find(t => t.id === seat.tableId);
  2295	        if (!table) return null;
  2296	
  2297	        const tableCenterX = table.posX + table.width / 2;
  2298	        const tableCenterY = table.posY + table.height / 2;
  2299	        const rotation = (table.rotation || 0) * Math.PI / 180;
  2300	        const cos = Math.cos(rotation);
  2301	        const sin = Math.sin(rotation);
  2302	        const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
  2303	        const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
  2304	        const seatAbsX = tableCenterX + rotatedX;
  2305	        const seatAbsY = tableCenterY + rotatedY;
  2306	
  2307	        return (
  2308	          <div
  2309	            key={`debug-${seat.id}`}
  2310	            style={{
  2311	              position: 'absolute',
  2312	              left: seatAbsX - SEAT_COLLISION_RADIUS,
  2313	              top: seatAbsY - SEAT_COLLISION_RADIUS,
  2314	              width: SEAT_COLLISION_RADIUS * 2,
  2315	              height: SEAT_COLLISION_RADIUS * 2,
  2316	              borderRadius: '50%',
  2317	              border: '1px dashed rgba(255, 100, 100, 0.6)',
  2318	              backgroundColor: 'rgba(255, 100, 100, 0.1)',
  2319	              pointerEvents: 'none',
  2320	              zIndex: 999,
  2321	            }}
  2322	          />
  2323	        );
  2324	      })}
  2325	
  2326	      {/* Debug: Show table inner boundary (no-go zone) */}
  2327	      {showBoundaryDebug && tables.map((table) => (
  2328	        <div
  2329	          key={`debug-inner-${table.id}`}
  2330	          style={{
  2331	            position: 'absolute',
  2332	            left: table.posX,
  2333	            top: table.posY,
  2334	            width: table.width,
  2335	            height: table.height,
  2336	            border: '2px solid rgba(255, 0, 0, 0.4)',
  2337	            backgroundColor: 'rgba(255, 0, 0, 0.05)',
  2338	            transform: `rotate(${table.rotation || 0}deg)`,
  2339	            transformOrigin: 'center center',
  2340	            pointerEvents: 'none',
  2341	            zIndex: 998,
  2342	          }}
  2343	        />
  2344	      ))}
  2345	
  2346	      {/* Debug mode indicator */}
  2347	      {showBoundaryDebug && (
  2348	        <div
  2349	          style={{
  2350	            position: 'absolute',
  2351	            top: 8,
  2352	            left: 8,
  2353	            padding: '4px 8px',
  2354	            backgroundColor: 'rgba(255, 100, 100, 0.9)',
  2355	            color: 'white',
  2356	            borderRadius: 4,
  2357	            fontSize: 11,
  2358	            fontWeight: 600,
  2359	            pointerEvents: 'none',
  2360	            zIndex: 2000,
  2361	          }}
  2362	        >
  2363	          DEBUG: Boundaries (Ctrl+B to toggle)
  2364	        </div>
  2365	      )}
  2366	
  2367	      {/* Preview */}
  2368	      {renderPreview()}
  2369	
  2370	      {/* Room info */}
  2371	      <div
  2372	        style={{
  2373	          position: 'absolute',
  2374	          bottom: 8,
  2375	          left: 8,
  2376	          padding: '4px 8px',
  2377	          backgroundColor: 'rgba(0, 0, 0, 0.6)',
  2378	          color: 'white',
  2379	          borderRadius: 4,
  2380	          fontSize: 12,
  2381	          pointerEvents: 'none',
  2382	        }}
  2383	      >
  2384	        {floorPlan.name} ({floorPlan.widthFeet}ft x {floorPlan.heightFeet}ft)
  2385	      </div>
  2386	
  2387	      {/* Cursor position */}
  2388	      {currentPoint && (
  2389	        <div
  2390	          style={{
  2391	            position: 'absolute',
  2392	            top: 8,
  2393	            right: 8,
  2394	            padding: '4px 8px',
  2395	            backgroundColor: 'rgba(0, 0, 0, 0.6)',
  2396	            color: 'white',
  2397	            borderRadius: 4,
  2398	            fontSize: 12,
  2399	            pointerEvents: 'none',
  2400	            fontFamily: 'monospace',
  2401	          }}
  2402	        >
  2403	          ({currentPoint.x.toFixed(1)}, {currentPoint.y.toFixed(1)})
  2404	        </div>
  2405	      )}
  2406	        </div>
  2407	      </div>
  2408	    </div>
  2409	  );
  2410	}
  2411	
  2412	export default EditorCanvas;

================================================================================
FILE: /src/domains/floor-plan/admin/FloorPlanEditor.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Floor Plan Editor Component
     6	 *
     7	 * Main editor interface for creating and editing floor plans.
     8	 * NOW WITH DATABASE PERSISTENCE!
     9	 */
    10	
    11	import React, { useState, useCallback, useEffect, useRef } from 'react';
    12	import { FloorCanvasAPI, RoomSelector } from '../canvas';
    13	import { EditorCanvas } from './EditorCanvas';
    14	import { FixtureToolbar } from './FixtureToolbar';
    15	import { FixtureProperties } from './FixtureProperties';
    16	import { TableProperties } from './TableProperties';
    17	import type { EditorToolMode, FixtureType, EditorTable, TableShape } from './types';
    18	import type { Fixture } from '../shared/types';
    19	import {
    20	  PIXELS_PER_FOOT,
    21	  ZOOM_MIN,
    22	  ZOOM_MAX,
    23	  ZOOM_STEP,
    24	} from '@/lib/floorplan/constants';
    25	
    26	// =============================================================================
    27	// TYPES
    28	// =============================================================================
    29	
    30	interface FloorPlanEditorProps {
    31	  initialRoomId?: string;
    32	  locationId?: string;
    33	  useDatabase?: boolean; // Toggle between in-memory and database mode
    34	  onSave?: () => void;
    35	  onExit?: () => void;
    36	}
    37	
    38	// Database element type
    39	interface FloorPlanElement {
    40	  id: string;
    41	  name: string;
    42	  elementType: string;
    43	  visualType: string;
    44	  geometry: unknown;
    45	  posX: number;
    46	  posY: number;
    47	  width: number;
    48	  height: number;
    49	  rotation: number;
    50	  thickness: number;
    51	  fillColor: string | null;
    52	  opacity: number;
    53	  isLocked: boolean;
    54	}
    55	
    56	// =============================================================================
    57	// DATABASE  EDITOR CONVERSION
    58	// =============================================================================
    59	// Database stores positions in PIXELS for direct FOH rendering
    60	// Editor canvas works in FEET (uses FloorCanvasAPI.feetToPixels for display)
    61	// We convert: DB (pixels)  Editor (feet) using PIXELS_PER_FOOT from constants
    62	
    63	function pixelsToFeet(pixels: number): number {
    64	  return pixels / PIXELS_PER_FOOT;
    65	}
    66	
    67	function feetToPixels(feet: number): number {
    68	  return feet * PIXELS_PER_FOOT;
    69	}
    70	
    71	// Convert database element (PIXELS) to Fixture (FEET) for Editor
    72	function elementToFixture(el: FloorPlanElement, sectionId: string): Fixture {
    73	  // For database mode, we use posX/posY/width/height as the source of truth
    74	  // The geometry field may be out of sync, so we reconstruct it from posX/posY/width/height
    75	  const elementType = el.elementType || 'fixture';
    76	  const geometry = el.geometry as { type: string; [key: string]: unknown } | null;
    77	  const geoType = geometry?.type;
    78	
    79	  let fixtureGeometry: Fixture['geometry'];
    80	
    81	  if (geoType === 'line') {
    82	    // For lines, use the geometry start/end if available, otherwise derive from posX/posY/width/height
    83	    const geoStart = geometry?.start as { x: number; y: number } | undefined;
    84	    const geoEnd = geometry?.end as { x: number; y: number } | undefined;
    85	
    86	    // Convert from pixels to feet
    87	    fixtureGeometry = {
    88	      type: 'line',
    89	      start: geoStart
    90	        ? { x: pixelsToFeet(geoStart.x), y: pixelsToFeet(geoStart.y) }
    91	        : { x: pixelsToFeet(el.posX), y: pixelsToFeet(el.posY) },
    92	      end: geoEnd
    93	        ? { x: pixelsToFeet(geoEnd.x), y: pixelsToFeet(geoEnd.y) }
    94	        : { x: pixelsToFeet(el.posX + el.width), y: pixelsToFeet(el.posY) },
    95	    };
    96	  } else if (geoType === 'circle') {
    97	    // For circles, reconstruct from posX/posY/width/height (more reliable)
    98	    // posX/posY is top-left of bounding box, width=height=diameter
    99	    const centerX = el.posX + el.width / 2;
   100	    const centerY = el.posY + el.height / 2;
   101	    const radius = el.width / 2;
   102	
   103	    fixtureGeometry = {
   104	      type: 'circle',
   105	      center: { x: pixelsToFeet(centerX), y: pixelsToFeet(centerY) },
   106	      radius: pixelsToFeet(radius),
   107	    };
   108	  } else {
   109	    // Rectangle - use posX/posY/width/height (always reliable)
   110	    fixtureGeometry = {
   111	      type: 'rectangle',
   112	      position: { x: pixelsToFeet(el.posX), y: pixelsToFeet(el.posY) },
   113	      width: pixelsToFeet(el.width),
   114	      height: pixelsToFeet(el.height),
   115	      rotation: el.rotation || 0,
   116	    };
   117	  }
   118	
   119	  return {
   120	    id: el.id,
   121	    floorPlanId: sectionId,
   122	    roomId: sectionId,
   123	    type: (el.visualType || 'custom_fixture') as Fixture['type'],
   124	    category: 'barrier',
   125	    label: el.name,
   126	    geometry: fixtureGeometry,
   127	    color: el.fillColor || '#666666',
   128	    opacity: el.opacity,
   129	    thickness: pixelsToFeet(el.thickness || 10), // Convert thickness too
   130	    height: null,
   131	    blocksPlacement: true,
   132	    blocksMovement: true,
   133	    snapTarget: false,
   134	    isActive: true,
   135	  };
   136	}
   137	
   138	// Convert Fixture (FEET) to database element (PIXELS) for storage
   139	function fixtureToElement(fixture: Omit<Fixture, 'id'> | Fixture): Partial<FloorPlanElement> & { geometry: unknown } {
   140	  let posX = 0, posY = 0, width = 1, height = 1;
   141	
   142	  // Extract positions in feet from fixture geometry
   143	  if (fixture.geometry.type === 'rectangle') {
   144	    posX = fixture.geometry.position.x;
   145	    posY = fixture.geometry.position.y;
   146	    width = fixture.geometry.width;
   147	    height = fixture.geometry.height;
   148	  } else if (fixture.geometry.type === 'circle') {
   149	    // For circle, posX/posY should be top-left of bounding box
   150	    posX = fixture.geometry.center.x - fixture.geometry.radius;
   151	    posY = fixture.geometry.center.y - fixture.geometry.radius;
   152	    width = fixture.geometry.radius * 2;
   153	    height = fixture.geometry.radius * 2;
   154	  } else if (fixture.geometry.type === 'line') {
   155	    posX = Math.min(fixture.geometry.start.x, fixture.geometry.end.x);
   156	    posY = Math.min(fixture.geometry.start.y, fixture.geometry.end.y);
   157	    width = Math.abs(fixture.geometry.end.x - fixture.geometry.start.x) || 0.05; // minimum 1px
   158	    height = Math.abs(fixture.geometry.end.y - fixture.geometry.start.y) || (fixture.thickness || 0.5);
   159	  }
   160	
   161	  // Build geometry in PIXELS for storage
   162	  let dbGeometry: unknown;
   163	  if (fixture.geometry.type === 'line') {
   164	    dbGeometry = {
   165	      type: 'line',
   166	      start: {
   167	        x: feetToPixels(fixture.geometry.start.x),
   168	        y: feetToPixels(fixture.geometry.start.y),
   169	      },
   170	      end: {
   171	        x: feetToPixels(fixture.geometry.end.x),
   172	        y: feetToPixels(fixture.geometry.end.y),
   173	      },
   174	    };
   175	  } else if (fixture.geometry.type === 'circle') {
   176	    dbGeometry = {
   177	      type: 'circle',
   178	      center: {
   179	        x: feetToPixels(fixture.geometry.center.x),
   180	        y: feetToPixels(fixture.geometry.center.y),
   181	      },
   182	      radius: feetToPixels(fixture.geometry.radius),
   183	    };
   184	  } else if (fixture.geometry.type === 'rectangle') {
   185	    dbGeometry = {
   186	      type: 'rectangle',
   187	      position: {
   188	        x: feetToPixels(fixture.geometry.position.x),
   189	        y: feetToPixels(fixture.geometry.position.y),
   190	      },
   191	      width: feetToPixels(fixture.geometry.width),
   192	      height: feetToPixels(fixture.geometry.height),
   193	      rotation: fixture.geometry.rotation || 0,
   194	    };
   195	  } else {
   196	    // Fallback for other geometry types (polygon, arc) - store as-is
   197	    dbGeometry = fixture.geometry;
   198	  }
   199	
   200	  const rotation = fixture.geometry.type === 'rectangle' ? (fixture.geometry.rotation || 0) : 0;
   201	
   202	  return {
   203	    name: fixture.label,
   204	    elementType: 'fixture',
   205	    visualType: fixture.type,
   206	    geometry: dbGeometry,
   207	    posX: feetToPixels(posX),
   208	    posY: feetToPixels(posY),
   209	    width: feetToPixels(width),
   210	    height: feetToPixels(height),
   211	    rotation,
   212	    thickness: fixture.thickness ? feetToPixels(fixture.thickness) : undefined,
   213	    fillColor: fixture.color,
   214	    opacity: fixture.opacity,
   215	    isLocked: false,
   216	  };
   217	}
   218	
   219	// =============================================================================
   220	// COMPONENT
   221	// =============================================================================
   222	
   223	export function FloorPlanEditor({
   224	  initialRoomId,
   225	  locationId,
   226	  useDatabase = false,
   227	  onSave,
   228	  onExit,
   229	}: FloorPlanEditorProps) {
   230	  // Room selection - in database mode, start empty and wait for sections to load
   231	  const [selectedRoomId, setSelectedRoomId] = useState<string>(
   232	    useDatabase ? (initialRoomId || '') : (initialRoomId || FloorCanvasAPI.getActiveRoom() || '')
   233	  );
   234	
   235	  // Tool mode
   236	  const [toolMode, setToolMode] = useState<EditorToolMode>('SELECT');
   237	  const [fixtureType, setFixtureType] = useState<FixtureType>('bar_counter');
   238	  const [tableShape, setTableShape] = useState<TableShape>('rectangle');
   239	
   240	  // Selection
   241	  const [selectedFixtureId, setSelectedFixtureId] = useState<string | null>(null);
   242	  const [selectedTableId, setSelectedTableId] = useState<string | null>(null);
   243	  const [selectedSeatId, setSelectedSeatId] = useState<string | null>(null);
   244	
   245	  // Force refresh key for immediate updates (eliminates polling lag)
   246	  const [refreshKey, setRefreshKey] = useState(0);
   247	
   248	  // Zoom control state and ref
   249	  const [currentZoom, setCurrentZoom] = useState(1);
   250	  const zoomControlRef = useRef<{
   251	    fitToScreen: () => void;
   252	    resetZoom: () => void;
   253	    setZoom: (z: number) => void;
   254	    zoom: number;
   255	  } | null>(null);
   256	
   257	  // Database state
   258	  const [dbElements, setDbElements] = useState<FloorPlanElement[]>([]);
   259	  const [dbTables, setDbTables] = useState<EditorTable[]>([]);
   260	  const [isLoading, setIsLoading] = useState(false);
   261	
   262	  // Database sections (rooms)
   263	  interface DbSection {
   264	    id: string;
   265	    name: string;
   266	    color: string | null;
   267	    widthFeet: number;
   268	    heightFeet: number;
   269	    gridSizeFeet: number;
   270	  }
   271	  const [dbSections, setDbSections] = useState<DbSection[]>([]);
   272	
   273	  // Fetch sections from database
   274	  const fetchSections = useCallback(async () => {
   275	    if (!useDatabase || !locationId) return;
   276	
   277	    try {
   278	      const response = await fetch(`/api/sections?locationId=${locationId}`);
   279	      if (response.ok) {
   280	        const data = await response.json();
   281	        setDbSections(data.sections || []);
   282	        // Auto-select first section if none selected
   283	        if (data.sections?.length > 0 && !selectedRoomId) {
   284	          setSelectedRoomId(data.sections[0].id);
   285	        }
   286	      }
   287	    } catch (error) {
   288	      console.error('Failed to fetch sections:', error);
   289	    }
   290	  }, [useDatabase, locationId, selectedRoomId]);
   291	
   292	  // Load sections when in database mode
   293	  useEffect(() => {
   294	    if (useDatabase) {
   295	      fetchSections();
   296	    }
   297	  }, [useDatabase, fetchSections]);
   298	
   299	  // Fetch elements from database
   300	  const fetchElements = useCallback(async () => {
   301	    if (!useDatabase || !selectedRoomId || !locationId) return;
   302	
   303	    try {
   304	      const response = await fetch(`/api/floor-plan-elements?locationId=${locationId}&sectionId=${selectedRoomId}`);
   305	      if (response.ok) {
   306	        const data = await response.json();
   307	        setDbElements(data.elements || []);
   308	      }
   309	    } catch (error) {
   310	      console.error('Failed to fetch floor plan elements:', error);
   311	    }
   312	  }, [useDatabase, selectedRoomId, locationId]);
   313	
   314	  // Load elements when room changes (database mode)
   315	  useEffect(() => {
   316	    if (useDatabase) {
   317	      fetchElements();
   318	    }
   319	  }, [useDatabase, fetchElements]);
   320	
   321	  // Fetch tables from database
   322	  const fetchTables = useCallback(async () => {
   323	    if (!useDatabase || !selectedRoomId || !locationId) return;
   324	
   325	    try {
   326	      const response = await fetch(`/api/tables?locationId=${locationId}&sectionId=${selectedRoomId}&includeSeats=true`);
   327	      if (response.ok) {
   328	        const data = await response.json();
   329	        // Map API response to EditorTable format
   330	        const editorTables: EditorTable[] = (data.tables || []).map((t: Record<string, unknown>) => ({
   331	          id: t.id as string,
   332	          name: t.name as string,
   333	          abbreviation: t.abbreviation as string | null,
   334	          capacity: t.capacity as number,
   335	          posX: t.posX as number,
   336	          posY: t.posY as number,
   337	          width: t.width as number,
   338	          height: t.height as number,
   339	          rotation: t.rotation as number,
   340	          shape: (t.shape as TableShape) || 'rectangle',
   341	          seatPattern: (t.seatPattern as EditorTable['seatPattern']) || 'all_around',
   342	          sectionId: t.section ? (t.section as { id: string }).id : null,
   343	          status: (t.status as string) || 'available',
   344	          isLocked: (t.isLocked as boolean) || false,
   345	          seats: (t.seats as EditorTable['seats']) || [],
   346	        }));
   347	        setDbTables(editorTables);
   348	      }
   349	    } catch (error) {
   350	      console.error('Failed to fetch tables:', error);
   351	    }
   352	  }, [useDatabase, selectedRoomId, locationId]);
   353	
   354	  // Load tables when room changes (database mode)
   355	  useEffect(() => {
   356	    if (useDatabase) {
   357	      fetchTables();
   358	    }
   359	  }, [useDatabase, fetchTables]);
   360	
   361	  // Handle room change
   362	  const handleRoomChange = useCallback((roomId: string) => {
   363	    setSelectedRoomId(roomId);
   364	    if (!useDatabase) {
   365	      FloorCanvasAPI.setActiveRoom(roomId);
   366	    }
   367	    setSelectedFixtureId(null);
   368	  }, [useDatabase]);
   369	
   370	  // Handle tool change
   371	  const handleToolChange = useCallback((tool: EditorToolMode) => {
   372	    setToolMode(tool);
   373	    setSelectedFixtureId(null);
   374	    setSelectedTableId(null);
   375	  }, []);
   376	
   377	  // Handle fixture type change
   378	  const handleFixtureTypeChange = useCallback((type: FixtureType) => {
   379	    setFixtureType(type);
   380	  }, []);
   381	
   382	  // Handle table shape change
   383	  const handleTableShapeChange = useCallback((shape: TableShape) => {
   384	    setTableShape(shape);
   385	  }, []);
   386	
   387	  // Handle fixture selection
   388	  const handleFixtureSelect = useCallback((fixtureId: string | null) => {
   389	    setSelectedFixtureId(fixtureId);
   390	    if (fixtureId) {
   391	      setToolMode('SELECT');
   392	      setSelectedTableId(null); // Deselect table when fixture selected
   393	    }
   394	  }, []);
   395	
   396	  // Handle table selection
   397	  const handleTableSelect = useCallback((tableId: string | null) => {
   398	    setSelectedTableId(tableId);
   399	    if (tableId) {
   400	      setToolMode('SELECT');
   401	      setSelectedFixtureId(null); // Deselect fixture when table selected
   402	    }
   403	  }, []);
   404	
   405	  // Handle fixture creation
   406	  const handleFixtureCreate = useCallback(
   407	    async (fixture: Omit<Fixture, 'id'>) => {
   408	      if (useDatabase) {
   409	        try {
   410	          const elementData = fixtureToElement(fixture);
   411	          const response = await fetch('/api/floor-plan-elements', {
   412	            method: 'POST',
   413	            headers: { 'Content-Type': 'application/json' },
   414	            body: JSON.stringify({
   415	              sectionId: selectedRoomId,
   416	              locationId: locationId || '',
   417	              ...elementData,
   418	            }),
   419	          });
   420	          if (response.ok) {
   421	            await fetchElements();
   422	            setRefreshKey((prev) => prev + 1);
   423	          }
   424	        } catch (error) {
   425	          console.error('Failed to create element:', error);
   426	        }
   427	      } else {
   428	        FloorCanvasAPI.addFixture(fixture);
   429	      }
   430	      setSelectedFixtureId(null);
   431	    },
   432	    [useDatabase, selectedRoomId, locationId, fetchElements]
   433	  );
   434	
   435	  // Handle fixture update
   436	  const handleFixtureUpdate = useCallback(
   437	    async (fixtureId: string, updates: Partial<Fixture>) => {
   438	      if (useDatabase) {
   439	        try {
   440	          // Get current element to merge updates
   441	          const currentElement = dbElements.find(el => el.id === fixtureId);
   442	          if (!currentElement) return;
   443	
   444	          // Convert current element to fixture, apply updates, then convert back
   445	          const currentFixture = elementToFixture(currentElement, selectedRoomId);
   446	          const updatedFixture = { ...currentFixture, ...updates };
   447	
   448	          // If geometry is being updated, merge it properly
   449	          if (updates.geometry) {
   450	            updatedFixture.geometry = updates.geometry;
   451	          }
   452	
   453	          const elementData = fixtureToElement(updatedFixture);
   454	
   455	          const response = await fetch(`/api/floor-plan-elements/${fixtureId}`, {
   456	            method: 'PUT',
   457	            headers: { 'Content-Type': 'application/json' },
   458	            body: JSON.stringify(elementData),
   459	          });
   460	
   461	          if (response.ok) {
   462	            // Update local state immediately for responsiveness
   463	            setDbElements(prev => prev.map(el =>
   464	              el.id === fixtureId
   465	                ? { ...el, ...elementData } as FloorPlanElement
   466	                : el
   467	            ));
   468	            setRefreshKey((prev) => prev + 1);
   469	          }
   470	        } catch (error) {
   471	          console.error('Failed to update element:', error);
   472	        }
   473	      } else {
   474	        FloorCanvasAPI.updateFixture(fixtureId, updates);
   475	        setRefreshKey((prev) => prev + 1);
   476	      }
   477	    },
   478	    [useDatabase, dbElements, selectedRoomId]
   479	  );
   480	
   481	  // Handle fixture deletion
   482	  const handleFixtureDelete = useCallback(
   483	    async (fixtureId: string) => {
   484	      if (useDatabase) {
   485	        try {
   486	          const response = await fetch(`/api/floor-plan-elements/${fixtureId}`, {
   487	            method: 'DELETE',
   488	          });
   489	          if (response.ok) {
   490	            setDbElements(prev => prev.filter(el => el.id !== fixtureId));
   491	            setRefreshKey((prev) => prev + 1);
   492	          }
   493	        } catch (error) {
   494	          console.error('Failed to delete element:', error);
   495	        }
   496	      } else {
   497	        FloorCanvasAPI.removeFixture(fixtureId);
   498	      }
   499	      setSelectedFixtureId(null);
   500	    },
   501	    [useDatabase]
   502	  );
   503	
   504	  // Handle table creation
   505	  const handleTableCreate = useCallback(
   506	    async (tableData: Omit<EditorTable, 'id'>) => {
   507	      if (!useDatabase || !locationId) return;
   508	
   509	      try {
   510	        const response = await fetch('/api/tables', {
   511	          method: 'POST',
   512	          headers: { 'Content-Type': 'application/json' },
   513	          body: JSON.stringify({
   514	            locationId,
   515	            sectionId: selectedRoomId,
   516	            name: tableData.name,
   517	            abbreviation: tableData.abbreviation,
   518	            capacity: tableData.capacity,
   519	            posX: tableData.posX,
   520	            posY: tableData.posY,
   521	            width: tableData.width,
   522	            height: tableData.height,
   523	            rotation: tableData.rotation,
   524	            shape: tableData.shape,
   525	            seatPattern: tableData.seatPattern,
   526	            skipSeatGeneration: true,
   527	          }),
   528	        });
   529	
   530	        if (response.ok) {
   531	          await fetchTables();
   532	          setRefreshKey((prev) => prev + 1);
   533	        }
   534	      } catch (error) {
   535	        console.error('Failed to create table:', error);
   536	      }
   537	    },
   538	    [useDatabase, locationId, selectedRoomId, fetchTables]
   539	  );
   540	
   541	  // Handle table update
   542	  const handleTableUpdate = useCallback(
   543	    async (tableId: string, updates: Partial<EditorTable>) => {
   544	      if (!useDatabase) return;
   545	
   546	      try {
   547	        const response = await fetch(`/api/tables/${tableId}`, {
   548	          method: 'PUT',
   549	          headers: { 'Content-Type': 'application/json' },
   550	          body: JSON.stringify(updates),
   551	        });
   552	
   553	        if (response.ok) {
   554	          // Update local state immediately for responsiveness
   555	          setDbTables(prev => prev.map(t =>
   556	            t.id === tableId ? { ...t, ...updates } : t
   557	          ));
   558	          setRefreshKey((prev) => prev + 1);
   559	        }
   560	      } catch (error) {
   561	        console.error('Failed to update table:', error);
   562	      }
   563	    },
   564	    [useDatabase]
   565	  );
   566	
   567	  // Handle table deletion
   568	  const handleTableDelete = useCallback(
   569	    async (tableId: string) => {
   570	      if (!useDatabase) return;
   571	
   572	      try {
   573	        const response = await fetch(`/api/tables/${tableId}`, {
   574	          method: 'DELETE',
   575	        });
   576	
   577	        if (response.ok) {
   578	          setDbTables(prev => prev.filter(t => t.id !== tableId));
   579	          setSelectedTableId(null);
   580	          setRefreshKey((prev) => prev + 1);
   581	        }
   582	      } catch (error) {
   583	        console.error('Failed to delete table:', error);
   584	      }
   585	    },
   586	    [useDatabase]
   587	  );
   588	
   589	  // Handle regenerate seats for a table
   590	  const handleRegenerateSeats = useCallback(
   591	    async (tableId: string) => {
   592	      if (!useDatabase) return;
   593	
   594	      // Get the current table to use its capacity and pattern
   595	      const table = dbTables.find(t => t.id === tableId);
   596	      if (!table) return;
   597	
   598	      // Clear any selected seat for this table to prevent stale references
   599	      setSelectedSeatId(null);
   600	
   601	      try {
   602	        const response = await fetch(`/api/tables/${tableId}/seats/auto-generate`, {
   603	          method: 'POST',
   604	          headers: { 'Content-Type': 'application/json' },
   605	          body: JSON.stringify({
   606	            count: table.capacity,
   607	            seatPattern: table.seatPattern,
   608	            replaceExisting: true,
   609	            checkCollisions: true,
   610	            forceGenerate: false, // Will prompt user if collisions detected
   611	          }),
   612	        });
   613	
   614	        const data = await response.json();
   615	
   616	        if (response.status === 409 && data.warning) {
   617	          // Collision detected - ask user if they want to force generate
   618	          const collisionCount = data.collisions?.length || 0;
   619	          const collisionTypes = data.collisions?.map((c: { collidedWith: string }) => c.collidedWith).slice(0, 3).join(', ');
   620	          const confirmed = window.confirm(
   621	            ` Seat Collision Warning\n\n` +
   622	            `${collisionCount} seat(s) would collide with: ${collisionTypes}${collisionCount > 3 ? '...' : ''}\n\n` +
   623	            `Options:\n` +
   624	            ` Click "Cancel" to abort and move/resize the table first\n` +
   625	            ` Click "OK" to generate seats anyway (they may overlap)`
   626	          );
   627	
   628	          if (confirmed) {
   629	            // Force generate despite collisions
   630	            const forceResponse = await fetch(`/api/tables/${tableId}/seats/auto-generate`, {
   631	              method: 'POST',
   632	              headers: { 'Content-Type': 'application/json' },
   633	              body: JSON.stringify({
   634	                count: table.capacity,
   635	                seatPattern: table.seatPattern,
   636	                replaceExisting: true,
   637	                checkCollisions: true,
   638	                forceGenerate: true,
   639	              }),
   640	            });
   641	
   642	            if (forceResponse.ok) {
   643	              await fetchTables();
   644	              setTimeout(() => setRefreshKey((prev) => prev + 1), 50);
   645	            }
   646	          }
   647	          return;
   648	        }
   649	
   650	        if (response.ok) {
   651	          // Check if there was a collision warning even with successful generation
   652	          if (data.warning && data.collisions?.length > 0) {
   653	            console.warn('Seats generated with collisions:', data.collisions);
   654	          }
   655	          // Refresh tables first, then increment key to trigger re-render
   656	          await fetchTables();
   657	          // Small delay to ensure state has propagated
   658	          setTimeout(() => {
   659	            setRefreshKey((prev) => prev + 1);
   660	          }, 50);
   661	        } else {
   662	          console.error('Failed to regenerate seats:', data);
   663	          alert('Failed to regenerate seats: ' + (data.error || 'Unknown error'));
   664	        }
   665	      } catch (error) {
   666	        console.error('Failed to regenerate seats:', error);
   667	        alert('Failed to regenerate seats. Check console for details.');
   668	      }
   669	    },
   670	    [useDatabase, dbTables, fetchTables]
   671	  );
   672	
   673	  // Handle seat reflow when table is resized
   674	  const handleSeatsReflow = useCallback(
   675	    async (tableId: string, dimensions: {
   676	      oldWidth: number;
   677	      oldHeight: number;
   678	      newWidth: number;
   679	      newHeight: number;
   680	    }) => {
   681	      if (!useDatabase) return;
   682	
   683	      try {
   684	        const response = await fetch(`/api/tables/${tableId}/seats/reflow`, {
   685	          method: 'POST',
   686	          headers: { 'Content-Type': 'application/json' },
   687	          body: JSON.stringify(dimensions),
   688	        });
   689	
   690	        if (response.ok) {
   691	          await fetchTables();
   692	          setRefreshKey((prev) => prev + 1);
   693	        }
   694	      } catch (error) {
   695	        console.error('Failed to reflow seats:', error);
   696	      }
   697	    },
   698	    [useDatabase, fetchTables]
   699	  );
   700	
   701	  // Handle seat update (for manual dragging)
   702	  const handleSeatUpdate = useCallback(
   703	    async (seatId: string, updates: { relativeX?: number; relativeY?: number }) => {
   704	      if (!useDatabase) return;
   705	
   706	      try {
   707	        const response = await fetch(`/api/seats/${seatId}`, {
   708	          method: 'PUT',
   709	          headers: { 'Content-Type': 'application/json' },
   710	          body: JSON.stringify(updates),
   711	        });
   712	
   713	        if (response.ok) {
   714	          await fetchTables();
   715	          setRefreshKey((prev) => prev + 1);
   716	        }
   717	      } catch (error) {
   718	        console.error('Failed to update seat:', error);
   719	      }
   720	    },
   721	    [useDatabase, fetchTables]
   722	  );
   723	
   724	  // Extract flat seats array from tables for EditorCanvas
   725	  const dbSeats = React.useMemo(() => {
   726	    if (!useDatabase) return undefined;
   727	    return dbTables.flatMap(table =>
   728	      (table.seats || []).map(seat => ({
   729	        ...seat,
   730	        tableId: table.id,
   731	      }))
   732	    );
   733	  }, [useDatabase, dbTables]);
   734	
   735	  // Handle save
   736	  const handleSave = useCallback(() => {
   737	    if (useDatabase) {
   738	      alert('Floor plan is automatically saved to the database!');
   739	    } else {
   740	      alert('Floor plan saved! (In production, this would save to the database)');
   741	    }
   742	    if (onSave) onSave();
   743	  }, [onSave, useDatabase]);
   744	
   745	  // Handle reset
   746	  const handleReset = useCallback(async () => {
   747	    if (window.confirm('Reset the floor plan to default? This will delete all fixtures.')) {
   748	      if (useDatabase) {
   749	        // Delete all elements
   750	        for (const el of dbElements) {
   751	          await fetch(`/api/floor-plan-elements/${el.id}`, { method: 'DELETE' });
   752	        }
   753	        setDbElements([]);
   754	      } else {
   755	        const fixtures = FloorCanvasAPI.getFixtures(selectedRoomId);
   756	        fixtures.forEach((f) => FloorCanvasAPI.removeFixture(f.id));
   757	      }
   758	      setSelectedFixtureId(null);
   759	      setRefreshKey((prev) => prev + 1);
   760	    }
   761	  }, [selectedRoomId, useDatabase, dbElements]);
   762	
   763	  // Handle keyboard shortcuts
   764	  React.useEffect(() => {
   765	    const handleKeyDown = (event: KeyboardEvent) => {
   766	      // Delete key: delete selected fixture or table
   767	      if (event.key === 'Delete') {
   768	        if (selectedFixtureId) {
   769	          handleFixtureDelete(selectedFixtureId);
   770	        } else if (selectedTableId) {
   771	          handleTableDelete(selectedTableId);
   772	        }
   773	      }
   774	
   775	      // Escape key: deselect
   776	      if (event.key === 'Escape') {
   777	        setSelectedFixtureId(null);
   778	        setSelectedTableId(null);
   779	        setToolMode('SELECT');
   780	      }
   781	
   782	      // Number keys: quick tool select
   783	      if (event.key === '1') setToolMode('SELECT');
   784	      if (event.key === '2') setToolMode('TABLE');
   785	      if (event.key === '3') setToolMode('WALL');
   786	      if (event.key === '4') setToolMode('RECTANGLE');
   787	      if (event.key === '5') setToolMode('CIRCLE');
   788	      if (event.key === '6') setToolMode('DELETE');
   789	    };
   790	
   791	    window.addEventListener('keydown', handleKeyDown);
   792	    return () => window.removeEventListener('keydown', handleKeyDown);
   793	  }, [selectedFixtureId, selectedTableId, handleFixtureDelete, handleTableDelete]);
   794	
   795	  return (
   796	    <div style={{ fontFamily: 'system-ui, sans-serif', padding: 24 }}>
   797	      {/* Header */}
   798	      <div
   799	        style={{
   800	          display: 'flex',
   801	          justifyContent: 'space-between',
   802	          alignItems: 'center',
   803	          marginBottom: 24,
   804	        }}
   805	      >
   806	        <h1 style={{ margin: 0, fontSize: 24, fontWeight: 600 }}>
   807	          Floor Plan Editor
   808	          {useDatabase && (
   809	            <span style={{
   810	              fontSize: 12,
   811	              fontWeight: 400,
   812	              marginLeft: 12,
   813	              padding: '2px 8px',
   814	              backgroundColor: '#e8f5e9',
   815	              color: '#2e7d32',
   816	              borderRadius: 4
   817	            }}>
   818	              Database Mode
   819	            </span>
   820	          )}
   821	        </h1>
   822	        <div style={{ display: 'flex', gap: 8 }}>
   823	          <button
   824	            onClick={handleSave}
   825	            style={{
   826	              padding: '8px 16px',
   827	              backgroundColor: '#4CAF50',
   828	              color: 'white',
   829	              border: 'none',
   830	              borderRadius: 6,
   831	              cursor: 'pointer',
   832	              fontSize: 14,
   833	              fontWeight: 600,
   834	            }}
   835	          >
   836	            Save
   837	          </button>
   838	          <button
   839	            onClick={handleReset}
   840	            style={{
   841	              padding: '8px 16px',
   842	              backgroundColor: '#f44336',
   843	              color: 'white',
   844	              border: 'none',
   845	              borderRadius: 6,
   846	              cursor: 'pointer',
   847	              fontSize: 14,
   848	              fontWeight: 600,
   849	            }}
   850	          >
   851	            Reset
   852	          </button>
   853	          {onExit && (
   854	            <button
   855	              onClick={onExit}
   856	              style={{
   857	                padding: '8px 16px',
   858	                backgroundColor: '#757575',
   859	                color: 'white',
   860	                border: 'none',
   861	                borderRadius: 6,
   862	                cursor: 'pointer',
   863	                fontSize: 14,
   864	                fontWeight: 600,
   865	              }}
   866	            >
   867	              Exit
   868	            </button>
   869	          )}
   870	
   871	          {/* Zoom Controls */}
   872	          <div style={{
   873	            display: 'flex',
   874	            alignItems: 'center',
   875	            gap: 8,
   876	            marginLeft: 16,
   877	            padding: '4px 12px',
   878	            backgroundColor: '#f5f5f5',
   879	            borderRadius: 6,
   880	          }}>
   881	            <button
   882	              onClick={() => zoomControlRef.current?.setZoom(Math.max(ZOOM_MIN, currentZoom - ZOOM_STEP))}
   883	              style={{
   884	                width: 28,
   885	                height: 28,
   886	                border: 'none',
   887	                borderRadius: 4,
   888	                backgroundColor: '#e0e0e0',
   889	                cursor: 'pointer',
   890	                fontSize: 16,
   891	                fontWeight: 'bold',
   892	              }}
   893	              title="Zoom Out"
   894	            >
   895	              
   896	            </button>
   897	
   898	            <span style={{
   899	              minWidth: 50,
   900	              textAlign: 'center',
   901	              fontSize: 13,
   902	              fontWeight: 500,
   903	            }}>
   904	              {Math.round(currentZoom * 100)}%
   905	            </span>
   906	
   907	            <button
   908	              onClick={() => zoomControlRef.current?.setZoom(Math.min(ZOOM_MAX, currentZoom + ZOOM_STEP))}
   909	              style={{
   910	                width: 28,
   911	                height: 28,
   912	                border: 'none',
   913	                borderRadius: 4,
   914	                backgroundColor: '#e0e0e0',
   915	                cursor: 'pointer',
   916	                fontSize: 16,
   917	                fontWeight: 'bold',
   918	              }}
   919	              title="Zoom In"
   920	            >
   921	              +
   922	            </button>
   923	
   924	            <div style={{ width: 1, height: 20, backgroundColor: '#ccc', margin: '0 4px' }} />
   925	
   926	            <button
   927	              onClick={() => zoomControlRef.current?.fitToScreen()}
   928	              style={{
   929	                padding: '4px 8px',
   930	                border: 'none',
   931	                borderRadius: 4,
   932	                backgroundColor: '#e0e0e0',
   933	                cursor: 'pointer',
   934	                fontSize: 12,
   935	              }}
   936	              title="Fit to Screen"
   937	            >
   938	              Fit
   939	            </button>
   940	
   941	            <button
   942	              onClick={() => zoomControlRef.current?.resetZoom()}
   943	              style={{
   944	                padding: '4px 8px',
   945	                border: 'none',
   946	                borderRadius: 4,
   947	                backgroundColor: '#e0e0e0',
   948	                cursor: 'pointer',
   949	                fontSize: 12,
   950	              }}
   951	              title="Reset to 100%"
   952	            >
   953	              100%
   954	            </button>
   955	          </div>
   956	        </div>
   957	      </div>
   958	
   959	      {/* Room Selector - Database mode shows sections, in-memory mode shows FloorCanvasAPI rooms */}
   960	      {useDatabase ? (
   961	        <div style={{ display: 'flex', gap: 8, marginBottom: 16, alignItems: 'center' }}>
   962	          {dbSections.length === 0 ? (
   963	            <div style={{ padding: '8px 16px', color: '#666', fontSize: 14 }}>
   964	              No sections found.{' '}
   965	              <button
   966	                onClick={async () => {
   967	                  const name = prompt('Enter section name:', 'Main Floor');
   968	                  if (name && locationId) {
   969	                    try {
   970	                      const res = await fetch('/api/sections', {
   971	                        method: 'POST',
   972	                        headers: { 'Content-Type': 'application/json' },
   973	                        body: JSON.stringify({ locationId, name }),
   974	                      });
   975	                      if (res.ok) {
   976	                        fetchSections();
   977	                      }
   978	                    } catch (e) {
   979	                      console.error('Failed to create section:', e);
   980	                    }
   981	                  }
   982	                }}
   983	                style={{
   984	                  padding: '4px 8px',
   985	                  borderRadius: 4,
   986	                  border: '1px solid #3498db',
   987	                  backgroundColor: '#e3f2fd',
   988	                  color: '#3498db',
   989	                  cursor: 'pointer',
   990	                }}
   991	              >
   992	                + Create Section
   993	              </button>
   994	            </div>
   995	          ) : (
   996	            <>
   997	              {dbSections.map((section) => (
   998	                <button
   999	                  key={section.id}
  1000	                  onClick={() => handleRoomChange(section.id)}
  1001	                  style={{
  1002	                    minWidth: 120,
  1003	                    padding: '8px 16px',
  1004	                    borderRadius: 8,
  1005	                    border: selectedRoomId === section.id ? '2px solid #3498db' : '1px solid #ccc',
  1006	                    backgroundColor: selectedRoomId === section.id ? '#e3f2fd' : 'white',
  1007	                    cursor: 'pointer',
  1008	                    fontWeight: selectedRoomId === section.id ? 600 : 400,
  1009	                    fontSize: 14,
  1010	                  }}
  1011	                >
  1012	                  {section.name}
  1013	                </button>
  1014	              ))}
  1015	              <button
  1016	                onClick={async () => {
  1017	                  const name = prompt('Enter section name:');
  1018	                  if (name && locationId) {
  1019	                    try {
  1020	                      const res = await fetch('/api/sections', {
  1021	                        method: 'POST',
  1022	                        headers: { 'Content-Type': 'application/json' },
  1023	                        body: JSON.stringify({ locationId, name }),
  1024	                      });
  1025	                      if (res.ok) {
  1026	                        fetchSections();
  1027	                      }
  1028	                    } catch (e) {
  1029	                      console.error('Failed to create section:', e);
  1030	                    }
  1031	                  }
  1032	                }}
  1033	                style={{
  1034	                  padding: '8px 16px',
  1035	                  borderRadius: 8,
  1036	                  border: '2px dashed #3498db',
  1037	                  backgroundColor: 'white',
  1038	                  color: '#3498db',
  1039	                  cursor: 'pointer',
  1040	                  fontWeight: 600,
  1041	                  fontSize: 14,
  1042	                }}
  1043	              >
  1044	                + Add Room
  1045	              </button>
  1046	            </>
  1047	          )}
  1048	        </div>
  1049	      ) : (
  1050	        <RoomSelector
  1051	          selectedRoomId={selectedRoomId}
  1052	          onRoomSelect={handleRoomChange}
  1053	        />
  1054	      )}
  1055	
  1056	      {/* Main Layout */}
  1057	      <div style={{ display: 'flex', gap: 24, marginTop: 16 }}>
  1058	        {/* Left Panel: Toolbar */}
  1059	        <div style={{ width: 200, flexShrink: 0, position: 'relative', zIndex: 10 }}>
  1060	          <FixtureToolbar
  1061	            selectedTool={toolMode}
  1062	            selectedFixtureType={fixtureType}
  1063	            selectedTableShape={tableShape}
  1064	            onToolSelect={handleToolChange}
  1065	            onFixtureTypeSelect={handleFixtureTypeChange}
  1066	            onTableShapeSelect={handleTableShapeChange}
  1067	          />
  1068	        </div>
  1069	
  1070	        {/* Center: Canvas */}
  1071	        <div style={{ flex: 1, overflow: 'auto', minWidth: 0, paddingLeft: 8 }}>
  1072	          <EditorCanvas
  1073	            roomId={selectedRoomId}
  1074	            toolMode={toolMode}
  1075	            fixtureType={fixtureType}
  1076	            tableShape={tableShape}
  1077	            selectedFixtureId={selectedFixtureId}
  1078	            selectedTableId={selectedTableId}
  1079	            refreshKey={refreshKey}
  1080	            onFixtureSelect={handleFixtureSelect}
  1081	            onFixtureUpdate={handleFixtureUpdate}
  1082	            onFixtureCreate={handleFixtureCreate}
  1083	            onFixtureDelete={handleFixtureDelete}
  1084	            // Table handling
  1085	            onTableSelect={handleTableSelect}
  1086	            onTableCreate={handleTableCreate}
  1087	            onTableUpdate={handleTableUpdate}
  1088	            onTableDelete={handleTableDelete}
  1089	            // Seat handling
  1090	            dbSeats={dbSeats}
  1091	            onSeatSelect={setSelectedSeatId}
  1092	            onSeatUpdate={handleSeatUpdate}
  1093	            onSeatsReflow={handleSeatsReflow}
  1094	            // Database mode props
  1095	            useDatabase={useDatabase}
  1096	            dbFixtures={useDatabase ? dbElements.map(el => elementToFixture(el, selectedRoomId)) : undefined}
  1097	            dbTables={useDatabase ? dbTables : undefined}
  1098	            dbFloorPlan={useDatabase ? (() => {
  1099	              const section = dbSections.find(s => s.id === selectedRoomId);
  1100	              if (!section) return undefined;
  1101	              return {
  1102	                id: section.id,
  1103	                name: section.name,
  1104	                widthFeet: section.widthFeet || 40,
  1105	                heightFeet: section.heightFeet || 30,
  1106	                gridSizeFeet: section.gridSizeFeet || 0.25,
  1107	              };
  1108	            })() : undefined}
  1109	            // Zoom control props
  1110	            onZoomChange={setCurrentZoom}
  1111	            zoomControlRef={zoomControlRef}
  1112	          />
  1113	        </div>
  1114	
  1115	        {/* Right Panel: Properties */}
  1116	        <div style={{ width: 250, flexShrink: 0, position: 'relative', zIndex: 10 }}>
  1117	          {/* Show TableProperties when a table is selected, otherwise show FixtureProperties */}
  1118	          {selectedTableId ? (
  1119	            <TableProperties
  1120	              table={dbTables.find(t => t.id === selectedTableId) || null}
  1121	              onUpdate={handleTableUpdate}
  1122	              onDelete={handleTableDelete}
  1123	              onRegenerateSeats={handleRegenerateSeats}
  1124	            />
  1125	          ) : (
  1126	            <FixtureProperties
  1127	              fixtureId={selectedFixtureId}
  1128	              onUpdate={handleFixtureUpdate}
  1129	              onDelete={handleFixtureDelete}
  1130	              // Database mode props
  1131	              useDatabase={useDatabase}
  1132	              dbFixtures={useDatabase ? dbElements.map(el => elementToFixture(el, selectedRoomId)) : undefined}
  1133	            />
  1134	          )}
  1135	        </div>
  1136	      </div>
  1137	
  1138	      {/* Keyboard Shortcuts Help */}
  1139	      <div
  1140	        style={{
  1141	          marginTop: 24,
  1142	          padding: 12,
  1143	          backgroundColor: '#f5f5f5',
  1144	          borderRadius: 8,
  1145	          fontSize: 11,
  1146	          color: '#666',
  1147	        }}
  1148	      >
  1149	        <strong>Keyboard Shortcuts:</strong>{' '}
  1150	        <span style={{ fontFamily: 'monospace' }}>
  1151	          1: Select | 2: Table | 3: Wall | 4: Fixture | 5: Circle | 6: Delete | Del: Remove | Esc: Deselect
  1152	        </span>
  1153	      </div>
  1154	    </div>
  1155	  );
  1156	}
  1157	
  1158	export default FloorPlanEditor;

================================================================================
FILE: /src/domains/floor-plan/admin/TableRenderer.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Table Renderer Component
     6	 *
     7	 * Renders tables in the Floor Plan Editor canvas with seats and selection state.
     8	 */
     9	
    10	import React from 'react';
    11	import { FloorCanvasAPI } from '../canvas';
    12	import type { EditorTable, EditorSeat, TableShape } from './types';
    13	import { SeatRenderer } from './SeatRenderer';
    14	
    15	// =============================================================================
    16	// TYPES
    17	// =============================================================================
    18	
    19	export type ResizeHandle = 'n' | 's' | 'e' | 'w' | 'ne' | 'nw' | 'se' | 'sw';
    20	
    21	interface TableRendererProps {
    22	  table: EditorTable;
    23	  isSelected: boolean;
    24	  onSelect: () => void;
    25	  isDragging?: boolean;
    26	  isRotating?: boolean;
    27	  isResizing?: boolean;
    28	  // Seat interaction
    29	  selectedSeatId?: string | null;
    30	  highlightedSeatId?: string | null;
    31	  onSeatClick?: (seatId: string) => void;
    32	  onSeatDoubleClick?: (seatId: string) => void;
    33	  // Seat state (optional - for visual indicators)
    34	  seatsWithItems?: Set<string>; // Set of seat IDs that have order items
    35	  // Rotation interaction
    36	  onRotateStart?: (e: React.MouseEvent) => void;
    37	  // Resize interaction
    38	  onResizeStart?: (handle: ResizeHandle) => void;
    39	}
    40	
    41	// =============================================================================
    42	// TABLE SHAPE RENDERERS
    43	// =============================================================================
    44	
    45	function RoundTableShape({
    46	  width,
    47	  height,
    48	  color,
    49	  isSelected,
    50	}: {
    51	  width: number;
    52	  height: number;
    53	  color: string;
    54	  isSelected: boolean;
    55	}) {
    56	  return (
    57	    <div
    58	      style={{
    59	        width,
    60	        height,
    61	        borderRadius: '50%',
    62	        backgroundColor: color,
    63	        border: isSelected ? '3px solid #3498db' : '2px solid #795548',
    64	        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
    65	      }}
    66	    />
    67	  );
    68	}
    69	
    70	function RectangleTableShape({
    71	  width,
    72	  height,
    73	  color,
    74	  isSelected,
    75	  borderRadius = 4,
    76	}: {
    77	  width: number;
    78	  height: number;
    79	  color: string;
    80	  isSelected: boolean;
    81	  borderRadius?: number;
    82	}) {
    83	  return (
    84	    <div
    85	      style={{
    86	        width,
    87	        height,
    88	        borderRadius,
    89	        backgroundColor: color,
    90	        border: isSelected ? '3px solid #3498db' : '2px solid #795548',
    91	        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
    92	      }}
    93	    />
    94	  );
    95	}
    96	
    97	function OvalTableShape({
    98	  width,
    99	  height,
   100	  color,
   101	  isSelected,
   102	}: {
   103	  width: number;
   104	  height: number;
   105	  color: string;
   106	  isSelected: boolean;
   107	}) {
   108	  return (
   109	    <div
   110	      style={{
   111	        width,
   112	        height,
   113	        borderRadius: '50%',
   114	        backgroundColor: color,
   115	        border: isSelected ? '3px solid #3498db' : '2px solid #795548',
   116	        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
   117	      }}
   118	    />
   119	  );
   120	}
   121	
   122	function BoothTableShape({
   123	  width,
   124	  height,
   125	  color,
   126	  isSelected,
   127	}: {
   128	  width: number;
   129	  height: number;
   130	  color: string;
   131	  isSelected: boolean;
   132	}) {
   133	  const boothBackHeight = 8;
   134	  return (
   135	    <div style={{ position: 'relative', width, height }}>
   136	      {/* Booth back */}
   137	      <div
   138	        style={{
   139	          position: 'absolute',
   140	          top: 0,
   141	          left: 0,
   142	          width: '100%',
   143	          height: boothBackHeight,
   144	          backgroundColor: '#5D4037',
   145	          borderRadius: '4px 4px 0 0',
   146	        }}
   147	      />
   148	      {/* Table surface */}
   149	      <div
   150	        style={{
   151	          position: 'absolute',
   152	          top: boothBackHeight,
   153	          left: 10,
   154	          width: width - 20,
   155	          height: height - boothBackHeight - 4,
   156	          borderRadius: 4,
   157	          backgroundColor: color,
   158	          border: isSelected ? '3px solid #3498db' : '2px solid #795548',
   159	          boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
   160	        }}
   161	      />
   162	    </div>
   163	  );
   164	}
   165	
   166	function BarSectionShape({
   167	  width,
   168	  height,
   169	  color,
   170	  isSelected,
   171	}: {
   172	  width: number;
   173	  height: number;
   174	  color: string;
   175	  isSelected: boolean;
   176	}) {
   177	  return (
   178	    <div
   179	      style={{
   180	        width,
   181	        height,
   182	        borderRadius: 2,
   183	        backgroundColor: color,
   184	        border: isSelected ? '3px solid #3498db' : '2px solid #5D4037',
   185	        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
   186	      }}
   187	    />
   188	  );
   189	}
   190	
   191	// =============================================================================
   192	// RESIZE HANDLES
   193	// =============================================================================
   194	
   195	interface ResizeHandlesProps {
   196	  width: number;
   197	  height: number;
   198	  onResizeStart: (handle: ResizeHandle) => void;
   199	}
   200	
   201	function ResizeHandles({ width, height, onResizeStart }: ResizeHandlesProps) {
   202	  const handleSize = 10;
   203	  const handleStyle: React.CSSProperties = {
   204	    position: 'absolute',
   205	    width: handleSize,
   206	    height: handleSize,
   207	    backgroundColor: 'white',
   208	    border: '2px solid #3498db',
   209	    borderRadius: 2,
   210	    zIndex: 1000,
   211	  };
   212	
   213	  const handles: { handle: ResizeHandle; style: React.CSSProperties; cursor: string }[] = [
   214	    // Corners
   215	    { handle: 'nw', style: { top: -handleSize / 2, left: -handleSize / 2 }, cursor: 'nwse-resize' },
   216	    { handle: 'ne', style: { top: -handleSize / 2, right: -handleSize / 2 }, cursor: 'nesw-resize' },
   217	    { handle: 'sw', style: { bottom: -handleSize / 2, left: -handleSize / 2 }, cursor: 'nesw-resize' },
   218	    { handle: 'se', style: { bottom: -handleSize / 2, right: -handleSize / 2 }, cursor: 'nwse-resize' },
   219	    // Edges
   220	    { handle: 'n', style: { top: -handleSize / 2, left: '50%', transform: 'translateX(-50%)' }, cursor: 'ns-resize' },
   221	    { handle: 's', style: { bottom: -handleSize / 2, left: '50%', transform: 'translateX(-50%)' }, cursor: 'ns-resize' },
   222	    { handle: 'w', style: { left: -handleSize / 2, top: '50%', transform: 'translateY(-50%)' }, cursor: 'ew-resize' },
   223	    { handle: 'e', style: { right: -handleSize / 2, top: '50%', transform: 'translateY(-50%)' }, cursor: 'ew-resize' },
   224	  ];
   225	
   226	  return (
   227	    <>
   228	      {handles.map(({ handle, style, cursor }) => (
   229	        <div
   230	          key={handle}
   231	          style={{ ...handleStyle, ...style, cursor }}
   232	          onMouseDown={(e) => {
   233	            e.stopPropagation();
   234	            onResizeStart(handle);
   235	          }}
   236	          title={`Resize ${handle.toUpperCase()}`}
   237	        />
   238	      ))}
   239	    </>
   240	  );
   241	}
   242	
   243	// =============================================================================
   244	// MAIN COMPONENT
   245	// =============================================================================
   246	
   247	export function TableRenderer({
   248	  table,
   249	  isSelected,
   250	  onSelect,
   251	  isDragging = false,
   252	  isRotating = false,
   253	  isResizing = false,
   254	  selectedSeatId = null,
   255	  highlightedSeatId = null,
   256	  onSeatClick,
   257	  onSeatDoubleClick,
   258	  seatsWithItems = new Set(),
   259	  onRotateStart,
   260	  onResizeStart,
   261	}: TableRendererProps) {
   262	  // Get table color based on status
   263	  const getTableColor = () => {
   264	    switch (table.status) {
   265	      case 'occupied':
   266	        return '#BBDEFB'; // Light blue
   267	      case 'reserved':
   268	        return '#F0E6FF'; // Light purple
   269	      case 'dirty':
   270	        return '#D7CCC8'; // Light brown
   271	      case 'blocked':
   272	        return '#9E9E9E'; // Grey
   273	      default:
   274	        return '#8D6E63'; // Default wood color
   275	    }
   276	  };
   277	
   278	  const color = getTableColor();
   279	
   280	  // Render the appropriate shape
   281	  const renderShape = () => {
   282	    const shapeProps = {
   283	      width: table.width,
   284	      height: table.height,
   285	      color,
   286	      isSelected,
   287	    };
   288	
   289	    switch (table.shape) {
   290	      case 'round':
   291	        return <RoundTableShape {...shapeProps} />;
   292	      case 'oval':
   293	        return <OvalTableShape {...shapeProps} />;
   294	      case 'booth':
   295	        return <BoothTableShape {...shapeProps} />;
   296	      case 'bar':
   297	        return <BarSectionShape {...shapeProps} />;
   298	      case 'square':
   299	        return <RectangleTableShape {...shapeProps} borderRadius={4} />;
   300	      case 'rectangle':
   301	      default:
   302	        return <RectangleTableShape {...shapeProps} borderRadius={4} />;
   303	    }
   304	  };
   305	
   306	  // Calculate table center (for seat positioning)
   307	  const tableCenterX = table.posX + table.width / 2;
   308	  const tableCenterY = table.posY + table.height / 2;
   309	
   310	  return (
   311	    <div
   312	      onClick={(e) => {
   313	        e.stopPropagation();
   314	        onSelect();
   315	      }}
   316	      style={{
   317	        position: 'absolute',
   318	        left: table.posX,
   319	        top: table.posY,
   320	        width: table.width,
   321	        height: table.height,
   322	        cursor: isDragging ? 'grabbing' : 'grab',
   323	        transform: `rotate(${table.rotation}deg)`,
   324	        transformOrigin: 'center center',
   325	        opacity: isDragging ? 0.7 : 1,
   326	        transition: isDragging ? 'none' : 'transform 0.1s ease',
   327	        zIndex: isSelected ? 100 : 10,
   328	      }}
   329	      title={`${table.name} (${table.capacity} seats)`}
   330	    >
   331	      {/* Table shape */}
   332	      {renderShape()}
   333	
   334	      {/* Table label */}
   335	      <div
   336	        style={{
   337	          position: 'absolute',
   338	          top: '50%',
   339	          left: '50%',
   340	          transform: `translate(-50%, -50%) rotate(-${table.rotation}deg)`,
   341	          fontSize: 14,
   342	          fontWeight: 700,
   343	          color: '#fff',
   344	          textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
   345	          pointerEvents: 'none',
   346	          whiteSpace: 'nowrap',
   347	          textAlign: 'center',
   348	        }}
   349	      >
   350	        {table.abbreviation || table.name}
   351	      </div>
   352	
   353	      {/* Capacity badge */}
   354	      <div
   355	        style={{
   356	          position: 'absolute',
   357	          top: -8,
   358	          right: -8,
   359	          width: 20,
   360	          height: 20,
   361	          borderRadius: '50%',
   362	          backgroundColor: '#4CAF50',
   363	          color: 'white',
   364	          fontSize: 11,
   365	          fontWeight: 700,
   366	          display: 'flex',
   367	          alignItems: 'center',
   368	          justifyContent: 'center',
   369	          transform: `rotate(-${table.rotation}deg)`,
   370	          pointerEvents: 'none',
   371	          boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
   372	        }}
   373	      >
   374	        {table.capacity}
   375	      </div>
   376	
   377	      {/* Locked indicator */}
   378	      {table.isLocked && (
   379	        <div
   380	          style={{
   381	            position: 'absolute',
   382	            top: -8,
   383	            left: -8,
   384	            width: 18,
   385	            height: 18,
   386	            borderRadius: '50%',
   387	            backgroundColor: '#F44336',
   388	            color: 'white',
   389	            fontSize: 10,
   390	            display: 'flex',
   391	            alignItems: 'center',
   392	            justifyContent: 'center',
   393	            transform: `rotate(-${table.rotation}deg)`,
   394	            pointerEvents: 'none',
   395	            boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
   396	          }}
   397	          title="Locked - Cannot be moved"
   398	        >
   399	          
   400	        </div>
   401	      )}
   402	
   403	      {/* Rotation handle (when selected) */}
   404	      {isSelected && onRotateStart && (
   405	        <div
   406	          onMouseDown={(e) => {
   407	            e.stopPropagation();
   408	            onRotateStart(e);
   409	          }}
   410	          style={{
   411	            position: 'absolute',
   412	            top: -40,
   413	            left: '50%',
   414	            transform: `translateX(-50%) rotate(-${table.rotation}deg)`,
   415	            transformOrigin: 'center bottom',
   416	            cursor: isRotating ? 'grabbing' : 'grab',
   417	            pointerEvents: 'auto',
   418	            zIndex: 1000,
   419	          }}
   420	          title="Drag to rotate table (hold Shift to snap to 15)"
   421	        >
   422	          {/* Stem line */}
   423	          <div
   424	            style={{
   425	              width: 2,
   426	              height: 30,
   427	              backgroundColor: '#3498db',
   428	              margin: '0 auto',
   429	              pointerEvents: 'none',
   430	            }}
   431	          />
   432	          {/* Handle circle */}
   433	          <div
   434	            style={{
   435	              width: 12,
   436	              height: 12,
   437	              borderRadius: '50%',
   438	              backgroundColor: 'white',
   439	              border: '2px solid #3498db',
   440	              margin: '0 auto',
   441	              cursor: isRotating ? 'grabbing' : 'grab',
   442	              boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
   443	            }}
   444	          />
   445	        </div>
   446	      )}
   447	
   448	      {/* Seats (rendered relative to table center) */}
   449	      {table.seats?.map((seat) => {
   450	        // Seat positions are relative to table center
   451	        // Position absolute within the table container
   452	        const seatCenterX = table.width / 2 + seat.relativeX;
   453	        const seatCenterY = table.height / 2 + seat.relativeY;
   454	        const seatSize = 20;
   455	
   456	        return (
   457	          <div
   458	            key={seat.id}
   459	            style={{
   460	              position: 'absolute',
   461	              left: seatCenterX - seatSize / 2,
   462	              top: seatCenterY - seatSize / 2,
   463	            }}
   464	          >
   465	            <SeatRenderer
   466	              seat={seat}
   467	              tableRotation={table.rotation}
   468	              isSelected={selectedSeatId === seat.id}
   469	              isHighlighted={highlightedSeatId === seat.id}
   470	              hasItems={seatsWithItems.has(seat.id)}
   471	              onClick={() => onSeatClick?.(seat.id)}
   472	              onDoubleClick={() => onSeatDoubleClick?.(seat.id)}
   473	            />
   474	          </div>
   475	        );
   476	      })}
   477	
   478	      {/* Resize handles (only when selected and not rotating) */}
   479	      {isSelected && !isRotating && onResizeStart && (
   480	        <ResizeHandles
   481	          width={table.width}
   482	          height={table.height}
   483	          onResizeStart={onResizeStart}
   484	        />
   485	      )}
   486	    </div>
   487	  );
   488	}
   489	
   490	export default TableRenderer;

================================================================================
FILE: /src/domains/floor-plan/admin/SeatRenderer.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Seat Renderer Component
     6	 *
     7	 * Renders individual seats with interaction and visual states for ordering.
     8	 */
     9	
    10	import React from 'react';
    11	import type { EditorSeat } from './types';
    12	
    13	// =============================================================================
    14	// TYPES
    15	// =============================================================================
    16	
    17	interface SeatRendererProps {
    18	  seat: EditorSeat;
    19	  tableRotation: number;  // Parent table rotation (to counter-rotate seat label)
    20	  isSelected: boolean;
    21	  isHighlighted: boolean; // For order entry - which seat is active
    22	  hasItems: boolean;      // Does this seat have order items?
    23	  onClick?: () => void;
    24	  onDoubleClick?: () => void; // Open seat details
    25	}
    26	
    27	// =============================================================================
    28	// COMPONENT
    29	// =============================================================================
    30	
    31	export function SeatRenderer({
    32	  seat,
    33	  tableRotation,
    34	  isSelected,
    35	  isHighlighted,
    36	  hasItems,
    37	  onClick,
    38	  onDoubleClick,
    39	}: SeatRendererProps) {
    40	  const seatSize = 20;
    41	
    42	  // Determine colors based on state
    43	  const getColors = () => {
    44	    if (hasItems) {
    45	      // Seat has order items - show filled
    46	      return {
    47	        backgroundColor: isHighlighted ? '#4CAF50' : '#66BB6A',
    48	        borderColor: '#2e7d32',
    49	        textColor: '#fff',
    50	      };
    51	    } else {
    52	      // Empty seat
    53	      return {
    54	        backgroundColor: '#ffffff',
    55	        borderColor: '#9E9E9E',
    56	        textColor: '#666',
    57	      };
    58	    }
    59	  };
    60	
    61	  const colors = getColors();
    62	
    63	  // Selection ring
    64	  const selectionRing = isSelected ? (
    65	    <div
    66	      style={{
    67	        position: 'absolute',
    68	        left: -4,
    69	        top: -4,
    70	        width: seatSize + 8,
    71	        height: seatSize + 8,
    72	        borderRadius: '50%',
    73	        border: '2px solid #3498db',
    74	        boxShadow: '0 0 8px rgba(52, 152, 219, 0.8)',
    75	        pointerEvents: 'none',
    76	      }}
    77	    />
    78	  ) : null;
    79	
    80	  // Highlighted glow (pulsing animation for active seat during ordering)
    81	  const highlightGlow = isHighlighted ? (
    82	    <div
    83	      style={{
    84	        position: 'absolute',
    85	        left: -6,
    86	        top: -6,
    87	        width: seatSize + 12,
    88	        height: seatSize + 12,
    89	        borderRadius: '50%',
    90	        backgroundColor: 'rgba(255, 193, 7, 0.3)',
    91	        animation: 'pulse 1.5s ease-in-out infinite',
    92	        pointerEvents: 'none',
    93	      }}
    94	    />
    95	  ) : null;
    96	
    97	  return (
    98	    <>
    99	      {/* CSS Animation for pulsing glow */}
   100	      {isHighlighted && (
   101	        <style>
   102	          {`
   103	            @keyframes pulse {
   104	              0%, 100% {
   105	                transform: scale(1);
   106	                opacity: 0.8;
   107	              }
   108	              50% {
   109	                transform: scale(1.2);
   110	                opacity: 0.4;
   111	              }
   112	            }
   113	          `}
   114	        </style>
   115	      )}
   116	
   117	      {/* Seat circle container */}
   118	      <div
   119	        onClick={(e) => {
   120	          e.stopPropagation();
   121	          onClick?.();
   122	        }}
   123	        onDoubleClick={(e) => {
   124	          e.stopPropagation();
   125	          onDoubleClick?.();
   126	        }}
   127	        style={{
   128	          position: 'relative',
   129	          width: seatSize,
   130	          height: seatSize,
   131	          cursor: onClick ? 'pointer' : 'default',
   132	        }}
   133	      >
   134	        {/* Highlight glow (behind) */}
   135	        {highlightGlow}
   136	
   137	        {/* Selection ring (middle) */}
   138	        {selectionRing}
   139	
   140	        {/* Seat circle (front) */}
   141	        <div
   142	          style={{
   143	            position: 'absolute',
   144	            left: 0,
   145	            top: 0,
   146	            width: seatSize,
   147	            height: seatSize,
   148	            borderRadius: '50%',
   149	            backgroundColor: colors.backgroundColor,
   150	            border: `2px solid ${colors.borderColor}`,
   151	            display: 'flex',
   152	            alignItems: 'center',
   153	            justifyContent: 'center',
   154	            fontSize: 11,
   155	            fontWeight: 600,
   156	            color: colors.textColor,
   157	            boxShadow: hasItems ? '0 2px 4px rgba(0,0,0,0.3)' : '0 1px 2px rgba(0,0,0,0.2)',
   158	            // Counter-rotate label to keep it upright
   159	            transform: `rotate(-${tableRotation}deg)`,
   160	            transition: 'all 0.2s ease',
   161	          }}
   162	          title={`Seat ${seat.label}${hasItems ? ' (Has items)' : ''}${isHighlighted ? ' (Active)' : ''}`}
   163	        >
   164	          {seat.label}
   165	        </div>
   166	      </div>
   167	    </>
   168	  );
   169	}
   170	
   171	export default SeatRenderer;

================================================================================
FILE: /src/domains/floor-plan/admin/TableProperties.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Table Properties Panel Component
     6	 *
     7	 * Properties panel for editing selected tables in the Floor Plan Editor.
     8	 */
     9	
    10	import React, { useState, useEffect } from 'react';
    11	import type { EditorTable, TableShape, SeatPattern } from './types';
    12	import { TABLE_SHAPES } from './types';
    13	
    14	// =============================================================================
    15	// TYPES
    16	// =============================================================================
    17	
    18	interface TablePropertiesProps {
    19	  table: EditorTable | null;
    20	  onUpdate: (tableId: string, updates: Partial<EditorTable>) => void;
    21	  onDelete: (tableId: string) => void;
    22	  onRegenerateSeats: (tableId: string) => void;
    23	}
    24	
    25	// =============================================================================
    26	// COMPONENT
    27	// =============================================================================
    28	
    29	export function TableProperties({ table, onUpdate, onDelete, onRegenerateSeats }: TablePropertiesProps) {
    30	  // Local state for editing
    31	  const [name, setName] = useState('');
    32	  const [abbreviation, setAbbreviation] = useState('');
    33	  const [capacity, setCapacity] = useState(4);
    34	  const [width, setWidth] = useState(100);
    35	  const [height, setHeight] = useState(100);
    36	  const [rotation, setRotation] = useState(0);
    37	  const [shape, setShape] = useState<TableShape>('rectangle');
    38	  const [seatPattern, setSeatPattern] = useState<SeatPattern>('all_around');
    39	  const [isLocked, setIsLocked] = useState(false);
    40	
    41	  // Sync with selected table
    42	  useEffect(() => {
    43	    if (table) {
    44	      setName(table.name);
    45	      setAbbreviation(table.abbreviation || '');
    46	      setCapacity(table.capacity);
    47	      setWidth(table.width);
    48	      setHeight(table.height);
    49	      setRotation(table.rotation);
    50	      setShape(table.shape as TableShape);
    51	      setSeatPattern(table.seatPattern as SeatPattern);
    52	      setIsLocked(table.isLocked);
    53	    }
    54	  }, [table]);
    55	
    56	  if (!table) {
    57	    return (
    58	      <div
    59	        style={{
    60	          padding: 16,
    61	          backgroundColor: '#f9f9f9',
    62	          borderRadius: 8,
    63	          border: '1px solid #e0e0e0',
    64	        }}
    65	      >
    66	        <h3 style={{ margin: '0 0 12px 0', fontSize: 16, fontWeight: 600, color: '#333' }}>
    67	          Table Properties
    68	        </h3>
    69	        <p style={{ fontSize: 14, color: '#666', margin: 0 }}>
    70	          Select a table to edit its properties.
    71	        </p>
    72	      </div>
    73	    );
    74	  }
    75	
    76	  const handleUpdate = (updates: Partial<EditorTable>) => {
    77	    onUpdate(table.id, updates);
    78	  };
    79	
    80	  const handleNameChange = (newName: string) => {
    81	    setName(newName);
    82	    handleUpdate({ name: newName });
    83	  };
    84	
    85	  const handleAbbreviationChange = (newAbbr: string) => {
    86	    setAbbreviation(newAbbr);
    87	    handleUpdate({ abbreviation: newAbbr || null });
    88	  };
    89	
    90	  const handleCapacityChange = (newCapacity: number) => {
    91	    const capped = Math.max(1, Math.min(20, newCapacity));
    92	    setCapacity(capped);
    93	    handleUpdate({ capacity: capped });
    94	  };
    95	
    96	  const handleWidthChange = (newWidth: number) => {
    97	    const capped = Math.max(40, Math.min(400, newWidth));
    98	    setWidth(capped);
    99	    handleUpdate({ width: capped });
   100	  };
   101	
   102	  const handleHeightChange = (newHeight: number) => {
   103	    const capped = Math.max(40, Math.min(400, newHeight));
   104	    setHeight(capped);
   105	    handleUpdate({ height: capped });
   106	  };
   107	
   108	  const handleRotationChange = (newRotation: number) => {
   109	    const normalized = ((newRotation % 360) + 360) % 360;
   110	    setRotation(normalized);
   111	    handleUpdate({ rotation: normalized });
   112	  };
   113	
   114	  const handleShapeChange = (newShape: TableShape) => {
   115	    setShape(newShape);
   116	    const shapeDefaults = TABLE_SHAPES.find(s => s.shape === newShape);
   117	    if (shapeDefaults) {
   118	      // Also update default dimensions and seat pattern for the shape
   119	      setWidth(shapeDefaults.defaultWidth);
   120	      setHeight(shapeDefaults.defaultHeight);
   121	      setSeatPattern(shapeDefaults.defaultSeatPattern);
   122	      handleUpdate({
   123	        shape: newShape,
   124	        width: shapeDefaults.defaultWidth,
   125	        height: shapeDefaults.defaultHeight,
   126	        seatPattern: shapeDefaults.defaultSeatPattern,
   127	      });
   128	    } else {
   129	      handleUpdate({ shape: newShape });
   130	    }
   131	  };
   132	
   133	  const handleSeatPatternChange = (newPattern: SeatPattern) => {
   134	    setSeatPattern(newPattern);
   135	    handleUpdate({ seatPattern: newPattern });
   136	  };
   137	
   138	  const handleLockedChange = (locked: boolean) => {
   139	    setIsLocked(locked);
   140	    handleUpdate({ isLocked: locked });
   141	  };
   142	
   143	  const inputStyle: React.CSSProperties = {
   144	    width: '100%',
   145	    padding: '6px 8px',
   146	    fontSize: 13,
   147	    borderRadius: 4,
   148	    border: '1px solid #ccc',
   149	    boxSizing: 'border-box',
   150	  };
   151	
   152	  const labelStyle: React.CSSProperties = {
   153	    display: 'block',
   154	    fontSize: 11,
   155	    fontWeight: 600,
   156	    color: '#555',
   157	    marginBottom: 2,
   158	  };
   159	
   160	  const fieldStyle: React.CSSProperties = {
   161	    marginBottom: 8,
   162	  };
   163	
   164	  return (
   165	    <div
   166	      style={{
   167	        padding: 12,
   168	        backgroundColor: '#f9f9f9',
   169	        borderRadius: 8,
   170	        border: '1px solid #e0e0e0',
   171	      }}
   172	    >
   173	      <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600, color: '#333' }}>
   174	        Table Properties
   175	      </h3>
   176	
   177	      {/* Name & Abbreviation - side by side */}
   178	      <div style={{ ...fieldStyle, display: 'flex', gap: 6 }}>
   179	        <div style={{ flex: 2 }}>
   180	          <label style={labelStyle}>Name</label>
   181	          <input
   182	            type="text"
   183	            value={name}
   184	            onChange={(e) => handleNameChange(e.target.value)}
   185	            placeholder="Table name"
   186	            style={inputStyle}
   187	          />
   188	        </div>
   189	        <div style={{ flex: 1 }}>
   190	          <label style={labelStyle}>Abbr</label>
   191	          <input
   192	            type="text"
   193	            value={abbreviation}
   194	            onChange={(e) => handleAbbreviationChange(e.target.value)}
   195	            placeholder="T1"
   196	            maxLength={6}
   197	            style={inputStyle}
   198	          />
   199	        </div>
   200	      </div>
   201	
   202	      {/* Shape */}
   203	      <div style={fieldStyle}>
   204	        <label style={labelStyle}>Shape</label>
   205	        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 4 }}>
   206	          {TABLE_SHAPES.map((shapeOption) => (
   207	            <button
   208	              key={shapeOption.shape}
   209	              onClick={() => handleShapeChange(shapeOption.shape)}
   210	              title={shapeOption.label}
   211	              style={{
   212	                padding: '4px 2px',
   213	                fontSize: 16,
   214	                borderRadius: 4,
   215	                border: shape === shapeOption.shape ? '2px solid #3498db' : '1px solid #ccc',
   216	                backgroundColor: shape === shapeOption.shape ? '#e3f2fd' : 'white',
   217	                cursor: 'pointer',
   218	              }}
   219	            >
   220	              {shapeOption.icon}
   221	            </button>
   222	          ))}
   223	        </div>
   224	      </div>
   225	
   226	      {/* Capacity */}
   227	      <div style={fieldStyle}>
   228	        <label style={labelStyle}>Capacity</label>
   229	        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
   230	          <button
   231	            onClick={() => handleCapacityChange(capacity - 1)}
   232	            style={{
   233	              width: 28,
   234	              height: 28,
   235	              borderRadius: 4,
   236	              border: '1px solid #ccc',
   237	              backgroundColor: 'white',
   238	              cursor: 'pointer',
   239	              fontSize: 16,
   240	              fontWeight: 700,
   241	            }}
   242	          >
   243	            -
   244	          </button>
   245	          <input
   246	            type="number"
   247	            value={capacity}
   248	            onChange={(e) => handleCapacityChange(parseInt(e.target.value, 10) || 1)}
   249	            min={1}
   250	            max={20}
   251	            style={{ ...inputStyle, width: 50, textAlign: 'center', padding: '4px' }}
   252	          />
   253	          <button
   254	            onClick={() => handleCapacityChange(capacity + 1)}
   255	            style={{
   256	              width: 28,
   257	              height: 28,
   258	              borderRadius: 4,
   259	              border: '1px solid #ccc',
   260	              backgroundColor: 'white',
   261	              cursor: 'pointer',
   262	              fontSize: 16,
   263	              fontWeight: 700,
   264	            }}
   265	          >
   266	            +
   267	          </button>
   268	        </div>
   269	      </div>
   270	
   271	      {/* Seat Pattern */}
   272	      <div style={fieldStyle}>
   273	        <label style={labelStyle}>Seat Arrangement</label>
   274	        <select
   275	          value={seatPattern}
   276	          onChange={(e) => handleSeatPatternChange(e.target.value as SeatPattern)}
   277	          style={inputStyle}
   278	        >
   279	          <option value="all_around">All Around</option>
   280	          <option value="front_only">Front Only (Bar)</option>
   281	          <option value="three_sides">Three Sides (U-shape)</option>
   282	          <option value="two_sides">Two Sides (Corner)</option>
   283	          <option value="inside">Inside (Booth)</option>
   284	        </select>
   285	      </div>
   286	
   287	      {/* Dimensions */}
   288	      <div style={fieldStyle}>
   289	        <label style={labelStyle}>Size (W  H)</label>
   290	        <div style={{ display: 'flex', gap: 4, alignItems: 'center' }}>
   291	          <input
   292	            type="number"
   293	            value={width}
   294	            onChange={(e) => handleWidthChange(parseInt(e.target.value, 10) || 40)}
   295	            min={40}
   296	            max={400}
   297	            style={{ ...inputStyle, width: 60, textAlign: 'center', padding: '4px' }}
   298	            title="Width"
   299	          />
   300	          <span style={{ color: '#999', fontSize: 12 }}></span>
   301	          <input
   302	            type="number"
   303	            value={height}
   304	            onChange={(e) => handleHeightChange(parseInt(e.target.value, 10) || 40)}
   305	            min={40}
   306	            max={400}
   307	            style={{ ...inputStyle, width: 60, textAlign: 'center', padding: '4px' }}
   308	            title="Height"
   309	          />
   310	        </div>
   311	      </div>
   312	
   313	      {/* Rotation */}
   314	      <div style={fieldStyle}>
   315	        <label style={labelStyle}>Rotation</label>
   316	        <div style={{ display: 'flex', gap: 3 }}>
   317	          {[0, 45, 90, 180, 270].map((angle) => (
   318	            <button
   319	              key={angle}
   320	              onClick={() => handleRotationChange(angle)}
   321	              style={{
   322	                flex: 1,
   323	                padding: '3px 0',
   324	                fontSize: 10,
   325	                borderRadius: 4,
   326	                border: rotation === angle ? '2px solid #3498db' : '1px solid #ccc',
   327	                backgroundColor: rotation === angle ? '#e3f2fd' : 'white',
   328	                cursor: 'pointer',
   329	              }}
   330	            >
   331	              {angle}
   332	            </button>
   333	          ))}
   334	        </div>
   335	      </div>
   336	
   337	      {/* Locked */}
   338	      <div style={fieldStyle}>
   339	        <label
   340	          style={{
   341	            display: 'flex',
   342	            alignItems: 'center',
   343	            gap: 6,
   344	            cursor: 'pointer',
   345	            fontSize: 12,
   346	          }}
   347	        >
   348	          <input
   349	            type="checkbox"
   350	            checked={isLocked}
   351	            onChange={(e) => handleLockedChange(e.target.checked)}
   352	            style={{ width: 14, height: 14 }}
   353	          />
   354	          <span>Lock Position</span>
   355	        </label>
   356	      </div>
   357	
   358	      {/* Action buttons - side by side */}
   359	      <div style={{ display: 'flex', gap: 6 }}>
   360	        <button
   361	          onClick={() => onRegenerateSeats(table.id)}
   362	          style={{
   363	            flex: 1,
   364	            padding: '6px 8px',
   365	            fontSize: 11,
   366	            fontWeight: 600,
   367	            borderRadius: 4,
   368	            border: 'none',
   369	            backgroundColor: '#ff9800',
   370	            color: 'white',
   371	            cursor: 'pointer',
   372	          }}
   373	        >
   374	          Regen Seats
   375	        </button>
   376	        <button
   377	          onClick={() => {
   378	            if (window.confirm(`Delete table "${table.name}"?`)) {
   379	              onDelete(table.id);
   380	            }
   381	          }}
   382	          style={{
   383	            flex: 1,
   384	            padding: '6px 8px',
   385	            fontSize: 11,
   386	            fontWeight: 600,
   387	            borderRadius: 4,
   388	            border: 'none',
   389	            backgroundColor: '#f44336',
   390	            color: 'white',
   391	            cursor: 'pointer',
   392	          }}
   393	        >
   394	          Delete
   395	        </button>
   396	      </div>
   397	    </div>
   398	  );
   399	}
   400	
   401	export default TableProperties;

================================================================================
FILE: /src/domains/floor-plan/admin/FixtureProperties.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Fixture Properties Panel
     6	 *
     7	 * Panel for editing selected fixture properties.
     8	 */
     9	
    10	import React, { useState, useEffect, useRef, useCallback } from 'react';
    11	import type { Fixture } from '../shared/types';
    12	import { FloorCanvasAPI } from '../canvas';
    13	import { FIXTURE_TYPES, getFixtureTypeMetadata } from './types';
    14	
    15	// =============================================================================
    16	// TYPES
    17	// =============================================================================
    18	
    19	interface FixturePropertiesProps {
    20	  fixtureId: string | null;
    21	  onUpdate: (fixtureId: string, updates: Partial<Fixture>) => void;
    22	  onDelete: (fixtureId: string) => void;
    23	  // Database mode props
    24	  useDatabase?: boolean;
    25	  dbFixtures?: Fixture[];
    26	}
    27	
    28	// =============================================================================
    29	// COMPONENT
    30	// =============================================================================
    31	
    32	export function FixtureProperties({
    33	  fixtureId,
    34	  onUpdate,
    35	  onDelete,
    36	  useDatabase = false,
    37	  dbFixtures,
    38	}: FixturePropertiesProps) {
    39	  const [fixture, setFixture] = useState<Fixture | null>(null);
    40	  const [label, setLabel] = useState('');
    41	  const [color, setColor] = useState('#424242');
    42	  const [thickness, setThickness] = useState(0.5);
    43	  const [opacity, setOpacity] = useState(1);
    44	  const rotationIntervalRef = useRef<NodeJS.Timeout | null>(null);
    45	
    46	  // Load fixture data when selection changes
    47	  useEffect(() => {
    48	    if (!fixtureId) {
    49	      setFixture(null);
    50	      return;
    51	    }
    52	
    53	    let foundFixture: Fixture | null = null;
    54	
    55	    if (useDatabase && dbFixtures) {
    56	      // Database mode: find from props
    57	      foundFixture = dbFixtures.find((f) => f.id === fixtureId) || null;
    58	    } else {
    59	      // In-memory mode: find from API
    60	      const allRooms = FloorCanvasAPI.getAllRooms();
    61	      for (const room of allRooms) {
    62	        const fixtures = FloorCanvasAPI.getFixtures(room.id);
    63	        foundFixture = fixtures.find((f) => f.id === fixtureId) || null;
    64	        if (foundFixture) break;
    65	      }
    66	    }
    67	
    68	    if (foundFixture) {
    69	      setFixture(foundFixture);
    70	      setLabel(foundFixture.label);
    71	      setColor(foundFixture.color);
    72	      setThickness(foundFixture.thickness);
    73	      setOpacity(foundFixture.opacity);
    74	    }
    75	  }, [fixtureId, useDatabase, dbFixtures]);
    76	
    77	  // Keep fixture state fresh with fast polling (for slider thumb to move) - in-memory mode only
    78	  useEffect(() => {
    79	    if (!fixtureId) return;
    80	    if (useDatabase) return; // Database mode uses dbFixtures prop
    81	
    82	    const intervalId = setInterval(() => {
    83	      const allRooms = FloorCanvasAPI.getAllRooms();
    84	      let foundFixture: Fixture | null = null;
    85	
    86	      for (const room of allRooms) {
    87	        const fixtures = FloorCanvasAPI.getFixtures(room.id);
    88	        foundFixture = fixtures.find((f) => f.id === fixtureId) || null;
    89	        if (foundFixture) break;
    90	      }
    91	
    92	      if (foundFixture) {
    93	        setFixture(foundFixture);
    94	      }
    95	    }, 50); // Fast polling to keep slider thumb position updated
    96	
    97	    return () => clearInterval(intervalId);
    98	  }, [fixtureId, useDatabase]);
    99	
   100	  // Handle property updates
   101	  const handleLabelChange = (value: string) => {
   102	    setLabel(value);
   103	    if (fixtureId) {
   104	      onUpdate(fixtureId, { label: value });
   105	    }
   106	  };
   107	
   108	  const handleColorChange = (value: string) => {
   109	    setColor(value);
   110	    if (fixtureId) {
   111	      onUpdate(fixtureId, { color: value });
   112	    }
   113	  };
   114	
   115	  const handleThicknessChange = (value: number) => {
   116	    setThickness(value);
   117	    if (fixtureId) {
   118	      onUpdate(fixtureId, { thickness: value });
   119	    }
   120	  };
   121	
   122	  const handleOpacityChange = (value: number) => {
   123	    setOpacity(value);
   124	    if (fixtureId) {
   125	      onUpdate(fixtureId, { opacity: value });
   126	    }
   127	  };
   128	
   129	  const handleRotationChange = (value: number) => {
   130	    if (fixtureId && fixture && fixture.geometry.type === 'rectangle') {
   131	      onUpdate(fixtureId, {
   132	        geometry: {
   133	          ...fixture.geometry,
   134	          rotation: value,
   135	        },
   136	      });
   137	    }
   138	  };
   139	
   140	  const handleRadiusChange = (value: number) => {
   141	    if (fixtureId && fixture && fixture.geometry.type === 'circle') {
   142	      onUpdate(fixtureId, {
   143	        geometry: {
   144	          ...fixture.geometry,
   145	          radius: value,
   146	        },
   147	      });
   148	    }
   149	  };
   150	
   151	  const handleTypeChange = (newType: string) => {
   152	    if (fixtureId) {
   153	      const metadata = getFixtureTypeMetadata(newType as any);
   154	      onUpdate(fixtureId, {
   155	        type: newType as any,
   156	        label: metadata.label,
   157	      });
   158	    }
   159	  };
   160	
   161	  // Rotation adjustment functions - fetches current state to avoid stale closure
   162	  const adjustRotation = useCallback((delta: number) => {
   163	    if (!fixtureId || !fixture) return;
   164	
   165	    let currentFixture: Fixture | null = null;
   166	
   167	    if (useDatabase && dbFixtures) {
   168	      // Database mode: find from props
   169	      currentFixture = dbFixtures.find((f) => f.id === fixtureId) || null;
   170	    } else {
   171	      // In-memory mode: Get CURRENT rotation from the fixture (not from closure)
   172	      const allRooms = FloorCanvasAPI.getAllRooms();
   173	      for (const room of allRooms) {
   174	        const fixtures = FloorCanvasAPI.getFixtures(room.id);
   175	        currentFixture = fixtures.find((f) => f.id === fixtureId) || null;
   176	        if (currentFixture) break;
   177	      }
   178	    }
   179	
   180	    if (!currentFixture || currentFixture.geometry.type !== 'rectangle') return;
   181	
   182	    const currentRotation = currentFixture.geometry.rotation || 0;
   183	    let newRotation = currentRotation + delta;
   184	
   185	    // Normalize to 0-360 range
   186	    if (newRotation < 0) newRotation += 360;
   187	    if (newRotation >= 360) newRotation -= 360;
   188	
   189	    onUpdate(fixtureId, {
   190	      geometry: { ...currentFixture.geometry, rotation: newRotation },
   191	    });
   192	  }, [fixtureId, fixture, onUpdate, useDatabase, dbFixtures]);
   193	
   194	  const startContinuousRotation = useCallback((delta: number) => {
   195	    // Fire immediately
   196	    adjustRotation(delta);
   197	
   198	    // Clear any existing interval
   199	    if (rotationIntervalRef.current) {
   200	      clearInterval(rotationIntervalRef.current);
   201	    }
   202	
   203	    // Start new interval for continuous rotation
   204	    rotationIntervalRef.current = setInterval(() => {
   205	      adjustRotation(delta);
   206	    }, 50); // 50ms = 20 updates per second for smooth feel
   207	  }, [adjustRotation]);
   208	
   209	  const stopContinuousRotation = useCallback(() => {
   210	    if (rotationIntervalRef.current) {
   211	      clearInterval(rotationIntervalRef.current);
   212	      rotationIntervalRef.current = null;
   213	    }
   214	  }, []);
   215	
   216	  // Cleanup interval on unmount
   217	  useEffect(() => {
   218	    return () => {
   219	      if (rotationIntervalRef.current) {
   220	        clearInterval(rotationIntervalRef.current);
   221	      }
   222	    };
   223	  }, []);
   224	
   225	  const handleDelete = () => {
   226	    if (fixtureId && window.confirm('Delete this fixture?')) {
   227	      onDelete(fixtureId);
   228	    }
   229	  };
   230	
   231	  if (!fixture) {
   232	    return (
   233	      <div
   234	        style={{
   235	          padding: 16,
   236	          backgroundColor: '#f5f5f5',
   237	          borderRadius: 8,
   238	          height: '100%',
   239	        }}
   240	      >
   241	        <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
   242	          Properties
   243	        </h3>
   244	        <p style={{ color: '#999', fontSize: 12 }}>
   245	          No fixture selected. Click a fixture to edit its properties.
   246	        </p>
   247	      </div>
   248	    );
   249	  }
   250	
   251	  return (
   252	    <div
   253	      style={{
   254	        padding: 16,
   255	        backgroundColor: '#f5f5f5',
   256	        borderRadius: 8,
   257	        height: '100%',
   258	        display: 'flex',
   259	        flexDirection: 'column',
   260	        gap: 16,
   261	      }}
   262	    >
   263	      <h3 style={{ margin: 0, fontSize: 14, fontWeight: 600 }}>
   264	        Properties
   265	      </h3>
   266	
   267	      {/* Fixture Type */}
   268	      <div>
   269	        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   270	          Type
   271	        </label>
   272	        <select
   273	          value={fixture.type}
   274	          onChange={(e) => handleTypeChange(e.target.value)}
   275	          style={{
   276	            width: '100%',
   277	            padding: '6px 8px',
   278	            backgroundColor: 'white',
   279	            border: '1px solid #ccc',
   280	            borderRadius: 4,
   281	            fontSize: 12,
   282	            cursor: 'pointer',
   283	          }}
   284	        >
   285	          {FIXTURE_TYPES.map((ft) => (
   286	            <option key={ft.type} value={ft.type}>
   287	              {ft.label}
   288	            </option>
   289	          ))}
   290	        </select>
   291	      </div>
   292	
   293	      {/* Label */}
   294	      <div>
   295	        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   296	          Label
   297	        </label>
   298	        <input
   299	          type="text"
   300	          value={label}
   301	          onChange={(e) => handleLabelChange(e.target.value)}
   302	          style={{
   303	            width: '100%',
   304	            padding: '6px 8px',
   305	            border: '1px solid #ccc',
   306	            borderRadius: 4,
   307	            fontSize: 12,
   308	          }}
   309	        />
   310	      </div>
   311	
   312	      {/* Color */}
   313	      <div>
   314	        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   315	          Color
   316	        </label>
   317	        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
   318	          <input
   319	            type="color"
   320	            value={color}
   321	            onChange={(e) => handleColorChange(e.target.value)}
   322	            style={{
   323	              width: 40,
   324	              height: 32,
   325	              border: '1px solid #ccc',
   326	              borderRadius: 4,
   327	              cursor: 'pointer',
   328	            }}
   329	          />
   330	          <input
   331	            type="text"
   332	            value={color}
   333	            onChange={(e) => handleColorChange(e.target.value)}
   334	            style={{
   335	              flex: 1,
   336	              padding: '6px 8px',
   337	              border: '1px solid #ccc',
   338	              borderRadius: 4,
   339	              fontSize: 12,
   340	              fontFamily: 'monospace',
   341	            }}
   342	          />
   343	        </div>
   344	      </div>
   345	
   346	      {/* Thickness (for lines/walls) */}
   347	      {fixture.geometry.type === 'line' && (
   348	        <div>
   349	          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   350	            Thickness (feet)
   351	          </label>
   352	          <input
   353	            type="number"
   354	            value={thickness}
   355	            onChange={(e) => handleThicknessChange(parseFloat(e.target.value) || 0)}
   356	            step={0.1}
   357	            min={0.1}
   358	            max={5}
   359	            style={{
   360	              width: '100%',
   361	              padding: '6px 8px',
   362	              border: '1px solid #ccc',
   363	              borderRadius: 4,
   364	              fontSize: 12,
   365	            }}
   366	          />
   367	        </div>
   368	      )}
   369	
   370	      {/* Opacity */}
   371	      <div>
   372	        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   373	          Opacity: {Math.round(opacity * 100)}%
   374	        </label>
   375	        <input
   376	          type="range"
   377	          value={opacity}
   378	          onChange={(e) => handleOpacityChange(parseFloat(e.target.value))}
   379	          min={0.1}
   380	          max={1}
   381	          step={0.1}
   382	          style={{
   383	            width: '100%',
   384	            accentColor: '#3498db',
   385	            cursor: 'pointer',
   386	          }}
   387	        />
   388	      </div>
   389	
   390	      {/* Radius (for circles) */}
   391	      {fixture.geometry.type === 'circle' && (
   392	        <div>
   393	          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   394	            Radius: {fixture.geometry.radius.toFixed(1)} ft
   395	          </label>
   396	          <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
   397	            <input
   398	              type="range"
   399	              value={fixture.geometry.radius}
   400	              onChange={(e) => handleRadiusChange(parseFloat(e.target.value))}
   401	              min={0.25}
   402	              max={10}
   403	              step={0.1}
   404	              style={{
   405	                flex: 1,
   406	                accentColor: '#3498db',
   407	                cursor: 'pointer',
   408	              }}
   409	            />
   410	            <input
   411	              type="number"
   412	              value={fixture.geometry.radius}
   413	              onChange={(e) => handleRadiusChange(parseFloat(e.target.value) || 0.25)}
   414	              min={0.25}
   415	              max={10}
   416	              step={0.1}
   417	              style={{
   418	                width: 60,
   419	                padding: '4px 6px',
   420	                border: '1px solid #ccc',
   421	                borderRadius: 4,
   422	                fontSize: 12,
   423	                textAlign: 'center',
   424	              }}
   425	            />
   426	            <span style={{ fontSize: 12, color: '#666' }}>ft</span>
   427	          </div>
   428	        </div>
   429	      )}
   430	
   431	      {/* Rotation (for rectangles) */}
   432	      {fixture.geometry.type === 'rectangle' && (
   433	        <div>
   434	          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   435	            Rotation: {fixture.geometry.rotation || 0}
   436	          </label>
   437	
   438	          {/* Fine Control Buttons + Slider + Number Input */}
   439	          <div style={{ display: 'flex', gap: 2, alignItems: 'center', marginBottom: 8 }}>
   440	            <button
   441	              onMouseDown={() => startContinuousRotation(-5)}
   442	              onMouseUp={stopContinuousRotation}
   443	              onMouseLeave={stopContinuousRotation}
   444	              style={{
   445	                flex: 1,
   446	                padding: '4px 2px',
   447	                fontSize: 10,
   448	                border: '1px solid #ccc',
   449	                borderRadius: 4,
   450	                backgroundColor: 'white',
   451	                cursor: 'pointer',
   452	                userSelect: 'none',
   453	              }}
   454	            >
   455	              -5
   456	            </button>
   457	            <button
   458	              onMouseDown={() => startContinuousRotation(-1)}
   459	              onMouseUp={stopContinuousRotation}
   460	              onMouseLeave={stopContinuousRotation}
   461	              style={{
   462	                flex: 1,
   463	                padding: '4px 2px',
   464	                fontSize: 10,
   465	                border: '1px solid #ccc',
   466	                borderRadius: 4,
   467	                backgroundColor: 'white',
   468	                cursor: 'pointer',
   469	                userSelect: 'none',
   470	              }}
   471	            >
   472	              -1
   473	            </button>
   474	            <input
   475	              type="range"
   476	              value={fixture.geometry.rotation || 0}
   477	              onChange={(e) => handleRotationChange(parseInt(e.target.value))}
   478	              min={0}
   479	              max={360}
   480	              step={1}
   481	              style={{
   482	                flex: 2,
   483	                accentColor: '#3498db',
   484	                cursor: 'pointer',
   485	              }}
   486	            />
   487	            <button
   488	              onMouseDown={() => startContinuousRotation(1)}
   489	              onMouseUp={stopContinuousRotation}
   490	              onMouseLeave={stopContinuousRotation}
   491	              style={{
   492	                flex: 1,
   493	                padding: '4px 2px',
   494	                fontSize: 10,
   495	                border: '1px solid #ccc',
   496	                borderRadius: 4,
   497	                backgroundColor: 'white',
   498	                cursor: 'pointer',
   499	                userSelect: 'none',
   500	              }}
   501	            >
   502	              +1
   503	            </button>
   504	            <button
   505	              onMouseDown={() => startContinuousRotation(5)}
   506	              onMouseUp={stopContinuousRotation}
   507	              onMouseLeave={stopContinuousRotation}
   508	              style={{
   509	                flex: 1,
   510	                padding: '4px 2px',
   511	                fontSize: 10,
   512	                border: '1px solid #ccc',
   513	                borderRadius: 4,
   514	                backgroundColor: 'white',
   515	                cursor: 'pointer',
   516	                userSelect: 'none',
   517	              }}
   518	            >
   519	              +5
   520	            </button>
   521	          </div>
   522	
   523	          {/* Number Input + Degree Symbol on separate row */}
   524	          <div style={{ display: 'flex', gap: 4, alignItems: 'center', marginBottom: 8 }}>
   525	            <input
   526	              type="number"
   527	              value={fixture.geometry.rotation || 0}
   528	              onChange={(e) => handleRotationChange(parseInt(e.target.value) || 0)}
   529	              min={0}
   530	              max={360}
   531	              style={{
   532	                flex: 1,
   533	                padding: '4px 6px',
   534	                border: '1px solid #ccc',
   535	                borderRadius: 4,
   536	                fontSize: 12,
   537	                textAlign: 'center',
   538	              }}
   539	            />
   540	            <span style={{ fontSize: 12, color: '#666' }}></span>
   541	          </div>
   542	
   543	          {/* Quick Angle Buttons */}
   544	          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 4 }}>
   545	            {[0, 45, 90, 135, 180, 225, 270, 315].map((angle) => (
   546	              <button
   547	                key={angle}
   548	                onClick={() => handleRotationChange(angle)}
   549	                style={{
   550	                  padding: '4px 8px',
   551	                  fontSize: 11,
   552	                  border: '1px solid #ccc',
   553	                  borderRadius: 4,
   554	                  backgroundColor: (fixture.geometry.type === 'rectangle' && fixture.geometry.rotation === angle) ? '#e3f2fd' : 'white',
   555	                  cursor: 'pointer',
   556	                  fontWeight: (fixture.geometry.type === 'rectangle' && fixture.geometry.rotation === angle) ? 600 : 400,
   557	                }}
   558	              >
   559	                {angle}
   560	              </button>
   561	            ))}
   562	          </div>
   563	        </div>
   564	      )}
   565	
   566	      {/* Geometry Info */}
   567	      <div>
   568	        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
   569	          Geometry
   570	        </label>
   571	        <div
   572	          style={{
   573	            padding: '6px 8px',
   574	            backgroundColor: 'white',
   575	            border: '1px solid #ccc',
   576	            borderRadius: 4,
   577	            fontSize: 11,
   578	            fontFamily: 'monospace',
   579	            whiteSpace: 'pre-wrap',
   580	            wordBreak: 'break-all',
   581	          }}
   582	        >
   583	          {fixture.geometry.type === 'line' && (
   584	            <>
   585	              Start: ({fixture.geometry.start.x.toFixed(1)}, {fixture.geometry.start.y.toFixed(1)})<br />
   586	              End: ({fixture.geometry.end.x.toFixed(1)}, {fixture.geometry.end.y.toFixed(1)})
   587	            </>
   588	          )}
   589	          {fixture.geometry.type === 'rectangle' && (
   590	            <>
   591	              Position: ({fixture.geometry.position.x.toFixed(1)}, {fixture.geometry.position.y.toFixed(1)})<br />
   592	              Size: {fixture.geometry.width.toFixed(1)} x {fixture.geometry.height.toFixed(1)}
   593	            </>
   594	          )}
   595	          {fixture.geometry.type === 'circle' && (
   596	            <>
   597	              Center: ({fixture.geometry.center.x.toFixed(1)}, {fixture.geometry.center.y.toFixed(1)})<br />
   598	              Radius: {fixture.geometry.radius.toFixed(1)}
   599	            </>
   600	          )}
   601	        </div>
   602	      </div>
   603	
   604	      {/* Delete Button */}
   605	      <button
   606	        onClick={handleDelete}
   607	        style={{
   608	          marginTop: 'auto',
   609	          padding: '8px 16px',
   610	          backgroundColor: '#f44336',
   611	          color: 'white',
   612	          border: 'none',
   613	          borderRadius: 4,
   614	          cursor: 'pointer',
   615	          fontSize: 12,
   616	          fontWeight: 600,
   617	        }}
   618	      >
   619	        Delete Fixture
   620	      </button>
   621	    </div>
   622	  );
   623	}
   624	
   625	export default FixtureProperties;

================================================================================
FILE: /src/domains/floor-plan/admin/FixtureToolbar.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Fixture Toolbar Component
     6	 *
     7	 * Toolbar for selecting editor tools and fixture types.
     8	 */
     9	
    10	import React from 'react';
    11	import type { EditorToolMode, FixtureType, TableShape } from './types';
    12	import { FIXTURE_TYPES, TABLE_SHAPES } from './types';
    13	
    14	// =============================================================================
    15	// TYPES
    16	// =============================================================================
    17	
    18	interface FixtureToolbarProps {
    19	  selectedTool: EditorToolMode;
    20	  selectedFixtureType: FixtureType;
    21	  selectedTableShape?: TableShape;
    22	  onToolSelect: (tool: EditorToolMode) => void;
    23	  onFixtureTypeSelect: (type: FixtureType) => void;
    24	  onTableShapeSelect?: (shape: TableShape) => void;
    25	}
    26	
    27	// =============================================================================
    28	// COMPONENT
    29	// =============================================================================
    30	
    31	export function FixtureToolbar({
    32	  selectedTool,
    33	  selectedFixtureType,
    34	  selectedTableShape = 'rectangle',
    35	  onToolSelect,
    36	  onFixtureTypeSelect,
    37	  onTableShapeSelect,
    38	}: FixtureToolbarProps) {
    39	  const tools: { mode: EditorToolMode; label: string; icon: React.ReactNode }[] = [
    40	    { mode: 'SELECT', label: 'Select', icon: '' },
    41	    {
    42	      mode: 'TABLE',
    43	      label: 'Table',
    44	      icon: (
    45	        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
    46	          <rect x="3" y="8" width="18" height="3" rx="1" />
    47	          <rect x="5" y="11" width="2" height="8" />
    48	          <rect x="17" y="11" width="2" height="8" />
    49	        </svg>
    50	      )
    51	    },
    52	    { mode: 'WALL', label: 'Wall', icon: '' },
    53	    { mode: 'RECTANGLE', label: 'Fixture', icon: '' },
    54	    { mode: 'CIRCLE', label: 'Circle', icon: '' },
    55	    { mode: 'DELETE', label: 'Delete', icon: '' },
    56	  ];
    57	
    58	  // Debug logging for tool selection
    59	  React.useEffect(() => {
    60	    console.log('[FixtureToolbar] selectedTool:', selectedTool);
    61	  }, [selectedTool]);
    62	
    63	  return (
    64	    <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
    65	      {/* Tool Mode Selector */}
    66	      <div>
    67	        <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
    68	          Tool Mode
    69	        </h3>
    70	        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 4 }}>
    71	          {tools.map((tool) => (
    72	            <button
    73	              key={tool.mode}
    74	              onClick={() => onToolSelect(tool.mode)}
    75	              style={{
    76	                padding: '8px 4px',
    77	                border: selectedTool === tool.mode ? '2px solid #3498db' : '1px solid #ccc',
    78	                backgroundColor: selectedTool === tool.mode ? '#e3f2fd' : 'white',
    79	                borderRadius: 6,
    80	                cursor: 'pointer',
    81	                fontSize: 11,
    82	                fontWeight: selectedTool === tool.mode ? 600 : 400,
    83	                display: 'flex',
    84	                flexDirection: 'column',
    85	                alignItems: 'center',
    86	                gap: 4,
    87	              }}
    88	            >
    89	              <span style={{ fontSize: 18 }}>{tool.icon}</span>
    90	              <span>{tool.label}</span>
    91	            </button>
    92	          ))}
    93	        </div>
    94	      </div>
    95	
    96	      {/* Table Shape Selector (shown for TABLE mode) */}
    97	      {selectedTool === 'TABLE' && onTableShapeSelect && (
    98	        <div>
    99	          <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
   100	            Table Shape
   101	          </h3>
   102	          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 4 }}>
   103	            {TABLE_SHAPES.map((tableShape) => (
   104	              <button
   105	                key={tableShape.shape}
   106	                onClick={() => onTableShapeSelect(tableShape.shape)}
   107	                style={{
   108	                  padding: '6px 8px',
   109	                  border: selectedTableShape === tableShape.shape ? '2px solid #3498db' : '1px solid #ccc',
   110	                  backgroundColor: selectedTableShape === tableShape.shape ? '#e3f2fd' : 'white',
   111	                  borderRadius: 4,
   112	                  cursor: 'pointer',
   113	                  fontSize: 11,
   114	                  fontWeight: selectedTableShape === tableShape.shape ? 600 : 400,
   115	                  textAlign: 'left',
   116	                  display: 'flex',
   117	                  alignItems: 'center',
   118	                  gap: 6,
   119	                }}
   120	              >
   121	                <span style={{ fontSize: 16 }}>{tableShape.icon}</span>
   122	                <span>{tableShape.label.split(' ')[0]}</span>
   123	              </button>
   124	            ))}
   125	          </div>
   126	        </div>
   127	      )}
   128	
   129	      {/* Fixture Type Selector (shown for RECTANGLE and CIRCLE modes) */}
   130	      {(selectedTool === 'RECTANGLE' || selectedTool === 'CIRCLE') && (
   131	        <div>
   132	          <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
   133	            Fixture Type
   134	          </h3>
   135	          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 4 }}>
   136	            {FIXTURE_TYPES.filter((ft) => {
   137	              // Only show rectangle types for RECTANGLE tool
   138	              if (selectedTool === 'RECTANGLE') {
   139	                return !['pillar'].includes(ft.type);
   140	              }
   141	              // Only show circle types for CIRCLE tool
   142	              if (selectedTool === 'CIRCLE') {
   143	                return ['pillar'].includes(ft.type);
   144	              }
   145	              return true;
   146	            }).map((fixtureType) => (
   147	              <button
   148	                key={fixtureType.type}
   149	                onClick={() => onFixtureTypeSelect(fixtureType.type)}
   150	                style={{
   151	                  padding: '6px 8px',
   152	                  border: selectedFixtureType === fixtureType.type ? '2px solid #3498db' : '1px solid #ccc',
   153	                  backgroundColor: selectedFixtureType === fixtureType.type ? '#e3f2fd' : 'white',
   154	                  borderRadius: 4,
   155	                  cursor: 'pointer',
   156	                  fontSize: 11,
   157	                  fontWeight: selectedFixtureType === fixtureType.type ? 600 : 400,
   158	                  textAlign: 'left',
   159	                  display: 'flex',
   160	                  alignItems: 'center',
   161	                  gap: 6,
   162	                }}
   163	              >
   164	                <span
   165	                  style={{
   166	                    display: 'inline-block',
   167	                    width: 16,
   168	                    height: 16,
   169	                    backgroundColor: fixtureType.defaultColor,
   170	                    borderRadius: fixtureType.type === 'pillar' ? '50%' : 2,
   171	                  }}
   172	                />
   173	                <span>{fixtureType.label}</span>
   174	              </button>
   175	            ))}
   176	          </div>
   177	        </div>
   178	      )}
   179	
   180	      {/* Hints */}
   181	      <div
   182	        style={{
   183	          padding: 8,
   184	          backgroundColor: '#f5f5f5',
   185	          borderRadius: 4,
   186	          fontSize: 11,
   187	          color: '#666',
   188	        }}
   189	      >
   190	        <strong>Hints:</strong>
   191	        <ul style={{ margin: '4px 0 0 0', paddingLeft: 16 }}>
   192	          {selectedTool === 'SELECT' && (
   193	            <>
   194	              <li>Click to select fixture/table</li>
   195	              <li>Drag to move it</li>
   196	              <li>Press Delete to remove</li>
   197	            </>
   198	          )}
   199	          {selectedTool === 'TABLE' && (
   200	            <>
   201	              <li>Choose shape, then click to place</li>
   202	              <li>Seats auto-generated</li>
   203	              <li>Edit properties on right</li>
   204	            </>
   205	          )}
   206	          {selectedTool === 'WALL' && (
   207	            <>
   208	              <li>Click for start point</li>
   209	              <li>Click again for end point</li>
   210	            </>
   211	          )}
   212	          {selectedTool === 'RECTANGLE' && (
   213	            <>
   214	              <li>Click and drag to draw</li>
   215	              <li>Release to create</li>
   216	            </>
   217	          )}
   218	          {selectedTool === 'CIRCLE' && (
   219	            <>
   220	              <li>Click to place circle</li>
   221	              <li>Default radius: 1 foot</li>
   222	            </>
   223	          )}
   224	          {selectedTool === 'DELETE' && (
   225	            <>
   226	              <li>Click a fixture to delete it</li>
   227	            </>
   228	          )}
   229	        </ul>
   230	      </div>
   231	    </div>
   232	  );
   233	}
   234	
   235	export default FixtureToolbar;

================================================================================
DOMAIN COMPONENTS - CANVAS
================================================================================

================================================================================
FILE: /src/domains/floor-plan/canvas/FloorCanvas.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Domain
     5	 * Layer 1: Floor Canvas Component
     6	 *
     7	 * Renders the floor plan canvas with rooms and fixtures.
     8	 */
     9	
    10	import React, { useRef, useEffect, useState, useCallback } from 'react';
    11	import { FloorCanvasAPI } from './floorCanvasAPI';
    12	import type { FloorPlan, Fixture, Point } from '../shared/types';
    13	
    14	// =============================================================================
    15	// TYPES
    16	// =============================================================================
    17	
    18	interface FloorCanvasProps {
    19	  roomId?: string;
    20	  width?: number;
    21	  height?: number;
    22	  showGrid?: boolean;
    23	  showFixtures?: boolean;
    24	  onPositionClick?: (position: Point) => void;
    25	  onFixtureClick?: (fixture: Fixture) => void;
    26	  children?: React.ReactNode;
    27	}
    28	
    29	// =============================================================================
    30	// FIXTURE RENDERER
    31	// =============================================================================
    32	
    33	interface FixtureRendererProps {
    34	  fixture: Fixture;
    35	  onClick?: (fixture: Fixture) => void;
    36	}
    37	
    38	function FixtureRenderer({ fixture, onClick }: FixtureRendererProps) {
    39	  const handleClick = () => {
    40	    if (onClick) onClick(fixture);
    41	  };
    42	
    43	  const baseStyle: React.CSSProperties = {
    44	    position: 'absolute',
    45	    backgroundColor: fixture.color,
    46	    opacity: fixture.opacity,
    47	    cursor: onClick ? 'pointer' : 'default',
    48	  };
    49	
    50	  // Render based on geometry type
    51	  if (fixture.geometry.type === 'rectangle') {
    52	    const { position, width, height, rotation } = fixture.geometry;
    53	    return (
    54	      <div
    55	        onClick={handleClick}
    56	        style={{
    57	          ...baseStyle,
    58	          left: FloorCanvasAPI.feetToPixels(position.x),
    59	          top: FloorCanvasAPI.feetToPixels(position.y),
    60	          width: FloorCanvasAPI.feetToPixels(width),
    61	          height: FloorCanvasAPI.feetToPixels(height),
    62	          transform: `rotate(${rotation}deg)`,
    63	          transformOrigin: 'center center',
    64	        }}
    65	        title={fixture.label}
    66	      />
    67	    );
    68	  }
    69	
    70	  if (fixture.geometry.type === 'circle') {
    71	    const { center, radius } = fixture.geometry;
    72	    const diameter = radius * 2;
    73	    return (
    74	      <div
    75	        onClick={handleClick}
    76	        style={{
    77	          ...baseStyle,
    78	          left: FloorCanvasAPI.feetToPixels(center.x - radius),
    79	          top: FloorCanvasAPI.feetToPixels(center.y - radius),
    80	          width: FloorCanvasAPI.feetToPixels(diameter),
    81	          height: FloorCanvasAPI.feetToPixels(diameter),
    82	          borderRadius: '50%',
    83	        }}
    84	        title={fixture.label}
    85	      />
    86	    );
    87	  }
    88	
    89	  if (fixture.geometry.type === 'line') {
    90	    const { start, end } = fixture.geometry;
    91	    const thickness = fixture.thickness || 0.5;
    92	
    93	    // Calculate line dimensions
    94	    const dx = end.x - start.x;
    95	    const dy = end.y - start.y;
    96	    const length = Math.sqrt(dx * dx + dy * dy);
    97	    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
    98	
    99	    return (
   100	      <div
   101	        onClick={handleClick}
   102	        style={{
   103	          ...baseStyle,
   104	          left: FloorCanvasAPI.feetToPixels(start.x),
   105	          top: FloorCanvasAPI.feetToPixels(start.y - thickness / 2),
   106	          width: FloorCanvasAPI.feetToPixels(length),
   107	          height: FloorCanvasAPI.feetToPixels(thickness),
   108	          transform: `rotate(${angle}deg)`,
   109	          transformOrigin: 'left center',
   110	        }}
   111	        title={fixture.label}
   112	      />
   113	    );
   114	  }
   115	
   116	  // Polygon rendering (simplified - just show bounding box)
   117	  if (fixture.geometry.type === 'polygon') {
   118	    const { points } = fixture.geometry;
   119	    if (points.length < 3) return null;
   120	
   121	    const minX = Math.min(...points.map((p) => p.x));
   122	    const maxX = Math.max(...points.map((p) => p.x));
   123	    const minY = Math.min(...points.map((p) => p.y));
   124	    const maxY = Math.max(...points.map((p) => p.y));
   125	
   126	    // Create SVG path for polygon
   127	    const pathD = points
   128	      .map((p, i) => {
   129	        const px = FloorCanvasAPI.feetToPixels(p.x - minX);
   130	        const py = FloorCanvasAPI.feetToPixels(p.y - minY);
   131	        return `${i === 0 ? 'M' : 'L'} ${px} ${py}`;
   132	      })
   133	      .join(' ') + ' Z';
   134	
   135	    return (
   136	      <svg
   137	        onClick={handleClick}
   138	        style={{
   139	          position: 'absolute',
   140	          left: FloorCanvasAPI.feetToPixels(minX),
   141	          top: FloorCanvasAPI.feetToPixels(minY),
   142	          width: FloorCanvasAPI.feetToPixels(maxX - minX),
   143	          height: FloorCanvasAPI.feetToPixels(maxY - minY),
   144	          overflow: 'visible',
   145	          cursor: onClick ? 'pointer' : 'default',
   146	        }}
   147	      >
   148	        <title>{fixture.label}</title>
   149	        <path
   150	          d={pathD}
   151	          fill={fixture.color}
   152	          fillOpacity={fixture.opacity}
   153	          stroke="none"
   154	        />
   155	      </svg>
   156	    );
   157	  }
   158	
   159	  return null;
   160	}
   161	
   162	// =============================================================================
   163	// GRID RENDERER
   164	// =============================================================================
   165	
   166	interface GridRendererProps {
   167	  widthPx: number;
   168	  heightPx: number;
   169	  gridSizeFeet: number;
   170	}
   171	
   172	function GridRenderer({ widthPx, heightPx, gridSizeFeet }: GridRendererProps) {
   173	  const gridSizePx = FloorCanvasAPI.feetToPixels(gridSizeFeet);
   174	
   175	  // Generate grid lines
   176	  const verticalLines: number[] = [];
   177	  const horizontalLines: number[] = [];
   178	
   179	  for (let x = 0; x <= widthPx; x += gridSizePx) {
   180	    verticalLines.push(x);
   181	  }
   182	  for (let y = 0; y <= heightPx; y += gridSizePx) {
   183	    horizontalLines.push(y);
   184	  }
   185	
   186	  return (
   187	    <svg
   188	      style={{
   189	        position: 'absolute',
   190	        top: 0,
   191	        left: 0,
   192	        width: widthPx,
   193	        height: heightPx,
   194	        pointerEvents: 'none',
   195	      }}
   196	    >
   197	      {/* Grid lines */}
   198	      {verticalLines.map((x) => (
   199	        <line
   200	          key={`v-${x}`}
   201	          x1={x}
   202	          y1={0}
   203	          x2={x}
   204	          y2={heightPx}
   205	          stroke="#e0e0e0"
   206	          strokeWidth={1}
   207	        />
   208	      ))}
   209	      {horizontalLines.map((y) => (
   210	        <line
   211	          key={`h-${y}`}
   212	          x1={0}
   213	          y1={y}
   214	          x2={widthPx}
   215	          y2={y}
   216	          stroke="#e0e0e0"
   217	          strokeWidth={1}
   218	        />
   219	      ))}
   220	    </svg>
   221	  );
   222	}
   223	
   224	// =============================================================================
   225	// FLOOR CANVAS COMPONENT
   226	// =============================================================================
   227	
   228	export function FloorCanvas({
   229	  roomId,
   230	  width,
   231	  height,
   232	  showGrid = true,
   233	  showFixtures = true,
   234	  onPositionClick,
   235	  onFixtureClick,
   236	  children,
   237	}: FloorCanvasProps) {
   238	  const containerRef = useRef<HTMLDivElement>(null);
   239	  const [floorPlan, setFloorPlan] = useState<FloorPlan | null>(null);
   240	  const [fixtures, setFixtures] = useState<Fixture[]>([]);
   241	
   242	  // Load floor plan data
   243	  useEffect(() => {
   244	    const fp = FloorCanvasAPI.getFloorPlan(roomId);
   245	    setFloorPlan(fp);
   246	
   247	    if (fp) {
   248	      const fixtureList = FloorCanvasAPI.getFixtures(fp.id);
   249	      setFixtures(fixtureList);
   250	    }
   251	  }, [roomId]);
   252	
   253	  // Calculate canvas dimensions - props override floor plan dimensions
   254	  const canvasDimensions = (width && height)
   255	    ? { widthPx: width, heightPx: height }
   256	    : floorPlan
   257	      ? FloorCanvasAPI.getCanvasDimensions(floorPlan.id)
   258	      : { widthPx: 800, heightPx: 600 };
   259	
   260	  // Handle click on canvas
   261	  const handleCanvasClick = useCallback(
   262	    (event: React.MouseEvent<HTMLDivElement>) => {
   263	      if (!onPositionClick || !floorPlan) return;
   264	
   265	      const rect = event.currentTarget.getBoundingClientRect();
   266	      const clickX = event.clientX - rect.left;
   267	      const clickY = event.clientY - rect.top;
   268	
   269	      // Convert to feet
   270	      const position: Point = {
   271	        x: FloorCanvasAPI.pixelsToFeet(clickX),
   272	        y: FloorCanvasAPI.pixelsToFeet(clickY),
   273	      };
   274	
   275	      // Snap to grid if grid is enabled
   276	      if (showGrid) {
   277	        const snapped = FloorCanvasAPI.snapToGrid(position, floorPlan.gridSizeFeet);
   278	        onPositionClick(snapped);
   279	      } else {
   280	        onPositionClick(position);
   281	      }
   282	    },
   283	    [onPositionClick, floorPlan, showGrid]
   284	  );
   285	
   286	  // Use CSS grid when showGrid is false but we have fixed dimensions (DB mode)
   287	  const usesCssGrid = !showGrid && width && height;
   288	  const gridSize = 32; // Match Editor GRID_SIZE
   289	
   290	  return (
   291	    <div
   292	      ref={containerRef}
   293	      onClick={handleCanvasClick}
   294	      style={{
   295	        position: 'relative',
   296	        width: canvasDimensions.widthPx,
   297	        height: canvasDimensions.heightPx,
   298	        backgroundColor: '#f8f9fa',
   299	        backgroundImage: usesCssGrid ? `
   300	          linear-gradient(rgba(0,0,0,0.08) 1px, transparent 1px),
   301	          linear-gradient(90deg, rgba(0,0,0,0.08) 1px, transparent 1px)
   302	        ` : undefined,
   303	        backgroundSize: usesCssGrid ? `${gridSize}px ${gridSize}px` : undefined,
   304	        border: '2px solid #ccc',
   305	        borderRadius: 8,
   306	        overflow: 'hidden',
   307	        cursor: onPositionClick ? 'crosshair' : 'default',
   308	      }}
   309	    >
   310	      {/* Grid layer */}
   311	      {showGrid && floorPlan && (
   312	        <GridRenderer
   313	          widthPx={canvasDimensions.widthPx}
   314	          heightPx={canvasDimensions.heightPx}
   315	          gridSizeFeet={floorPlan.gridSizeFeet}
   316	        />
   317	      )}
   318	
   319	      {/* Fixtures layer */}
   320	      {showFixtures &&
   321	        fixtures.map((fixture) => (
   322	          <FixtureRenderer
   323	            key={fixture.id}
   324	            fixture={fixture}
   325	            onClick={onFixtureClick}
   326	          />
   327	        ))}
   328	
   329	      {/* Children (tables, seats, etc. from other layers) */}
   330	      {children}
   331	
   332	      {/* Room info overlay */}
   333	      {floorPlan && (
   334	        <div
   335	          style={{
   336	            position: 'absolute',
   337	            bottom: 8,
   338	            left: 8,
   339	            padding: '4px 8px',
   340	            backgroundColor: 'rgba(0, 0, 0, 0.6)',
   341	            color: 'white',
   342	            borderRadius: 4,
   343	            fontSize: 12,
   344	            pointerEvents: 'none',
   345	          }}
   346	        >
   347	          {floorPlan.name} ({floorPlan.widthFeet}ft x {floorPlan.heightFeet}ft)
   348	        </div>
   349	      )}
   350	    </div>
   351	  );
   352	}
   353	
   354	// =============================================================================
   355	// ROOM SELECTOR COMPONENT
   356	// =============================================================================
   357	
   358	interface RoomSelectorProps {
   359	  selectedRoomId?: string;
   360	  onRoomSelect: (roomId: string) => void;
   361	}
   362	
   363	export function RoomSelector({ selectedRoomId, onRoomSelect }: RoomSelectorProps) {
   364	  const [rooms, setRooms] = useState<FloorPlan[]>([]);
   365	  const [editingRoomId, setEditingRoomId] = useState<string | null>(null);
   366	  const [editingName, setEditingName] = useState('');
   367	
   368	  useEffect(() => {
   369	    setRooms(FloorCanvasAPI.getAllRooms());
   370	  }, []);
   371	
   372	  const handleAddRoom = () => {
   373	    // TODO: Implement room creation via FloorCanvasAPI
   374	    alert('Add Room feature coming soon!\nThis will create a new room in the floor plan.');
   375	  };
   376	
   377	  const handleStartRename = (room: FloorPlan, event: React.MouseEvent) => {
   378	    event.stopPropagation();
   379	    setEditingRoomId(room.id);
   380	    setEditingName(room.name);
   381	  };
   382	
   383	  const handleRenameSubmit = (roomId: string) => {
   384	    if (editingName.trim()) {
   385	      // TODO: Implement room rename via FloorCanvasAPI
   386	      alert(`Rename feature coming soon!\nWould rename room to: ${editingName}`);
   387	    }
   388	    setEditingRoomId(null);
   389	    setEditingName('');
   390	  };
   391	
   392	  const handleDeleteRoom = (room: FloorPlan, event: React.MouseEvent) => {
   393	    event.stopPropagation();
   394	    if (window.confirm(`Delete room "${room.name}"?\n\nThis will remove all fixtures in this room.`)) {
   395	      // TODO: Implement room deletion via FloorCanvasAPI
   396	      alert('Delete Room feature coming soon!');
   397	    }
   398	  };
   399	
   400	  if (rooms.length === 0) {
   401	    return null;
   402	  }
   403	
   404	  return (
   405	    <div
   406	      style={{
   407	        display: 'flex',
   408	        gap: 8,
   409	        marginBottom: 16,
   410	        alignItems: 'center',
   411	      }}
   412	    >
   413	      {rooms.map((room) => (
   414	        <div
   415	          key={room.id}
   416	          style={{
   417	            display: 'flex',
   418	            alignItems: 'center',
   419	            gap: 4,
   420	          }}
   421	        >
   422	          {editingRoomId === room.id ? (
   423	            <input
   424	              type="text"
   425	              value={editingName}
   426	              onChange={(e) => setEditingName(e.target.value)}
   427	              onBlur={() => handleRenameSubmit(room.id)}
   428	              onKeyDown={(e) => {
   429	                if (e.key === 'Enter') handleRenameSubmit(room.id);
   430	                if (e.key === 'Escape') {
   431	                  setEditingRoomId(null);
   432	                  setEditingName('');
   433	                }
   434	              }}
   435	              autoFocus
   436	              style={{
   437	                minWidth: 120,
   438	                padding: '8px 16px',
   439	                borderRadius: 8,
   440	                border: '2px solid #3498db',
   441	                fontSize: 14,
   442	              }}
   443	            />
   444	          ) : (
   445	            <button
   446	              onClick={() => onRoomSelect(room.id)}
   447	              onDoubleClick={(e) => handleStartRename(room, e)}
   448	              style={{
   449	                minWidth: 120,
   450	                padding: '8px 16px',
   451	                borderRadius: 8,
   452	                border: selectedRoomId === room.id ? '2px solid #3498db' : '1px solid #ccc',
   453	                backgroundColor: selectedRoomId === room.id ? '#e3f2fd' : 'white',
   454	                cursor: 'pointer',
   455	                fontWeight: selectedRoomId === room.id ? 600 : 400,
   456	                fontSize: 14,
   457	              }}
   458	            >
   459	              {room.name}
   460	            </button>
   461	          )}
   462	          {rooms.length > 1 && selectedRoomId === room.id && (
   463	            <button
   464	              onClick={(e) => handleDeleteRoom(room, e)}
   465	              style={{
   466	                padding: '4px 8px',
   467	                borderRadius: 4,
   468	                border: '1px solid #f44336',
   469	                backgroundColor: 'white',
   470	                color: '#f44336',
   471	                cursor: 'pointer',
   472	                fontSize: 12,
   473	              }}
   474	              title="Delete room"
   475	            >
   476	              
   477	            </button>
   478	          )}
   479	        </div>
   480	      ))}
   481	      <button
   482	        onClick={handleAddRoom}
   483	        style={{
   484	          padding: '8px 16px',
   485	          borderRadius: 8,
   486	          border: '2px dashed #3498db',
   487	          backgroundColor: 'white',
   488	          color: '#3498db',
   489	          cursor: 'pointer',
   490	          fontWeight: 600,
   491	          fontSize: 14,
   492	        }}
   493	      >
   494	        + Add Room
   495	      </button>
   496	    </div>
   497	  );
   498	}
   499	
   500	// =============================================================================
   501	// EXPORTS
   502	// =============================================================================
   503	
   504	export default FloorCanvas;

================================================================================
FILE: /src/domains/floor-plan/canvas/floorCanvasAPI.ts
================================================================================
     1	/**
     2	 * GWI POS - Floor Plan Domain
     3	 * Layer 1: Floor Canvas API
     4	 *
     5	 * Manages floor plans, rooms, fixtures, and collision detection.
     6	 */
     7	
     8	import type {
     9	  FloorPlan,
    10	  Fixture,
    11	  FixtureType,
    12	  FixtureCategory,
    13	  Point,
    14	} from '../shared/types';
    15	
    16	// =============================================================================
    17	// CONFIGURATION
    18	// =============================================================================
    19	
    20	const DEFAULT_PIXELS_PER_FOOT = 20; // 20px = 1 foot
    21	let pixelsPerFoot = DEFAULT_PIXELS_PER_FOOT;
    22	
    23	// =============================================================================
    24	// STATE (In production, this would come from the database)
    25	// =============================================================================
    26	
    27	let floorPlans: Map<string, FloorPlan> = new Map();
    28	let fixtures: Map<string, Fixture> = new Map();
    29	let activeRoomId: string | null = null;
    30	
    31	// =============================================================================
    32	// COORDINATE SYSTEM
    33	// =============================================================================
    34	
    35	/**
    36	 * Convert feet to pixels
    37	 */
    38	export function feetToPixels(feet: number): number {
    39	  return feet * pixelsPerFoot;
    40	}
    41	
    42	/**
    43	 * Convert pixels to feet
    44	 */
    45	export function pixelsToFeet(pixels: number): number {
    46	  return pixels / pixelsPerFoot;
    47	}
    48	
    49	/**
    50	 * Set the scale (pixels per foot)
    51	 */
    52	export function setScale(pxPerFoot: number): void {
    53	  pixelsPerFoot = pxPerFoot;
    54	}
    55	
    56	/**
    57	 * Get current scale
    58	 */
    59	export function getScale(): number {
    60	  return pixelsPerFoot;
    61	}
    62	
    63	/**
    64	 * Snap a position to the grid
    65	 */
    66	export function snapToGrid(position: Point, gridSizeFeet: number): Point {
    67	  return {
    68	    x: Math.round(position.x / gridSizeFeet) * gridSizeFeet,
    69	    y: Math.round(position.y / gridSizeFeet) * gridSizeFeet,
    70	  };
    71	}
    72	
    73	// =============================================================================
    74	// FLOOR PLAN / ROOM MANAGEMENT
    75	// =============================================================================
    76	
    77	/**
    78	 * Get a floor plan by ID
    79	 */
    80	export function getFloorPlan(roomId?: string): FloorPlan | null {
    81	  const id = roomId ?? activeRoomId;
    82	  if (!id) return null;
    83	  return floorPlans.get(id) ?? null;
    84	}
    85	
    86	/**
    87	 * Get all rooms/floor plans
    88	 */
    89	export function getAllRooms(): FloorPlan[] {
    90	  return Array.from(floorPlans.values())
    91	    .filter((fp) => fp.isActive)
    92	    .sort((a, b) => a.sortOrder - b.sortOrder);
    93	}
    94	
    95	/**
    96	 * Get the currently active room ID
    97	 */
    98	export function getActiveRoom(): string | null {
    99	  return activeRoomId;
   100	}
   101	
   102	/**
   103	 * Set the active room
   104	 */
   105	export function setActiveRoom(roomId: string): void {
   106	  if (floorPlans.has(roomId)) {
   107	    activeRoomId = roomId;
   108	  }
   109	}
   110	
   111	/**
   112	 * Get rooms by type
   113	 */
   114	export function getRoomsByType(type: string): FloorPlan[] {
   115	  return Array.from(floorPlans.values()).filter(
   116	    (fp) => fp.type === type && fp.isActive
   117	  );
   118	}
   119	
   120	/**
   121	 * Get canvas dimensions in pixels for a room
   122	 */
   123	export function getCanvasDimensions(roomId?: string): {
   124	  widthPx: number;
   125	  heightPx: number;
   126	} {
   127	  const fp = getFloorPlan(roomId);
   128	  if (!fp) {
   129	    return { widthPx: 0, heightPx: 0 };
   130	  }
   131	  return {
   132	    widthPx: feetToPixels(fp.widthFeet),
   133	    heightPx: feetToPixels(fp.heightFeet),
   134	  };
   135	}
   136	
   137	// =============================================================================
   138	// FLOOR PLAN CRUD
   139	// =============================================================================
   140	
   141	/**
   142	 * Create a new floor plan
   143	 */
   144	export function createFloorPlan(
   145	  data: Omit<FloorPlan, 'id'>
   146	): FloorPlan {
   147	  const id = `fp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
   148	  const floorPlan: FloorPlan = {
   149	    id,
   150	    ...data,
   151	  };
   152	  floorPlans.set(id, floorPlan);
   153	
   154	  // Set as active if it's the first one
   155	  if (!activeRoomId) {
   156	    activeRoomId = id;
   157	  }
   158	
   159	  return floorPlan;
   160	}
   161	
   162	/**
   163	 * Update a floor plan
   164	 */
   165	export function updateFloorPlan(
   166	  roomId: string,
   167	  updates: Partial<FloorPlan>
   168	): void {
   169	  const fp = floorPlans.get(roomId);
   170	  if (fp) {
   171	    floorPlans.set(roomId, { ...fp, ...updates });
   172	  }
   173	}
   174	
   175	/**
   176	 * Delete a floor plan
   177	 */
   178	export function deleteFloorPlan(roomId: string): void {
   179	  floorPlans.delete(roomId);
   180	  // Also delete all fixtures in this room
   181	  for (const [id, fixture] of fixtures) {
   182	    if (fixture.roomId === roomId) {
   183	      fixtures.delete(id);
   184	    }
   185	  }
   186	  // Update active room if necessary
   187	  if (activeRoomId === roomId) {
   188	    const rooms = getAllRooms();
   189	    activeRoomId = rooms.length > 0 ? rooms[0].id : null;
   190	  }
   191	}
   192	
   193	// =============================================================================
   194	// FIXTURE MANAGEMENT
   195	// =============================================================================
   196	
   197	/**
   198	 * Get all fixtures for a room
   199	 */
   200	export function getFixtures(roomId: string): Fixture[] {
   201	  return Array.from(fixtures.values()).filter(
   202	    (f) => f.roomId === roomId && f.isActive
   203	  );
   204	}
   205	
   206	/**
   207	 * Get fixtures by type
   208	 */
   209	export function getFixturesByType(
   210	  roomId: string,
   211	  type: FixtureType
   212	): Fixture[] {
   213	  return getFixtures(roomId).filter((f) => f.type === type);
   214	}
   215	
   216	/**
   217	 * Get fixtures by category
   218	 */
   219	export function getFixturesByCategory(
   220	  roomId: string,
   221	  category: FixtureCategory
   222	): Fixture[] {
   223	  return getFixtures(roomId).filter((f) => f.category === category);
   224	}
   225	
   226	/**
   227	 * Get bar counters (convenience method)
   228	 */
   229	export function getBarCounters(roomId: string): Fixture[] {
   230	  return getFixturesByType(roomId, 'bar_counter');
   231	}
   232	
   233	/**
   234	 * Add a fixture
   235	 */
   236	export function addFixture(data: Omit<Fixture, 'id'>): Fixture {
   237	  const id = `fix_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
   238	  const fixture: Fixture = {
   239	    id,
   240	    ...data,
   241	  };
   242	  fixtures.set(id, fixture);
   243	  return fixture;
   244	}
   245	
   246	/**
   247	 * Update a fixture
   248	 */
   249	export function updateFixture(
   250	  fixtureId: string,
   251	  updates: Partial<Fixture>
   252	): void {
   253	  const fixture = fixtures.get(fixtureId);
   254	  if (fixture) {
   255	    fixtures.set(fixtureId, { ...fixture, ...updates });
   256	  }
   257	}
   258	
   259	/**
   260	 * Remove a fixture
   261	 */
   262	export function removeFixture(fixtureId: string): void {
   263	  fixtures.delete(fixtureId);
   264	}
   265	
   266	// =============================================================================
   267	// COLLISION DETECTION
   268	// =============================================================================
   269	
   270	/**
   271	 * Check if a position is blocked by fixtures
   272	 */
   273	export function isPositionBlocked(
   274	  roomId: string,
   275	  position: Point,
   276	  objectWidth: number,
   277	  objectHeight: number
   278	): boolean {
   279	  const roomFixtures = getFixtures(roomId);
   280	
   281	  // Calculate object bounds
   282	  const objectLeft = position.x;
   283	  const objectRight = position.x + objectWidth;
   284	  const objectTop = position.y;
   285	  const objectBottom = position.y + objectHeight;
   286	
   287	  for (const fixture of roomFixtures) {
   288	    // Skip fixtures that don't block placement
   289	    if (!fixture.blocksPlacement) continue;
   290	
   291	    // Check collision based on geometry type
   292	    if (fixture.geometry.type === 'rectangle') {
   293	      const { position: fPos, width, height, rotation } = fixture.geometry;
   294	
   295	      // For now, ignore rotation (simplified collision)
   296	      const fixtureLeft = fPos.x;
   297	      const fixtureRight = fPos.x + width;
   298	      const fixtureTop = fPos.y;
   299	      const fixtureBottom = fPos.y + height;
   300	
   301	      // AABB collision check
   302	      if (
   303	        objectLeft < fixtureRight &&
   304	        objectRight > fixtureLeft &&
   305	        objectTop < fixtureBottom &&
   306	        objectBottom > fixtureTop
   307	      ) {
   308	        return true;
   309	      }
   310	    } else if (fixture.geometry.type === 'circle') {
   311	      const { center, radius } = fixture.geometry;
   312	
   313	      // Check if any corner of the object is inside the circle
   314	      // Or if the circle center is inside the object bounds
   315	      const closestX = Math.max(objectLeft, Math.min(center.x, objectRight));
   316	      const closestY = Math.max(objectTop, Math.min(center.y, objectBottom));
   317	
   318	      const distanceX = center.x - closestX;
   319	      const distanceY = center.y - closestY;
   320	      const distanceSquared = distanceX * distanceX + distanceY * distanceY;
   321	
   322	      if (distanceSquared < radius * radius) {
   323	        return true;
   324	      }
   325	    } else if (fixture.geometry.type === 'line') {
   326	      const { start, end } = fixture.geometry;
   327	      const thickness = fixture.thickness || 0.5; // Default wall thickness
   328	
   329	      // Convert line to rectangle for collision
   330	      const lineLeft = Math.min(start.x, end.x) - thickness / 2;
   331	      const lineRight = Math.max(start.x, end.x) + thickness / 2;
   332	      const lineTop = Math.min(start.y, end.y) - thickness / 2;
   333	      const lineBottom = Math.max(start.y, end.y) + thickness / 2;
   334	
   335	      if (
   336	        objectLeft < lineRight &&
   337	        objectRight > lineLeft &&
   338	        objectTop < lineBottom &&
   339	        objectBottom > lineTop
   340	      ) {
   341	        return true;
   342	      }
   343	    }
   344	    // Add more geometry types as needed
   345	  }
   346	
   347	  // Also check room boundaries
   348	  const room = getFloorPlan(roomId);
   349	  if (room) {
   350	    if (
   351	      objectLeft < 0 ||
   352	      objectTop < 0 ||
   353	      objectRight > room.widthFeet ||
   354	      objectBottom > room.heightFeet
   355	    ) {
   356	      return true;
   357	    }
   358	  }
   359	
   360	  return false;
   361	}
   362	
   363	/**
   364	 * Get fixtures that an object can snap to
   365	 */
   366	export function getSnapTargets(
   367	  roomId: string,
   368	  objectPosition: Point,
   369	  snapDistance: number
   370	): Fixture[] {
   371	  const roomFixtures = getFixtures(roomId);
   372	
   373	  return roomFixtures.filter((fixture) => {
   374	    if (!fixture.snapTarget) return false;
   375	
   376	    // Calculate distance to fixture (simplified)
   377	    if (fixture.geometry.type === 'rectangle') {
   378	      const { position: fPos, width, height } = fixture.geometry;
   379	      const centerX = fPos.x + width / 2;
   380	      const centerY = fPos.y + height / 2;
   381	
   382	      const dx = Math.abs(objectPosition.x - centerX);
   383	      const dy = Math.abs(objectPosition.y - centerY);
   384	
   385	      // Check if within snap distance of any edge
   386	      return (
   387	        (dx < width / 2 + snapDistance && dy < height / 2) ||
   388	        (dy < height / 2 + snapDistance && dx < width / 2)
   389	      );
   390	    }
   391	
   392	    return false;
   393	  });
   394	}
   395	
   396	/**
   397	 * Get the nearest edge point of a fixture
   398	 */
   399	export function getNearestFixtureEdge(
   400	  roomId: string,
   401	  position: Point,
   402	  fixtureId: string
   403	): Point | null {
   404	  const fixture = fixtures.get(fixtureId);
   405	  if (!fixture || fixture.roomId !== roomId) return null;
   406	
   407	  if (fixture.geometry.type === 'rectangle') {
   408	    const { position: fPos, width, height } = fixture.geometry;
   409	
   410	    // Calculate distances to each edge
   411	    const edges = [
   412	      { x: position.x, y: fPos.y }, // Top edge
   413	      { x: position.x, y: fPos.y + height }, // Bottom edge
   414	      { x: fPos.x, y: position.y }, // Left edge
   415	      { x: fPos.x + width, y: position.y }, // Right edge
   416	    ];
   417	
   418	    // Clamp positions to be on the fixture
   419	    edges[0].x = Math.max(fPos.x, Math.min(position.x, fPos.x + width));
   420	    edges[1].x = Math.max(fPos.x, Math.min(position.x, fPos.x + width));
   421	    edges[2].y = Math.max(fPos.y, Math.min(position.y, fPos.y + height));
   422	    edges[3].y = Math.max(fPos.y, Math.min(position.y, fPos.y + height));
   423	
   424	    // Find nearest edge
   425	    let nearest = edges[0];
   426	    let minDist = Infinity;
   427	
   428	    for (const edge of edges) {
   429	      const dist = Math.sqrt(
   430	        Math.pow(position.x - edge.x, 2) + Math.pow(position.y - edge.y, 2)
   431	      );
   432	      if (dist < minDist) {
   433	        minDist = dist;
   434	        nearest = edge;
   435	      }
   436	    }
   437	
   438	    return nearest;
   439	  }
   440	
   441	  return null;
   442	}
   443	
   444	/**
   445	 * Get the valid placement area (room minus barriers)
   446	 * Returns a simplified polygon of placeable area
   447	 */
   448	export function getPlaceableArea(roomId: string): Point[] {
   449	  const room = getFloorPlan(roomId);
   450	  if (!room) return [];
   451	
   452	  // Start with room boundaries
   453	  const area: Point[] = [
   454	    { x: 0, y: 0 },
   455	    { x: room.widthFeet, y: 0 },
   456	    { x: room.widthFeet, y: room.heightFeet },
   457	    { x: 0, y: room.heightFeet },
   458	  ];
   459	
   460	  // In a full implementation, we would subtract barrier fixtures
   461	  // For now, return the room boundary
   462	  return area;
   463	}
   464	
   465	// =============================================================================
   466	// INITIALIZATION
   467	// =============================================================================
   468	
   469	/**
   470	 * Initialize the canvas with floor plans from the database
   471	 */
   472	export function initializeFloorPlans(plans: FloorPlan[], fixtureList: Fixture[]): void {
   473	  floorPlans.clear();
   474	  fixtures.clear();
   475	
   476	  for (const plan of plans) {
   477	    floorPlans.set(plan.id, plan);
   478	  }
   479	
   480	  for (const fixture of fixtureList) {
   481	    fixtures.set(fixture.id, fixture);
   482	  }
   483	
   484	  // Set first active room
   485	  const activeRooms = getAllRooms();
   486	  if (activeRooms.length > 0 && !activeRoomId) {
   487	    activeRoomId = activeRooms[0].id;
   488	  }
   489	}
   490	
   491	/**
   492	 * Clear all data (for testing)
   493	 */
   494	export function clearAll(): void {
   495	  floorPlans.clear();
   496	  fixtures.clear();
   497	  activeRoomId = null;
   498	}
   499	
   500	// =============================================================================
   501	// EXPORT THE API
   502	// =============================================================================
   503	
   504	export const FloorCanvasAPI = {
   505	  // Coordinate system
   506	  feetToPixels,
   507	  pixelsToFeet,
   508	  setScale,
   509	  getScale,
   510	  snapToGrid,
   511	
   512	  // Room management
   513	  getFloorPlan,
   514	  getAllRooms,
   515	  getActiveRoom,
   516	  setActiveRoom,
   517	  getRoomsByType,
   518	  getCanvasDimensions,
   519	
   520	  // Floor plan CRUD
   521	  createFloorPlan,
   522	  updateFloorPlan,
   523	  deleteFloorPlan,
   524	
   525	  // Fixture management
   526	  getFixtures,
   527	  getFixturesByType,
   528	  getFixturesByCategory,
   529	  getBarCounters,
   530	  addFixture,
   531	  updateFixture,
   532	  removeFixture,
   533	
   534	  // Collision detection
   535	  isPositionBlocked,
   536	  getSnapTargets,
   537	  getNearestFixtureEdge,
   538	  getPlaceableArea,
   539	
   540	  // Initialization
   541	  initializeFloorPlans,
   542	  clearAll,
   543	};
   544	
   545	export default FloorCanvasAPI;

================================================================================
FILE: /src/domains/floor-plan/canvas/index.ts
================================================================================
     1	/**
     2	 * GWI POS - Floor Plan Domain
     3	 * Layer 1: Floor Canvas
     4	 *
     5	 * Public exports for the canvas layer.
     6	 */
     7	
     8	export { FloorCanvas, RoomSelector } from './FloorCanvas';
     9	export { FloorCanvasAPI, default as floorCanvasAPI } from './floorCanvasAPI';
    10	
    11	// Re-export types used by this layer
    12	export type {
    13	  FloorPlan,
    14	  Fixture,
    15	  FixtureType,
    16	  FixtureCategory,
    17	  FixtureGeometry,
    18	  Point,
    19	  RoomType,
    20	} from '../shared/types';

================================================================================
DOMAIN COMPONENTS - GROUPS/VIRTUAL COMBINE
================================================================================

================================================================================
FILE: /src/domains/floor-plan/groups/tableGroupAPI.ts
================================================================================
     1	/**
     2	 * GWI POS - Floor Plan Domain
     3	 * Layer 4: Table Groups - API Service
     4	 *
     5	 * Central service for managing table groups (physical merge + virtual groups)
     6	 */
     7	
     8	import { TableGroup, Seat } from '../shared/types';
     9	import {
    10	  getNextAvailableColor,
    11	  markColorInUse,
    12	  releaseColor,
    13	  clearColorAssignments,
    14	} from './colorPalette';
    15	
    16	// In-memory storage for groups (would be replaced with database)
    17	const groups = new Map<string, TableGroup>();
    18	
    19	// Track which tables are in groups
    20	const tableToGroupMap = new Map<string, string>();
    21	
    22	// Counter for generating group IDs
    23	let groupIdCounter = 1;
    24	
    25	/**
    26	 * Table Group API Interface
    27	 */
    28	export interface TableGroupAPI {
    29	  // Create/dissolve
    30	  createPhysicalMerge(tableIds: string[]): TableGroup;
    31	  createVirtualGroup(tableIds: string[]): TableGroup;
    32	  dissolveGroup(groupId: string): void;
    33	
    34	  // Queries
    35	  getGroup(groupId: string): TableGroup | null;
    36	  getGroupForTable(tableId: string): TableGroup | null;
    37	  getAllActiveGroups(): TableGroup[];
    38	  getGroupsInRoom(roomId: string): TableGroup[];
    39	
    40	  // Membership
    41	  addTableToGroup(groupId: string, tableId: string): void;
    42	  removeTableFromGroup(groupId: string, tableId: string): void;
    43	
    44	  // Properties
    45	  setGroupColor(groupId: string, color: string): void;
    46	  setGroupIdentifier(groupId: string, identifier: string): void;
    47	
    48	  // Seats
    49	  getGroupSeats(groupId: string): Seat[];
    50	  getGroupSeatCount(groupId: string): number;
    51	
    52	  // Cross-room
    53	  getGroupRooms(groupId: string): string[];
    54	  isCrossRoomGroup(groupId: string): boolean;
    55	
    56	  // Initialization
    57	  initializeGroups(groups: TableGroup[]): void;
    58	  clearAll(): void;
    59	}
    60	
    61	/**
    62	 * Create a physical merge group
    63	 * Tables snap together, share color, seats renumber sequentially
    64	 */
    65	function createPhysicalMerge(tableIds: string[]): TableGroup {
    66	  if (tableIds.length < 2) {
    67	    throw new Error('Physical merge requires at least 2 tables');
    68	  }
    69	
    70	  // Check if any tables are already grouped
    71	  for (const tableId of tableIds) {
    72	    if (tableToGroupMap.has(tableId)) {
    73	      throw new Error(`Table ${tableId} is already in a group`);
    74	    }
    75	  }
    76	
    77	  // TODO: Get tables from TableAPI to validate they're in same room
    78	  // TODO: Calculate snap positions using mergeLogic
    79	  // TODO: Update table positions via TableAPI
    80	
    81	  const groupId = `group-${groupIdCounter++}`;
    82	  const color = getNextAvailableColor();
    83	
    84	  const group: TableGroup = {
    85	    id: groupId,
    86	    locationId: '', // TODO: Get from tables
    87	    tableIds: [...tableIds],
    88	    primaryTableId: tableIds[0],
    89	    isVirtual: false,
    90	    color,
    91	    identifier: '',
    92	    combinedCapacity: 0, // TODO: Calculate from seats
    93	    isActive: true,
    94	    createdAt: new Date(),
    95	    createdBy: '', // TODO: Get from context
    96	  };
    97	
    98	  groups.set(groupId, group);
    99	
   100	  // Update table-to-group mapping
   101	  for (const tableId of tableIds) {
   102	    tableToGroupMap.set(tableId, groupId);
   103	  }
   104	
   105	  // TODO: Call SeatAPI.renumberSeatsForMerge(tableIds)
   106	  // TODO: Call TableAPI.setTableColor(tableId, color) for each table
   107	  // TODO: Call TableAPI.updateTable to set groupId
   108	
   109	  return group;
   110	}
   111	
   112	/**
   113	 * Create a virtual group
   114	 * Tables stay in place but are linked for ordering
   115	 */
   116	function createVirtualGroup(tableIds: string[]): TableGroup {
   117	  if (tableIds.length < 2) {
   118	    throw new Error('Virtual group requires at least 2 tables');
   119	  }
   120	
   121	  // Check if any tables are already grouped
   122	  for (const tableId of tableIds) {
   123	    if (tableToGroupMap.has(tableId)) {
   124	      throw new Error(`Table ${tableId} is already in a group`);
   125	    }
   126	  }
   127	
   128	  const groupId = `group-${groupIdCounter++}`;
   129	  const color = getNextAvailableColor();
   130	
   131	  const group: TableGroup = {
   132	    id: groupId,
   133	    locationId: '', // TODO: Get from tables
   134	    tableIds: [...tableIds],
   135	    primaryTableId: tableIds[0],
   136	    isVirtual: true,
   137	    color,
   138	    identifier: '',
   139	    combinedCapacity: 0, // TODO: Calculate from seats
   140	    isActive: true,
   141	    createdAt: new Date(),
   142	    createdBy: '', // TODO: Get from context
   143	  };
   144	
   145	  groups.set(groupId, group);
   146	
   147	  // Update table-to-group mapping
   148	  for (const tableId of tableIds) {
   149	    tableToGroupMap.set(tableId, groupId);
   150	  }
   151	
   152	  // TODO: Call TableAPI.setTableColor(tableId, color) for each table
   153	  // TODO: Call TableAPI.updateTable to set groupId
   154	  // NOTE: Tables do NOT move for virtual groups
   155	
   156	  return group;
   157	}
   158	
   159	/**
   160	 * Dissolve a group and restore tables to ungrouped state
   161	 */
   162	function dissolveGroup(groupId: string): void {
   163	  const group = groups.get(groupId);
   164	  if (!group) {
   165	    throw new Error(`Group ${groupId} not found`);
   166	  }
   167	
   168	  // Release color back to pool
   169	  releaseColor(group.color);
   170	
   171	  // Remove table mappings
   172	  for (const tableId of group.tableIds) {
   173	    tableToGroupMap.delete(tableId);
   174	  }
   175	
   176	  // TODO: For physical merges, restore original table positions
   177	  // TODO: Call TableAPI.setTableColor(tableId, null) to clear color
   178	  // TODO: Call TableAPI.updateTable to clear groupId
   179	  // TODO: Call SeatAPI to restore original seat numbering
   180	
   181	  // Mark group as inactive
   182	  group.isActive = false;
   183	  groups.delete(groupId);
   184	}
   185	
   186	/**
   187	 * Get a specific group by ID
   188	 */
   189	function getGroup(groupId: string): TableGroup | null {
   190	  return groups.get(groupId) || null;
   191	}
   192	
   193	/**
   194	 * Get the group that a table belongs to
   195	 */
   196	function getGroupForTable(tableId: string): TableGroup | null {
   197	  const groupId = tableToGroupMap.get(tableId);
   198	  if (!groupId) return null;
   199	  return groups.get(groupId) || null;
   200	}
   201	
   202	/**
   203	 * Get all active groups
   204	 */
   205	function getAllActiveGroups(): TableGroup[] {
   206	  return Array.from(groups.values()).filter((g) => g.isActive);
   207	}
   208	
   209	/**
   210	 * Get all groups in a specific room
   211	 */
   212	function getGroupsInRoom(_roomId: string): TableGroup[] {
   213	  // TODO: Filter by room using TableAPI to check table locations
   214	  return getAllActiveGroups();
   215	}
   216	
   217	/**
   218	 * Add a table to an existing group
   219	 */
   220	function addTableToGroup(groupId: string, tableId: string): void {
   221	  const group = groups.get(groupId);
   222	  if (!group) {
   223	    throw new Error(`Group ${groupId} not found`);
   224	  }
   225	
   226	  if (tableToGroupMap.has(tableId)) {
   227	    throw new Error(`Table ${tableId} is already in a group`);
   228	  }
   229	
   230	  group.tableIds.push(tableId);
   231	  tableToGroupMap.set(tableId, groupId);
   232	
   233	  // TODO: Update table position if physical merge
   234	  // TODO: Call TableAPI.setTableColor(tableId, group.color)
   235	  // TODO: Call SeatAPI.renumberSeatsForMerge if needed
   236	}
   237	
   238	/**
   239	 * Remove a table from a group
   240	 */
   241	function removeTableFromGroup(groupId: string, tableId: string): void {
   242	  const group = groups.get(groupId);
   243	  if (!group) {
   244	    throw new Error(`Group ${groupId} not found`);
   245	  }
   246	
   247	  const index = group.tableIds.indexOf(tableId);
   248	  if (index === -1) {
   249	    throw new Error(`Table ${tableId} not in group ${groupId}`);
   250	  }
   251	
   252	  group.tableIds.splice(index, 1);
   253	  tableToGroupMap.delete(tableId);
   254	
   255	  // TODO: Restore table to original position if physical merge
   256	  // TODO: Call TableAPI.setTableColor(tableId, null)
   257	
   258	  // If only one table left, dissolve the group
   259	  if (group.tableIds.length < 2) {
   260	    dissolveGroup(groupId);
   261	  }
   262	}
   263	
   264	/**
   265	 * Set the color for a group
   266	 */
   267	function setGroupColor(groupId: string, color: string): void {
   268	  const group = groups.get(groupId);
   269	  if (!group) {
   270	    throw new Error(`Group ${groupId} not found`);
   271	  }
   272	
   273	  // Release old color
   274	  releaseColor(group.color);
   275	
   276	  // Set new color
   277	  group.color = color;
   278	  markColorInUse(color);
   279	
   280	  // TODO: Update all table colors via TableAPI
   281	}
   282	
   283	/**
   284	 * Set the identifier for a group
   285	 */
   286	function setGroupIdentifier(groupId: string, identifier: string): void {
   287	  const group = groups.get(groupId);
   288	  if (!group) {
   289	    throw new Error(`Group ${groupId} not found`);
   290	  }
   291	
   292	  group.identifier = identifier;
   293	}
   294	
   295	/**
   296	 * Get all seats for a group (across all tables)
   297	 */
   298	function getGroupSeats(groupId: string): Seat[] {
   299	  const group = groups.get(groupId);
   300	  if (!group) {
   301	    return [];
   302	  }
   303	
   304	  // TODO: Call SeatAPI.getSeatsForTable for each table and combine
   305	  return [];
   306	}
   307	
   308	/**
   309	 * Get total seat count for a group
   310	 */
   311	function getGroupSeatCount(groupId: string): number {
   312	  const group = groups.get(groupId);
   313	  if (!group) {
   314	    return 0;
   315	  }
   316	
   317	  // TODO: Sum seat counts from all tables
   318	  return group.combinedCapacity;
   319	}
   320	
   321	/**
   322	 * Get all unique room IDs that tables in this group belong to
   323	 */
   324	function getGroupRooms(groupId: string): string[] {
   325	  const group = groups.get(groupId);
   326	  if (!group) {
   327	    return [];
   328	  }
   329	
   330	  // TODO: Get room IDs from tables via TableAPI
   331	  // For now, return empty array
   332	  return [];
   333	}
   334	
   335	/**
   336	 * Check if a group spans multiple rooms
   337	 */
   338	function isCrossRoomGroup(groupId: string): boolean {
   339	  const rooms = getGroupRooms(groupId);
   340	  return rooms.length > 1;
   341	}
   342	
   343	/**
   344	 * Initialize groups from database
   345	 */
   346	function initializeGroups(loadedGroups: TableGroup[]): void {
   347	  clearAll();
   348	
   349	  for (const group of loadedGroups) {
   350	    groups.set(group.id, group);
   351	
   352	    // Mark color as in use
   353	    markColorInUse(group.color);
   354	
   355	    // Update table-to-group mapping
   356	    for (const tableId of group.tableIds) {
   357	      tableToGroupMap.set(tableId, group.id);
   358	    }
   359	  }
   360	}
   361	
   362	/**
   363	 * Clear all groups and reset state
   364	 */
   365	function clearAll(): void {
   366	  groups.clear();
   367	  tableToGroupMap.clear();
   368	  clearColorAssignments();
   369	  groupIdCounter = 1;
   370	}
   371	
   372	/**
   373	 * Export API instance
   374	 */
   375	export const tableGroupAPI: TableGroupAPI = {
   376	  createPhysicalMerge,
   377	  createVirtualGroup,
   378	  dissolveGroup,
   379	  getGroup,
   380	  getGroupForTable,
   381	  getAllActiveGroups,
   382	  getGroupsInRoom,
   383	  addTableToGroup,
   384	  removeTableFromGroup,
   385	  setGroupColor,
   386	  setGroupIdentifier,
   387	  getGroupSeats,
   388	  getGroupSeatCount,
   389	  getGroupRooms,
   390	  isCrossRoomGroup,
   391	  initializeGroups,
   392	  clearAll,
   393	};

================================================================================
FILE: /src/domains/floor-plan/groups/mergeLogic.ts
================================================================================
     1	/**
     2	 * GWI POS - Floor Plan Domain
     3	 * Layer 4: Table Groups - Merge Logic
     4	 *
     5	 * Handles snap/magnet calculations for physical table merging
     6	 */
     7	
     8	import { Point, Table } from '../shared/types';
     9	import { MergeDetection, MERGE_CONSTANTS } from './types';
    10	
    11	/**
    12	 * Detect if dragging table can merge with target table
    13	 */
    14	export function detectMergeOpportunity(
    15	  draggingTable: Table,
    16	  targetTable: Table,
    17	  dragPosition: Point
    18	): MergeDetection {
    19	  // Can't merge with self
    20	  if (draggingTable.id === targetTable.id) {
    21	    return {
    22	      canMerge: false,
    23	      snapPosition: null,
    24	      snapEdge: null,
    25	      snapDistance: Infinity,
    26	    };
    27	  }
    28	
    29	  // Can't merge if tables are in different rooms
    30	  if (draggingTable.floorPlanId !== targetTable.floorPlanId) {
    31	    return {
    32	      canMerge: false,
    33	      snapPosition: null,
    34	      snapEdge: null,
    35	      snapDistance: Infinity,
    36	    };
    37	  }
    38	
    39	  // Check each edge for snap opportunity
    40	  const edges: Array<'top' | 'bottom' | 'left' | 'right'> = [
    41	    'top',
    42	    'bottom',
    43	    'left',
    44	    'right',
    45	  ];
    46	
    47	  let closestEdge: typeof edges[number] | null = null;
    48	  let closestDistance = Infinity;
    49	  let closestSnapPosition: Point | null = null;
    50	
    51	  for (const edge of edges) {
    52	    const snapPos = calculateSnapPosition(draggingTable, targetTable, edge, dragPosition);
    53	    if (!snapPos) continue;
    54	
    55	    const distance = getDistance(dragPosition, snapPos);
    56	
    57	    if (distance < closestDistance && distance <= MERGE_CONSTANTS.SNAP_DISTANCE_FEET) {
    58	      closestDistance = distance;
    59	      closestEdge = edge;
    60	      closestSnapPosition = snapPos;
    61	    }
    62	  }
    63	
    64	  return {
    65	    canMerge: closestEdge !== null,
    66	    snapPosition: closestSnapPosition,
    67	    snapEdge: closestEdge,
    68	    snapDistance: closestDistance,
    69	  };
    70	}
    71	
    72	/**
    73	 * Calculate snap position for a specific edge alignment
    74	 */
    75	export function calculateSnapPosition(
    76	  draggingTable: Table,
    77	  targetTable: Table,
    78	  edge: 'top' | 'bottom' | 'left' | 'right',
    79	  currentPosition?: Point
    80	): Point | null {
    81	  const target = {
    82	    x: targetTable.positionX,
    83	    y: targetTable.positionY,
    84	    width: targetTable.width,
    85	    height: targetTable.height,
    86	  };
    87	
    88	  const dragging = {
    89	    width: draggingTable.width,
    90	    height: draggingTable.height,
    91	  };
    92	
    93	  let snapX: number;
    94	  let snapY: number;
    95	
    96	  switch (edge) {
    97	    case 'top':
    98	      // Dragging table snaps to top edge of target (above it)
    99	      snapX = target.x;
   100	      snapY = target.y - dragging.height;
   101	      break;
   102	
   103	    case 'bottom':
   104	      // Dragging table snaps to bottom edge of target (below it)
   105	      snapX = target.x;
   106	      snapY = target.y + target.height;
   107	      break;
   108	
   109	    case 'left':
   110	      // Dragging table snaps to left edge of target (left of it)
   111	      snapX = target.x - dragging.width;
   112	      snapY = target.y;
   113	      break;
   114	
   115	    case 'right':
   116	      // Dragging table snaps to right edge of target (right of it)
   117	      snapX = target.x + target.width;
   118	      snapY = target.y;
   119	      break;
   120	  }
   121	
   122	  // Check alignment tolerance (tables should be roughly aligned)
   123	  if (currentPosition) {
   124	    const alignmentOk = checkAlignment(
   125	      { x: snapX, y: snapY },
   126	      currentPosition,
   127	      edge
   128	    );
   129	    if (!alignmentOk) {
   130	      return null;
   131	    }
   132	  }
   133	
   134	  return { x: snapX, y: snapY };
   135	}
   136	
   137	/**
   138	 * Check if tables are aligned enough to snap
   139	 */
   140	function checkAlignment(
   141	  snapPos: Point,
   142	  currentPos: Point,
   143	  edge: 'top' | 'bottom' | 'left' | 'right'
   144	): boolean {
   145	  const tolerance = MERGE_CONSTANTS.SNAP_ALIGN_TOLERANCE;
   146	
   147	  if (edge === 'top' || edge === 'bottom') {
   148	    // For vertical edges, check horizontal alignment
   149	    return Math.abs(snapPos.x - currentPos.x) <= tolerance;
   150	  } else {
   151	    // For horizontal edges, check vertical alignment
   152	    return Math.abs(snapPos.y - currentPos.y) <= tolerance;
   153	  }
   154	}
   155	
   156	/**
   157	 * Calculate distance between two points
   158	 */
   159	function getDistance(p1: Point, p2: Point): number {
   160	  const dx = p2.x - p1.x;
   161	  const dy = p2.y - p1.y;
   162	  return Math.sqrt(dx * dx + dy * dy);
   163	}
   164	
   165	/**
   166	 * Check if two tables are adjacent (touching edges)
   167	 */
   168	export function areTablesAdjacent(table1: Table, table2: Table): boolean {
   169	  const t1 = {
   170	    left: table1.positionX,
   171	    right: table1.positionX + table1.width,
   172	    top: table1.positionY,
   173	    bottom: table1.positionY + table1.height,
   174	  };
   175	
   176	  const t2 = {
   177	    left: table2.positionX,
   178	    right: table2.positionX + table2.width,
   179	    top: table2.positionY,
   180	    bottom: table2.positionY + table2.height,
   181	  };
   182	
   183	  const tolerance = 0.1; // Small tolerance for floating point
   184	
   185	  // Check if touching on any edge
   186	  const touchingTop = Math.abs(t1.bottom - t2.top) < tolerance;
   187	  const touchingBottom = Math.abs(t1.top - t2.bottom) < tolerance;
   188	  const touchingLeft = Math.abs(t1.right - t2.left) < tolerance;
   189	  const touchingRight = Math.abs(t1.left - t2.right) < tolerance;
   190	
   191	  // Check if there's overlap on the perpendicular axis
   192	  const horizontalOverlap =
   193	    (t1.left <= t2.right && t1.right >= t2.left) ||
   194	    (t2.left <= t1.right && t2.right >= t1.left);
   195	  const verticalOverlap =
   196	    (t1.top <= t2.bottom && t1.bottom >= t2.top) ||
   197	    (t2.top <= t1.bottom && t2.bottom >= t1.top);
   198	
   199	  return (
   200	    ((touchingTop || touchingBottom) && horizontalOverlap) ||
   201	    ((touchingLeft || touchingRight) && verticalOverlap)
   202	  );
   203	}

================================================================================
FOH VIEW
================================================================================

================================================================================
FILE: /src/app/test-floorplan/page.tsx
================================================================================
     1	'use client';
     2	
     3	/**
     4	 * GWI POS - Floor Plan Test Page (Frontend / FOH View)
     5	 *
     6	 * Visual test page for the Floor Plan domain components.
     7	 * Access at: http://localhost:3000/test-floorplan
     8	 *
     9	 * This page receives real-time updates from the Editor via socket events.
    10	 * Changes made in /test-floorplan/editor will appear here automatically.
    11	 */
    12	
    13	import React, { useEffect, useState, useCallback } from 'react';
    14	import { FloorCanvas, RoomSelector, FloorCanvasAPI } from '@/domains/floor-plan/canvas';
    15	import { Table as TableComponent, SmartObject, TableAPI } from '@/domains/floor-plan/tables';
    16	import { Seat, SeatAPI } from '@/domains/floor-plan/seats';
    17	import type { Point, Table, Seat as SeatType, Fixture } from '@/domains/floor-plan/shared/types';
    18	import { sampleFloorPlans, sampleFixtures, sampleTables } from './sampleData';
    19	import { PIXELS_PER_FOOT, CANVAS_WIDTH, CANVAS_HEIGHT, GRID_SIZE } from '@/lib/floorplan/constants';
    20	
    21	// =============================================================================
    22	// DATABASE FIXTURE CONVERSION
    23	// =============================================================================
    24	// IMPORTANT: Database stores positions in PIXELS for direct rendering
    25	// These fixtures are rendered DIRECTLY using pixel values (no feet conversion)
    26	
    27	interface DbFloorPlanElement {
    28	  id: string;
    29	  name: string;
    30	  elementType: string;
    31	  visualType: string;
    32	  geometry: unknown;
    33	  posX: number;
    34	  posY: number;
    35	  width: number;
    36	  height: number;
    37	  rotation: number;
    38	  thickness: number;
    39	  fillColor: string | null;
    40	  opacity: number;
    41	  isLocked: boolean;
    42	  sectionId: string | null;
    43	}
    44	
    45	interface DbSeat {
    46	  id: string;
    47	  label: string;
    48	  seatNumber: number;
    49	  relativeX: number;
    50	  relativeY: number;
    51	  angle: number;
    52	  seatType: string;
    53	}
    54	
    55	interface DbTable {
    56	  id: string;
    57	  name: string;
    58	  abbreviation: string | null;
    59	  capacity: number;
    60	  posX: number;
    61	  posY: number;
    62	  width: number;
    63	  height: number;
    64	  rotation: number;
    65	  shape: string;
    66	  status: string;
    67	  section: { id: string; name: string; color: string | null } | null;
    68	  seats: DbSeat[];
    69	}
    70	
    71	// Convert database element to a "pixel fixture" for DIRECT rendering (no feet conversion)
    72	// The returned fixture has geometry in PIXELS, not feet
    73	interface PixelFixture {
    74	  id: string;
    75	  floorPlanId: string;
    76	  roomId: string;
    77	  type: string;
    78	  category: string;
    79	  label: string;
    80	  geometry: {
    81	    type: 'rectangle';
    82	    position: { x: number; y: number };
    83	    width: number;
    84	    height: number;
    85	    rotation: number;
    86	  } | {
    87	    type: 'circle';
    88	    center: { x: number; y: number };
    89	    radius: number;
    90	  } | {
    91	    type: 'line';
    92	    start: { x: number; y: number };
    93	    end: { x: number; y: number };
    94	  };
    95	  color: string;
    96	  opacity: number;
    97	  thickness: number;
    98	  isActive: boolean;
    99	}
   100	
   101	function dbElementToPixelFixture(el: DbFloorPlanElement, roomId: string): PixelFixture {
   102	  const geometry = el.geometry as { type: string; [key: string]: unknown } | null;
   103	
   104	  let fixtureGeometry: PixelFixture['geometry'];
   105	  if (geometry?.type === 'line') {
   106	    fixtureGeometry = {
   107	      type: 'line',
   108	      start: (geometry.start as { x: number; y: number }) || { x: el.posX, y: el.posY },
   109	      end: (geometry.end as { x: number; y: number }) || { x: el.posX + el.width, y: el.posY },
   110	    };
   111	  } else if (geometry?.type === 'circle') {
   112	    // For circles, reconstruct from posX/posY/width/height (bounding box)
   113	    const centerX = el.posX + el.width / 2;
   114	    const centerY = el.posY + el.height / 2;
   115	    const radius = el.width / 2;
   116	    fixtureGeometry = {
   117	      type: 'circle',
   118	      center: { x: centerX, y: centerY },
   119	      radius: radius,
   120	    };
   121	  } else {
   122	    fixtureGeometry = {
   123	      type: 'rectangle',
   124	      position: { x: el.posX, y: el.posY },
   125	      width: el.width,
   126	      height: el.height,
   127	      rotation: el.rotation,
   128	    };
   129	  }
   130	
   131	  return {
   132	    id: el.id,
   133	    floorPlanId: roomId,
   134	    roomId: roomId,
   135	    type: el.visualType || 'custom_fixture',
   136	    category: 'barrier',
   137	    label: el.name,
   138	    geometry: fixtureGeometry,
   139	    color: el.fillColor || '#666666',
   140	    opacity: el.opacity,
   141	    thickness: el.thickness,
   142	    isActive: true,
   143	  };
   144	}
   145	
   146	// =============================================================================
   147	// DATABASE FIXTURE RENDERER (PIXELS - NO CONVERSION)
   148	// =============================================================================
   149	// Renders fixtures using PIXEL coordinates directly from the database
   150	// NO feetToPixels conversion because DB already stores pixels
   151	
   152	interface DbFixtureRendererProps {
   153	  fixture: PixelFixture;
   154	  onClick?: () => void;
   155	}
   156	
   157	function DbFixtureRenderer({ fixture, onClick }: DbFixtureRendererProps) {
   158	  const baseStyle: React.CSSProperties = {
   159	    position: 'absolute',
   160	    backgroundColor: fixture.color,
   161	    opacity: fixture.opacity,
   162	    cursor: onClick ? 'pointer' : 'default',
   163	    border: '1px solid rgba(0,0,0,0.2)',
   164	  };
   165	
   166	  // Render based on geometry type - using PIXEL values directly
   167	  if (fixture.geometry.type === 'rectangle') {
   168	    const { position, width, height, rotation } = fixture.geometry;
   169	    return (
   170	      <div
   171	        onClick={onClick}
   172	        style={{
   173	          ...baseStyle,
   174	          left: position.x,  // Already in pixels
   175	          top: position.y,   // Already in pixels
   176	          width: width,      // Already in pixels
   177	          height: height,    // Already in pixels
   178	          transform: `rotate(${rotation}deg)`,
   179	          transformOrigin: 'center center',
   180	        }}
   181	        title={fixture.label}
   182	      />
   183	    );
   184	  }
   185	
   186	  if (fixture.geometry.type === 'circle') {
   187	    const { center, radius } = fixture.geometry;
   188	    const diameter = radius * 2;
   189	    return (
   190	      <div
   191	        onClick={onClick}
   192	        style={{
   193	          ...baseStyle,
   194	          left: center.x - radius,  // Already in pixels
   195	          top: center.y - radius,   // Already in pixels
   196	          width: diameter,          // Already in pixels
   197	          height: diameter,         // Already in pixels
   198	          borderRadius: '50%',
   199	        }}
   200	        title={fixture.label}
   201	      />
   202	    );
   203	  }
   204	
   205	  if (fixture.geometry.type === 'line') {
   206	    const { start, end } = fixture.geometry;
   207	    const thickness = fixture.thickness || 10; // Default thickness in pixels
   208	    const dx = end.x - start.x;
   209	    const dy = end.y - start.y;
   210	    const length = Math.sqrt(dx * dx + dy * dy);
   211	    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
   212	
   213	    return (
   214	      <div
   215	        onClick={onClick}
   216	        style={{
   217	          ...baseStyle,
   218	          left: start.x,              // Already in pixels
   219	          top: start.y - thickness / 2, // Already in pixels
   220	          width: length,              // Already in pixels
   221	          height: thickness,          // Already in pixels
   222	          transform: `rotate(${angle}deg)`,
   223	          transformOrigin: 'left center',
   224	        }}
   225	        title={fixture.label}
   226	      />
   227	    );
   228	  }
   229	
   230	  return null;
   231	}
   232	
   233	// =============================================================================
   234	// DATABASE TABLE RENDERER
   235	// =============================================================================
   236	
   237	interface DbTableRendererProps {
   238	  table: DbTable;
   239	  showSeats?: boolean;
   240	  onClick?: () => void;
   241	}
   242	
   243	function DbTableRenderer({ table, showSeats, onClick }: DbTableRendererProps) {
   244	  const isRound = table.shape === 'round' || table.shape === 'circle';
   245	
   246	  const tableCenterX = table.posX + table.width / 2;
   247	  const tableCenterY = table.posY + table.height / 2;
   248	
   249	  // Render seats with rotation
   250	  const renderSeats = () => {
   251	    if (!showSeats || !table.seats || table.seats.length === 0) return null;
   252	
   253	    return table.seats.map((seat) => {
   254	      // Apply table rotation to seat position
   255	      const angleRad = (table.rotation * Math.PI) / 180;
   256	      const cos = Math.cos(angleRad);
   257	      const sin = Math.sin(angleRad);
   258	
   259	      const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
   260	      const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
   261	
   262	      const seatAbsX = tableCenterX + rotatedX;
   263	      const seatAbsY = tableCenterY + rotatedY;
   264	
   265	      // Smaller seats (24px) to prevent overlap and allow tapping
   266	      const SEAT_SIZE = 24;
   267	      const SEAT_HALF = SEAT_SIZE / 2;
   268	
   269	      return (
   270	        <div
   271	          key={seat.id}
   272	          onClick={(e) => {
   273	            e.stopPropagation();
   274	            // When we integrate with orders, this will select the seat
   275	            console.log(`Seat ${seat.seatNumber} tapped on table ${table.name}`);
   276	          }}
   277	          style={{
   278	            position: 'absolute',
   279	            left: seatAbsX - SEAT_HALF,
   280	            top: seatAbsY - SEAT_HALF,
   281	            width: SEAT_SIZE,
   282	            height: SEAT_SIZE,
   283	            backgroundColor: '#fff',
   284	            border: '2px solid #555',
   285	            borderRadius: '50%',
   286	            display: 'flex',
   287	            alignItems: 'center',
   288	            justifyContent: 'center',
   289	            fontSize: 10,
   290	            fontWeight: 600,
   291	            cursor: 'pointer',
   292	            pointerEvents: 'auto',
   293	            boxShadow: '0 1px 3px rgba(0,0,0,0.2)',
   294	            transition: 'transform 0.1s, box-shadow 0.1s',
   295	          }}
   296	          onMouseEnter={(e) => {
   297	            e.currentTarget.style.transform = 'scale(1.15)';
   298	            e.currentTarget.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
   299	            e.currentTarget.style.zIndex = '100';
   300	          }}
   301	          onMouseLeave={(e) => {
   302	            e.currentTarget.style.transform = 'scale(1)';
   303	            e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
   304	            e.currentTarget.style.zIndex = 'auto';
   305	          }}
   306	          title={`Seat ${seat.seatNumber}`}
   307	        >
   308	          {seat.seatNumber}
   309	        </div>
   310	      );
   311	    });
   312	  };
   313	
   314	  return (
   315	    <>
   316	      <div
   317	        onClick={onClick}
   318	        style={{
   319	          position: 'absolute',
   320	          left: table.posX,
   321	          top: table.posY,
   322	          width: table.width,
   323	          height: table.height,
   324	          backgroundColor: table.status === 'occupied' ? '#ffcdd2' : '#e8f5e9',
   325	          border: '2px solid #666',
   326	          borderRadius: isRound ? '50%' : 8,
   327	          cursor: 'pointer',
   328	          display: 'flex',
   329	          alignItems: 'center',
   330	          justifyContent: 'center',
   331	          fontSize: 12,
   332	          fontWeight: 600,
   333	          transform: `rotate(${table.rotation}deg)`,
   334	          transformOrigin: 'center center',
   335	        }}
   336	        title={`${table.name} (${table.capacity} seats)`}
   337	      >
   338	        {table.abbreviation || table.name}
   339	      </div>
   340	      {renderSeats()}
   341	    </>
   342	  );
   343	}
   344	
   345	// =============================================================================
   346	// TABLE RENDERER - Using Layer 2 Components
   347	// =============================================================================
   348	
   349	// =============================================================================
   350	// TEST PAGE COMPONENT
   351	// =============================================================================
   352	
   353	// Database section type
   354	interface DbSection {
   355	  id: string;
   356	  name: string;
   357	  widthFeet: number;
   358	  heightFeet: number;
   359	}
   360	
   361	export default function TestFloorPlanPage() {
   362	  const [selectedRoomId, setSelectedRoomId] = useState<string>('room-main');
   363	  const [clickedPosition, setClickedPosition] = useState<Point | null>(null);
   364	  const [selectedTable, setSelectedTable] = useState<Table | null>(null);
   365	  const [selectedSeat, setSelectedSeat] = useState<SeatType | null>(null);
   366	
   367	  // Database fixtures from FloorPlanElement table
   368	  const [dbFixtures, setDbFixtures] = useState<PixelFixture[]>([]);
   369	  const [dbSections, setDbSections] = useState<DbSection[]>([]);
   370	  const [dbTables, setDbTables] = useState<DbTable[]>([]);
   371	  const [locationId, setLocationId] = useState<string | null>(null);
   372	  const [isDbMode, setIsDbMode] = useState(false);
   373	  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
   374	  const [showDbSeats, setShowDbSeats] = useState(true);
   375	
   376	  // Fetch database fixtures
   377	  const fetchDbFixtures = useCallback(async (locId: string) => {
   378	    try {
   379	      const res = await fetch(`/api/floor-plan-elements?locationId=${locId}`);
   380	      if (res.ok) {
   381	        const data = await res.json();
   382	        const fixtures = (data.elements || []).map((el: DbFloorPlanElement) =>
   383	          dbElementToPixelFixture(el, el.sectionId || 'db-room')
   384	        );
   385	        setDbFixtures(fixtures);
   386	        setIsDbMode(fixtures.length > 0);
   387	        setLastUpdate(new Date());
   388	        console.log(`[FOH] Loaded ${fixtures.length} fixtures from database`);
   389	      }
   390	    } catch (error) {
   391	      console.error('[FOH] Failed to fetch database fixtures:', error);
   392	    }
   393	  }, []);
   394	
   395	  // Fetch database sections
   396	  const fetchDbSections = useCallback(async (locId: string) => {
   397	    try {
   398	      const res = await fetch(`/api/sections?locationId=${locId}`);
   399	      if (res.ok) {
   400	        const data = await res.json();
   401	        const sections = data.sections || [];
   402	        setDbSections(sections);
   403	        console.log(`[FOH] Loaded ${sections.length} sections from database`);
   404	        // Auto-select first section if available
   405	        if (sections.length > 0) {
   406	          setSelectedRoomId(sections[0].id);
   407	        }
   408	        return sections;
   409	      }
   410	    } catch (error) {
   411	      console.error('[FOH] Failed to fetch sections:', error);
   412	    }
   413	    return [];
   414	  }, []);
   415	
   416	  // Fetch database tables
   417	  const fetchDbTables = useCallback(async (locId: string, sectionId?: string) => {
   418	    try {
   419	      let url = `/api/tables?locationId=${locId}&includeSeats=true`;
   420	      if (sectionId) {
   421	        url += `&sectionId=${sectionId}`;
   422	      }
   423	      const res = await fetch(url);
   424	      if (res.ok) {
   425	        const data = await res.json();
   426	        setDbTables(data.tables || []);
   427	        console.log(`[FOH] Loaded ${(data.tables || []).length} tables from database`);
   428	      }
   429	    } catch (error) {
   430	      console.error('[FOH] Failed to fetch database tables:', error);
   431	    }
   432	  }, []);
   433	
   434	  // Get location ID and initialize
   435	  useEffect(() => {
   436	    async function init() {
   437	      // Get location ID
   438	      try {
   439	        const res = await fetch('/api/locations');
   440	        if (res.ok) {
   441	          const data = await res.json();
   442	          if (data.locations && data.locations.length > 0) {
   443	            const locId = data.locations[0].id;
   444	            setLocationId(locId);
   445	            // Fetch database sections and fixtures
   446	            const sections = await fetchDbSections(locId);
   447	            await fetchDbFixtures(locId);
   448	            await fetchDbTables(locId);
   449	            // If we have sections, we're in DB mode
   450	            if (sections.length > 0) {
   451	              setIsDbMode(true);
   452	            }
   453	          }
   454	        }
   455	      } catch {
   456	        console.log('[FOH] No locations API available');
   457	      }
   458	
   459	      // Initialize in-memory data as fallback
   460	      if (FloorCanvasAPI.getAllRooms().length === 0) {
   461	        FloorCanvasAPI.initializeFloorPlans(sampleFloorPlans, sampleFixtures);
   462	      }
   463	
   464	      // Only initialize tables if not already done
   465	      if (TableAPI.getAllTables().length === 0) {
   466	        TableAPI.initializeTables(sampleTables);
   467	
   468	        // Generate seats for seatable tables
   469	        sampleTables.forEach((table) => {
   470	          if (table.category === 'seatable') {
   471	            SeatAPI.generateSeatsForTable(
   472	              table.id,
   473	              table.defaultCapacity,
   474	              table.shape
   475	            );
   476	          }
   477	        });
   478	      }
   479	
   480	      // Only set to room-main if not already set to a DB section
   481	      if (!isDbMode) {
   482	        setSelectedRoomId('room-main');
   483	      }
   484	    }
   485	    init();
   486	  }, [fetchDbFixtures, fetchDbSections, fetchDbTables, isDbMode]);
   487	
   488	  // Listen for floor-plan:updated socket events
   489	  useEffect(() => {
   490	    if (!locationId) return;
   491	
   492	    // Set up EventSource for Server-Sent Events (simple polling fallback)
   493	    // For a full implementation, use socket.io-client
   494	    let intervalId: NodeJS.Timeout | null = null;
   495	
   496	    // Poll for updates every 5 seconds (simple approach without socket.io)
   497	    // Don't pass sectionId - fetch ALL tables and filter client-side
   498	    // This prevents the "0 tables" bug when polling with wrong section filter
   499	    intervalId = setInterval(() => {
   500	      fetchDbFixtures(locationId);
   501	      fetchDbTables(locationId); // No sectionId filter - client filters by section
   502	    }, 5000);
   503	
   504	    console.log('[FOH] Started polling for floor plan updates');
   505	
   506	    return () => {
   507	      if (intervalId) {
   508	        clearInterval(intervalId);
   509	        console.log('[FOH] Stopped polling');
   510	      }
   511	    };
   512	  }, [locationId, fetchDbFixtures, fetchDbTables]);
   513	
   514	  // Get tables for current room using TableAPI
   515	  const tablesInRoom = TableAPI.getTablesForRoom(selectedRoomId);
   516	
   517	  // Get all seats for tables in the current room
   518	  const seatsInRoom: SeatType[] = [];
   519	  tablesInRoom.forEach((table) => {
   520	    const tableSeats = SeatAPI.getSeatsForTable(table.id);
   521	    seatsInRoom.push(...tableSeats);
   522	  });
   523	
   524	  const handlePositionClick = (position: Point) => {
   525	    setClickedPosition(position);
   526	    setSelectedTable(null);
   527	    setSelectedSeat(null);
   528	  };
   529	
   530	  const handleTableClick = (table: Table) => {
   531	    setSelectedTable(table);
   532	    setClickedPosition(null);
   533	    setSelectedSeat(null);
   534	  };
   535	
   536	  const handleSeatClick = (seatId: string) => {
   537	    const seat = SeatAPI.getSeat(seatId);
   538	    if (seat) {
   539	      setSelectedSeat(seat);
   540	      setSelectedTable(null);
   541	      setClickedPosition(null);
   542	    }
   543	  };
   544	
   545	  const handleFixtureClick = (fixture: PixelFixture | Fixture) => {
   546	    alert(`Fixture clicked: ${fixture.label} (${fixture.type})`);
   547	  };
   548	
   549	  // Combine in-memory fixtures with database fixtures for display
   550	  const allFixtures = isDbMode ? dbFixtures : FloorCanvasAPI.getFixtures(selectedRoomId);
   551	
   552	  return (
   553	    <div style={{ padding: 24, fontFamily: 'system-ui, sans-serif' }}>
   554	      <h1 style={{ marginBottom: 8 }}>Floor Plan Test Page (FOH View)</h1>
   555	      <p style={{ color: '#666', marginBottom: 24 }}>
   556	        {isDbMode ? (
   557	          <>Real-time sync enabled. Fixtures from database: <strong>{dbFixtures.length}</strong>
   558	            {lastUpdate && <span style={{ marginLeft: 8, fontSize: 12 }}>(Updated: {lastUpdate.toLocaleTimeString()})</span>}
   559	          </>
   560	        ) : (
   561	          'Using sample data. Create fixtures in Editor to enable database sync.'
   562	        )}
   563	      </p>
   564	
   565	      {/* Room/Section Selector */}
   566	      {isDbMode && dbSections.length > 0 ? (
   567	        <div style={{ display: 'flex', gap: 8, marginBottom: 16, alignItems: 'center' }}>
   568	          {dbSections.map((section) => (
   569	            <button
   570	              key={section.id}
   571	              onClick={() => setSelectedRoomId(section.id)}
   572	              style={{
   573	                padding: '8px 16px',
   574	                borderRadius: 8,
   575	                border: selectedRoomId === section.id ? '2px solid #3498db' : '1px solid #ccc',
   576	                backgroundColor: selectedRoomId === section.id ? '#e3f2fd' : 'white',
   577	                cursor: 'pointer',
   578	                fontWeight: selectedRoomId === section.id ? 600 : 400,
   579	                fontSize: 14,
   580	              }}
   581	            >
   582	              {section.name}
   583	            </button>
   584	          ))}
   585	
   586	          {/* Show/Hide Seats Toggle */}
   587	          <button
   588	            onClick={() => setShowDbSeats(!showDbSeats)}
   589	            style={{
   590	              padding: '8px 16px',
   591	              borderRadius: 8,
   592	              border: '1px solid #ccc',
   593	              backgroundColor: showDbSeats ? '#e3f2fd' : 'white',
   594	              cursor: 'pointer',
   595	              fontSize: 14,
   596	              fontWeight: showDbSeats ? 600 : 400,
   597	              marginLeft: 'auto',
   598	            }}
   599	          >
   600	            {showDbSeats ? 'Hide Seats' : 'Show Seats'}
   601	          </button>
   602	        </div>
   603	      ) : (
   604	        <RoomSelector
   605	          selectedRoomId={selectedRoomId}
   606	          onRoomSelect={setSelectedRoomId}
   607	        />
   608	      )}
   609	
   610	      {/* Main Canvas */}
   611	      <div style={{ display: 'flex', gap: 24 }}>
   612	        <div>
   613	          <FloorCanvas
   614	            roomId={selectedRoomId}
   615	            showGrid={!isDbMode} // Disable grid in DB mode (we render our own canvas)
   616	            showFixtures={!isDbMode}
   617	            // Use FIXED canvas dimensions to match Editor (stable coordinates)
   618	            width={CANVAS_WIDTH}
   619	            height={CANVAS_HEIGHT}
   620	            onPositionClick={handlePositionClick}
   621	            onFixtureClick={handleFixtureClick}
   622	          >
   623	            {/* Render database fixtures when in DB mode - filter by selected section */}
   624	            {isDbMode && dbFixtures
   625	              .filter((fixture) => {
   626	                // In DB mode, filter by sectionId (stored as roomId in PixelFixture)
   627	                return fixture.roomId === selectedRoomId;
   628	              })
   629	              .map((fixture) => (
   630	                <DbFixtureRenderer
   631	                  key={fixture.id}
   632	                  fixture={fixture}
   633	                  onClick={() => handleFixtureClick(fixture)}
   634	                />
   635	              ))}
   636	
   637	            {/* Render database tables when in DB mode - filter by selected section */}
   638	            {/* Tables without a section will show in first section as fallback */}
   639	            {isDbMode && dbTables
   640	              .filter((table) => {
   641	                // Show tables that match the selected section
   642	                if (table.section?.id === selectedRoomId) return true;
   643	                // Also show tables with no section in the first section
   644	                if (!table.section && dbSections.length > 0 && dbSections[0].id === selectedRoomId) return true;
   645	                return false;
   646	              })
   647	              .map((table) => (
   648	                <DbTableRenderer
   649	                  key={table.id}
   650	                  table={table}
   651	                  showSeats={showDbSeats}
   652	                  onClick={() => alert(`Table: ${table.name}`)}
   653	                />
   654	              ))}
   655	
   656	            {/* Render tables using Layer 2 components (SVG) */}
   657	            <svg
   658	              style={{
   659	                position: 'absolute',
   660	                top: 0,
   661	                left: 0,
   662	                width: '100%',
   663	                height: '100%',
   664	                pointerEvents: 'none',
   665	              }}
   666	            >
   667	              <g style={{ pointerEvents: 'auto' }}>
   668	                {tablesInRoom.map((table) =>
   669	                  table.category === 'seatable' ? (
   670	                    <TableComponent
   671	                      key={table.id}
   672	                      table={table}
   673	                      pixelsPerFoot={PIXELS_PER_FOOT}
   674	                      isSelected={selectedTable?.id === table.id}
   675	                      onSelect={(id) => {
   676	                        const t = TableAPI.getTable(id);
   677	                        if (t) setSelectedTable(t);
   678	                      }}
   679	                    />
   680	                  ) : (
   681	                    <SmartObject
   682	                      key={table.id}
   683	                      object={table}
   684	                      pixelsPerFoot={PIXELS_PER_FOOT}
   685	                      isSelected={selectedTable?.id === table.id}
   686	                      onSelect={(id) => {
   687	                        const t = TableAPI.getTable(id);
   688	                        if (t) setSelectedTable(t);
   689	                      }}
   690	                    />
   691	                  )
   692	                )}
   693	
   694	                {/* Render seats around tables */}
   695	                {seatsInRoom.map((seat) => {
   696	                  const table = TableAPI.getTable(seat.tableId);
   697	                  if (!table) return null;
   698	
   699	                  return (
   700	                    <Seat
   701	                      key={seat.id}
   702	                      seat={seat}
   703	                      tableX={table.positionX}
   704	                      tableY={table.positionY}
   705	                      pixelsPerFoot={PIXELS_PER_FOOT}
   706	                      isSelected={selectedSeat?.id === seat.id}
   707	                      onSelect={handleSeatClick}
   708	                    />
   709	                  );
   710	                })}
   711	              </g>
   712	            </svg>
   713	          </FloorCanvas>
   714	        </div>
   715	
   716	        {/* Info Panel */}
   717	        <div style={{ width: 300 }}>
   718	          <div
   719	            style={{
   720	              padding: 16,
   721	              backgroundColor: '#f5f5f5',
   722	              borderRadius: 8,
   723	              marginBottom: 16,
   724	            }}
   725	          >
   726	            <h3 style={{ margin: '0 0 12px 0' }}>Click Info</h3>
   727	            {clickedPosition ? (
   728	              <div>
   729	                <p><strong>Position:</strong> ({clickedPosition.x.toFixed(1)}ft, {clickedPosition.y.toFixed(1)}ft)</p>
   730	                <p><strong>Blocked:</strong> {FloorCanvasAPI.isPositionBlocked(selectedRoomId, clickedPosition, 3, 3) ? 'Yes' : 'No'}</p>
   731	              </div>
   732	            ) : selectedSeat ? (
   733	              <div>
   734	                <p><strong>Seat:</strong> #{selectedSeat.seatNumber}</p>
   735	                <p><strong>Table:</strong> {(() => {
   736	                  const table = TableAPI.getTable(selectedSeat.tableId);
   737	                  return table ? table.label : 'Unknown';
   738	                })()}</p>
   739	                <p><strong>Position Index:</strong> {selectedSeat.positionIndex}</p>
   740	                <p><strong>Offset:</strong> ({selectedSeat.offsetX.toFixed(2)}ft, {selectedSeat.offsetY.toFixed(2)}ft)</p>
   741	                <p><strong>Occupied:</strong> {selectedSeat.isOccupied ? 'Yes' : 'No'}</p>
   742	                <p><strong>Virtual:</strong> {selectedSeat.isVirtual ? 'Yes' : 'No'}</p>
   743	              </div>
   744	            ) : selectedTable ? (
   745	              <div>
   746	                <p><strong>Table:</strong> {selectedTable.label}</p>
   747	                <p><strong>Type:</strong> {selectedTable.objectType}</p>
   748	                <p><strong>Shape:</strong> {selectedTable.shape}</p>
   749	                <p><strong>Capacity:</strong> {selectedTable.minCapacity}-{selectedTable.maxCapacity}</p>
   750	                <p><strong>Position:</strong> ({selectedTable.positionX}ft, {selectedTable.positionY}ft)</p>
   751	                <p><strong>Seats:</strong> {SeatAPI.getSeatsForTable(selectedTable.id).length}</p>
   752	              </div>
   753	            ) : (
   754	              <p style={{ color: '#999' }}>Click on canvas, table, or seat</p>
   755	            )}
   756	          </div>
   757	
   758	          <div
   759	            style={{
   760	              padding: 16,
   761	              backgroundColor: '#f5f5f5',
   762	              borderRadius: 8,
   763	              marginBottom: 16,
   764	            }}
   765	          >
   766	            <h3 style={{ margin: '0 0 12px 0' }}>Room Info</h3>
   767	            {(() => {
   768	              const room = FloorCanvasAPI.getFloorPlan(selectedRoomId);
   769	              if (!room) return <p>No room selected</p>;
   770	              return (
   771	                <div>
   772	                  <p><strong>Name:</strong> {room.name}</p>
   773	                  <p><strong>Type:</strong> {room.type}</p>
   774	                  <p><strong>Size:</strong> {room.widthFeet}ft x {room.heightFeet}ft</p>
   775	                  <p><strong>Grid:</strong> {room.gridSizeFeet}ft</p>
   776	                  <p><strong>Tables:</strong> {tablesInRoom.length}</p>
   777	                  <p><strong>Fixtures:</strong> {isDbMode ? dbFixtures.length : FloorCanvasAPI.getFixtures(selectedRoomId).length}</p>
   778	                  {isDbMode && <p style={{ color: '#4caf50', fontSize: 12 }}>Database Mode Active</p>}
   779	                </div>
   780	              );
   781	            })()}
   782	          </div>
   783	
   784	          <div
   785	            style={{
   786	              padding: 16,
   787	              backgroundColor: isDbMode ? '#e8f5e9' : '#e3f2fd',
   788	              borderRadius: 8,
   789	            }}
   790	          >
   791	            <h3 style={{ margin: '0 0 12px 0' }}>Sync Status</h3>
   792	            {isDbMode ? (
   793	              <>
   794	                <p style={{ color: '#2e7d32' }}>Database Connected</p>
   795	                <p style={{ fontSize: 12 }}>Fixtures: {dbFixtures.length}</p>
   796	                <p style={{ fontSize: 12 }}>Polling: every 5s</p>
   797	                {lastUpdate && (
   798	                  <p style={{ fontSize: 11, color: '#666' }}>
   799	                    Last: {lastUpdate.toLocaleTimeString()}
   800	                  </p>
   801	                )}
   802	              </>
   803	            ) : (
   804	              <>
   805	                <p style={{ color: '#1976d2' }}>In-Memory Mode</p>
   806	                <p style={{ fontSize: 12 }}>Using sample data</p>
   807	                <p style={{ fontSize: 12 }}>Create fixtures in Editor to enable sync</p>
   808	              </>
   809	            )}
   810	          </div>
   811	
   812	          <div
   813	            style={{
   814	              padding: 16,
   815	              backgroundColor: '#fff3e0',
   816	              borderRadius: 8,
   817	              marginTop: 16,
   818	            }}
   819	          >
   820	            <h3 style={{ margin: '0 0 12px 0' }}>Test Pages</h3>
   821	            <p><a href="/test-floorplan" style={{ color: '#e65100' }}> Frontend Test (Current)</a></p>
   822	            <p><a href="/test-floorplan/api" style={{ color: '#e65100' }}>Backend API Test</a></p>
   823	            <p>
   824	              <a
   825	                href="/test-floorplan/editor"
   826	                style={{
   827	                  color: '#e65100',
   828	                  fontWeight: 'bold',
   829	                  textDecoration: 'none',
   830	                  display: 'inline-block',
   831	                  padding: '4px 8px',
   832	                  backgroundColor: '#ffebee',
   833	                  borderRadius: 4,
   834	                }}
   835	              >
   836	                 Edit Floor Plan 
   837	              </a>
   838	            </p>
   839	            <p style={{ fontSize: 12, color: '#666', marginTop: 8 }}>
   840	              {isDbMode
   841	                ? 'Changes made in Editor will appear here automatically (5s polling)'
   842	                : 'Create fixtures in Editor to enable real-time sync'}
   843	            </p>
   844	          </div>
   845	        </div>
   846	      </div>
   847	
   848	      {/* Tables List */}
   849	      <div style={{ marginTop: 24 }}>
   850	        <h3>Tables in {FloorCanvasAPI.getFloorPlan(selectedRoomId)?.name || 'Room'}</h3>
   851	        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
   852	          {tablesInRoom.map((table) => (
   853	            <div
   854	              key={table.id}
   855	              onClick={() => handleTableClick(table)}
   856	              style={{
   857	                padding: '8px 16px',
   858	                backgroundColor: selectedTable?.id === table.id ? '#3498db' : '#f5f5f5',
   859	                color: selectedTable?.id === table.id ? 'white' : 'black',
   860	                borderRadius: 8,
   861	                cursor: 'pointer',
   862	              }}
   863	            >
   864	              {table.label} ({table.objectType})
   865	            </div>
   866	          ))}
   867	          {tablesInRoom.length === 0 && (
   868	            <p style={{ color: '#999' }}>No tables in this room</p>
   869	          )}
   870	        </div>
   871	      </div>
   872	    </div>
   873	  );
   874	}

================================================================================
FILE: /src/components/floor-plan/FloorPlanHome.tsx
================================================================================
     1	'use client'
     2	
     3	import { useEffect, useState, useCallback, useRef, useMemo } from 'react'
     4	import { motion, AnimatePresence } from 'framer-motion'
     5	import { useFloorPlanStore, FloorPlanTable, FloorPlanElement } from './use-floor-plan'
     6	import { FloorPlanEntertainment } from './FloorPlanEntertainment'
     7	import { TableNode, getCombinedGroupColor } from './TableNode'
     8	import { TableInfoPanel } from './TableInfoPanel'
     9	import { CategoriesBar } from './CategoriesBar'
    10	import { VirtualCombineBar } from './VirtualCombineBar'
    11	import { ExistingOrdersModal } from './ExistingOrdersModal'
    12	import { VirtualGroupManagerModal } from './VirtualGroupManagerModal'
    13	import { RoomTabs } from './RoomTabs'
    14	import { RoomReorderModal } from './RoomReorderModal'
    15	import { useFloorPlanAutoScale, useFloorPlanDrag } from './hooks'
    16	import { calculateAttachSide, calculateAttachPosition } from './table-positioning'
    17	import { getCombinedGroupTables, calculatePerimeterCapacity } from '@/lib/table-geometry'
    18	import { toTableRect, toTableRectArray } from '@/lib/table-utils'
    19	import { usePOSLayout } from '@/hooks/usePOSLayout'
    20	import { QuickAccessBar } from '@/components/pos/QuickAccessBar'
    21	import { MenuItemContextMenu } from '@/components/pos/MenuItemContextMenu'
    22	import { StockBadge } from '@/components/menu/StockBadge'
    23	import type { PizzaOrderConfig } from '@/types'
    24	import { toast } from '@/stores/toast-store'
    25	import { useEvents } from '@/lib/events'
    26	import './styles/floor-plan.css'
    27	
    28	interface Category {
    29	  id: string
    30	  name: string
    31	  color?: string
    32	  itemCount?: number
    33	  categoryType?: string
    34	}
    35	
    36	interface MenuItem {
    37	  id: string
    38	  name: string
    39	  price: number
    40	  description?: string
    41	  categoryId: string
    42	  categoryType?: string // 'food' | 'pizza' | 'entertainment' | etc.
    43	  hasModifiers?: boolean
    44	  isPizza?: boolean
    45	  itemType?: string // 'standard' | 'combo' | 'timed_rental' | 'pizza'
    46	  entertainmentStatus?: 'available' | 'in_use' | 'maintenance'
    47	  blockTimeMinutes?: number
    48	  modifierGroupCount?: number
    49	  timedPricing?: {
    50	    per15Min?: number
    51	    per30Min?: number
    52	    perHour?: number
    53	    minimum?: number
    54	  }
    55	  // Prep stock status (from API)
    56	  stockStatus?: 'ok' | 'low' | 'critical' | 'out'
    57	  stockCount?: number | null
    58	  stockIngredientName?: string | null
    59	  // 86 status (ingredient out of stock)
    60	  is86d?: boolean
    61	  reasons86d?: string[]
    62	}
    63	
    64	interface InlineOrderItem {
    65	  id: string
    66	  menuItemId: string
    67	  name: string
    68	  price: number
    69	  quantity: number
    70	  modifiers?: { id: string; name: string; price: number }[]
    71	  specialNotes?: string
    72	  seatNumber?: number
    73	  sourceTableId?: string // For virtual groups - tracks which table this item was ordered from
    74	  courseNumber?: number
    75	  courseStatus?: 'pending' | 'fired' | 'ready' | 'served'
    76	  isHeld?: boolean
    77	  sentToKitchen?: boolean
    78	  isCompleted?: boolean
    79	  status?: 'active' | 'voided' | 'comped'
    80	  blockTimeMinutes?: number // For timed rental items
    81	}
    82	
    83	interface OpenOrder {
    84	  id: string
    85	  orderNumber: number
    86	  tableId?: string
    87	  tableName?: string
    88	  tabName?: string
    89	  orderType: string
    90	  total: number
    91	  itemCount: number
    92	  openedAt: string
    93	  employeeName?: string
    94	}
    95	
    96	// View mode: tables (floor plan) or menu (category items)
    97	type ViewMode = 'tables' | 'menu'
    98	
    99	// Order type for quick order buttons
   100	type QuickOrderType = 'takeout' | 'delivery' | 'bar_tab'
   101	
   102	interface FloorPlanHomeProps {
   103	  locationId: string
   104	  employeeId: string
   105	  employeeName: string
   106	  employeeRole?: string
   107	  onLogout: () => void
   108	  onSwitchUser?: () => void
   109	  onOpenSettings?: () => void
   110	  onOpenAdminNav?: () => void
   111	  isManager?: boolean
   112	  // Payment and modifier callbacks
   113	  onOpenPayment?: (orderId: string) => void
   114	  onOpenModifiers?: (item: MenuItem, onComplete: (modifiers: { id: string; name: string; price: number }[]) => void, existingModifiers?: { id: string; name: string; price: number }[]) => void
   115	  // Open Orders panel
   116	  onOpenOrdersPanel?: () => void
   117	  // Tabs page (for bartenders)
   118	  onOpenTabs?: () => void
   119	  // Switch to bartender view (speed-optimized for bar tabs)
   120	  onSwitchToBartenderView?: () => void
   121	  // Guest count for seat assignment (from table or default)
   122	  defaultGuestCount?: number
   123	  // Timed rental/entertainment modal callback
   124	  onOpenTimedRental?: (item: MenuItem, onComplete: (price: number, blockMinutes: number) => void) => void
   125	  // Pizza builder modal callback
   126	  onOpenPizzaBuilder?: (item: MenuItem, onComplete: (config: PizzaOrderConfig) => void) => void
   127	  // Order to load (from Open Orders panel) - set this to load an existing order
   128	  orderToLoad?: { id: string; orderNumber: number; tableId?: string; tabName?: string; orderType: string } | null
   129	  // Callback when order is loaded (to clear the orderToLoad prop)
   130	  onOrderLoaded?: () => void
   131	  // Order ID that was just paid - triggers clearing of order panel
   132	  paidOrderId?: string | null
   133	  // Callback when paid order is cleared (to reset paidOrderId prop)
   134	  onPaidOrderCleared?: () => void
   135	}
   136	
   137	// Pizza order configuration (matches what pizza builder produces)
   138	export function FloorPlanHome({
   139	  locationId,
   140	  employeeId,
   141	  employeeName,
   142	  employeeRole,
   143	  onLogout,
   144	  onSwitchUser,
   145	  onOpenSettings,
   146	  onOpenAdminNav,
   147	  isManager = false,
   148	  onOpenPayment,
   149	  onOpenModifiers,
   150	  onOpenOrdersPanel,
   151	  onOpenTabs,
   152	  onSwitchToBartenderView,
   153	  defaultGuestCount = 4,
   154	  onOpenTimedRental,
   155	  onOpenPizzaBuilder,
   156	  orderToLoad,
   157	  onOrderLoaded,
   158	  paidOrderId,
   159	  onPaidOrderCleared,
   160	}: FloorPlanHomeProps) {
   161	  const containerRef = useRef<HTMLDivElement>(null)
   162	
   163	  // View mode: tables (floor plan) or menu (category items)
   164	  const [viewMode, setViewMode] = useState<ViewMode>('tables')
   165	
   166	  // Categories and menu items
   167	  const [categories, setCategories] = useState<Category[]>([])
   168	  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(null)
   169	  const [menuItems, setMenuItems] = useState<MenuItem[]>([])
   170	  const [loadingMenuItems, setLoadingMenuItems] = useState(false)
   171	
   172	  // Open orders count
   173	  const [openOrdersCount, setOpenOrdersCount] = useState(0)
   174	
   175	  // Employee dropdown
   176	  const [showEmployeeDropdown, setShowEmployeeDropdown] = useState(false)
   177	
   178	  // Settings dropdown
   179	  const [showSettingsDropdown, setShowSettingsDropdown] = useState(false)
   180	
   181	  // Active order state (for selected table or quick order)
   182	  const [activeTableId, setActiveTableId] = useState<string | null>(null)
   183	  const [activeOrderId, setActiveOrderId] = useState<string | null>(null)
   184	  const [activeOrderNumber, setActiveOrderNumber] = useState<string | null>(null)
   185	  const [activeOrderType, setActiveOrderType] = useState<string | null>(null)
   186	  const [inlineOrderItems, setInlineOrderItems] = useState<InlineOrderItem[]>([])
   187	  const [showOrderPanel, setShowOrderPanel] = useState(false)
   188	  const [isSendingOrder, setIsSendingOrder] = useState(false)
   189	  const [guestCount, setGuestCount] = useState(defaultGuestCount)
   190	
   191	  // Notes editing state
   192	  const [editingNotesItemId, setEditingNotesItemId] = useState<string | null>(null)
   193	  const [editingNotesText, setEditingNotesText] = useState('')
   194	
   195	  // Item controls expansion state
   196	  const [expandedItemId, setExpandedItemId] = useState<string | null>(null)
   197	
   198	  // Active seat for auto-assignment (null = "Shared")
   199	  const [activeSeatNumber, setActiveSeatNumber] = useState<number | null>(null)
   200	  // Source table for seat (for virtual groups - tracks which table the seat belongs to)
   201	  const [activeSourceTableId, setActiveSourceTableId] = useState<string | null>(null)
   202	
   203	  // Context menu state for menu items (right-click)
   204	  const [contextMenu, setContextMenu] = useState<{
   205	    x: number
   206	    y: number
   207	    item: MenuItem
   208	  } | null>(null)
   209	
   210	  // Note: Drag state (lastDropPosition) is now managed by useFloorPlanDrag hook
   211	
   212	  // Room/section selection state
   213	  const [selectedSectionId, setSelectedSectionId] = useState<string | null>(null)
   214	  const [showRoomReorderModal, setShowRoomReorderModal] = useState(false)
   215	  const [preferredRoomOrder, setPreferredRoomOrder] = useState<string[]>([])
   216	
   217	  // Virtual group manager modal state
   218	  const [virtualGroupManagerTableId, setVirtualGroupManagerTableId] = useState<string | null>(null)
   219	
   220	  const {
   221	    tables,
   222	    sections,
   223	    elements,
   224	    selectedTableId,
   225	    draggedTableId,
   226	    dropTargetTableId,
   227	    infoPanelTableId,
   228	    undoStack,
   229	    isLoading,
   230	    showSeats,
   231	    selectedSeat,
   232	    flashingTables,
   233	    setTables,
   234	    setSections,
   235	    setElements,
   236	    selectTable,
   237	    startDrag,
   238	    updateDragTarget,
   239	    endDrag,
   240	    openInfoPanel,
   241	    closeInfoPanel,
   242	    addUndoAction,
   243	    popUndoAction,
   244	    clearExpiredUndos,
   245	    toggleShowSeats,
   246	    selectSeat,
   247	    clearSelectedSeat,
   248	    flashTableMessage,
   249	    clearExpiredFlashes,
   250	    setLoading,
   251	    // Virtual combine mode
   252	    virtualCombineMode,
   253	    virtualCombineSelectedIds,
   254	    virtualCombinePrimaryId,
   255	    startVirtualCombineMode,
   256	    toggleVirtualCombineSelection,
   257	    cancelVirtualCombineMode,
   258	    clearVirtualCombineMode,
   259	    updateTablesWithVirtualGroup,
   260	  } = useFloorPlanStore()
   261	
   262	  // Auto-scaling hook (fits floor plan to container)
   263	  const {
   264	    containerSize,
   265	    tableBounds,
   266	    autoScale,
   267	    autoScaleOffset,
   268	  } = useFloorPlanAutoScale({
   269	    containerRef,
   270	    tables,
   271	    elements,
   272	    selectedSectionId,
   273	  })
   274	
   275	  // POS Layout personalization hook (quick bar, colors, etc.)
   276	  const {
   277	    quickBar,
   278	    quickBarEnabled,
   279	    toggleQuickBar,
   280	    addToQuickBar,
   281	    removeFromQuickBar,
   282	    isInQuickBar,
   283	    menuItemColors,
   284	    categoryColors,
   285	    canCustomize,
   286	    resetAllCategoryColors,
   287	    resetAllMenuItemStyles,
   288	  } = usePOSLayout({
   289	    employeeId,
   290	    locationId,
   291	    permissions: { posLayout: ['customize_personal'] }, // Servers can customize their own layout
   292	  })
   293	
   294	  // Editing modes (for settings dropdown options)
   295	  const [isEditingFavorites, setIsEditingFavorites] = useState(false)
   296	  const [isEditingCategories, setIsEditingCategories] = useState(false)
   297	  const [isEditingMenuItems, setIsEditingMenuItems] = useState(false)
   298	
   299	  // Sort sections based on employee's preferred room order
   300	  const sortedSections = useMemo(() => {
   301	    if (preferredRoomOrder.length === 0) return sections
   302	
   303	    return [...sections].sort((a, b) => {
   304	      const aIndex = preferredRoomOrder.indexOf(a.id)
   305	      const bIndex = preferredRoomOrder.indexOf(b.id)
   306	
   307	      // Rooms in preferred order come first, in that order
   308	      // Rooms not in preferred order come after, in original order
   309	      if (aIndex >= 0 && bIndex >= 0) return aIndex - bIndex
   310	      if (aIndex >= 0) return -1
   311	      if (bIndex >= 0) return 1
   312	      return 0
   313	    })
   314	  }, [sections, preferredRoomOrder])
   315	
   316	  // Load employee's room order preferences on mount
   317	  useEffect(() => {
   318	    const loadPreferences = async () => {
   319	      if (!employeeId) return
   320	      try {
   321	        const res = await fetch(`/api/employees/${employeeId}/preferences`)
   322	        if (res.ok) {
   323	          const data = await res.json()
   324	          if (data.preferences?.preferredRoomOrder) {
   325	            setPreferredRoomOrder(data.preferences.preferredRoomOrder)
   326	          }
   327	        }
   328	      } catch (error) {
   329	        console.error('Failed to load room preferences:', error)
   330	      }
   331	    }
   332	    loadPreferences()
   333	  }, [employeeId])
   334	
   335	  // Initialize to first room when sections load
   336	  useEffect(() => {
   337	    if (sortedSections.length > 0 && selectedSectionId === null) {
   338	      setSelectedSectionId(sortedSections[0].id)
   339	    }
   340	  }, [sortedSections, selectedSectionId])
   341	
   342	  // Save room order preferences
   343	  const handleSaveRoomOrder = useCallback(async (orderedRoomIds: string[]) => {
   344	    if (!employeeId) return
   345	    try {
   346	      const res = await fetch(`/api/employees/${employeeId}/preferences`, {
   347	        method: 'PUT',
   348	        headers: { 'Content-Type': 'application/json' },
   349	        body: JSON.stringify({ preferredRoomOrder: orderedRoomIds }),
   350	      })
   351	      if (res.ok) {
   352	        setPreferredRoomOrder(orderedRoomIds)
   353	        toast.success('Room order saved')
   354	      } else {
   355	        toast.error('Failed to save room order')
   356	      }
   357	    } catch (error) {
   358	      console.error('Failed to save room order:', error)
   359	      toast.error('Failed to save room order')
   360	    }
   361	  }, [employeeId])
   362	
   363	  // Virtual combine state
   364	  const [isCreatingVirtualGroup, setIsCreatingVirtualGroup] = useState(false)
   365	  const [showExistingOrdersModal, setShowExistingOrdersModal] = useState(false)
   366	  const [pendingExistingOrders, setPendingExistingOrders] = useState<Array<{
   367	    tableId: string
   368	    tableName: string
   369	    orderId: string
   370	    orderNumber: number
   371	    itemCount: number
   372	    total: number
   373	  }>>([])
   374	
   375	  // Seat management refresh trigger (Skill 121)
   376	  const [refreshKey, setRefreshKey] = useState(0)
   377	
   378	  // Extra virtual seats per table (for walk-up guests before order exists)
   379	  const [extraSeats, setExtraSeats] = useState<Map<string, number>>(new Map())
   380	
   381	  // FIX: Ref to always access latest tables data (avoids stale closure issues)
   382	  const tablesRef = useRef(tables)
   383	  tablesRef.current = tables
   384	
   385	  // Ref for fixtures/elements data (for collision detection)
   386	  const fixturesRef = useRef(elements)
   387	  fixturesRef.current = elements
   388	
   389	  // FIX: Refs for auto-scale values (needed in handlePointerMove for coordinate transformation)
   390	  const autoScaleRef = useRef(autoScale)
   391	  autoScaleRef.current = autoScale
   392	  const autoScaleOffsetRef = useRef(autoScaleOffset)
   393	  autoScaleOffsetRef.current = autoScaleOffset
   394	
   395	  // Helper to get best seat count - use MAX of capacity and actual seats, plus any extra virtual seats
   396	  const getTableSeatCount = useCallback((t: FloorPlanTable): number => {
   397	    const seatsLen = t.seats?.length || 0
   398	    const cap = t.capacity || 0
   399	    const extra = extraSeats.get(t.id) || 0
   400	    return Math.max(seatsLen, cap) + extra
   401	  }, [extraSeats])
   402	
   403	  // Get all tables in a virtual group (returns array with primary table first)
   404	  // FIX: Uses tablesRef.current to always access latest tables data
   405	  const getVirtualGroupTables = useCallback((table: FloorPlanTable | null): FloorPlanTable[] => {
   406	    if (!table) return []
   407	    if (!table.virtualGroupId) return [table]
   408	
   409	    // Find all tables in the same virtual group - use ref for latest data
   410	    const groupTables = tablesRef.current.filter(t => t.virtualGroupId === table.virtualGroupId)
   411	
   412	    // Sort so primary table is first
   413	    return groupTables.sort((a, b) => {
   414	      if (a.virtualGroupPrimary) return -1
   415	      if (b.virtualGroupPrimary) return 1
   416	      return 0
   417	    })
   418	  }, [])
   419	
   420	  // Calculate total seats for a table (including combined tables or virtual group)
   421	  // Uses perimeter-based capacity for combined groups to avoid the "8-seat" problem
   422	  // FIX: Uses tablesRef.current to always access latest tables data (avoids stale closure)
   423	  const getTotalSeats = useCallback((table: FloorPlanTable | null): number => {
   424	    if (!table) return 0
   425	
   426	    // Always use the ref to get the latest tables data
   427	    const currentTables = tablesRef.current
   428	
   429	    // If this is a virtual group, sum all tables in the group (including extra seats)
   430	    if (table.virtualGroupId) {
   431	      const groupTables = getVirtualGroupTables(table)
   432	      const total = groupTables.reduce((sum, t) => {
   433	        const tableSeats = getTableSeatCount(t)
   434	        const tableExtra = extraSeats.get(t.id) || 0
   435	        return sum + tableSeats + tableExtra
   436	      }, 0)
   437	      console.log(`[getTotalSeats] Virtual group ${table.name}: tables=${groupTables.length}, total=${total}`)
   438	      return total
   439	    }
   440	
   441	    // FIX: If this is a CHILD of a combined group, redirect to the PRIMARY
   442	    // This handles the case where user taps on a child table or if activeTableId is stale
   443	    if (table.combinedWithId) {
   444	      const primaryTable = currentTables.find(t => t.id === table.combinedWithId)
   445	      if (primaryTable) {
   446	        console.log(`[getTotalSeats] Redirecting from child ${table.name} to primary ${primaryTable.name}`)
   447	        // Calculate seats from the primary's perspective
   448	        const combinedIds = primaryTable.combinedTableIds as string[] | null
   449	        if (combinedIds && Array.isArray(combinedIds) && combinedIds.length > 0) {
   450	          const primarySeats = primaryTable.seats?.length || 0
   451	          const primaryExtra = extraSeats.get(primaryTable.id) || 0
   452	          let totalSeats = primarySeats + primaryExtra
   453	
   454	          for (const childId of combinedIds) {
   455	            const childTable = currentTables.find(t => t.id === childId)
   456	            if (childTable) {
   457	              const childSeats = childTable.seats?.length || 0
   458	              const childExtra = extraSeats.get(childId) || 0
   459	              totalSeats += childSeats + childExtra
   460	            }
   461	          }
   462	
   463	          if (totalSeats === 0) {
   464	            totalSeats = primaryTable.capacity || 0
   465	          }
   466	
   467	          console.log(`[getTotalSeats] Child ${table.name} -> Primary ${primaryTable.name}: TOTAL=${totalSeats}`)
   468	          return totalSeats
   469	        }
   470	        // Primary doesn't have combinedTableIds - fall back to primary's seat count
   471	        return getTableSeatCount(primaryTable)
   472	      }
   473	      // Primary not found - just return this table's count
   474	      console.warn(`[getTotalSeats] Primary table ${table.combinedWithId} not found for child ${table.name}`)
   475	    }
   476	
   477	    // If this is a combined table (primary), sum seats from primary + all children
   478	    // Use combinedTableIds directly instead of getCombinedGroupTables for reliability
   479	    const combinedIds = table.combinedTableIds as string[] | null
   480	    if (combinedIds && Array.isArray(combinedIds) && combinedIds.length > 0) {
   481	      // Start with primary table's seats
   482	      const primarySeats = table.seats?.length || 0
   483	      const primaryExtra = extraSeats.get(table.id) || 0
   484	      let totalSeats = primarySeats + primaryExtra
   485	
   486	      console.log(`[getTotalSeats] Combined primary ${table.name}: seats.length=${primarySeats}, extra=${primaryExtra}, combinedIds=${combinedIds.length}`)
   487	
   488	      // Add seats from each child table listed in combinedTableIds
   489	      for (const childId of combinedIds) {
   490	        const childTable = currentTables.find(t => t.id === childId)
   491	        if (childTable) {
   492	          const childSeats = childTable.seats?.length || 0
   493	          const childExtra = extraSeats.get(childId) || 0
   494	          console.log(`[getTotalSeats] + Child ${childTable.name}: seats.length=${childSeats}, extra=${childExtra}`)
   495	          totalSeats += childSeats + childExtra
   496	        } else {
   497	          console.warn(`[getTotalSeats] Child table ${childId} not found in tables array! (tables count: ${currentTables.length})`)
   498	        }
   499	      }
   500	
   501	      // If no actual seat records exist, fall back to primary's combined capacity
   502	      if (totalSeats === 0) {
   503	        totalSeats = table.capacity || 0
   504	        console.log(`[getTotalSeats] No seats found, using capacity=${totalSeats}`)
   505	      }
   506	
   507	      console.log(`[getTotalSeats] Combined table ${table.name}: TOTAL=${totalSeats}`)
   508	      return totalSeats
   509	    }
   510	
   511	    // Single table - use MAX of capacity and seats array length
   512	    const seatCount = getTableSeatCount(table)
   513	    console.log(`[getTotalSeats] Table ${table.name}: capacity=${table.capacity}, seats.length=${table.seats?.length}, returning=${seatCount}`)
   514	    return seatCount
   515	  }, [getTableSeatCount, getVirtualGroupTables, extraSeats])
   516	
   517	  // Get combined table count (includes virtual groups)
   518	  const getCombinedTableCount = useCallback((table: FloorPlanTable | null): number => {
   519	    if (!table) return 0
   520	
   521	    // Check virtual group first
   522	    if (table.virtualGroupId) {
   523	      const groupTables = getVirtualGroupTables(table)
   524	      return groupTables.length
   525	    }
   526	
   527	    // Physical combine
   528	    if (table.combinedTableIds && table.combinedTableIds.length > 0) {
   529	      return table.combinedTableIds.length + 1 // +1 for the primary table
   530	    }
   531	    return 1
   532	  }, [getVirtualGroupTables])
   533	
   534	  // Get the active table object
   535	  const activeTable = activeTableId ? tables.find(t => t.id === activeTableId) || null : null
   536	
   537	  // FIX 3: Group order items by seat for display - use useMemo instead of useCallback
   538	  // useCallback returns a function that runs on every render; useMemo caches the result
   539	  const groupedOrderItems = useMemo(() => {
   540	    if (!activeTable || getTotalSeats(activeTable) === 0) {
   541	      // No seats - just return all items in one "group"
   542	      return [{ seatNumber: null, label: 'All Items', items: inlineOrderItems }]
   543	    }
   544	
   545	    const groups: { seatNumber: number | null; sourceTableId: string | null; label: string; items: InlineOrderItem[] }[] = []
   546	
   547	    // For virtual groups, use T-S notation (e.g., T4-S1)
   548	    const isVirtualGroup = activeTable.virtualGroupId !== null
   549	
   550	    if (isVirtualGroup) {
   551	      // Group by sourceTableId + seatNumber
   552	      const seatKeys = new Map<string, InlineOrderItem[]>()
   553	
   554	      inlineOrderItems.forEach(item => {
   555	        if (item.seatNumber && item.sourceTableId) {
   556	          const key = `${item.sourceTableId}-${item.seatNumber}`
   557	          if (!seatKeys.has(key)) {
   558	            seatKeys.set(key, [])
   559	          }
   560	          seatKeys.get(key)!.push(item)
   561	        }
   562	      })
   563	
   564	      // Sort by table name, then seat number
   565	      const sortedKeys = Array.from(seatKeys.keys()).sort((a, b) => {
   566	        const [tableIdA, seatA] = a.split('-')
   567	        const [tableIdB, seatB] = b.split('-')
   568	        const tableA = tables.find(t => t.id === tableIdA)
   569	        const tableB = tables.find(t => t.id === tableIdB)
   570	        const nameCompare = (tableA?.name || '').localeCompare(tableB?.name || '')
   571	        if (nameCompare !== 0) return nameCompare
   572	        return parseInt(seatA) - parseInt(seatB)
   573	      })
   574	
   575	      sortedKeys.forEach(key => {
   576	        const [tableId, seatNumStr] = key.split('-')
   577	        const seatNum = parseInt(seatNumStr)
   578	        const table = tables.find(t => t.id === tableId)
   579	        const tableLabel = table?.abbreviation || table?.name || 'Table'
   580	        groups.push({
   581	          seatNumber: seatNum,
   582	          sourceTableId: tableId,
   583	          label: `${tableLabel}-S${seatNum}`,
   584	          items: seatKeys.get(key)!,
   585	        })
   586	      })
   587	    } else {
   588	      // Non-virtual group - simple seat grouping
   589	      const seatsWithItems = new Set<number>()
   590	      inlineOrderItems.forEach(item => {
   591	        if (item.seatNumber) {
   592	          seatsWithItems.add(item.seatNumber)
   593	        }
   594	      })
   595	
   596	      Array.from(seatsWithItems).sort((a, b) => a - b).forEach(seatNum => {
   597	        groups.push({
   598	          seatNumber: seatNum,
   599	          sourceTableId: null,
   600	          label: `Seat ${seatNum}`,
   601	          items: inlineOrderItems.filter(item => item.seatNumber === seatNum),
   602	        })
   603	      })
   604	    }
   605	
   606	    // Add shared items (no seat) at the end
   607	    const sharedItems = inlineOrderItems.filter(item => !item.seatNumber)
   608	    if (sharedItems.length > 0) {
   609	      groups.push({
   610	        seatNumber: null,
   611	        sourceTableId: null,
   612	        label: 'Shared',
   613	        items: sharedItems,
   614	      })
   615	    }
   616	
   617	    return groups
   618	  }, [activeTable, getTotalSeats, inlineOrderItems, tables])
   619	
   620	  // Quick bar items with full data
   621	  const [quickBarItems, setQuickBarItems] = useState<{
   622	    id: string
   623	    name: string
   624	    price: number
   625	    bgColor?: string | null
   626	    textColor?: string | null
   627	  }[]>([])
   628	
   629	  // Load quick bar items when quickBar changes
   630	  useEffect(() => {
   631	    if (quickBar.length === 0) {
   632	      setQuickBarItems([])
   633	      return
   634	    }
   635	
   636	    const loadQuickBarItems = async () => {
   637	      try {
   638	        // Fetch item details for each quick bar item
   639	        const itemPromises = quickBar.map(async (itemId) => {
   640	          const res = await fetch(`/api/menu/items/${itemId}`)
   641	          if (res.ok) {
   642	            const data = await res.json()
   643	            const customStyle = menuItemColors[itemId]
   644	            return {
   645	              id: data.item.id,
   646	              name: data.item.name,
   647	              price: Number(data.item.price),
   648	              bgColor: customStyle?.bgColor || null,
   649	              textColor: customStyle?.textColor || null,
   650	            }
   651	          }
   652	          return null
   653	        })
   654	
   655	        const items = await Promise.all(itemPromises)
   656	        setQuickBarItems(items.filter(Boolean) as typeof quickBarItems)
   657	      } catch (error) {
   658	        console.error('[FloorPlanHome] Quick bar items load error:', error)
   659	      }
   660	    }
   661	
   662	    loadQuickBarItems()
   663	  }, [quickBar, menuItemColors])
   664	
   665	  // Load data on mount
   666	  useEffect(() => {
   667	    loadFloorPlanData()
   668	    loadCategories()
   669	    loadOpenOrdersCount()
   670	    // Clear any leftover virtual combine state from previous sessions
   671	    cancelVirtualCombineMode()
   672	  }, [locationId, cancelVirtualCombineMode])
   673	
   674	  // Consolidated heartbeat - single interval for all periodic tasks
   675	  // FIX 4: Uses refs for callbacks to prevent interval restart on re-render
   676	  // This prevents multiple setIntervals from causing frame drops during animations
   677	  useEffect(() => {
   678	    let tickCount = 0
   679	    const heartbeat = setInterval(() => {
   680	      tickCount++
   681	
   682	      // Every tick (1s): Clear expired undos and flashes
   683	      callbacksRef.current.clearExpiredUndos()
   684	      callbacksRef.current.clearExpiredFlashes()
   685	
   686	      // Every 5 ticks (5s): Refresh floor plan data for live preview
   687	      // This allows admin changes to tables/entertainment to appear on POS
   688	      if (tickCount % 5 === 0) {
   689	        callbacksRef.current.loadFloorPlanData?.()
   690	      }
   691	
   692	      // Every 30 ticks (30s): Refresh open orders count
   693	      if (tickCount >= 30) {
   694	        tickCount = 0
   695	        callbacksRef.current.loadOpenOrdersCount?.()
   696	      }
   697	    }, 1000)
   698	
   699	    return () => clearInterval(heartbeat)
   700	  }, []) // Empty deps - refs keep callbacks fresh
   701	
   702	  // Socket.io: Listen for floor plan updates from admin
   703	  const { subscribe, isConnected } = useEvents({ locationId, autoConnect: true })
   704	
   705	  useEffect(() => {
   706	    if (!isConnected) return
   707	
   708	    // Subscribe to floor-plan:updated event for live preview
   709	    // Pass false to skip loading state during background refresh
   710	    const unsubscribe = subscribe('floor-plan:updated', () => {
   711	      console.log('[FloorPlanHome] Received floor-plan:updated event, refreshing...')
   712	      loadFloorPlanData(false)
   713	    })
   714	
   715	    return unsubscribe
   716	    // eslint-disable-next-line react-hooks/exhaustive-deps
   717	  }, [isConnected, subscribe])
   718	
   719	  // Load order when orderToLoad prop is set (from Open Orders panel)
   720	  useEffect(() => {
   721	    if (!orderToLoad) return
   722	
   723	    const loadOrder = async () => {
   724	      try {
   725	        const res = await fetch(`/api/orders/${orderToLoad.id}`)
   726	        if (!res.ok) {
   727	          console.error('[FloorPlanHome] Failed to load order:', orderToLoad.id)
   728	          toast.error('Failed to load order. Please try again.')
   729	          return
   730	        }
   731	
   732	        const data = await res.json()
   733	
   734	        // Set order state
   735	        setActiveOrderId(orderToLoad.id)
   736	        setActiveOrderNumber(String(orderToLoad.orderNumber))
   737	        setActiveTableId(orderToLoad.tableId || null)
   738	        setActiveOrderType(orderToLoad.orderType || 'bar_tab')
   739	        setShowOrderPanel(true)
   740	
   741	        // Load items
   742	        const items = (data.items || []).map((item: { id: string; menuItemId: string; name: string; price: number; quantity: number; modifiers?: { id: string; name: string; price: number }[]; specialNotes?: string; seatNumber?: number; courseNumber?: number; courseStatus?: string; isHeld?: boolean; isCompleted?: boolean; kitchenStatus?: string; status?: string; blockTimeMinutes?: number }) => ({
   743	          id: item.id,
   744	          menuItemId: item.menuItemId,
   745	          name: item.name || 'Unknown',
   746	          price: Number(item.price) || 0,
   747	          quantity: item.quantity,
   748	          modifiers: (item.modifiers || []).map((m: { id: string; name: string; price: number }) => ({
   749	            id: m.id,
   750	            name: m.name || '',
   751	            price: Number(m.price) || 0,
   752	          })),
   753	          specialNotes: item.specialNotes,
   754	          seatNumber: item.seatNumber,
   755	          courseNumber: item.courseNumber,
   756	          courseStatus: item.courseStatus as 'pending' | 'fired' | 'ready' | 'served' | undefined,
   757	          isHeld: item.isHeld,
   758	          isCompleted: item.isCompleted,
   759	          sentToKitchen: item.kitchenStatus !== 'pending' && item.kitchenStatus !== undefined,
   760	          status: item.status as 'active' | 'voided' | 'comped' | undefined,
   761	          blockTimeMinutes: item.blockTimeMinutes,
   762	        }))
   763	        setInlineOrderItems(items)
   764	
   765	        // Notify parent that order is loaded
   766	        onOrderLoaded?.()
   767	      } catch (error) {
   768	        console.error('[FloorPlanHome] Failed to load order:', error)
   769	        toast.error('Failed to load order. Please try again.')
   770	      }
   771	    }
   772	
   773	    loadOrder()
   774	  }, [orderToLoad, onOrderLoaded])
   775	
   776	  // Clear order when it's been paid (paidOrderId matches activeOrderId)
   777	  useEffect(() => {
   778	    if (!paidOrderId) return
   779	    if (paidOrderId !== activeOrderId) return
   780	
   781	    // Clear the order panel state
   782	    setActiveOrderId(null)
   783	    setActiveOrderNumber(null)
   784	    setActiveTableId(null)
   785	    setActiveOrderType(null)
   786	    setInlineOrderItems([])
   787	    setShowOrderPanel(false)
   788	    setSelectedCategoryId(null)
   789	    setViewMode('tables')
   790	
   791	    // Refresh floor plan to show updated table status
   792	    loadFloorPlanData()
   793	    loadOpenOrdersCount()
   794	
   795	    // Notify parent that we've cleared the paid order
   796	    onPaidOrderCleared?.()
   797	  }, [paidOrderId, activeOrderId, onPaidOrderCleared])
   798	
   799	  // Refs to track previous data for change detection (prevents flashing during polling)
   800	  const prevTablesJsonRef = useRef<string>('')
   801	  const prevSectionsJsonRef = useRef<string>('')
   802	  const prevElementsJsonRef = useRef<string>('')
   803	
   804	  // Ref to prevent double-tap race condition on Send button
   805	  const isProcessingSendRef = useRef(false)
   806	
   807	  // FIX 4: Refs for heartbeat callbacks - prevents interval restart on re-render
   808	  const callbacksRef = useRef({
   809	    clearExpiredUndos,
   810	    clearExpiredFlashes,
   811	    loadFloorPlanData: null as (() => Promise<void>) | null,
   812	    loadOpenOrdersCount: null as (() => Promise<void>) | null,
   813	  })
   814	
   815	  const loadFloorPlanData = async (showLoading = true) => {
   816	    // Only show loading state on initial load, not during background polling
   817	    if (showLoading) setLoading(true)
   818	    try {
   819	      const [tablesRes, sectionsRes, elementsRes] = await Promise.all([
   820	        fetch(`/api/tables?locationId=${locationId}&includeSeats=true&includeOrderItems=true`),
   821	        fetch(`/api/sections?locationId=${locationId}`),
   822	        fetch(`/api/floor-plan-elements?locationId=${locationId}`),
   823	      ])
   824	
   825	      if (tablesRes.ok) {
   826	        const data = await tablesRes.json()
   827	        const newTables = data.tables || []
   828	        // Only update if data actually changed to prevent flashing during polling
   829	        const newJson = JSON.stringify(newTables)
   830	        if (newJson !== prevTablesJsonRef.current) {
   831	          prevTablesJsonRef.current = newJson
   832	          setTables(newTables)
   833	        }
   834	      }
   835	      if (sectionsRes.ok) {
   836	        const data = await sectionsRes.json()
   837	        const newSections = data.sections || []
   838	        const newJson = JSON.stringify(newSections)
   839	        if (newJson !== prevSectionsJsonRef.current) {
   840	          prevSectionsJsonRef.current = newJson
   841	          setSections(newSections)
   842	        }
   843	      }
   844	      if (elementsRes.ok) {
   845	        const data = await elementsRes.json()
   846	        const newElements = data.elements || []
   847	        const newJson = JSON.stringify(newElements)
   848	        if (newJson !== prevElementsJsonRef.current) {
   849	          prevElementsJsonRef.current = newJson
   850	          setElements(newElements)
   851	        }
   852	      }
   853	    } catch (error) {
   854	      console.error('[FloorPlanHome] Load error:', error)
   855	    } finally {
   856	      if (showLoading) setLoading(false)
   857	    }
   858	  }
   859	
   860	  const loadCategories = async () => {
   861	    try {
   862	      // Use same /api/menu endpoint as orders page for consistency
   863	      const timestamp = Date.now()
   864	      const params = new URLSearchParams({ locationId, _t: timestamp.toString() })
   865	      const res = await fetch(`/api/menu?${params}`, {
   866	        cache: 'no-store',
   867	        headers: { 'Cache-Control': 'no-cache' },
   868	      })
   869	      if (res.ok) {
   870	        const data = await res.json()
   871	        setCategories(data.categories || [])
   872	      }
   873	    } catch (error) {
   874	      console.error('[FloorPlanHome] Categories load error:', error)
   875	    }
   876	  }
   877	
   878	  const loadOpenOrdersCount = async () => {
   879	    try {
   880	      const res = await fetch(`/api/orders?locationId=${locationId}&status=open&count=true`)
   881	      if (res.ok) {
   882	        const data = await res.json()
   883	        setOpenOrdersCount(data.count || 0)
   884	      }
   885	    } catch (error) {
   886	      console.error('[FloorPlanHome] Open orders count error:', error)
   887	    }
   888	  }
   889	
   890	  // FIX 4: Keep refs updated with latest callbacks
   891	  useEffect(() => {
   892	    callbacksRef.current = {
   893	      clearExpiredUndos,
   894	      clearExpiredFlashes,
   895	      loadFloorPlanData: () => loadFloorPlanData(false),
   896	      loadOpenOrdersCount,
   897	    }
   898	  })
   899	
   900	  const loadMenuItems = async (categoryId: string) => {
   901	    setLoadingMenuItems(true)
   902	    try {
   903	      // Include stock status for prep item tracking
   904	      const res = await fetch(`/api/menu/items?categoryId=${categoryId}&locationId=${locationId}&includeStock=true`)
   905	      if (res.ok) {
   906	        const data = await res.json()
   907	        setMenuItems(data.items || [])
   908	      }
   909	    } catch (error) {
   910	      console.error('[FloorPlanHome] Menu items load error:', error)
   911	    } finally {
   912	      setLoadingMenuItems(false)
   913	    }
   914	  }
   915	
   916	  // Handle category click - toggle between tables and menu view
   917	  const handleCategoryClick = useCallback((categoryId: string | null) => {
   918	    if (!categoryId) {
   919	      // "All" was clicked - show tables
   920	      setSelectedCategoryId(null)
   921	      setViewMode('tables')
   922	      setMenuItems([])
   923	      return
   924	    }
   925	
   926	    // Toggle behavior: clicking same category deselects it
   927	    if (categoryId === selectedCategoryId) {
   928	      setSelectedCategoryId(null)
   929	      setViewMode('tables')
   930	      setMenuItems([])
   931	      return
   932	    }
   933	
   934	    // Select new category
   935	    setSelectedCategoryId(categoryId)
   936	    setViewMode('menu')
   937	    loadMenuItems(categoryId)
   938	  }, [selectedCategoryId])
   939	
   940	
   941	  // Handle confirming virtual combine
   942	  const handleConfirmVirtualCombine = useCallback(async (existingOrderActions?: Array<{ orderId: string; action: 'merge' | 'close' }>) => {
   943	    if (virtualCombineSelectedIds.size < 2) return
   944	
   945	    // FIX: Use tablesRef.current to get latest table data (avoids stale closure)
   946	    const currentTables = tablesRef.current
   947	    const selectedTableIds = Array.from(virtualCombineSelectedIds)
   948	    const primaryId = virtualCombinePrimaryId || selectedTableIds[0]
   949	    const primaryTable = currentTables.find(t => t.id === primaryId)
   950	
   951	    setIsCreatingVirtualGroup(true)
   952	
   953	    try {
   954	      // Check if primary table is already in a virtual group (ADD mode vs CREATE mode)
   955	      if (primaryTable?.virtualGroupId) {
   956	        // ADD mode: Add new tables to existing group
   957	        const existingGroupId = primaryTable.virtualGroupId
   958	        const tablesToAdd = selectedTableIds.filter(id => {
   959	          const table = currentTables.find(t => t.id === id)
   960	          return !table?.virtualGroupId // Only add tables not already in the group
   961	        })
   962	
   963	        if (tablesToAdd.length === 0) {
   964	          toast.info('All selected tables are already in this group')
   965	          clearVirtualCombineMode()
   966	          return
   967	        }
   968	
   969	        // Add each new table to the group
   970	        const addedTables: Array<{ id: string; virtualGroupId: string; virtualGroupPrimary: boolean; virtualGroupColor: string }> = []
   971	
   972	        for (const tableId of tablesToAdd) {
   973	          const res = await fetch(`/api/tables/virtual-combine/${existingGroupId}/add`, {
   974	            method: 'POST',
   975	            headers: { 'Content-Type': 'application/json' },
   976	            body: JSON.stringify({
   977	              tableId,
   978	              locationId,
   979	              employeeId,
   980	              mergeExistingOrder: existingOrderActions?.find(a =>
   981	                currentTables.find(t => t.id === tableId)?.currentOrder?.id === a.orderId
   982	              )?.action === 'merge',
   983	            }),
   984	          })
   985	
   986	          const data = await res.json()
   987	
   988	          if (data.requiresAction) {
   989	            // Show modal to handle this table's existing order
   990	            setPendingExistingOrders([data.existingOrder])
   991	            setShowExistingOrdersModal(true)
   992	            setIsCreatingVirtualGroup(false)
   993	            return
   994	          }
   995	
   996	          if (!res.ok) {
   997	            throw new Error(data.error || `Failed to add table to group`)
   998	          }
   999	
  1000	          if (data.data?.table) {
  1001	            addedTables.push({
  1002	              id: data.data.table.id,
  1003	              virtualGroupId: data.data.table.virtualGroupId,
  1004	              virtualGroupPrimary: false,
  1005	              virtualGroupColor: data.data.table.virtualGroupColor,
  1006	            })
  1007	          }
  1008	        }
  1009	
  1010	        // Update local state with added tables
  1011	        if (addedTables.length > 0) {
  1012	          updateTablesWithVirtualGroup(addedTables)
  1013	        }
  1014	
  1015	        toast.success(`Added ${tablesToAdd.length} table${tablesToAdd.length > 1 ? 's' : ''} to virtual group`)
  1016	      } else {
  1017	        // CREATE mode: Create a new virtual group
  1018	        const res = await fetch('/api/tables/virtual-combine', {
  1019	          method: 'POST',
  1020	          headers: { 'Content-Type': 'application/json' },
  1021	          body: JSON.stringify({
  1022	            tableIds: selectedTableIds,
  1023	            primaryTableId: primaryId,
  1024	            locationId,
  1025	            employeeId,
  1026	            existingOrderActions,
  1027	          }),
  1028	        })
  1029	
  1030	        const data = await res.json()
  1031	
  1032	        if (data.requiresAction) {
  1033	          // Show modal to handle existing orders
  1034	          setPendingExistingOrders(data.existingOrders)
  1035	          setShowExistingOrdersModal(true)
  1036	          setIsCreatingVirtualGroup(false)
  1037	          return
  1038	        }
  1039	
  1040	        if (!res.ok) {
  1041	          throw new Error(data.error || 'Failed to create virtual group')
  1042	        }
  1043	
  1044	        // Update local state with new virtual group info
  1045	        if (data.data?.tables) {
  1046	          updateTablesWithVirtualGroup(
  1047	            data.data.tables.map((t: { id: string; virtualGroupId: string; virtualGroupPrimary: boolean; virtualGroupColor: string }) => ({
  1048	              id: t.id,
  1049	              virtualGroupId: t.virtualGroupId,
  1050	              virtualGroupPrimary: t.virtualGroupPrimary,
  1051	              virtualGroupColor: t.virtualGroupColor,
  1052	            }))
  1053	          )
  1054	        }
  1055	
  1056	        toast.success(`Virtual group created with ${selectedTableIds.length} tables`)
  1057	      }
  1058	
  1059	      clearVirtualCombineMode()
  1060	      setShowExistingOrdersModal(false)
  1061	      setPendingExistingOrders([])
  1062	    } catch (error) {
  1063	      console.error('Failed to create/add to virtual group:', error)
  1064	      toast.error(error instanceof Error ? error.message : 'Failed to create virtual group')
  1065	    } finally {
  1066	      setIsCreatingVirtualGroup(false)
  1067	    }
  1068	  }, [virtualCombineSelectedIds, virtualCombinePrimaryId, locationId, employeeId, updateTablesWithVirtualGroup, clearVirtualCombineMode])
  1069	  // Note: Using tablesRef.current instead of tables in dependency array
  1070	
  1071	  // Handle table tap - open order panel
  1072	  // If tapped table is part of a combined group, redirect to the PRIMARY table
  1073	  // If in virtual combine mode, toggle selection instead
  1074	  // FIX: Uses tablesRef.current to always access latest tables data
  1075	  const handleTableTap = useCallback(async (table: FloorPlanTable) => {
  1076	    console.log('[VirtualCombine] handleTableTap called:', { tableId: table.id, virtualCombineMode, selectedIds: Array.from(virtualCombineSelectedIds) })
  1077	
  1078	    // Always use the ref to get the latest tables data
  1079	    const currentTables = tablesRef.current
  1080	
  1081	    // In virtual combine mode, toggle selection
  1082	    if (virtualCombineMode) {
  1083	      const primaryTable = currentTables.find(t => t.id === virtualCombinePrimaryId)
  1084	      const primaryGroupId = primaryTable?.virtualGroupId
  1085	
  1086	      // Prevent selecting tables that are in a DIFFERENT virtual group
  1087	      if (table.virtualGroupId && table.virtualGroupId !== primaryGroupId && !virtualCombineSelectedIds.has(table.id)) {
  1088	        toast.error(`${table.name} is already in another group. Dissolve that group first.`)
  1089	        return
  1090	      }
  1091	      // Prevent selecting tables that are physically combined
  1092	      if (table.combinedWithId || (table.combinedTableIds && table.combinedTableIds.length > 0)) {
  1093	        toast.error(`${table.name} is physically combined. Split it first.`)
  1094	        return
  1095	      }
  1096	      console.log('[VirtualCombine] Toggling selection for table:', table.id)
  1097	      toggleVirtualCombineSelection(table.id)
  1098	      return
  1099	    }
  1100	
  1101	    if (selectedSeat) {
  1102	      clearSelectedSeat()
  1103	    }
  1104	
  1105	    // If this table is in a VIRTUAL group, redirect to the PRIMARY virtual table
  1106	    if (table.virtualGroupId && !table.virtualGroupPrimary) {
  1107	      const virtualPrimary = currentTables.find(t => t.virtualGroupId === table.virtualGroupId && t.virtualGroupPrimary)
  1108	      if (virtualPrimary) {
  1109	        table = virtualPrimary
  1110	      }
  1111	    }
  1112	
  1113	    // If this table is combined INTO another (physical), find and use the primary instead
  1114	    // FIX: Also check if the table passed in has stale data - look up fresh from ref
  1115	    let primaryTable = table
  1116	    const freshTable = currentTables.find(t => t.id === table.id)
  1117	    if (freshTable?.combinedWithId) {
  1118	      const foundPrimary = currentTables.find(t => t.id === freshTable.combinedWithId)
  1119	      if (foundPrimary) {
  1120	        primaryTable = foundPrimary
  1121	        console.log(`[handleTableTap] Redirecting from child ${table.name} to primary ${foundPrimary.name}`)
  1122	      }
  1123	    } else if (table.combinedWithId) {
  1124	      const foundPrimary = currentTables.find(t => t.id === table.combinedWithId)
  1125	      if (foundPrimary) {
  1126	        primaryTable = foundPrimary
  1127	      }
  1128	    }
  1129	
  1130	    const totalSeats = getTotalSeats(primaryTable)
  1131	    console.log(`[handleTableTap] Setting guest count to ${totalSeats} for table ${primaryTable.name} (capacity=${primaryTable.capacity})`)
  1132	
  1133	    setActiveTableId(primaryTable.id)
  1134	    setActiveOrderType('dine_in')
  1135	    setShowOrderPanel(true)
  1136	    setActiveSeatNumber(null) // Reset active seat when switching tables
  1137	    setActiveSourceTableId(null) // Reset source table too
  1138	    setGuestCount(totalSeats) // Set guest count based on table capacity
  1139	
  1140	    if (primaryTable.currentOrder) {
  1141	      // Load existing order items from PRIMARY table (combined tables share one order)
  1142	      setActiveOrderId(primaryTable.currentOrder.id)
  1143	      setActiveOrderNumber(String(primaryTable.currentOrder.orderNumber))
  1144	      try {
  1145	        const res = await fetch(`/api/orders/${primaryTable.currentOrder.id}`)
  1146	        if (res.ok) {
  1147	          const data = await res.json()
  1148	          const items = (data.items || []).map((item: { id: string; menuItemId: string; name: string; price: number; quantity: number; modifiers?: { id: string; name: string; price: number }[]; specialNotes?: string; seatNumber?: number; courseNumber?: number; courseStatus?: string; isHeld?: boolean; isCompleted?: boolean; kitchenStatus?: string; status?: string; blockTimeMinutes?: number }) => ({
  1149	            id: item.id,
  1150	            menuItemId: item.menuItemId,
  1151	            name: item.name || 'Unknown',
  1152	            price: Number(item.price) || 0,
  1153	            quantity: item.quantity,
  1154	            modifiers: (item.modifiers || []).map((m: { id: string; name: string; price: number }) => ({
  1155	              id: m.id,
  1156	              name: m.name || '',
  1157	              price: Number(m.price) || 0,
  1158	            })),
  1159	            specialNotes: item.specialNotes,
  1160	            seatNumber: item.seatNumber,
  1161	            courseNumber: item.courseNumber,
  1162	            courseStatus: item.courseStatus as 'pending' | 'fired' | 'ready' | 'served' | undefined,
  1163	            isHeld: item.isHeld,
  1164	            isCompleted: item.isCompleted,
  1165	            sentToKitchen: item.kitchenStatus !== 'pending' && item.kitchenStatus !== undefined,
  1166	            status: item.status as 'active' | 'voided' | 'comped' | undefined,
  1167	            blockTimeMinutes: item.blockTimeMinutes,
  1168	          }))
  1169	          setInlineOrderItems(items)
  1170	        }
  1171	      } catch (error) {
  1172	        console.error('[FloorPlanHome] Failed to load order:', error)
  1173	      }
  1174	    } else {
  1175	      setActiveOrderId(null)
  1176	      setActiveOrderNumber(null)
  1177	      setInlineOrderItems([])
  1178	    }
  1179	  }, [selectedSeat, clearSelectedSeat, getTotalSeats, virtualCombineMode, toggleVirtualCombineSelection, virtualCombineSelectedIds.size, virtualCombinePrimaryId])
  1180	
  1181	  // Handle quick order type (Takeout, Delivery, Bar Tab)
  1182	  const handleQuickOrderType = useCallback((orderType: QuickOrderType) => {
  1183	    setActiveTableId(null)
  1184	    setActiveOrderType(orderType)
  1185	    setActiveOrderId(null)
  1186	    setActiveOrderNumber(null)
  1187	    setInlineOrderItems([])
  1188	    setShowOrderPanel(true)
  1189	  }, [])
  1190	
  1191	  // Handle menu item tap - add to order
  1192	  const handleMenuItemTap = useCallback((item: MenuItem) => {
  1193	    if (!showOrderPanel) {
  1194	      // No order panel open, open it first
  1195	      setShowOrderPanel(true)
  1196	    }
  1197	
  1198	    // Check for timed rental (entertainment) items - show rate selection modal
  1199	    if (item.itemType === 'timed_rental' && onOpenTimedRental) {
  1200	      onOpenTimedRental(item, (price: number, blockMinutes: number) => {
  1201	        const newItem: InlineOrderItem = {
  1202	          id: `temp-${crypto.randomUUID()}`,
  1203	          menuItemId: item.id,
  1204	          name: item.name,
  1205	          price: price, // Use selected rate price
  1206	          quantity: 1,
  1207	          modifiers: [],
  1208	          seatNumber: activeSeatNumber || undefined,
  1209	          sourceTableId: activeSourceTableId || undefined,
  1210	          sentToKitchen: false,
  1211	          // Store block time info for timed session
  1212	          blockTimeMinutes: blockMinutes,
  1213	        }
  1214	        setInlineOrderItems(prev => [...prev, newItem])
  1215	      })
  1216	      return
  1217	    }
  1218	
  1219	    // Check for pizza items - show pizza builder modal
  1220	    if (item.isPizza && onOpenPizzaBuilder) {
  1221	      onOpenPizzaBuilder(item, (config: PizzaOrderConfig) => {
  1222	        // Build pizza item with selections as modifiers
  1223	        // Use priceBreakdown since the global PizzaOrderConfig structure has that
  1224	        const pizzaModifiers: { id: string; name: string; price: number }[] = []
  1225	
  1226	        // Add size and crust
  1227	        pizzaModifiers.push({ id: config.sizeId, name: `Size`, price: config.priceBreakdown.sizePrice })
  1228	        pizzaModifiers.push({ id: config.crustId, name: `Crust`, price: config.priceBreakdown.crustPrice })
  1229	
  1230	        // Add sauces if present
  1231	        if (config.sauces && config.sauces.length > 0) {
  1232	          config.sauces.forEach(s => {
  1233	            pizzaModifiers.push({ id: s.sauceId, name: `${s.name} (${s.amount})`, price: s.price || 0 })
  1234	          })
  1235	        } else if (config.sauceId) {
  1236	          pizzaModifiers.push({ id: config.sauceId, name: `Sauce (${config.sauceAmount})`, price: config.priceBreakdown.saucePrice })
  1237	        }
  1238	
  1239	        // Add cheeses if present
  1240	        if (config.cheeses && config.cheeses.length > 0) {
  1241	          config.cheeses.forEach(c => {
  1242	            pizzaModifiers.push({ id: c.cheeseId, name: `${c.name} (${c.amount})`, price: c.price || 0 })
  1243	          })
  1244	        } else if (config.cheeseId) {
  1245	          pizzaModifiers.push({ id: config.cheeseId, name: `Cheese (${config.cheeseAmount})`, price: config.priceBreakdown.cheesePrice })
  1246	        }
  1247	
  1248	        // Add toppings
  1249	        config.toppings.forEach(t => {
  1250	          const sectionStr = t.sections ? `sections: ${t.sections.length}` : ''
  1251	          pizzaModifiers.push({ id: t.toppingId, name: `${t.name}${sectionStr ? ` (${sectionStr})` : ''}`, price: t.price })
  1252	        })
  1253	
  1254	        const newItem: InlineOrderItem = {
  1255	          id: `temp-${crypto.randomUUID()}`,
  1256	          menuItemId: item.id,
  1257	          name: item.name,
  1258	          price: config.totalPrice, // Use calculated pizza price
  1259	          quantity: 1,
  1260	          modifiers: pizzaModifiers,
  1261	          seatNumber: activeSeatNumber || undefined,
  1262	          sourceTableId: activeSourceTableId || undefined,
  1263	          sentToKitchen: false,
  1264	        }
  1265	        setInlineOrderItems(prev => [...prev, newItem])
  1266	      })
  1267	      return
  1268	    }
  1269	
  1270	    // If item has modifiers and callback provided, open modifier modal
  1271	    if (item.hasModifiers && onOpenModifiers) {
  1272	      onOpenModifiers(item, (modifiers) => {
  1273	        const newItem: InlineOrderItem = {
  1274	          id: `temp-${crypto.randomUUID()}`,
  1275	          menuItemId: item.id,
  1276	          name: item.name,
  1277	          price: item.price,
  1278	          quantity: 1,
  1279	          modifiers,
  1280	          seatNumber: activeSeatNumber || undefined, // Assign active seat
  1281	          sourceTableId: activeSourceTableId || undefined,
  1282	          sentToKitchen: false,
  1283	        }
  1284	        setInlineOrderItems(prev => [...prev, newItem])
  1285	      })
  1286	      return
  1287	    }
  1288	
  1289	    // Add item directly
  1290	    const newItem: InlineOrderItem = {
  1291	      id: `temp-${crypto.randomUUID()}`,
  1292	      menuItemId: item.id,
  1293	      name: item.name,
  1294	      price: item.price,
  1295	      quantity: 1,
  1296	      modifiers: [],
  1297	      seatNumber: activeSeatNumber || undefined, // Assign active seat
  1298	      sourceTableId: activeSourceTableId || undefined,
  1299	      sentToKitchen: false,
  1300	    }
  1301	    setInlineOrderItems(prev => [...prev, newItem])
  1302	
  1303	    // Haptic feedback
  1304	    if (navigator.vibrate) {
  1305	      navigator.vibrate(10)
  1306	    }
  1307	  }, [showOrderPanel, onOpenModifiers, onOpenTimedRental, onOpenPizzaBuilder, activeSeatNumber, activeSourceTableId])
  1308	
  1309	  // Handle quick bar item click - add to order
  1310	  const handleQuickBarItemClick = useCallback(async (itemId: string) => {
  1311	    // Find the item in quickBarItems to get full info
  1312	    const qbItem = quickBarItems.find(i => i.id === itemId)
  1313	    if (!qbItem) return
  1314	
  1315	    // Fetch full item details (including hasModifiers)
  1316	    try {
  1317	      const res = await fetch(`/api/menu/items/${itemId}`)
  1318	      if (!res.ok) return
  1319	
  1320	      const { item } = await res.json()
  1321	      handleMenuItemTap({
  1322	        id: item.id,
  1323	        name: item.name,
  1324	        price: Number(item.price),
  1325	        categoryId: item.categoryId,
  1326	        categoryType: item.categoryType,
  1327	        hasModifiers: item.modifierGroups?.length > 0,
  1328	        itemType: item.itemType,
  1329	        isPizza: item.isPizza,
  1330	        entertainmentStatus: item.entertainmentStatus,
  1331	        blockTimeMinutes: item.blockTimeMinutes,
  1332	        timedPricing: item.timedPricing,
  1333	      })
  1334	    } catch (error) {
  1335	      console.error('[FloorPlanHome] Quick bar item load error:', error)
  1336	    }
  1337	  }, [quickBarItems, handleMenuItemTap])
  1338	
  1339	  // Handle right-click on menu item (context menu)
  1340	  const handleMenuItemContextMenu = useCallback((e: React.MouseEvent, item: MenuItem) => {
  1341	    e.preventDefault()
  1342	    e.stopPropagation()
  1343	    setContextMenu({
  1344	      x: e.clientX,
  1345	      y: e.clientY,
  1346	      item,
  1347	    })
  1348	  }, [])
  1349	
  1350	  // Close context menu
  1351	  const closeContextMenu = useCallback(() => {
  1352	    setContextMenu(null)
  1353	  }, [])
  1354	
  1355	  // Update item quantity
  1356	  const handleUpdateQuantity = useCallback((itemId: string, quantity: number) => {
  1357	    if (quantity <= 0) {
  1358	      setInlineOrderItems(prev => prev.filter(item => item.id !== itemId))
  1359	    } else {
  1360	      setInlineOrderItems(prev =>
  1361	        prev.map(item =>
  1362	          item.id === itemId ? { ...item, quantity } : item
  1363	        )
  1364	      )
  1365	    }
  1366	  }, [])
  1367	
  1368	  // Remove item
  1369	  const handleRemoveItem = useCallback((itemId: string) => {
  1370	    setInlineOrderItems(prev => prev.filter(item => item.id !== itemId))
  1371	  }, [])
  1372	
  1373	  // Toggle hold on item
  1374	  const handleToggleHold = useCallback((itemId: string) => {
  1375	    setInlineOrderItems(prev =>
  1376	      prev.map(item =>
  1377	        item.id === itemId ? { ...item, isHeld: !item.isHeld } : item
  1378	      )
  1379	    )
  1380	  }, [])
  1381	
  1382	  // Open notes editor
  1383	  const handleOpenNotesEditor = useCallback((itemId: string, currentNotes?: string) => {
  1384	    setEditingNotesItemId(itemId)
  1385	    setEditingNotesText(currentNotes || '')
  1386	  }, [])
  1387	
  1388	  // Save notes
  1389	  const handleSaveNotes = useCallback(() => {
  1390	    if (editingNotesItemId) {
  1391	      setInlineOrderItems(prev =>
  1392	        prev.map(item =>
  1393	          item.id === editingNotesItemId
  1394	            ? { ...item, specialNotes: editingNotesText.trim() || undefined }
  1395	            : item
  1396	        )
  1397	      )
  1398	    }
  1399	    setEditingNotesItemId(null)
  1400	    setEditingNotesText('')
  1401	  }, [editingNotesItemId, editingNotesText])
  1402	
  1403	  // Update seat number
  1404	  const handleUpdateSeat = useCallback((itemId: string, seatNumber: number | null) => {
  1405	    setInlineOrderItems(prev =>
  1406	      prev.map(item =>
  1407	        item.id === itemId
  1408	          ? { ...item, seatNumber: seatNumber || undefined }
  1409	          : item
  1410	      )
  1411	    )
  1412	  }, [])
  1413	
  1414	  // Add a new seat to the table (Skill 121 - Atomic Seat Management)
  1415	  // Works with or without an active order
  1416	  const handleAddSeat = useCallback(async (tableId?: string) => {
  1417	    const targetTableId = tableId || activeTable?.id
  1418	    if (!targetTableId) {
  1419	      toast.error('No table selected')
  1420	      return
  1421	    }
  1422	
  1423	    // If there's an active order, add seat via API
  1424	    if (activeOrderId) {
  1425	      try {
  1426	        const response = await fetch(`/api/orders/${activeOrderId}/seating`, {
  1427	          method: 'POST',
  1428	          headers: { 'Content-Type': 'application/json' },
  1429	          body: JSON.stringify({
  1430	            action: 'INSERT',
  1431	            position: getTotalSeats(activeTable) + 1, // Add at the end
  1432	          }),
  1433	        })
  1434	
  1435	        if (!response.ok) {
  1436	          const data = await response.json()
  1437	          throw new Error(data.error || 'Failed to add seat')
  1438	        }
  1439	
  1440	        const result = await response.json()
  1441	        toast.success(`Seat ${result.position} added`)
  1442	
  1443	        // Refresh the order to get updated seat count
  1444	        const orderResponse = await fetch(`/api/orders/${activeOrderId}`)
  1445	        if (orderResponse.ok) {
  1446	          // Force a refresh by updating the state
  1447	          setRefreshKey(prev => prev + 1)
  1448	        }
  1449	      } catch (err) {
  1450	        console.error('[FloorPlanHome] Failed to add seat:', err)
  1451	        toast.error(err instanceof Error ? err.message : 'Failed to add seat')
  1452	      }
  1453	    } else {
  1454	      // No active order - add a virtual seat locally
  1455	      setExtraSeats(prev => {
  1456	        const next = new Map(prev)
  1457	        const current = next.get(targetTableId) || 0
  1458	        next.set(targetTableId, current + 1)
  1459	        return next
  1460	      })
  1461	      // Use getTotalSeats for combined tables (8+5=13, so new seat is 14)
  1462	      const newSeatNum = getTotalSeats(activeTable!) + 1
  1463	      toast.success(`Seat ${newSeatNum} added`)
  1464	    }
  1465	  }, [activeOrderId, activeTable, getTotalSeats])
  1466	
  1467	  // Update course number
  1468	  const handleUpdateCourse = useCallback((itemId: string, courseNumber: number | null) => {
  1469	    setInlineOrderItems(prev =>
  1470	      prev.map(item =>
  1471	        item.id === itemId
  1472	          ? { ...item, courseNumber: courseNumber || undefined }
  1473	          : item
  1474	      )
  1475	    )
  1476	  }, [])
  1477	
  1478	  // Toggle item controls expansion
  1479	  const handleToggleItemControls = useCallback((itemId: string) => {
  1480	    setExpandedItemId(prev => prev === itemId ? null : itemId)
  1481	  }, [])
  1482	
  1483	  // Edit item (reopen modifiers)
  1484	  const handleEditItem = useCallback((item: InlineOrderItem) => {
  1485	    // Find the menu item to get its data
  1486	    const menuItem = menuItems.find(mi => mi.id === item.menuItemId)
  1487	    if (!menuItem) return
  1488	
  1489	    if (onOpenModifiers) {
  1490	      onOpenModifiers(menuItem, (newModifiers) => {
  1491	        setInlineOrderItems(prev =>
  1492	          prev.map(i =>
  1493	            i.id === item.id
  1494	              ? { ...i, modifiers: newModifiers }
  1495	              : i
  1496	          )
  1497	        )
  1498	      }, item.modifiers)
  1499	    }
  1500	  }, [menuItems, onOpenModifiers])
  1501	
  1502	  // Send order to kitchen
  1503	  const handleSendToKitchen = useCallback(async () => {
  1504	    // FIX 2: Race condition prevention - immediate gate catches double-taps
  1505	    if (isProcessingSendRef.current || inlineOrderItems.length === 0) return
  1506	
  1507	    // Filter out held items and already-sent items
  1508	    const unsavedItems = inlineOrderItems.filter(item => !item.sentToKitchen && !item.isHeld)
  1509	    if (unsavedItems.length === 0) return
  1510	
  1511	    isProcessingSendRef.current = true  // Set BEFORE any async work
  1512	    setIsSendingOrder(true)
  1513	
  1514	    try {
  1515	      let orderId = activeOrderId
  1516	
  1517	      // FIX 1: Use correlationId pattern to properly match items back
  1518	      // The temp item.id serves as a unique correlationId for each item
  1519	      const itemsPayload = unsavedItems.map(item => ({
  1520	        menuItemId: item.menuItemId,
  1521	        correlationId: item.id, // Use temp ID as unique anchor for matching
  1522	        name: item.name,
  1523	        price: item.price,
  1524	        quantity: item.quantity,
  1525	        modifiers: item.modifiers?.map(m => ({
  1526	          modifierId: m.id,
  1527	          name: m.name,
  1528	          price: m.price,
  1529	        })) || [],
  1530	        seatNumber: item.seatNumber,
  1531	        courseNumber: item.courseNumber,
  1532	        specialNotes: item.specialNotes,
  1533	        blockTimeMinutes: item.blockTimeMinutes, // For timed rental items
  1534	      }))
  1535	
  1536	      if (!orderId) {
  1537	        // Create new order
  1538	        const createRes = await fetch('/api/orders', {
  1539	          method: 'POST',
  1540	          headers: { 'Content-Type': 'application/json' },
  1541	          body: JSON.stringify({
  1542	            locationId,
  1543	            employeeId,
  1544	            tableId: activeTableId || undefined,
  1545	            orderType: activeOrderType || 'dine_in',
  1546	            items: itemsPayload,
  1547	          }),
  1548	        })
  1549	
  1550	        if (createRes.ok) {
  1551	          const data = await createRes.json()
  1552	          orderId = data.id
  1553	          setActiveOrderId(orderId)
  1554	          setActiveOrderNumber(String(data.orderNumber))
  1555	
  1556	          // Clear extra virtual seats for this table since they're now part of the order
  1557	          if (activeTableId) {
  1558	            setExtraSeats(prev => {
  1559	              const next = new Map(prev)
  1560	              next.delete(activeTableId)
  1561	              return next
  1562	            })
  1563	          }
  1564	
  1565	          // Match using correlationId - prevents ghost ID issues with identical items
  1566	          if (data.items && data.items.length > 0) {
  1567	            const serverItems = data.items as { id: string; correlationId?: string; menuItemId: string; name: string }[]
  1568	            setInlineOrderItems(prev => prev.map(localItem => {
  1569	              // First try matching by correlationId (reliable)
  1570	              const matchByCorrelation = serverItems.find(s => s.correlationId === localItem.id)
  1571	              if (matchByCorrelation) {
  1572	                return { ...localItem, id: matchByCorrelation.id }
  1573	              }
  1574	              // Fallback for older API: match by temp prefix + menuItemId + name
  1575	              if (localItem.id.startsWith('temp-')) {
  1576	                const matchByLegacy = serverItems.find(
  1577	                  s => s.menuItemId === localItem.menuItemId && s.name === localItem.name
  1578	                )
  1579	                if (matchByLegacy) {
  1580	                  return { ...localItem, id: matchByLegacy.id }
  1581	                }
  1582	              }
  1583	              return localItem
  1584	            }))
  1585	          }
  1586	        } else {
  1587	          const errorData = await createRes.json().catch(() => ({}))
  1588	          console.error('[FloorPlanHome] Create order failed:', errorData)
  1589	          toast.error('Failed to create order. Please try again.')
  1590	          throw new Error('Failed to create order')
  1591	        }
  1592	      } else {
  1593	        // Add items to existing order - use POST to append atomically
  1594	        const appendRes = await fetch(`/api/orders/${orderId}/items`, {
  1595	          method: 'POST',
  1596	          headers: { 'Content-Type': 'application/json' },
  1597	          body: JSON.stringify({ items: itemsPayload }),
  1598	        })
  1599	
  1600	        const appendData = await appendRes.json().catch(() => ({}))
  1601	
  1602	        if (!appendRes.ok) {
  1603	          console.error('[FloorPlanHome] Append items failed:', appendData)
  1604	          toast.error('Failed to add items to order. Please try again.')
  1605	          throw new Error('Failed to add items to order')
  1606	        }
  1607	
  1608	        // Match using correlationId - prevents ghost ID issues with identical items
  1609	        if (appendData?.addedItems && appendData.addedItems.length > 0) {
  1610	          const addedItems = appendData.addedItems as { id: string; correlationId?: string; name: string }[]
  1611	          setInlineOrderItems(prev => prev.map(localItem => {
  1612	            // First try matching by correlationId (reliable)
  1613	            const matchByCorrelation = addedItems.find(s => s.correlationId === localItem.id)
  1614	            if (matchByCorrelation) {
  1615	              return { ...localItem, id: matchByCorrelation.id }
  1616	            }
  1617	            // Fallback for older API: match by temp prefix + name
  1618	            if (localItem.id.startsWith('temp-')) {
  1619	              const matchByLegacy = addedItems.find(s => s.name === localItem.name)
  1620	              if (matchByLegacy) {
  1621	                return { ...localItem, id: matchByLegacy.id }
  1622	              }
  1623	            }
  1624	            return localItem
  1625	          }))
  1626	        }
  1627	      }
  1628	
  1629	      // Send to kitchen
  1630	      if (orderId) {
  1631	        const sendRes = await fetch(`/api/orders/${orderId}/send`, { method: 'POST' })
  1632	        if (!sendRes.ok) {
  1633	          const errorData = await sendRes.json().catch(() => ({}))
  1634	          console.error('[FloorPlanHome] Send to kitchen failed:', errorData)
  1635	          // Don't throw - order is saved, just printing/kitchen send failed
  1636	          toast.warning('Order saved but failed to send to kitchen. Check printer connection.')
  1637	        } else {
  1638	          toast.success('Order sent to kitchen')
  1639	        }
  1640	      }
  1641	
  1642	      // Mark non-held items as sent
  1643	      setInlineOrderItems(prev =>
  1644	        prev.map(item =>
  1645	          item.isHeld ? item : { ...item, sentToKitchen: true }
  1646	        )
  1647	      )
  1648	
  1649	      // Refresh data (without showing loading indicator)
  1650	      loadFloorPlanData(false)
  1651	      loadOpenOrdersCount()
  1652	
  1653	    } catch (error) {
  1654	      console.error('[FloorPlanHome] Failed to send order:', error)
  1655	      toast.error('Failed to send order. Please try again.')
  1656	    } finally {
  1657	      isProcessingSendRef.current = false
  1658	      setIsSendingOrder(false)
  1659	    }
  1660	  }, [activeTableId, activeOrderId, activeOrderType, inlineOrderItems, locationId, employeeId])
  1661	
  1662	  // Open payment
  1663	  const handleOpenPayment = useCallback(() => {
  1664	    if (activeOrderId && onOpenPayment) {
  1665	      onOpenPayment(activeOrderId)
  1666	    }
  1667	  }, [activeOrderId, onOpenPayment])
  1668	
  1669	  // Close order panel
  1670	  const handleCloseOrderPanel = useCallback(() => {
  1671	    // Clear dependent state FIRST
  1672	    setInlineOrderItems([])
  1673	    setActiveOrderId(null)
  1674	    setActiveOrderNumber(null)
  1675	    setActiveOrderType(null)
  1676	    setExpandedItemId(null)
  1677	    setEditingNotesItemId(null)
  1678	    setEditingNotesText('')
  1679	    setGuestCount(defaultGuestCount)
  1680	    setActiveSeatNumber(null)
  1681	    setActiveSourceTableId(null)
  1682	
  1683	    // Clear primary state LAST
  1684	    setActiveTableId(null)
  1685	    setShowOrderPanel(false)
  1686	  }, [defaultGuestCount])
  1687	
  1688	  // Payment mode state (cash or card)
  1689	  const [paymentMode, setPaymentMode] = useState<'cash' | 'card'>('cash')
  1690	  const [showTotalDetails, setShowTotalDetails] = useState(false)
  1691	
  1692	  // Calculate order subtotal
  1693	  const orderSubtotal = inlineOrderItems.reduce((sum, item) => {
  1694	    const itemTotal = item.price * item.quantity
  1695	    const modifiersTotal = (item.modifiers || []).reduce((mSum, m) => mSum + m.price, 0) * item.quantity
  1696	    return sum + itemTotal + modifiersTotal
  1697	  }, 0)
  1698	
  1699	  // Tax rate (TODO: make this configurable per location)
  1700	  const TAX_RATE = 0.08
  1701	  const CASH_DISCOUNT_RATE = 0.04
  1702	
  1703	  // Calculate totals
  1704	  const cashDiscount = paymentMode === 'cash' ? orderSubtotal * CASH_DISCOUNT_RATE : 0
  1705	  const taxableAmount = orderSubtotal - cashDiscount
  1706	  const tax = taxableAmount * TAX_RATE
  1707	  const orderTotal = taxableAmount + tax
  1708	  const cardTotal = (orderSubtotal * (1 + TAX_RATE))
  1709	
  1710	  // Get primary tables for combined groups
  1711	  const primaryTables = tables.filter(
  1712	    t => t.combinedTableIds && t.combinedTableIds.length > 0
  1713	  )
  1714	
  1715	  // Build connection lines between combined tables
  1716	  const connectionLines = primaryTables.flatMap(primary => {
  1717	    const connectedIds = primary.combinedTableIds || []
  1718	    const groupColor = getCombinedGroupColor(primary.id)
  1719	
  1720	    return connectedIds.map(connectedId => {
  1721	      const connected = tables.find(t => t.id === connectedId)
  1722	      if (!connected) return null
  1723	
  1724	      const primaryCenterX = primary.posX + primary.width / 2
  1725	      const primaryCenterY = primary.posY + primary.height / 2
  1726	      const connectedCenterX = connected.posX + connected.width / 2
  1727	      const connectedCenterY = connected.posY + connected.height / 2
  1728	
  1729	      const dx = connectedCenterX - primaryCenterX
  1730	      const dy = connectedCenterY - primaryCenterY
  1731	
  1732	      let x1: number, y1: number, x2: number, y2: number
  1733	
  1734	      if (Math.abs(dx) > Math.abs(dy)) {
  1735	        if (dx > 0) {
  1736	          x1 = primary.posX + primary.width
  1737	          y1 = primary.posY + primary.height / 2
  1738	          x2 = connected.posX
  1739	          y2 = connected.posY + connected.height / 2
  1740	        } else {
  1741	          x1 = primary.posX
  1742	          y1 = primary.posY + primary.height / 2
  1743	          x2 = connected.posX + connected.width
  1744	          y2 = connected.posY + connected.height / 2
  1745	        }
  1746	      } else {
  1747	        if (dy > 0) {
  1748	          x1 = primary.posX + primary.width / 2
  1749	          y1 = primary.posY + primary.height
  1750	          x2 = connected.posX + connected.width / 2
  1751	          y2 = connected.posY
  1752	        } else {
  1753	          x1 = primary.posX + primary.width / 2
  1754	          y1 = primary.posY
  1755	          x2 = connected.posX + connected.width / 2
  1756	          y2 = connected.posY + connected.height
  1757	        }
  1758	      }
  1759	
  1760	      return { id: `${primary.id}-${connectedId}`, x1, y1, x2, y2, color: groupColor }
  1761	    }).filter(Boolean)
  1762	  }) as { id: string; x1: number; y1: number; x2: number; y2: number; color: string }[]
  1763	
  1764	  // Build combined group colors map
  1765	  const combinedGroupColors = new Map<string, string>()
  1766	  for (const primary of primaryTables) {
  1767	    const color = getCombinedGroupColor(primary.id)
  1768	    combinedGroupColors.set(primary.id, color)
  1769	    const childIds = primary.combinedTableIds || []
  1770	    for (const childId of childIds) {
  1771	      combinedGroupColors.set(childId, color)
  1772	    }
  1773	  }
  1774	
  1775	  // Note: Ghost preview calculation is now handled by useFloorPlanDrag hook
  1776	
  1777	  // Handle table combine
  1778	  const handleTableCombine = useCallback(async (
  1779	    sourceId: string,
  1780	    targetId: string,
  1781	    dropPosition?: { x: number; y: number }
  1782	  ) => {
  1783	    try {
  1784	      // FIX: Use tablesRef.current to get latest table positions (avoids stale closure)
  1785	      const allTablesData = tablesRef.current.map(t => ({
  1786	        id: t.id,
  1787	        posX: t.posX,
  1788	        posY: t.posY,
  1789	        width: t.width,
  1790	        height: t.height,
  1791	      }))
  1792	
  1793	      const payload = {
  1794	        sourceTableId: sourceId,
  1795	        targetTableId: targetId,
  1796	        locationId,
  1797	        employeeId,
  1798	        dropX: dropPosition?.x,
  1799	        dropY: dropPosition?.y,
  1800	        allTables: allTablesData,
  1801	      }
  1802	
  1803	      // Debug: Log request payload to identify missing fields
  1804	      console.log('[FloorPlanHome] Combine request:', {
  1805	        sourceId,
  1806	        targetId,
  1807	        locationId: locationId || 'MISSING!',
  1808	        employeeId: employeeId || 'MISSING!',
  1809	        dropPosition,
  1810	        tablesCount: allTablesData.length
  1811	      })
  1812	
  1813	      const res = await fetch('/api/tables/combine', {
  1814	        method: 'POST',
  1815	        headers: { 'Content-Type': 'application/json' },
  1816	        body: JSON.stringify(payload),
  1817	      })
  1818	
  1819	      if (res.ok) {
  1820	        addUndoAction({
  1821	          type: 'combine',
  1822	          sourceTableId: sourceId,
  1823	          targetTableId: targetId,
  1824	          timestamp: Date.now(),
  1825	        })
  1826	        // Await data refresh to prevent stale table data when user taps combined table
  1827	        await loadFloorPlanData()
  1828	        return true
  1829	      } else {
  1830	        // Log the error response for debugging - capture raw text first
  1831	        const rawText = await res.text()
  1832	        console.error('[FloorPlanHome] Combine failed:', res.status, 'Raw response:', rawText)
  1833	        let errorData: { error?: string; details?: string } = {}
  1834	        try {
  1835	          errorData = JSON.parse(rawText)
  1836	        } catch {
  1837	          console.error('[FloorPlanHome] Response was not JSON')
  1838	        }
  1839	        toast.error(`Failed to combine tables: ${errorData.details || errorData.error || 'Unknown error'}`)
  1840	      }
  1841	      return false
  1842	    } catch (error) {
  1843	      console.error('[FloorPlanHome] Combine error:', error)
  1844	      toast.error('Failed to combine tables. Please try again.')
  1845	      return false
  1846	    }
  1847	  }, [locationId, employeeId, addUndoAction])
  1848	  // Note: Using tablesRef.current instead of tables in dependency array
  1849	
  1850	  // Handle reset to default
  1851	  const handleResetToDefault = useCallback(async (tableIds: string[]) => {
  1852	    try {
  1853	      const res = await fetch('/api/tables/reset-to-default', {
  1854	        method: 'POST',
  1855	        headers: { 'Content-Type': 'application/json' },
  1856	        body: JSON.stringify({
  1857	          tableIds,
  1858	          locationId,
  1859	          employeeId,
  1860	        }),
  1861	      })
  1862	
  1863	      if (res.ok) {
  1864	        const result = await res.json()
  1865	        if (result.data?.skippedTableIds?.length > 0) {
  1866	          for (const tableId of result.data.skippedTableIds) {
  1867	            flashTableMessage(tableId, 'OPEN ORDER', 3000)
  1868	          }
  1869	        }
  1870	        // FIX: Await data refresh to ensure positions are loaded before continuing
  1871	        await loadFloorPlanData()
  1872	        closeInfoPanel()
  1873	        return true
  1874	      }
  1875	      return false
  1876	    } catch (error) {
  1877	      console.error('[FloorPlanHome] Reset error:', error)
  1878	      return false
  1879	    }
  1880	  }, [locationId, employeeId, closeInfoPanel, flashTableMessage])
  1881	
  1882	  // Handle status update
  1883	  const handleUpdateStatus = useCallback(async (tableId: string, status: string) => {
  1884	    try {
  1885	      await fetch(`/api/tables/${tableId}`, {
  1886	        method: 'PUT',
  1887	        headers: { 'Content-Type': 'application/json' },
  1888	        body: JSON.stringify({ status }),
  1889	      })
  1890	      loadFloorPlanData()
  1891	    } catch (error) {
  1892	      console.error('Failed to update status:', error)
  1893	    }
  1894	  }, [])
  1895	
  1896	  // Handle undo - removes the last table added to a combined group
  1897	  const handleUndo = useCallback(async () => {
  1898	    const action = popUndoAction()
  1899	    if (!action) return
  1900	
  1901	    if (action.type === 'combine') {
  1902	      // Remove just the source table (the one that was added) from the group
  1903	      // This is different from split which breaks apart ALL tables
  1904	      const res = await fetch(`/api/tables/${action.sourceTableId}/remove-from-group`, {
  1905	        method: 'POST',
  1906	        headers: { 'Content-Type': 'application/json' },
  1907	        body: JSON.stringify({
  1908	          locationId,
  1909	          employeeId,
  1910	        }),
  1911	      })
  1912	
  1913	      if (!res.ok) {
  1914	        const error = await res.json().catch(() => ({}))
  1915	        console.error('[Undo] Failed to remove table from group:', error)
  1916	      }
  1917	
  1918	      // Await data refresh to prevent stale table data
  1919	      await loadFloorPlanData()
  1920	    }
  1921	  }, [popUndoAction, locationId, employeeId, loadFloorPlanData])
  1922	
  1923	  // Handle seat tap - sync both visual selection and order panel seat
  1924	  // FIX: Uses tablesRef.current to always access latest tables data (avoids stale closure)
  1925	  const handleSeatTap = useCallback((tableId: string, seatNumber: number) => {
  1926	    // For combined tables, always use the primary table ID for consistency
  1927	    // This ensures order panel and table visual stay in sync
  1928	    const table = tablesRef.current.find(t => t.id === tableId)
  1929	    const effectiveTableId = table?.combinedWithId || tableId
  1930	    const isCombinedGroup = Boolean(table?.combinedWithId || table?.combinedTableIds?.length)
  1931	    const isVirtualGroup = Boolean(table?.virtualGroupId)
  1932	
  1933	    // For combined groups, just check seatNumber since seats are sequential across tables
  1934	    // For single tables, check both tableId and seatNumber
  1935	    const isAlreadySelected = isCombinedGroup
  1936	      ? selectedSeat?.seatNumber === seatNumber
  1937	      : selectedSeat?.tableId === effectiveTableId && selectedSeat?.seatNumber === seatNumber
  1938	
  1939	    if (isAlreadySelected) {
  1940	      // Deselecting - clear both
  1941	      clearSelectedSeat()
  1942	      setActiveSeatNumber(null)
  1943	      setActiveSourceTableId(null)
  1944	    } else {
  1945	      // Selecting - update both
  1946	      selectSeat(effectiveTableId, seatNumber)
  1947	      setActiveSeatNumber(seatNumber)
  1948	      // For virtual groups, track which table the seat belongs to
  1949	      setActiveSourceTableId(isVirtualGroup ? tableId : effectiveTableId)
  1950	    }
  1951	  }, [selectedSeat, selectSeat, clearSelectedSeat])
  1952	  // Note: Using tablesRef.current instead of tables in dependency array
  1953	
  1954	  // Drag handlers hook (handles pointer move/up and ghost preview)
  1955	  const {
  1956	    handlePointerMove,
  1957	    handlePointerUp,
  1958	    ghostPreview,
  1959	    isColliding,
  1960	  } = useFloorPlanDrag({
  1961	    containerRef,
  1962	    tablesRef,
  1963	    fixturesRef,
  1964	    autoScaleRef,
  1965	    autoScaleOffsetRef,
  1966	    draggedTableId,
  1967	    dropTargetTableId,
  1968	    updateDragTarget,
  1969	    endDrag,
  1970	    onCombine: handleTableCombine,
  1971	  })
  1972	
  1973	  // Keyboard shortcuts
  1974	  useEffect(() => {
  1975	    const handleKeyDown = (e: KeyboardEvent) => {
  1976	      if (e.key === 'Escape') {
  1977	        if (viewMode === 'menu') {
  1978	          // Escape in menu mode goes back to tables
  1979	          setSelectedCategoryId(null)
  1980	          setViewMode('tables')
  1981	          setMenuItems([])
  1982	        } else {
  1983	          closeInfoPanel()
  1984	          selectTable(null)
  1985	          handleCloseOrderPanel()
  1986	        }
  1987	      }
  1988	      if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
  1989	        e.preventDefault()
  1990	        handleUndo()
  1991	      }
  1992	    }
  1993	
  1994	    window.addEventListener('keydown', handleKeyDown)
  1995	    return () => window.removeEventListener('keydown', handleKeyDown)
  1996	  }, [viewMode, closeInfoPanel, selectTable, handleUndo, handleCloseOrderPanel])
  1997	
  1998	  // Close employee dropdown when clicking outside
  1999	  useEffect(() => {
  2000	    const handleClickOutside = () => setShowEmployeeDropdown(false)
  2001	    if (showEmployeeDropdown) {
  2002	      document.addEventListener('click', handleClickOutside)
  2003	      return () => document.removeEventListener('click', handleClickOutside)
  2004	    }
  2005	  }, [showEmployeeDropdown])
  2006	
  2007	  // Close settings dropdown when clicking outside
  2008	  useEffect(() => {
  2009	    const handleClickOutside = () => setShowSettingsDropdown(false)
  2010	    if (showSettingsDropdown) {
  2011	      document.addEventListener('click', handleClickOutside)
  2012	      return () => document.removeEventListener('click', handleClickOutside)
  2013	    }
  2014	  }, [showSettingsDropdown])
  2015	
  2016	  const selectedCategory = categories.find(c => c.id === selectedCategoryId)
  2017	
  2018	  return (
  2019	    <div className={`floor-plan-container floor-plan-home ${virtualCombineMode ? 'virtual-combine-mode' : ''}`}>
  2020	      {/* Header */}
  2021	      <header className="floor-plan-header">
  2022	        <div className="floor-plan-header-left">
  2023	          {/* Employee Menu Dropdown */}
  2024	          <div style={{ position: 'relative', zIndex: 100 }}>
  2025	            <button
  2026	              className="employee-dropdown-trigger"
  2027	              onClick={(e) => {
  2028	                e.stopPropagation()
  2029	                setShowEmployeeDropdown(!showEmployeeDropdown)
  2030	              }}
  2031	              style={{
  2032	                display: 'flex',
  2033	                alignItems: 'center',
  2034	                gap: '8px',
  2035	                padding: '8px 12px',
  2036	                background: 'rgba(255, 255, 255, 0.05)',
  2037	                border: '1px solid rgba(255, 255, 255, 0.1)',
  2038	                borderRadius: '10px',
  2039	                color: '#f1f5f9',
  2040	                cursor: 'pointer',
  2041	                fontSize: '14px',
  2042	                fontWeight: 500,
  2043	              }}
  2044	            >
  2045	              <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2046	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
  2047	              </svg>
  2048	              <span>{employeeName}</span>
  2049	              <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ opacity: 0.6 }}>
  2050	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
  2051	              </svg>
  2052	            </button>
  2053	
  2054	            {/* Dropdown Menu */}
  2055	            <AnimatePresence>
  2056	              {showEmployeeDropdown && (
  2057	                <motion.div
  2058	                  initial={{ opacity: 0, y: -10 }}
  2059	                  animate={{ opacity: 1, y: 0 }}
  2060	                  exit={{ opacity: 0, y: -10 }}
  2061	                  style={{
  2062	                    position: 'absolute',
  2063	                    top: '100%',
  2064	                    left: 0,
  2065	                    marginTop: '4px',
  2066	                    minWidth: '200px',
  2067	                    background: 'rgba(15, 23, 42, 0.98)',
  2068	                    border: '1px solid rgba(255, 255, 255, 0.1)',
  2069	                    borderRadius: '12px',
  2070	                    padding: '8px 0',
  2071	                    boxShadow: '0 10px 40px rgba(0, 0, 0, 0.5)',
  2072	                    zIndex: 1000,
  2073	                  }}
  2074	                  onClick={(e) => e.stopPropagation()}
  2075	                >
  2076	                  {/* Employee Info */}
  2077	                  <div style={{ padding: '12px 16px', borderBottom: '1px solid rgba(255, 255, 255, 0.1)' }}>
  2078	                    <div style={{ fontSize: '14px', fontWeight: 600, color: '#f1f5f9' }}>{employeeName}</div>
  2079	                    {employeeRole && (
  2080	                      <div style={{ fontSize: '12px', color: '#64748b', marginTop: '2px' }}>{employeeRole}</div>
  2081	                    )}
  2082	                  </div>
  2083	
  2084	                  {/* Menu Items */}
  2085	                  <div style={{ padding: '4px 0' }}>
  2086	                    {onSwitchUser && (
  2087	                      <button
  2088	                        onClick={() => {
  2089	                          setShowEmployeeDropdown(false)
  2090	                          onSwitchUser()
  2091	                        }}
  2092	                        style={{
  2093	                          display: 'flex',
  2094	                          alignItems: 'center',
  2095	                          gap: '10px',
  2096	                          width: '100%',
  2097	                          padding: '10px 16px',
  2098	                          background: 'transparent',
  2099	                          border: 'none',
  2100	                          color: '#e2e8f0',
  2101	                          fontSize: '13px',
  2102	                          cursor: 'pointer',
  2103	                          textAlign: 'left',
  2104	                        }}
  2105	                        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
  2106	                        onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2107	                      >
  2108	                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2109	                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
  2110	                        </svg>
  2111	                        Switch User
  2112	                      </button>
  2113	                    )}
  2114	
  2115	                    {onOpenSettings && (
  2116	                      <button
  2117	                        onClick={() => {
  2118	                          setShowEmployeeDropdown(false)
  2119	                          onOpenSettings()
  2120	                        }}
  2121	                        style={{
  2122	                          display: 'flex',
  2123	                          alignItems: 'center',
  2124	                          gap: '10px',
  2125	                          width: '100%',
  2126	                          padding: '10px 16px',
  2127	                          background: 'transparent',
  2128	                          border: 'none',
  2129	                          color: '#e2e8f0',
  2130	                          fontSize: '13px',
  2131	                          cursor: 'pointer',
  2132	                          textAlign: 'left',
  2133	                        }}
  2134	                        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
  2135	                        onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2136	                      >
  2137	                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2138	                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
  2139	                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  2140	                        </svg>
  2141	                        Settings
  2142	                      </button>
  2143	                    )}
  2144	
  2145	                    {onSwitchToBartenderView && (
  2146	                      <button
  2147	                        onClick={() => {
  2148	                          setShowEmployeeDropdown(false)
  2149	                          onSwitchToBartenderView()
  2150	                        }}
  2151	                        style={{
  2152	                          display: 'flex',
  2153	                          alignItems: 'center',
  2154	                          gap: '10px',
  2155	                          width: '100%',
  2156	                          padding: '10px 16px',
  2157	                          background: 'transparent',
  2158	                          border: 'none',
  2159	                          color: '#818cf8',
  2160	                          fontSize: '13px',
  2161	                          cursor: 'pointer',
  2162	                          textAlign: 'left',
  2163	                        }}
  2164	                        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
  2165	                        onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2166	                      >
  2167	                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2168	                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
  2169	                        </svg>
  2170	                        Bar Mode
  2171	                      </button>
  2172	                    )}
  2173	
  2174	                    <div style={{ height: '1px', background: 'rgba(255, 255, 255, 0.1)', margin: '4px 0' }} />
  2175	
  2176	                    <button
  2177	                      onClick={() => {
  2178	                        setShowEmployeeDropdown(false)
  2179	                        onLogout()
  2180	                      }}
  2181	                      style={{
  2182	                        display: 'flex',
  2183	                        alignItems: 'center',
  2184	                        gap: '10px',
  2185	                        width: '100%',
  2186	                        padding: '10px 16px',
  2187	                        background: 'transparent',
  2188	                        border: 'none',
  2189	                        color: '#f87171',
  2190	                        fontSize: '13px',
  2191	                        cursor: 'pointer',
  2192	                        textAlign: 'left',
  2193	                      }}
  2194	                      onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
  2195	                      onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2196	                    >
  2197	                      <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2198	                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
  2199	                      </svg>
  2200	                      Clock Out
  2201	                    </button>
  2202	                  </div>
  2203	                </motion.div>
  2204	              )}
  2205	            </AnimatePresence>
  2206	          </div>
  2207	
  2208	          {/* Quick Order Type Buttons */}
  2209	          <div style={{ display: 'flex', gap: '8px', marginLeft: '16px' }}>
  2210	            {/* Tables Button - Returns to floor plan view */}
  2211	            <button
  2212	              onClick={() => {
  2213	                setViewMode('tables')
  2214	                setSelectedCategoryId(null)
  2215	              }}
  2216	              style={{
  2217	                display: 'flex',
  2218	                alignItems: 'center',
  2219	                gap: '6px',
  2220	                padding: '8px 14px',
  2221	                background: viewMode === 'tables' && !activeOrderType ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
  2222	                border: `1px solid ${viewMode === 'tables' && !activeOrderType ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
  2223	                borderRadius: '8px',
  2224	                color: viewMode === 'tables' && !activeOrderType ? '#a5b4fc' : '#94a3b8',
  2225	                fontSize: '13px',
  2226	                fontWeight: 500,
  2227	                cursor: 'pointer',
  2228	              }}
  2229	            >
  2230	              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2231	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
  2232	              </svg>
  2233	              Tables
  2234	            </button>
  2235	
  2236	            <button
  2237	              onClick={() => handleQuickOrderType('takeout')}
  2238	              style={{
  2239	                display: 'flex',
  2240	                alignItems: 'center',
  2241	                gap: '6px',
  2242	                padding: '8px 14px',
  2243	                background: activeOrderType === 'takeout' ? 'rgba(34, 197, 94, 0.2)' : 'rgba(255, 255, 255, 0.03)',
  2244	                border: `1px solid ${activeOrderType === 'takeout' ? 'rgba(34, 197, 94, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
  2245	                borderRadius: '8px',
  2246	                color: activeOrderType === 'takeout' ? '#86efac' : '#94a3b8',
  2247	                fontSize: '13px',
  2248	                fontWeight: 500,
  2249	                cursor: 'pointer',
  2250	              }}
  2251	            >
  2252	              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2253	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8" />
  2254	              </svg>
  2255	              Takeout
  2256	            </button>
  2257	
  2258	            <button
  2259	              onClick={() => handleQuickOrderType('delivery')}
  2260	              style={{
  2261	                display: 'flex',
  2262	                alignItems: 'center',
  2263	                gap: '6px',
  2264	                padding: '8px 14px',
  2265	                background: activeOrderType === 'delivery' ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
  2266	                border: `1px solid ${activeOrderType === 'delivery' ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
  2267	                borderRadius: '8px',
  2268	                color: activeOrderType === 'delivery' ? '#a5b4fc' : '#94a3b8',
  2269	                fontSize: '13px',
  2270	                fontWeight: 500,
  2271	                cursor: 'pointer',
  2272	              }}
  2273	            >
  2274	              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2275	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16V6a1 1 0 00-1-1H4a1 1 0 00-1 1v10a1 1 0 001 1h1m8-1a1 1 0 01-1 1H9m4-1V8a1 1 0 011-1h2.586a1 1 0 01.707.293l3.414 3.414a1 1 0 01.293.707V16a1 1 0 01-1 1h-1m-6-1a1 1 0 001 1h1M5 17a2 2 0 104 0m-4 0a2 2 0 114 0m6 0a2 2 0 104 0m-4 0a2 2 0 114 0" />
  2276	              </svg>
  2277	              Delivery
  2278	            </button>
  2279	
  2280	            {onSwitchToBartenderView && (
  2281	              <button
  2282	                onClick={() => onSwitchToBartenderView()}
  2283	                style={{
  2284	                  display: 'flex',
  2285	                  alignItems: 'center',
  2286	                  gap: '6px',
  2287	                  padding: '8px 14px',
  2288	                  background: 'rgba(255, 255, 255, 0.03)',
  2289	                  border: '1px solid rgba(255, 255, 255, 0.08)',
  2290	                  borderRadius: '8px',
  2291	                  color: '#94a3b8',
  2292	                  fontSize: '13px',
  2293	                  fontWeight: 500,
  2294	                  cursor: 'pointer',
  2295	                }}
  2296	              >
  2297	                <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2298	                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
  2299	                </svg>
  2300	                Bar Mode
  2301	              </button>
  2302	            )}
  2303	
  2304	            {/* Gear Settings Button */}
  2305	            <div style={{ position: 'relative', marginLeft: '8px' }}>
  2306	              <button
  2307	                onClick={(e) => {
  2308	                  e.stopPropagation()
  2309	                  setShowSettingsDropdown(!showSettingsDropdown)
  2310	                }}
  2311	                style={{
  2312	                  display: 'flex',
  2313	                  alignItems: 'center',
  2314	                  justifyContent: 'center',
  2315	                  padding: '8px',
  2316	                  background: showSettingsDropdown ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
  2317	                  border: `1px solid ${showSettingsDropdown ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
  2318	                  borderRadius: '8px',
  2319	                  color: showSettingsDropdown ? '#a5b4fc' : '#94a3b8',
  2320	                  cursor: 'pointer',
  2321	                }}
  2322	                title="Layout Settings"
  2323	              >
  2324	                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2325	                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
  2326	                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  2327	                </svg>
  2328	              </button>
  2329	
  2330	              {/* Settings Dropdown */}
  2331	              <AnimatePresence>
  2332	                {showSettingsDropdown && (
  2333	                  <motion.div
  2334	                    initial={{ opacity: 0, y: -10 }}
  2335	                    animate={{ opacity: 1, y: 0 }}
  2336	                    exit={{ opacity: 0, y: -10 }}
  2337	                    style={{
  2338	                      position: 'absolute',
  2339	                      top: '100%',
  2340	                      left: 0,
  2341	                      marginTop: '4px',
  2342	                      minWidth: '220px',
  2343	                      background: 'rgba(15, 23, 42, 0.98)',
  2344	                      border: '1px solid rgba(255, 255, 255, 0.1)',
  2345	                      borderRadius: '12px',
  2346	                      padding: '8px 0',
  2347	                      boxShadow: '0 10px 40px rgba(0, 0, 0, 0.5)',
  2348	                      zIndex: 1000,
  2349	                    }}
  2350	                    onClick={(e) => e.stopPropagation()}
  2351	                  >
  2352	                    {canCustomize && (
  2353	                      <>
  2354	                        {/* Show/Hide Quick Bar Toggle */}
  2355	                        <button
  2356	                          onClick={() => {
  2357	                            toggleQuickBar()
  2358	                            setShowSettingsDropdown(false)
  2359	                          }}
  2360	                          style={{
  2361	                            display: 'flex',
  2362	                            alignItems: 'center',
  2363	                            gap: '10px',
  2364	                            width: '100%',
  2365	                            padding: '10px 16px',
  2366	                            background: 'transparent',
  2367	                            border: 'none',
  2368	                            color: '#e2e8f0',
  2369	                            fontSize: '13px',
  2370	                            cursor: 'pointer',
  2371	                            textAlign: 'left',
  2372	                          }}
  2373	                          onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
  2374	                          onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2375	                        >
  2376	                          <svg width="16" height="16" fill="none" stroke={quickBarEnabled ? '#22c55e' : '#94a3b8'} viewBox="0 0 24 24">
  2377	                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
  2378	                          </svg>
  2379	                          {quickBarEnabled ? ' Quick Bar Enabled' : 'Enable Quick Bar'}
  2380	                        </button>
  2381	
  2382	                        <div style={{ height: '1px', background: 'rgba(255, 255, 255, 0.1)', margin: '4px 0' }} />
  2383	
  2384	                        {/* Edit Favorites */}
  2385	                        <button
  2386	                          onClick={() => {
  2387	                            setIsEditingFavorites(!isEditingFavorites)
  2388	                            setIsEditingCategories(false)
  2389	                            setIsEditingMenuItems(false)
  2390	                            setShowSettingsDropdown(false)
  2391	                          }}
  2392	                          style={{
  2393	                            display: 'flex',
  2394	                            alignItems: 'center',
  2395	                            gap: '10px',
  2396	                            width: '100%',
  2397	                            padding: '10px 16px',
  2398	                            background: isEditingFavorites ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
  2399	                            border: 'none',
  2400	                            color: isEditingFavorites ? '#a5b4fc' : '#e2e8f0',
  2401	                            fontSize: '13px',
  2402	                            cursor: 'pointer',
  2403	                            textAlign: 'left',
  2404	                          }}
  2405	                          onMouseEnter={(e) => { if (!isEditingFavorites) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)' }}
  2406	                          onMouseLeave={(e) => { if (!isEditingFavorites) e.currentTarget.style.background = 'transparent' }}
  2407	                        >
  2408	                          <svg width="16" height="16" fill={isEditingFavorites ? '#a5b4fc' : '#94a3b8'} viewBox="0 0 20 20">
  2409	                            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
  2410	                          </svg>
  2411	                          {isEditingFavorites ? ' Done Editing Favorites' : 'Edit Favorites'}
  2412	                        </button>
  2413	
  2414	                        {/* Reorder Categories */}
  2415	                        <button
  2416	                          onClick={() => {
  2417	                            setIsEditingCategories(!isEditingCategories)
  2418	                            setIsEditingFavorites(false)
  2419	                            setIsEditingMenuItems(false)
  2420	                            setShowSettingsDropdown(false)
  2421	                          }}
  2422	                          style={{
  2423	                            display: 'flex',
  2424	                            alignItems: 'center',
  2425	                            gap: '10px',
  2426	                            width: '100%',
  2427	                            padding: '10px 16px',
  2428	                            background: isEditingCategories ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
  2429	                            border: 'none',
  2430	                            color: isEditingCategories ? '#a5b4fc' : '#e2e8f0',
  2431	                            fontSize: '13px',
  2432	                            cursor: 'pointer',
  2433	                            textAlign: 'left',
  2434	                          }}
  2435	                          onMouseEnter={(e) => { if (!isEditingCategories) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)' }}
  2436	                          onMouseLeave={(e) => { if (!isEditingCategories) e.currentTarget.style.background = 'transparent' }}
  2437	                        >
  2438	                          <svg width="16" height="16" fill="none" stroke={isEditingCategories ? '#a5b4fc' : '#94a3b8'} viewBox="0 0 24 24">
  2439	                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" />
  2440	                          </svg>
  2441	                          {isEditingCategories ? ' Done Reordering' : 'Reorder Categories'}
  2442	                        </button>
  2443	
  2444	                        {/* Customize Item Colors */}
  2445	                        <button
  2446	                          onClick={() => {
  2447	                            setIsEditingMenuItems(!isEditingMenuItems)
  2448	                            setIsEditingFavorites(false)
  2449	                            setIsEditingCategories(false)
  2450	                            setShowSettingsDropdown(false)
  2451	                          }}
  2452	                          style={{
  2453	                            display: 'flex',
  2454	                            alignItems: 'center',
  2455	                            gap: '10px',
  2456	                            width: '100%',
  2457	                            padding: '10px 16px',
  2458	                            background: isEditingMenuItems ? 'rgba(168, 85, 247, 0.15)' : 'transparent',
  2459	                            border: 'none',
  2460	                            color: isEditingMenuItems ? '#c4b5fd' : '#e2e8f0',
  2461	                            fontSize: '13px',
  2462	                            cursor: 'pointer',
  2463	                            textAlign: 'left',
  2464	                          }}
  2465	                          onMouseEnter={(e) => { if (!isEditingMenuItems) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)' }}
  2466	                          onMouseLeave={(e) => { if (!isEditingMenuItems) e.currentTarget.style.background = 'transparent' }}
  2467	                        >
  2468	                          <svg width="16" height="16" fill="none" stroke={isEditingMenuItems ? '#c4b5fd' : '#94a3b8'} viewBox="0 0 24 24">
  2469	                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
  2470	                          </svg>
  2471	                          {isEditingMenuItems ? ' Done Customizing Items' : 'Customize Item Colors'}
  2472	                        </button>
  2473	
  2474	                        <div style={{ height: '1px', background: 'rgba(255, 255, 255, 0.1)', margin: '4px 0' }} />
  2475	
  2476	                        {/* Reset All Category Colors */}
  2477	                        <button
  2478	                          onClick={() => {
  2479	                            resetAllCategoryColors()
  2480	                            setShowSettingsDropdown(false)
  2481	                          }}
  2482	                          style={{
  2483	                            display: 'flex',
  2484	                            alignItems: 'center',
  2485	                            gap: '10px',
  2486	                            width: '100%',
  2487	                            padding: '10px 16px',
  2488	                            background: 'transparent',
  2489	                            border: 'none',
  2490	                            color: '#f87171',
  2491	                            fontSize: '13px',
  2492	                            cursor: 'pointer',
  2493	                            textAlign: 'left',
  2494	                          }}
  2495	                          onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(248, 113, 113, 0.1)'}
  2496	                          onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2497	                        >
  2498	                          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2499	                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  2500	                          </svg>
  2501	                          Reset All Category Colors
  2502	                        </button>
  2503	
  2504	                        {/* Reset All Item Styles */}
  2505	                        <button
  2506	                          onClick={() => {
  2507	                            resetAllMenuItemStyles()
  2508	                            setShowSettingsDropdown(false)
  2509	                          }}
  2510	                          style={{
  2511	                            display: 'flex',
  2512	                            alignItems: 'center',
  2513	                            gap: '10px',
  2514	                            width: '100%',
  2515	                            padding: '10px 16px',
  2516	                            background: 'transparent',
  2517	                            border: 'none',
  2518	                            color: '#f87171',
  2519	                            fontSize: '13px',
  2520	                            cursor: 'pointer',
  2521	                            textAlign: 'left',
  2522	                          }}
  2523	                          onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(248, 113, 113, 0.1)'}
  2524	                          onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
  2525	                        >
  2526	                          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2527	                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  2528	                          </svg>
  2529	                          Reset All Item Styles
  2530	                        </button>
  2531	                      </>
  2532	                    )}
  2533	                  </motion.div>
  2534	                )}
  2535	              </AnimatePresence>
  2536	            </div>
  2537	          </div>
  2538	        </div>
  2539	
  2540	        <div className="floor-plan-header-right">
  2541	          {/* Open Orders Button */}
  2542	          <button
  2543	            onClick={onOpenOrdersPanel}
  2544	            style={{
  2545	              display: 'flex',
  2546	              alignItems: 'center',
  2547	              gap: '8px',
  2548	              padding: '8px 16px',
  2549	              background: openOrdersCount > 0 ? 'rgba(99, 102, 241, 0.15)' : 'rgba(255, 255, 255, 0.03)',
  2550	              border: `1px solid ${openOrdersCount > 0 ? 'rgba(99, 102, 241, 0.3)' : 'rgba(255, 255, 255, 0.08)'}`,
  2551	              borderRadius: '10px',
  2552	              color: openOrdersCount > 0 ? '#a5b4fc' : '#94a3b8',
  2553	              fontSize: '13px',
  2554	              fontWeight: 600,
  2555	              cursor: 'pointer',
  2556	            }}
  2557	          >
  2558	            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2559	              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
  2560	            </svg>
  2561	            Open Orders
  2562	            {openOrdersCount > 0 && (
  2563	              <span
  2564	                style={{
  2565	                  background: 'rgba(99, 102, 241, 0.3)',
  2566	                  padding: '2px 8px',
  2567	                  borderRadius: '12px',
  2568	                  fontSize: '12px',
  2569	                  fontWeight: 700,
  2570	                }}
  2571	              >
  2572	                {openOrdersCount}
  2573	              </span>
  2574	            )}
  2575	          </button>
  2576	
  2577	          {/* Show Seats Toggle */}
  2578	          <button
  2579	            className={`icon-btn ${showSeats ? 'active' : ''}`}
  2580	            onClick={toggleShowSeats}
  2581	            title={showSeats ? 'Hide Seats' : 'Show Seats'}
  2582	            style={showSeats ? { background: 'rgba(99, 102, 241, 0.2)', borderColor: 'rgba(99, 102, 241, 0.4)' } : undefined}
  2583	          >
  2584	            <svg width="18" height="18" fill="none" stroke={showSeats ? '#a5b4fc' : 'currentColor'} viewBox="0 0 24 24">
  2585	              <circle cx="12" cy="12" r="3" strokeWidth={2} />
  2586	              <circle cx="12" cy="4" r="2" strokeWidth={2} />
  2587	              <circle cx="12" cy="20" r="2" strokeWidth={2} />
  2588	              <circle cx="4" cy="12" r="2" strokeWidth={2} />
  2589	              <circle cx="20" cy="12" r="2" strokeWidth={2} />
  2590	            </svg>
  2591	          </button>
  2592	
  2593	          {/* Reset Layout (if combined tables exist) */}
  2594	          {primaryTables.length > 0 && (
  2595	            <button
  2596	              className="reset-to-default-btn"
  2597	              onClick={() => handleResetToDefault(primaryTables.map(t => t.id))}
  2598	              title="Reset all combined tables"
  2599	            >
  2600	              <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2601	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  2602	              </svg>
  2603	              Reset
  2604	            </button>
  2605	          )}
  2606	
  2607	          {/* Undo Button */}
  2608	          <AnimatePresence>
  2609	            {undoStack.length > 0 && (
  2610	              <motion.button
  2611	                className="icon-btn"
  2612	                onClick={handleUndo}
  2613	                title="Undo"
  2614	                initial={{ scale: 0 }}
  2615	                animate={{ scale: 1 }}
  2616	                exit={{ scale: 0 }}
  2617	                style={{ background: 'rgba(251, 191, 36, 0.15)', borderColor: 'rgba(251, 191, 36, 0.3)' }}
  2618	              >
  2619	                <svg width="18" height="18" fill="none" stroke="#fbbf24" viewBox="0 0 24 24">
  2620	                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
  2621	                </svg>
  2622	              </motion.button>
  2623	            )}
  2624	          </AnimatePresence>
  2625	
  2626	          {/* Admin Menu - Always show if callback provided, permissions control nav content */}
  2627	          {onOpenAdminNav && (
  2628	            <button
  2629	              className="icon-btn"
  2630	              onClick={onOpenAdminNav}
  2631	              title="Menu"
  2632	              style={{
  2633	                background: 'rgba(59, 130, 246, 0.2)',
  2634	                border: '1px solid rgba(59, 130, 246, 0.4)',
  2635	                borderRadius: '8px',
  2636	                padding: '8px',
  2637	              }}
  2638	            >
  2639	              <svg width="22" height="22" fill="none" stroke="#3b82f6" viewBox="0 0 24 24">
  2640	                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
  2641	              </svg>
  2642	            </button>
  2643	          )}
  2644	        </div>
  2645	      </header>
  2646	
  2647	      {/* Quick Access Bar - Personal favorites */}
  2648	      {(quickBarEnabled || isEditingFavorites) && (
  2649	        <QuickAccessBar
  2650	          items={quickBarItems}
  2651	          onItemClick={handleQuickBarItemClick}
  2652	          onRemoveItem={removeFromQuickBar}
  2653	          isEditMode={isEditingFavorites}
  2654	        />
  2655	      )}
  2656	
  2657	      {/* Categories Bar */}
  2658	      <CategoriesBar
  2659	        categories={categories}
  2660	        selectedCategoryId={selectedCategoryId}
  2661	        onCategorySelect={handleCategoryClick}
  2662	      />
  2663	
  2664	      {/* Main Content Area - Tables OR Menu Items */}
  2665	      <div className="floor-plan-main" style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
  2666	        {/* Left Panel - Tables or Menu Items */}
  2667	        <div style={{ flex: 1, overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>
  2668	          {viewMode === 'tables' ? (
  2669	            <>
  2670	              {/* Room/Section Tabs */}
  2671	              {sortedSections.length > 0 && (
  2672	                <RoomTabs
  2673	                  rooms={sortedSections.map(s => ({ id: s.id, name: s.name, color: s.color }))}
  2674	                  selectedRoomId={selectedSectionId}
  2675	                  onRoomSelect={setSelectedSectionId}
  2676	                  showAllTab={false}
  2677	                  showSettingsButton={true}
  2678	                  onOpenSettings={() => setShowRoomReorderModal(true)}
  2679	                />
  2680	              )}
  2681	
  2682	              {/* Floor Plan Canvas */}
  2683	              <div
  2684	                ref={containerRef}
  2685	                className="floor-plan-canvas"
  2686	                onPointerMove={handlePointerMove}
  2687	                onPointerUp={handlePointerUp}
  2688	                onClick={() => selectTable(null)}
  2689	                style={{ flex: 1 }}
  2690	              >
  2691	              {isLoading ? (
  2692	                <div className="flex items-center justify-center h-full text-slate-400">
  2693	                  <motion.div
  2694	                    animate={{ rotate: 360 }}
  2695	                    transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
  2696	                  >
  2697	                    <svg width="32" height="32" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  2698	                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  2699	                    </svg>
  2700	                  </motion.div>
  2701	                </div>
  2702	              ) : tables.length === 0 ? (
  2703	                <div className="flex flex-col items-center justify-center h-full text-slate-400">
  2704	                  <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24" className="opacity-50 mb-4">
  2705	                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
  2706	                  </svg>
  2707	                  <p className="text-lg font-medium">No tables configured</p>
  2708	                  <p className="text-sm opacity-60 mt-1">Add tables in the admin settings</p>
  2709	                </div>
  2710	              ) : (
  2711	                <>
  2712	                  {/* Scale indicator - show when auto-scaled */}
  2713	                  {autoScale < 1 && (
  2714	                    <div
  2715	                      style={{
  2716	                        position: 'absolute',
  2717	                        top: '8px',
  2718	                        right: '8px',
  2719	                        padding: '4px 8px',
  2720	                        borderRadius: '6px',
  2721	                        background: 'rgba(99, 102, 241, 0.2)',
  2722	                        border: '1px solid rgba(99, 102, 241, 0.3)',
  2723	                        color: '#a5b4fc',
  2724	                        fontSize: '11px',
  2725	                        fontWeight: 500,
  2726	                        zIndex: 10,
  2727	                      }}
  2728	                    >
  2729	                      {Math.round(autoScale * 100)}% zoom
  2730	                    </div>
  2731	                  )}
  2732	
  2733	                  {/* Auto-scaled content wrapper */}
  2734	                  <div
  2735	                    style={{
  2736	                      position: 'absolute',
  2737	                      top: 0,
  2738	                      left: 0,
  2739	                      width: '100%',
  2740	                      height: '100%',
  2741	                      transform: autoScale < 1
  2742	                        ? `translate(${autoScaleOffset.x}px, ${autoScaleOffset.y}px) scale(${autoScale})`
  2743	                        : undefined,
  2744	                      transformOrigin: 'top left',
  2745	                      pointerEvents: 'auto',
  2746	                    }}
  2747	                  >
  2748	                  {/* Connection Lines */}
  2749	                  {connectionLines.length > 0 && (
  2750	                    <svg className="connection-lines-layer">
  2751	                      <defs>
  2752	                        <filter id="connectionGlow" x="-50%" y="-50%" width="200%" height="200%">
  2753	                          <feGaussianBlur stdDeviation="3" result="blur" />
  2754	                          <feMerge>
  2755	                            <feMergeNode in="blur" />
  2756	                            <feMergeNode in="SourceGraphic" />
  2757	                          </feMerge>
  2758	                        </filter>
  2759	                      </defs>
  2760	                      {connectionLines.map(line => (
  2761	                        <g key={line.id}>
  2762	                          <line
  2763	                            x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
  2764	                            stroke={`${line.color}66`} strokeWidth="8" strokeLinecap="round"
  2765	                            filter="url(#connectionGlow)"
  2766	                          />
  2767	                          <line
  2768	                            x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
  2769	                            stroke={line.color} strokeWidth="3" strokeLinecap="round"
  2770	                            strokeDasharray="8 4" className="connection-line-animated"
  2771	                          />
  2772	                        </g>
  2773	                      ))}
  2774	                    </svg>
  2775	                  )}
  2776	
  2777	                  {/* Section Labels - filtered by selected section */}
  2778	                  {sections
  2779	                    .filter(section => {
  2780	                      // Show all section labels when "All" is selected
  2781	                      if (selectedSectionId === null) return true
  2782	                      // Only show the selected section's label
  2783	                      return section.id === selectedSectionId
  2784	                    })
  2785	                    .map(section => (
  2786	                      <div
  2787	                        key={section.id}
  2788	                        className="section-label"
  2789	                        style={{ left: section.posX + 10, top: section.posY + 10, color: section.color }}
  2790	                      >
  2791	                        {section.name}
  2792	                      </div>
  2793	                    ))}
  2794	
  2795	                  {/* Tables - filtered by selected section */}
  2796	                  <AnimatePresence>
  2797	                    {tables
  2798	                      .filter(table => {
  2799	                        // Show all tables when "All" is selected (selectedSectionId is null)
  2800	                        if (selectedSectionId === null) return true
  2801	                        // Show tables in the selected section
  2802	                        return table.section?.id === selectedSectionId
  2803	                      })
  2804	                      .map(table => {
  2805	                      const flash = flashingTables.get(table.id)
  2806	                      const flashMessage = flash && flash.expiresAt > Date.now() ? flash.message : null
  2807	
  2808	                      // Check if this table is part of the active combined group
  2809	                      // A table is selected if:
  2810	                      // 1. It's directly selected (selectedTableId or activeTableId)
  2811	                      // 2. It's a child and its primary is active
  2812	                      // 3. It's a primary and one of its children is somehow active (shouldn't happen with redirect)
  2813	                      const isInActiveGroup = (() => {
  2814	                        if (!activeTableId) return false
  2815	                        // Direct match
  2816	                        if (table.id === activeTableId) return true
  2817	                        // This table is a child of the active table
  2818	                        if (table.combinedWithId === activeTableId) return true
  2819	                        // This table is a primary and has the active table as a child
  2820	                        if (table.combinedTableIds?.includes(activeTableId)) return true
  2821	                        return false
  2822	                      })()
  2823	
  2824	                      // Calculate combinedSeatOffset for sequential seat numbering across combined tables
  2825	                      // Primary table: offset = 0 (but still part of combined group)
  2826	                      // Child tables: offset = primary's seats + preceding siblings' seats
  2827	                      let combinedSeatOffset = 0
  2828	                      let isPartOfCombinedGroup = false
  2829	
  2830	                      if (table.combinedWithId) {
  2831	                        // This is a child table - find the primary and calculate offset
  2832	                        isPartOfCombinedGroup = true
  2833	                        const primaryTable = tables.find(t => t.id === table.combinedWithId)
  2834	                        if (primaryTable && primaryTable.combinedTableIds) {
  2835	                          // Start with primary table's seat count
  2836	                          combinedSeatOffset = primaryTable.seats?.length || primaryTable.capacity || 0
  2837	                          // Add seats from all preceding siblings in the combinedTableIds array
  2838	                          const myIndex = primaryTable.combinedTableIds.indexOf(table.id)
  2839	                          for (let i = 0; i < myIndex; i++) {
  2840	                            const siblingTable = tables.find(t => t.id === primaryTable.combinedTableIds![i])
  2841	                            if (siblingTable) {
  2842	                              combinedSeatOffset += siblingTable.seats?.length || siblingTable.capacity || 0
  2843	                            }
  2844	                          }
  2845	                        }
  2846	                      } else if (table.combinedTableIds && table.combinedTableIds.length > 0) {
  2847	                        // This is the primary table of a combined group
  2848	                        // Offset is 0 but we still mark it as part of a combined group
  2849	                        isPartOfCombinedGroup = true
  2850	                      }
  2851	
  2852	                      // Calculate total seats for the combined group (for selection validation)
  2853	                      const combinedTotalSeats = isPartOfCombinedGroup ? getTotalSeats(table) : undefined
  2854	
  2855	                      return (
  2856	                        <TableNode
  2857	                          key={table.id}
  2858	                          table={table}
  2859	                          isSelected={selectedTableId === table.id || isInActiveGroup}
  2860	                          isDragging={draggedTableId === table.id}
  2861	                          isDropTarget={dropTargetTableId === table.id}
  2862	                          isColliding={draggedTableId === table.id && isColliding}
  2863	                          combinedGroupColor={combinedGroupColors.get(table.id)}
  2864	                          showSeats={showSeats}
  2865	                          selectedSeat={selectedSeat}
  2866	                          flashMessage={flashMessage}
  2867	                          combinedSeatOffset={combinedSeatOffset}
  2868	                          combinedTotalSeats={combinedTotalSeats}
  2869	                          isVirtualCombineMode={virtualCombineMode}
  2870	                          isVirtualCombineSelected={virtualCombineSelectedIds.has(table.id)}
  2871	                          isVirtualCombineUnavailable={virtualCombineMode && !virtualCombineSelectedIds.has(table.id) && (() => {
  2872	                            // Allow tables in same virtual group as primary
  2873	                            const primaryTable = tables.find(t => t.id === virtualCombinePrimaryId)
  2874	                            const primaryGroupId = primaryTable?.virtualGroupId
  2875	                            if (table.virtualGroupId && table.virtualGroupId === primaryGroupId) {
  2876	                              return false // Same group - available
  2877	                            }
  2878	                            return (
  2879	                              Boolean(table.virtualGroupId) || // In different group
  2880	                              Boolean(table.combinedWithId) ||
  2881	                              Boolean(table.combinedTableIds && table.combinedTableIds.length > 0)
  2882	                            )
  2883	                          })()}
  2884	                          virtualGroupColor={table.virtualGroupColor || undefined}
  2885	                          onTap={() => handleTableTap(table)}
  2886	                          onDragStart={() => startDrag(table.id)}
  2887	                          onDragEnd={endDrag}
  2888	                          onLongPress={() => {
  2889	                            // Long press starts virtual combine mode (or opens manager/info panel)
  2890	                            if (virtualCombineMode) {
  2891	                              // Already in virtual combine mode - no action
  2892	                              return
  2893	                            }
  2894	                            if (table.combinedTableIds && table.combinedTableIds.length > 0) {
  2895	                              // Physical combined table - open info panel
  2896	                              openInfoPanel(table.id)
  2897	                            } else if (table.virtualGroupId) {
  2898	                              // Already in a virtual group - open virtual group manager modal
  2899	                              setVirtualGroupManagerTableId(table.id)
  2900	                            } else {
  2901	                              // Start virtual combine mode with this table
  2902	                              startVirtualCombineMode(table.id)
  2903	                            }
  2904	                          }}
  2905	                          onSeatTap={(seatNumber) => handleSeatTap(table.id, seatNumber)}
  2906	                        />
  2907	                      )
  2908	                    })}
  2909	                  </AnimatePresence>
  2910	
  2911	                  {/* Entertainment Elements - filtered by selected section */}
  2912	                  {elements
  2913	                    .filter(element => {
  2914	                      // Show all elements when "All" is selected
  2915	                      if (selectedSectionId === null) return true
  2916	                      // Show elements in the selected section (or unassigned elements)
  2917	                      return element.sectionId === selectedSectionId || element.sectionId === null
  2918	                    })
  2919	                    .map(element => (
  2920	                      <div
  2921	                        key={element.id}
  2922	                        style={{
  2923	                          position: 'absolute',
  2924	                          left: element.posX,
  2925	                          top: element.posY,
  2926	                          zIndex: 10,
  2927	                        }}
  2928	                      >
  2929	                        <FloorPlanEntertainment
  2930	                          element={element}
  2931	                          isSelected={false}
  2932	                          mode="service"
  2933	                          onSelect={() => {
  2934	                            // Handle tapping on entertainment item - start timed rental
  2935	                            if (element.linkedMenuItem) {
  2936	                              const menuItem: MenuItem = {
  2937	                                id: element.linkedMenuItem.id,
  2938	                                name: element.linkedMenuItem.name,
  2939	                                price: element.linkedMenuItem.price,
  2940	                                categoryId: '',
  2941	                                itemType: 'timed_rental',
  2942	                                entertainmentStatus: element.linkedMenuItem.entertainmentStatus as 'available' | 'in_use' | 'maintenance' | undefined,
  2943	                                blockTimeMinutes: element.linkedMenuItem.blockTimeMinutes || undefined,
  2944	                              }
  2945	                              // Use existing handleMenuItemTap which handles timed rentals
  2946	                              handleMenuItemTap(menuItem)
  2947	                            }
  2948	                          }}
  2949	                        />
  2950	                      </div>
  2951	                    ))}
  2952	
  2953	                  {/* Ghost Preview */}
  2954	                  {ghostPreview && (
  2955	                    <motion.div
  2956	                      className="table-ghost-preview"
  2957	                      initial={{ opacity: 0, scale: 0.9 }}
  2958	                      animate={{ opacity: 0.6, scale: 1 }}
  2959	                      exit={{ opacity: 0, scale: 0.9 }}
  2960	                      style={{
  2961	                        position: 'absolute',
  2962	                        left: ghostPreview.posX,
  2963	                        top: ghostPreview.posY,
  2964	                        width: ghostPreview.width,
  2965	                        height: ghostPreview.height,
  2966	                        borderRadius: '12px',
  2967	                        border: '2px dashed #22c55e',
  2968	                        backgroundColor: 'rgba(34, 197, 94, 0.15)',
  2969	                        pointerEvents: 'none',
  2970	                        zIndex: 90,
  2971	                      }}
  2972	                    >
  2973	                      <div
  2974	                        style={{
  2975	                          position: 'absolute',
  2976	                          bottom: '-24px',
  2977	                          left: '50%',
  2978	                          transform: 'translateX(-50%)',
  2979	                          fontSize: '11px',
  2980	                          fontWeight: 600,
  2981	                          color: '#22c55e',
  2982	                          textTransform: 'uppercase',
  2983	                          whiteSpace: 'nowrap',
  2984	                        }}
  2985	                      >
  2986	                        Attach {ghostPreview.side}
  2987	                      </div>
  2988	                    </motion.div>
  2989	                  )}
  2990	                  </div>
  2991	                  {/* End of auto-scaled content wrapper */}
  2992	                </>
  2993	              )}
  2994	            </div>
  2995	            </>
  2996	          ) : (
  2997	            /* Menu Items Grid - replaces tables when category is selected */
  2998	            <div
  2999	              style={{ flex: 1, overflow: 'auto', padding: '20px' }}
  3000	              onClick={(e) => {
  3001	                // Click on empty area deselects category
  3002	                if (e.target === e.currentTarget) {
  3003	                  setSelectedCategoryId(null)
  3004	                  setViewMode('tables')
  3005	                  setMenuItems([])
  3006	                }
  3007	              }}
  3008	            >
  3009	              {loadingMenuItems ? (
  3010	                <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%', color: '#64748b' }}>
  3011	                  <motion.div
  3012	                    animate={{ rotate: 360 }}
  3013	                    transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
  3014	                  >
  3015	                    <svg width="32" height="32" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3016	                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  3017	                    </svg>
  3018	                  </motion.div>
  3019	                </div>
  3020	              ) : menuItems.length === 0 ? (
  3021	                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#64748b' }}>
  3022	                  <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ opacity: 0.5, marginBottom: '16px' }}>
  3023	                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4" />
  3024	                  </svg>
  3025	                  <p style={{ fontSize: '14px' }}>No items in this category</p>
  3026	                  <p style={{ fontSize: '12px', marginTop: '4px', opacity: 0.6 }}>Tap the category again to go back</p>
  3027	                </div>
  3028	              ) : (
  3029	                  <div
  3030	                    style={{
  3031	                      display: 'grid',
  3032	                      gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))',
  3033	                      gap: '16px',
  3034	                    }}
  3035	                  >
  3036	                    {menuItems.map((item) => {
  3037	                      const customStyle = menuItemColors[item.id]
  3038	                      const inQuickBar = isInQuickBar(item.id)
  3039	                      // Check if item is 86'd (ingredient-level or out of prep stock)
  3040	                      const isItem86d = item.is86d || item.stockStatus === 'out'
  3041	                      const bgColor = isItem86d
  3042	                        ? 'rgba(100, 100, 100, 0.3)'
  3043	                        : (customStyle?.bgColor || 'rgba(255, 255, 255, 0.03)')
  3044	                      const textColor = isItem86d
  3045	                        ? '#6b7280'
  3046	                        : (customStyle?.textColor || '#e2e8f0')
  3047	
  3048	                      return (
  3049	                        <motion.button
  3050	                          key={item.id}
  3051	                          onClick={() => {
  3052	                            if (isItem86d) {
  3053	                              // Show toast explaining why item is unavailable
  3054	                              const reason = item.reasons86d?.length
  3055	                                ? `${item.name} is unavailable - ${item.reasons86d.join(', ')} is out`
  3056	                                : item.stockIngredientName
  3057	                                  ? `${item.name} is unavailable - ${item.stockIngredientName} is out`
  3058	                                  : `${item.name} is currently unavailable`
  3059	                              toast.warning(reason)
  3060	                            } else {
  3061	                              handleMenuItemTap(item)
  3062	                            }
  3063	                          }}
  3064	                          onContextMenu={(e) => handleMenuItemContextMenu(e, item)}
  3065	                          whileHover={isItem86d ? {} : { scale: 1.02, y: -2 }}
  3066	                          whileTap={isItem86d ? {} : { scale: 0.98 }}
  3067	                          className={inQuickBar ? 'ring-2 ring-amber-400/50' : ''}
  3068	                          style={{
  3069	                            display: 'flex',
  3070	                            flexDirection: 'column',
  3071	                            alignItems: 'center',
  3072	                            justifyContent: 'center',
  3073	                            padding: '20px 16px',
  3074	                            background: bgColor,
  3075	                            border: `1px solid ${isItem86d ? 'rgba(239, 68, 68, 0.3)' : 'rgba(255, 255, 255, 0.08)'}`,
  3076	                            borderRadius: '14px',
  3077	                            cursor: isItem86d ? 'not-allowed' : 'pointer',
  3078	                            minHeight: '110px',
  3079	                            transition: 'all 0.15s ease',
  3080	                            position: 'relative',
  3081	                            opacity: isItem86d ? 0.6 : 1,
  3082	                          }}
  3083	                          onMouseOver={(e) => {
  3084	                            if (!isItem86d) {
  3085	                              if (!customStyle?.bgColor) {
  3086	                                e.currentTarget.style.background = 'rgba(99, 102, 241, 0.15)'
  3087	                              }
  3088	                              e.currentTarget.style.borderColor = 'rgba(99, 102, 241, 0.3)'
  3089	                            }
  3090	                          }}
  3091	                          onMouseOut={(e) => {
  3092	                            e.currentTarget.style.background = bgColor
  3093	                            e.currentTarget.style.borderColor = isItem86d
  3094	                              ? 'rgba(239, 68, 68, 0.3)'
  3095	                              : 'rgba(255, 255, 255, 0.08)'
  3096	                          }}
  3097	                        >
  3098	                          {/* Quick bar indicator */}
  3099	                          {inQuickBar && !isItem86d && (
  3100	                            <span className="absolute top-1 left-1 text-amber-400 z-10">
  3101	                              <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
  3102	                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
  3103	                              </svg>
  3104	                            </span>
  3105	                          )}
  3106	                          {/* 86 badge - ingredient-level */}
  3107	                          {item.is86d && (
  3108	                            <span
  3109	                              className="absolute top-1 right-1 px-1.5 py-0.5 bg-red-600 text-white text-[10px] font-bold rounded z-10"
  3110	                              title={item.reasons86d?.length
  3111	                                ? `Out: ${item.reasons86d.join(', ')}`
  3112	                                : 'Out of stock'}
  3113	                            >
  3114	                              86
  3115	                            </span>
  3116	                          )}
  3117	                          {/* Prep stock status badge (low/critical/out) */}
  3118	                          {!item.is86d && item.stockStatus && (
  3119	                            <StockBadge
  3120	                              status={item.stockStatus}
  3121	                              count={item.stockCount}
  3122	                              ingredientName={item.stockIngredientName}
  3123	                            />
  3124	                          )}
  3125	                          {/* Striped overlay for 86'd items */}
  3126	                          {isItem86d && (
  3127	                            <div
  3128	                              className="absolute inset-0 rounded-[14px] pointer-events-none"
  3129	                              style={{
  3130	                                background: 'repeating-linear-gradient(135deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px)',
  3131	                              }}
  3132	                            />
  3133	                          )}
  3134	                          <span
  3135	                            style={{
  3136	                              fontSize: '15px',
  3137	                              fontWeight: 500,
  3138	                              color: textColor,
  3139	                              textAlign: 'center',
  3140	                              marginBottom: '8px',
  3141	                              lineHeight: 1.3,
  3142	                              textDecoration: isItem86d ? 'line-through' : 'none',
  3143	                            }}
  3144	                          >
  3145	                            {item.name}
  3146	                          </span>
  3147	                          <span
  3148	                            style={{
  3149	                              fontSize: '15px',
  3150	                              fontWeight: 600,
  3151	                              color: isItem86d ? '#6b7280' : '#22c55e',
  3152	                            }}
  3153	                          >
  3154	                            ${item.price.toFixed(2)}
  3155	                          </span>
  3156	                          {item.hasModifiers && !isItem86d && (
  3157	                            <span
  3158	                              style={{
  3159	                                fontSize: '11px',
  3160	                                color: '#94a3b8',
  3161	                                marginTop: '6px',
  3162	                              }}
  3163	                            >
  3164	                              + options
  3165	                            </span>
  3166	                          )}
  3167	                        </motion.button>
  3168	                      )
  3169	                    })}
  3170	                  </div>
  3171	                )}
  3172	            </div>
  3173	          )}
  3174	        </div>
  3175	
  3176	        {/* Right Panel - Order Panel */}
  3177	        <AnimatePresence>
  3178	          {showOrderPanel && (
  3179	            <motion.div
  3180	              initial={{ width: 0, opacity: 0 }}
  3181	              animate={{ width: 360, opacity: 1 }}
  3182	              exit={{ width: 0, opacity: 0 }}
  3183	              transition={{ type: 'spring', damping: 25, stiffness: 300 }}
  3184	              style={{
  3185	                borderLeft: '1px solid rgba(255, 255, 255, 0.08)',
  3186	                background: 'rgba(15, 23, 42, 0.6)',
  3187	                display: 'flex',
  3188	                flexDirection: 'column',
  3189	                overflow: 'hidden',
  3190	                height: '100%', // Explicit height needed for flex children to work
  3191	              }}
  3192	            >
  3193	              {/* Order Panel Header - Fixed, doesn't scroll */}
  3194	              <div
  3195	                style={{
  3196	                  padding: '16px 20px',
  3197	                  borderBottom: '1px solid rgba(255, 255, 255, 0.08)',
  3198	                  display: 'flex',
  3199	                  alignItems: 'center',
  3200	                  justifyContent: 'space-between',
  3201	                  flexShrink: 0,
  3202	                }}
  3203	              >
  3204	                <div style={{ flex: 1, minWidth: 0 }}>
  3205	                  <h3 style={{ fontSize: '16px', fontWeight: 600, color: '#f1f5f9', margin: 0 }}>
  3206	                    {activeTable
  3207	                      ? activeTable.virtualGroupId
  3208	                        ? 'Virtual Group'
  3209	                        : getCombinedTableCount(activeTable) > 1
  3210	                          ? `Combined ${getCombinedTableCount(activeTable)} Tables`
  3211	                          : activeTable.name
  3212	                      : activeOrderType === 'bar_tab' ? 'Bar Tab'
  3213	                      : activeOrderType === 'takeout' ? 'Takeout'
  3214	                      : activeOrderType === 'delivery' ? 'Delivery'
  3215	                      : 'New Order'}
  3216	                  </h3>
  3217	                  {/* Virtual group: Show table list with primary indicator */}
  3218	                  {activeTable?.virtualGroupId && (
  3219	                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginTop: '4px', flexWrap: 'wrap' }}>
  3220	                      {getVirtualGroupTables(activeTable).map((t, i) => (
  3221	                        <span
  3222	                          key={t.id}
  3223	                          style={{
  3224	                            fontSize: '11px',
  3225	                            fontWeight: t.virtualGroupPrimary ? 600 : 400,
  3226	                            color: t.virtualGroupPrimary ? '#06b6d4' : '#94a3b8',
  3227	                            padding: '2px 6px',
  3228	                            background: t.virtualGroupPrimary ? 'rgba(6, 182, 212, 0.15)' : 'rgba(255, 255, 255, 0.05)',
  3229	                            borderRadius: '4px',
  3230	                          }}
  3231	                        >
  3232	                          {t.abbreviation || t.name}{t.virtualGroupPrimary ? ' ' : ''}
  3233	                        </span>
  3234	                      ))}
  3235	                    </div>
  3236	                  )}
  3237	                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '2px' }}>
  3238	                    {activeOrderNumber && (
  3239	                      <span style={{ fontSize: '12px', color: '#64748b' }}>
  3240	                        Order #{activeOrderNumber}
  3241	                      </span>
  3242	                    )}
  3243	                    {activeTable && getTotalSeats(activeTable) > 0 && (
  3244	                      <span style={{ fontSize: '11px', color: '#64748b', padding: '2px 6px', background: 'rgba(255, 255, 255, 0.05)', borderRadius: '4px' }}>
  3245	                        {getTotalSeats(activeTable)} seats
  3246	                      </span>
  3247	                    )}
  3248	                  </div>
  3249	                </div>
  3250	                <button
  3251	                  onClick={handleCloseOrderPanel}
  3252	                  style={{
  3253	                    background: 'rgba(255, 255, 255, 0.05)',
  3254	                    border: '1px solid rgba(255, 255, 255, 0.1)',
  3255	                    borderRadius: '8px',
  3256	                    padding: '8px',
  3257	                    color: '#94a3b8',
  3258	                    cursor: 'pointer',
  3259	                  }}
  3260	                >
  3261	                  <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3262	                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
  3263	                  </svg>
  3264	                </button>
  3265	              </div>
  3266	
  3267	              {/* Seat Selection Buttons (for table orders with seats) - Fixed, doesn't scroll */}
  3268	              {activeTable && getTotalSeats(activeTable) > 0 && (
  3269	                <div
  3270	                  style={{
  3271	                    padding: '10px 20px',
  3272	                    borderBottom: '1px solid rgba(255, 255, 255, 0.08)',
  3273	                    background: 'rgba(255, 255, 255, 0.02)',
  3274	                    flexShrink: 0,
  3275	                    maxHeight: '150px',
  3276	                    overflowY: 'auto',
  3277	                  }}
  3278	                >
  3279	                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
  3280	                    <span style={{ fontSize: '11px', color: '#64748b', fontWeight: 500 }}>Assign to seat:</span>
  3281	                    {activeSeatNumber && (
  3282	                      <span style={{ fontSize: '10px', color: '#c084fc' }}>
  3283	                        New items  {activeSourceTableId && activeTable.virtualGroupId
  3284	                          ? `${tables.find(t => t.id === activeSourceTableId)?.abbreviation || tables.find(t => t.id === activeSourceTableId)?.name || 'Table'}-S${activeSeatNumber}`
  3285	                          : `Seat ${activeSeatNumber}`}
  3286	                      </span>
  3287	                    )}
  3288	                  </div>
  3289	
  3290	                  {/* "Shared" button */}
  3291	                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', marginBottom: activeTable.virtualGroupId ? '12px' : '0' }}>
  3292	                    <button
  3293	                      onClick={() => {
  3294	                        setActiveSeatNumber(null)
  3295	                        setActiveSourceTableId(null)
  3296	                        clearSelectedSeat() // Sync visual selection
  3297	                      }}
  3298	                      style={{
  3299	                        padding: '6px 12px',
  3300	                        borderRadius: '6px',
  3301	                        border: `1px solid ${!activeSeatNumber ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
  3302	                        background: !activeSeatNumber ? 'rgba(168, 85, 247, 0.2)' : 'rgba(255, 255, 255, 0.05)',
  3303	                        color: !activeSeatNumber ? '#c084fc' : '#94a3b8',
  3304	                        fontSize: '12px',
  3305	                        fontWeight: !activeSeatNumber ? 600 : 400,
  3306	                        cursor: 'pointer',
  3307	                        transition: 'all 0.15s ease',
  3308	                      }}
  3309	                    >
  3310	                      Shared
  3311	                    </button>
  3312	                  </div>
  3313	
  3314	                  {/* Virtual Group: Show seats grouped by table */}
  3315	                  {activeTable.virtualGroupId ? (
  3316	                    <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
  3317	                      {getVirtualGroupTables(activeTable).map((groupTable) => (
  3318	                        <div key={groupTable.id} style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
  3319	                          {/* Table label */}
  3320	                          <span
  3321	                            style={{
  3322	                              fontSize: '11px',
  3323	                              fontWeight: 600,
  3324	                              color: groupTable.virtualGroupPrimary ? '#06b6d4' : '#94a3b8',
  3325	                              padding: '4px 8px',
  3326	                              background: groupTable.virtualGroupPrimary ? 'rgba(6, 182, 212, 0.15)' : 'rgba(255, 255, 255, 0.05)',
  3327	                              borderRadius: '4px',
  3328	                              minWidth: '50px',
  3329	                              textAlign: 'center',
  3330	                            }}
  3331	                          >
  3332	                            {groupTable.abbreviation || groupTable.name}
  3333	                            {groupTable.virtualGroupPrimary && ' '}
  3334	                          </span>
  3335	
  3336	                          {/* Seat buttons for this table */}
  3337	                          <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
  3338	                            {Array.from({ length: getTableSeatCount(groupTable) }, (_, i) => i + 1).map(seatNum => {
  3339	                              const isSelected = activeSeatNumber === seatNum && activeSourceTableId === groupTable.id
  3340	                              return (
  3341	                                <button
  3342	                                  key={`${groupTable.id}-${seatNum}`}
  3343	                                  onClick={() => {
  3344	                                    setActiveSeatNumber(seatNum)
  3345	                                    setActiveSourceTableId(groupTable.id)
  3346	                                    selectSeat(groupTable.id, seatNum)
  3347	                                  }}
  3348	                                  style={{
  3349	                                    width: '28px',
  3350	                                    height: '28px',
  3351	                                    borderRadius: '5px',
  3352	                                    border: `1px solid ${isSelected ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
  3353	                                    background: isSelected ? 'rgba(168, 85, 247, 0.2)' : 'rgba(255, 255, 255, 0.05)',
  3354	                                    color: isSelected ? '#c084fc' : '#94a3b8',
  3355	                                    fontSize: '11px',
  3356	                                    fontWeight: isSelected ? 600 : 400,
  3357	                                    cursor: 'pointer',
  3358	                                    transition: 'all 0.15s ease',
  3359	                                    display: 'flex',
  3360	                                    alignItems: 'center',
  3361	                                    justifyContent: 'center',
  3362	                                  }}
  3363	                                >
  3364	                                  {seatNum}
  3365	                                </button>
  3366	                              )
  3367	                            })}
  3368	
  3369	                            {/* Add Seat Button for this table in virtual group */}
  3370	                            <button
  3371	                              onClick={() => handleAddSeat(groupTable.id)}
  3372	                              title={`Add a seat to ${groupTable.name}`}
  3373	                              style={{
  3374	                                width: '28px',
  3375	                                height: '28px',
  3376	                                borderRadius: '5px',
  3377	                                border: '2px dashed rgba(34, 197, 94, 0.4)',
  3378	                                background: 'rgba(34, 197, 94, 0.1)',
  3379	                                color: '#22c55e',
  3380	                                fontSize: '14px',
  3381	                                fontWeight: 600,
  3382	                                cursor: 'pointer',
  3383	                                transition: 'all 0.15s ease',
  3384	                                display: 'flex',
  3385	                                alignItems: 'center',
  3386	                                justifyContent: 'center',
  3387	                              }}
  3388	                              onMouseEnter={(e) => {
  3389	                                e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)'
  3390	                                e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)'
  3391	                              }}
  3392	                              onMouseLeave={(e) => {
  3393	                                e.currentTarget.style.background = 'rgba(34, 197, 94, 0.1)'
  3394	                                e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)'
  3395	                              }}
  3396	                            >
  3397	                              +
  3398	                            </button>
  3399	                          </div>
  3400	                        </div>
  3401	                      ))}
  3402	                    </div>
  3403	                  ) : (
  3404	                    /* Single table or physical combine: Show flat seat list */
  3405	                    <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', alignItems: 'center' }}>
  3406	                      {Array.from({ length: getTotalSeats(activeTable) }, (_, i) => i + 1).map(seatNum => (
  3407	                        <button
  3408	                          key={seatNum}
  3409	                          onClick={() => {
  3410	                            setActiveSeatNumber(seatNum)
  3411	                            setActiveSourceTableId(activeTable.id)
  3412	                            // Sync visual selection on table
  3413	                            if (activeTableId) {
  3414	                              selectSeat(activeTableId, seatNum)
  3415	                            }
  3416	                          }}
  3417	                          style={{
  3418	                            width: '32px',
  3419	                            height: '32px',
  3420	                            borderRadius: '6px',
  3421	                            border: `1px solid ${activeSeatNumber === seatNum ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
  3422	                            background: activeSeatNumber === seatNum ? 'rgba(168, 85, 247, 0.2)' : 'rgba(255, 255, 255, 0.05)',
  3423	                            color: activeSeatNumber === seatNum ? '#c084fc' : '#94a3b8',
  3424	                            fontSize: '13px',
  3425	                            fontWeight: activeSeatNumber === seatNum ? 600 : 400,
  3426	                            cursor: 'pointer',
  3427	                            transition: 'all 0.15s ease',
  3428	                            display: 'flex',
  3429	                            alignItems: 'center',
  3430	                            justifyContent: 'center',
  3431	                          }}
  3432	                        >
  3433	                          {seatNum}
  3434	                        </button>
  3435	                      ))}
  3436	
  3437	                      {/* Add Seat Button (Skill 121) - works with or without active order */}
  3438	                      <button
  3439	                        onClick={() => handleAddSeat()}
  3440	                        title="Add a seat for extra guest"
  3441	                          style={{
  3442	                            width: '32px',
  3443	                            height: '32px',
  3444	                            borderRadius: '6px',
  3445	                            border: '2px dashed rgba(34, 197, 94, 0.4)',
  3446	                            background: 'rgba(34, 197, 94, 0.1)',
  3447	                            color: '#22c55e',
  3448	                            fontSize: '18px',
  3449	                            fontWeight: 600,
  3450	                            cursor: 'pointer',
  3451	                            transition: 'all 0.15s ease',
  3452	                            display: 'flex',
  3453	                            alignItems: 'center',
  3454	                            justifyContent: 'center',
  3455	                          }}
  3456	                          onMouseEnter={(e) => {
  3457	                            e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)'
  3458	                            e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)'
  3459	                          }}
  3460	                          onMouseLeave={(e) => {
  3461	                            e.currentTarget.style.background = 'rgba(34, 197, 94, 0.1)'
  3462	                            e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)'
  3463	                          }}
  3464	                        >
  3465	                          +
  3466	                        </button>
  3467	                    </div>
  3468	                  )}
  3469	                </div>
  3470	              )}
  3471	
  3472	              {/* Order Items */}
  3473	              <div style={{ flex: 1, overflow: 'auto', padding: '16px 20px' }}>
  3474	                {inlineOrderItems.length === 0 ? (
  3475	                  <div style={{ textAlign: 'center', padding: '40px 20px', color: '#64748b' }}>
  3476	                    <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ opacity: 0.5, margin: '0 auto 16px' }}>
  3477	                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
  3478	                    </svg>
  3479	                    <p style={{ fontSize: '14px' }}>No items yet</p>
  3480	                    <p style={{ fontSize: '12px', marginTop: '4px' }}>
  3481	                      {activeTable && getTotalSeats(activeTable) > 0
  3482	                        ? 'Select a seat, then tap a category to add items'
  3483	                        : 'Tap a category to add items'}
  3484	                    </p>
  3485	                  </div>
  3486	                ) : (
  3487	                  <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
  3488	                    {/* Group items by seat when table has seats */}
  3489	                    {groupedOrderItems.map((group) => (
  3490	                      <div key={group.label}>
  3491	                        {/* Group Header (only show when using seats) */}
  3492	                        {activeTable && getTotalSeats(activeTable) > 0 && groupedOrderItems.length > 1 && (
  3493	                          <div
  3494	                            style={{
  3495	                              display: 'flex',
  3496	                              alignItems: 'center',
  3497	                              gap: '8px',
  3498	                              marginBottom: '8px',
  3499	                              paddingBottom: '6px',
  3500	                              borderBottom: '1px solid rgba(255, 255, 255, 0.05)',
  3501	                            }}
  3502	                          >
  3503	                            <span
  3504	                              style={{
  3505	                                fontSize: '12px',
  3506	                                fontWeight: 600,
  3507	                                color: group.seatNumber ? '#c084fc' : '#94a3b8',
  3508	                                padding: '2px 8px',
  3509	                                background: group.seatNumber ? 'rgba(168, 85, 247, 0.15)' : 'rgba(255, 255, 255, 0.05)',
  3510	                                borderRadius: '4px',
  3511	                              }}
  3512	                            >
  3513	                              {group.label}
  3514	                            </span>
  3515	                            <span style={{ fontSize: '11px', color: '#64748b' }}>
  3516	                              {group.items.length} item{group.items.length !== 1 ? 's' : ''}
  3517	                            </span>
  3518	                          </div>
  3519	                        )}
  3520	
  3521	                        {/* Items in this group */}
  3522	                        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
  3523	                          {group.items.map((item) => (
  3524	                      <div
  3525	                        key={item.id}
  3526	                        style={{
  3527	                          padding: '12px',
  3528	                          background: item.sentToKitchen
  3529	                            ? item.isCompleted ? 'rgba(34, 197, 94, 0.1)' : 'rgba(59, 130, 246, 0.05)'
  3530	                            : 'rgba(255, 255, 255, 0.03)',
  3531	                          border: `1px solid ${
  3532	                            item.sentToKitchen
  3533	                              ? item.isCompleted ? 'rgba(34, 197, 94, 0.3)' : 'rgba(59, 130, 246, 0.2)'
  3534	                              : 'rgba(255, 255, 255, 0.08)'
  3535	                          }`,
  3536	                          borderRadius: '10px',
  3537	                        }}
  3538	                      >
  3539	                        {/* Item Header */}
  3540	                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
  3541	                          <div style={{ flex: 1 }}>
  3542	                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' }}>
  3543	                              <span style={{ fontSize: '14px', fontWeight: 500, color: '#e2e8f0' }}>
  3544	                                {item.quantity > 1 && <span style={{ color: '#94a3b8' }}>{item.quantity}x </span>}
  3545	                                {item.name}
  3546	                              </span>
  3547	
  3548	                              {/* Status Badges */}
  3549	                              {item.sentToKitchen && !item.isCompleted && (
  3550	                                <span style={{ fontSize: '9px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(59, 130, 246, 0.2)', color: '#60a5fa', fontWeight: 600, textTransform: 'uppercase' }}>
  3551	                                  Sent
  3552	                                </span>
  3553	                              )}
  3554	                              {item.isCompleted && (
  3555	                                <span style={{ fontSize: '9px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(34, 197, 94, 0.2)', color: '#4ade80', fontWeight: 600, textTransform: 'uppercase' }}>
  3556	                                  Ready
  3557	                                </span>
  3558	                              )}
  3559	
  3560	                              {/* Seat Badge */}
  3561	                              {item.seatNumber && (
  3562	                                <span style={{ fontSize: '9px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(168, 85, 247, 0.2)', color: '#c084fc', fontWeight: 600 }}>
  3563	                                  S{item.seatNumber}
  3564	                                </span>
  3565	                              )}
  3566	
  3567	                              {/* Course Badge */}
  3568	                              {item.courseNumber && (
  3569	                                <span style={{
  3570	                                  fontSize: '9px',
  3571	                                  padding: '2px 6px',
  3572	                                  borderRadius: '4px',
  3573	                                  background: item.courseStatus === 'fired' ? 'rgba(251, 191, 36, 0.2)'
  3574	                                    : item.courseStatus === 'ready' ? 'rgba(34, 197, 94, 0.2)'
  3575	                                    : 'rgba(59, 130, 246, 0.2)',
  3576	                                  color: item.courseStatus === 'fired' ? '#fbbf24'
  3577	                                    : item.courseStatus === 'ready' ? '#4ade80'
  3578	                                    : '#60a5fa',
  3579	                                  fontWeight: 600
  3580	                                }}>
  3581	                                  C{item.courseNumber}
  3582	                                </span>
  3583	                              )}
  3584	
  3585	                              {/* Held Badge */}
  3586	                              {item.isHeld && (
  3587	                                <span style={{ fontSize: '9px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(239, 68, 68, 0.2)', color: '#f87171', fontWeight: 600, textTransform: 'uppercase' }}>
  3588	                                  HELD
  3589	                                </span>
  3590	                              )}
  3591	
  3592	                              {/* Timed Rental Badge */}
  3593	                              {item.blockTimeMinutes && (
  3594	                                <span style={{
  3595	                                  fontSize: '9px',
  3596	                                  padding: '2px 6px',
  3597	                                  borderRadius: '4px',
  3598	                                  background: 'rgba(168, 85, 247, 0.2)',
  3599	                                  color: '#c084fc',
  3600	                                  fontWeight: 600,
  3601	                                  display: 'flex',
  3602	                                  alignItems: 'center',
  3603	                                  gap: '3px'
  3604	                                }}>
  3605	                                  <svg width="10" height="10" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3606	                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  3607	                                  </svg>
  3608	                                  {item.blockTimeMinutes} MIN
  3609	                                </span>
  3610	                              )}
  3611	                            </div>
  3612	
  3613	                            {/* Modifiers - Bullet point format */}
  3614	                            {item.modifiers && item.modifiers.length > 0 && (
  3615	                              <div style={{ fontSize: '12px', color: '#94a3b8', marginTop: '4px' }}>
  3616	                                {item.modifiers.map((m, idx) => (
  3617	                                  <div key={idx} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
  3618	                                    <span style={{ color: '#64748b' }}></span>
  3619	                                    <span>{m.name}{m.price > 0 ? ` (+$${m.price.toFixed(2)})` : ''}</span>
  3620	                                  </div>
  3621	                                ))}
  3622	                              </div>
  3623	                            )}
  3624	
  3625	                            {/* Kitchen Note */}
  3626	                            {item.specialNotes && (
  3627	                              <div style={{ fontSize: '11px', color: '#f59e0b', marginTop: '4px', display: 'flex', alignItems: 'center', gap: '4px' }}>
  3628	                                <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3629	                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
  3630	                                </svg>
  3631	                                {item.specialNotes}
  3632	                              </div>
  3633	                            )}
  3634	
  3635	                            {/* Timed Session Info */}
  3636	                            {item.blockTimeMinutes && (
  3637	                              <div style={{
  3638	                                marginTop: '8px',
  3639	                                padding: '8px 10px',
  3640	                                background: 'rgba(168, 85, 247, 0.1)',
  3641	                                border: '1px solid rgba(168, 85, 247, 0.2)',
  3642	                                borderRadius: '6px',
  3643	                              }}>
  3644	                                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
  3645	                                  <svg width="14" height="14" fill="none" stroke="#c084fc" viewBox="0 0 24 24">
  3646	                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  3647	                                  </svg>
  3648	                                  <span style={{ fontSize: '12px', color: '#c084fc', fontWeight: 500 }}>
  3649	                                    {item.blockTimeMinutes >= 60
  3650	                                      ? `${Math.floor(item.blockTimeMinutes / 60)} hour${item.blockTimeMinutes >= 120 ? 's' : ''} session`
  3651	                                      : `${item.blockTimeMinutes} minute session`
  3652	                                    }
  3653	                                  </span>
  3654	                                </div>
  3655	                                {!item.sentToKitchen && (
  3656	                                  <div style={{ fontSize: '10px', color: '#94a3b8', marginTop: '4px' }}>
  3657	                                    Timer starts when order is sent
  3658	                                  </div>
  3659	                                )}
  3660	                              </div>
  3661	                            )}
  3662	                          </div>
  3663	
  3664	                          {/* Price */}
  3665	                          <div style={{ fontSize: '14px', fontWeight: 600, color: '#22c55e', marginLeft: '8px' }}>
  3666	                            ${((item.price + (item.modifiers || []).reduce((sum, m) => sum + m.price, 0)) * item.quantity).toFixed(2)}
  3667	                          </div>
  3668	                        </div>
  3669	
  3670	                        {/* Action Buttons Row */}
  3671	                        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginTop: '10px', flexWrap: 'wrap' }}>
  3672	                          {/* Quantity Controls */}
  3673	                          <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
  3674	                            <button
  3675	                              onClick={() => handleUpdateQuantity(item.id, item.quantity - 1)}
  3676	                              disabled={item.sentToKitchen}
  3677	                              style={{
  3678	                                width: '26px',
  3679	                                height: '26px',
  3680	                                display: 'flex',
  3681	                                alignItems: 'center',
  3682	                                justifyContent: 'center',
  3683	                                background: 'rgba(255, 255, 255, 0.05)',
  3684	                                border: '1px solid rgba(255, 255, 255, 0.1)',
  3685	                                borderRadius: '6px',
  3686	                                color: item.sentToKitchen ? '#475569' : '#e2e8f0',
  3687	                                cursor: item.sentToKitchen ? 'not-allowed' : 'pointer',
  3688	                                fontSize: '14px',
  3689	                              }}
  3690	                            >
  3691	                              
  3692	                            </button>
  3693	                            <span style={{ fontSize: '13px', fontWeight: 600, color: '#f1f5f9', minWidth: '20px', textAlign: 'center' }}>
  3694	                              {item.quantity}
  3695	                            </span>
  3696	                            <button
  3697	                              onClick={() => handleUpdateQuantity(item.id, item.quantity + 1)}
  3698	                              disabled={item.sentToKitchen}
  3699	                              style={{
  3700	                                width: '26px',
  3701	                                height: '26px',
  3702	                                display: 'flex',
  3703	                                alignItems: 'center',
  3704	                                justifyContent: 'center',
  3705	                                background: 'rgba(255, 255, 255, 0.05)',
  3706	                                border: '1px solid rgba(255, 255, 255, 0.1)',
  3707	                                borderRadius: '6px',
  3708	                                color: item.sentToKitchen ? '#475569' : '#e2e8f0',
  3709	                                cursor: item.sentToKitchen ? 'not-allowed' : 'pointer',
  3710	                                fontSize: '14px',
  3711	                              }}
  3712	                            >
  3713	                              +
  3714	                            </button>
  3715	                          </div>
  3716	
  3717	                          {/* Note Button */}
  3718	                          {!item.sentToKitchen && (
  3719	                            <button
  3720	                              onClick={() => handleOpenNotesEditor(item.id, item.specialNotes)}
  3721	                              style={{
  3722	                                padding: '5px 8px',
  3723	                                background: item.specialNotes ? 'rgba(245, 158, 11, 0.15)' : 'rgba(255, 255, 255, 0.05)',
  3724	                                border: `1px solid ${item.specialNotes ? 'rgba(245, 158, 11, 0.3)' : 'rgba(255, 255, 255, 0.1)'}`,
  3725	                                borderRadius: '6px',
  3726	                                color: item.specialNotes ? '#f59e0b' : '#94a3b8',
  3727	                                cursor: 'pointer',
  3728	                                display: 'flex',
  3729	                                alignItems: 'center',
  3730	                                gap: '4px',
  3731	                                fontSize: '11px',
  3732	                              }}
  3733	                              title={item.specialNotes ? 'Edit note' : 'Add note'}
  3734	                            >
  3735	                              <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3736	                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
  3737	                              </svg>
  3738	                              Note
  3739	                            </button>
  3740	                          )}
  3741	
  3742	                          {/* Hold Button */}
  3743	                          {!item.sentToKitchen && (
  3744	                            <button
  3745	                              onClick={() => handleToggleHold(item.id)}
  3746	                              style={{
  3747	                                padding: '5px 8px',
  3748	                                background: item.isHeld ? 'rgba(239, 68, 68, 0.15)' : 'rgba(255, 255, 255, 0.05)',
  3749	                                border: `1px solid ${item.isHeld ? 'rgba(239, 68, 68, 0.3)' : 'rgba(255, 255, 255, 0.1)'}`,
  3750	                                borderRadius: '6px',
  3751	                                color: item.isHeld ? '#f87171' : '#94a3b8',
  3752	                                cursor: 'pointer',
  3753	                                display: 'flex',
  3754	                                alignItems: 'center',
  3755	                                gap: '4px',
  3756	                                fontSize: '11px',
  3757	                              }}
  3758	                              title={item.isHeld ? 'Release hold' : 'Hold item'}
  3759	                            >
  3760	                              <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3761	                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  3762	                              </svg>
  3763	                              {item.isHeld ? 'Held' : 'Hold'}
  3764	                            </button>
  3765	                          )}
  3766	
  3767	                          {/* Edit Button */}
  3768	                          {!item.sentToKitchen && item.modifiers && item.modifiers.length > 0 && (
  3769	                            <button
  3770	                              onClick={() => handleEditItem(item)}
  3771	                              style={{
  3772	                                padding: '5px 8px',
  3773	                                background: 'rgba(255, 255, 255, 0.05)',
  3774	                                border: '1px solid rgba(255, 255, 255, 0.1)',
  3775	                                borderRadius: '6px',
  3776	                                color: '#94a3b8',
  3777	                                cursor: 'pointer',
  3778	                                display: 'flex',
  3779	                                alignItems: 'center',
  3780	                                gap: '4px',
  3781	                                fontSize: '11px',
  3782	                              }}
  3783	                              title="Edit modifiers"
  3784	                            >
  3785	                              <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3786	                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
  3787	                              </svg>
  3788	                              Edit
  3789	                            </button>
  3790	                          )}
  3791	
  3792	                          {/* More Options Toggle */}
  3793	                          {!item.sentToKitchen && (
  3794	                            <button
  3795	                              onClick={() => handleToggleItemControls(item.id)}
  3796	                              style={{
  3797	                                padding: '5px 8px',
  3798	                                background: expandedItemId === item.id ? 'rgba(99, 102, 241, 0.15)' : 'rgba(255, 255, 255, 0.05)',
  3799	                                border: `1px solid ${expandedItemId === item.id ? 'rgba(99, 102, 241, 0.3)' : 'rgba(255, 255, 255, 0.1)'}`,
  3800	                                borderRadius: '6px',
  3801	                                color: expandedItemId === item.id ? '#a5b4fc' : '#94a3b8',
  3802	                                cursor: 'pointer',
  3803	                                fontSize: '11px',
  3804	                              }}
  3805	                            >
  3806	                              {expandedItemId === item.id ? '' : ''} More
  3807	                            </button>
  3808	                          )}
  3809	
  3810	                          {/* Delete Button */}
  3811	                          {!item.sentToKitchen && (
  3812	                            <button
  3813	                              onClick={() => handleRemoveItem(item.id)}
  3814	                              style={{
  3815	                                marginLeft: 'auto',
  3816	                                padding: '5px',
  3817	                                background: 'rgba(239, 68, 68, 0.1)',
  3818	                                border: '1px solid rgba(239, 68, 68, 0.2)',
  3819	                                borderRadius: '6px',
  3820	                                color: '#f87171',
  3821	                                cursor: 'pointer',
  3822	                              }}
  3823	                              title="Remove item"
  3824	                            >
  3825	                              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  3826	                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
  3827	                              </svg>
  3828	                            </button>
  3829	                          )}
  3830	                        </div>
  3831	
  3832	                        {/* Expanded Seat/Course Controls */}
  3833	                        {expandedItemId === item.id && !item.sentToKitchen && (
  3834	                          <motion.div
  3835	                            initial={{ height: 0, opacity: 0 }}
  3836	                            animate={{ height: 'auto', opacity: 1 }}
  3837	                            exit={{ height: 0, opacity: 0 }}
  3838	                            style={{
  3839	                              marginTop: '10px',
  3840	                              padding: '10px',
  3841	                              background: 'rgba(255, 255, 255, 0.02)',
  3842	                              borderRadius: '8px',
  3843	                              display: 'flex',
  3844	                              flexDirection: 'column',
  3845	                              gap: '10px',
  3846	                            }}
  3847	                          >
  3848	                            {/* Seat Assignment */}
  3849	                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
  3850	                              <span style={{ fontSize: '11px', color: '#64748b', width: '45px' }}>Seat:</span>
  3851	                              <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
  3852	                                <button
  3853	                                  onClick={() => handleUpdateSeat(item.id, null)}
  3854	                                  style={{
  3855	                                    width: '24px',
  3856	                                    height: '24px',
  3857	                                    display: 'flex',
  3858	                                    alignItems: 'center',
  3859	                                    justifyContent: 'center',
  3860	                                    background: !item.seatNumber ? 'rgba(148, 163, 184, 0.3)' : 'rgba(255, 255, 255, 0.05)',
  3861	                                    border: '1px solid rgba(255, 255, 255, 0.1)',
  3862	                                    borderRadius: '4px',
  3863	                                    color: '#94a3b8',
  3864	                                    cursor: 'pointer',
  3865	                                    fontSize: '11px',
  3866	                                  }}
  3867	                                >
  3868	                                  
  3869	                                </button>
  3870	                                {Array.from({ length: Math.max(guestCount, 4) }, (_, i) => i + 1).map(seat => (
  3871	                                  <button
  3872	                                    key={seat}
  3873	                                    onClick={() => handleUpdateSeat(item.id, seat)}
  3874	                                    style={{
  3875	                                      width: '24px',
  3876	                                      height: '24px',
  3877	                                      display: 'flex',
  3878	                                      alignItems: 'center',
  3879	                                      justifyContent: 'center',
  3880	                                      background: item.seatNumber === seat ? 'rgba(168, 85, 247, 0.3)' : 'rgba(255, 255, 255, 0.05)',
  3881	                                      border: `1px solid ${item.seatNumber === seat ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
  3882	                                      borderRadius: '4px',
  3883	                                      color: item.seatNumber === seat ? '#c084fc' : '#94a3b8',
  3884	                                      cursor: 'pointer',
  3885	                                      fontSize: '11px',
  3886	                                      fontWeight: item.seatNumber === seat ? 600 : 400,
  3887	                                    }}
  3888	                                  >
  3889	                                    {seat}
  3890	                                  </button>
  3891	                                ))}
  3892	                              </div>
  3893	                            </div>
  3894	
  3895	                            {/* Course Assignment */}
  3896	                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
  3897	                              <span style={{ fontSize: '11px', color: '#64748b', width: '45px' }}>Course:</span>
  3898	                              <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
  3899	                                <button
  3900	                                  onClick={() => handleUpdateCourse(item.id, null)}
  3901	                                  style={{
  3902	                                    width: '24px',
  3903	                                    height: '24px',
  3904	                                    display: 'flex',
  3905	                                    alignItems: 'center',
  3906	                                    justifyContent: 'center',
  3907	                                    background: !item.courseNumber ? 'rgba(148, 163, 184, 0.3)' : 'rgba(255, 255, 255, 0.05)',
  3908	                                    border: '1px solid rgba(255, 255, 255, 0.1)',
  3909	                                    borderRadius: '4px',
  3910	                                    color: '#94a3b8',
  3911	                                    cursor: 'pointer',
  3912	                                    fontSize: '11px',
  3913	                                  }}
  3914	                                >
  3915	                                  
  3916	                                </button>
  3917	                                {[1, 2, 3, 4, 5].map(course => (
  3918	                                  <button
  3919	                                    key={course}
  3920	                                    onClick={() => handleUpdateCourse(item.id, course)}
  3921	                                    style={{
  3922	                                      width: '24px',
  3923	                                      height: '24px',
  3924	                                      display: 'flex',
  3925	                                      alignItems: 'center',
  3926	                                      justifyContent: 'center',
  3927	                                      background: item.courseNumber === course ? 'rgba(59, 130, 246, 0.3)' : 'rgba(255, 255, 255, 0.05)',
  3928	                                      border: `1px solid ${item.courseNumber === course ? 'rgba(59, 130, 246, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
  3929	                                      borderRadius: '4px',
  3930	                                      color: item.courseNumber === course ? '#60a5fa' : '#94a3b8',
  3931	                                      cursor: 'pointer',
  3932	                                      fontSize: '11px',
  3933	                                      fontWeight: item.courseNumber === course ? 600 : 400,
  3934	                                    }}
  3935	                                  >
  3936	                                    {course}
  3937	                                  </button>
  3938	                                ))}
  3939	                              </div>
  3940	                            </div>
  3941	                          </motion.div>
  3942	                        )}
  3943	                          </div>
  3944	                        ))}
  3945	                        </div>
  3946	                      </div>
  3947	                    ))}
  3948	                  </div>
  3949	                )}
  3950	              </div>
  3951	
  3952	              {/* Order Panel Footer - Fixed at bottom, doesn't scroll */}
  3953	              <div
  3954	                style={{
  3955	                  padding: '16px 20px',
  3956	                  borderTop: '1px solid rgba(255, 255, 255, 0.08)',
  3957	                  background: 'rgba(15, 23, 42, 0.95)',
  3958	                  flexShrink: 0, // Prevent footer from shrinking - stays fixed at bottom
  3959	                }}
  3960	              >
  3961	                {/* Cash/Card Toggle */}
  3962	                <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
  3963	                  <button
  3964	                    onClick={() => setPaymentMode('cash')}
  3965	                    style={{
  3966	                      flex: 1,
  3967	                      padding: '10px',
  3968	                      background: paymentMode === 'cash' ? '#16a34a' : '#14532d', // Light green selected, dark green unselected
  3969	                      border: `1px solid ${paymentMode === 'cash' ? '#22c55e' : '#166534'}`,
  3970	                      borderRadius: '10px',
  3971	                      cursor: 'pointer',
  3972	                      textAlign: 'center',
  3973	                      transition: 'all 0.15s ease',
  3974	                    }}
  3975	                  >
  3976	                    <div style={{ fontSize: '11px', color: paymentMode === 'cash' ? '#bbf7d0' : '#86efac', fontWeight: 500, marginBottom: '2px' }}>
  3977	                      Cash
  3978	                    </div>
  3979	                    <div style={{ fontSize: '13px', fontWeight: 600, color: paymentMode === 'cash' ? '#ffffff' : '#86efac' }}>
  3980	                      ${orderTotal.toFixed(2)}
  3981	                    </div>
  3982	                  </button>
  3983	                  <button
  3984	                    onClick={() => setPaymentMode('card')}
  3985	                    style={{
  3986	                      flex: 1,
  3987	                      padding: '10px',
  3988	                      background: paymentMode === 'card' ? '#4f46e5' : '#312e81', // Light blue selected, dark blue unselected
  3989	                      border: `1px solid ${paymentMode === 'card' ? '#6366f1' : '#3730a3'}`,
  3990	                      borderRadius: '10px',
  3991	                      cursor: 'pointer',
  3992	                      textAlign: 'center',
  3993	                      transition: 'all 0.15s ease',
  3994	                    }}
  3995	                  >
  3996	                    <div style={{ fontSize: '11px', color: paymentMode === 'card' ? '#c7d2fe' : '#a5b4fc', fontWeight: 500, marginBottom: '2px' }}>
  3997	                      Card
  3998	                    </div>
  3999	                    <div style={{ fontSize: '13px', fontWeight: 600, color: paymentMode === 'card' ? '#ffffff' : '#a5b4fc' }}>
  4000	                      ${cardTotal.toFixed(2)}
  4001	                    </div>
  4002	                  </button>
  4003	                </div>
  4004	
  4005	                {/* Expandable Total Section */}
  4006	                <button
  4007	                  onClick={() => setShowTotalDetails(!showTotalDetails)}
  4008	                  style={{
  4009	                    width: '100%',
  4010	                    display: 'flex',
  4011	                    justifyContent: 'space-between',
  4012	                    alignItems: 'center',
  4013	                    padding: '10px 0',
  4014	                    background: 'transparent',
  4015	                    border: 'none',
  4016	                    cursor: 'pointer',
  4017	                    marginBottom: '12px',
  4018	                  }}
  4019	                >
  4020	                  <span style={{ fontSize: '14px', color: '#94a3b8', display: 'flex', alignItems: 'center', gap: '6px' }}>
  4021	                    <svg
  4022	                      width="12"
  4023	                      height="12"
  4024	                      fill="none"
  4025	                      stroke="currentColor"
  4026	                      viewBox="0 0 24 24"
  4027	                      style={{ transform: showTotalDetails ? 'rotate(180deg)' : 'rotate(0)', transition: 'transform 0.2s' }}
  4028	                    >
  4029	                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
  4030	                    </svg>
  4031	                    Total ({inlineOrderItems.length} item{inlineOrderItems.length !== 1 ? 's' : ''})
  4032	                  </span>
  4033	                  <span style={{ fontSize: '20px', fontWeight: 700, color: '#f1f5f9' }}>
  4034	                    ${orderTotal.toFixed(2)}
  4035	                  </span>
  4036	                </button>
  4037	
  4038	                {/* Expanded Total Details */}
  4039	                <AnimatePresence>
  4040	                  {showTotalDetails && (
  4041	                    <motion.div
  4042	                      initial={{ height: 0, opacity: 0 }}
  4043	                      animate={{ height: 'auto', opacity: 1 }}
  4044	                      exit={{ height: 0, opacity: 0 }}
  4045	                      style={{
  4046	                        overflow: 'hidden',
  4047	                        marginBottom: '12px',
  4048	                        padding: '12px',
  4049	                        background: 'rgba(255, 255, 255, 0.02)',
  4050	                        borderRadius: '10px',
  4051	                        border: '1px solid rgba(255, 255, 255, 0.05)',
  4052	                      }}
  4053	                    >
  4054	                      {/* Line Items */}
  4055	                      {inlineOrderItems.map((item) => (
  4056	                        <div key={item.id} style={{ marginBottom: '8px' }}>
  4057	                          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '13px' }}>
  4058	                            <span style={{ color: '#e2e8f0' }}>
  4059	                              {item.quantity}x {item.name}
  4060	                            </span>
  4061	                            <span style={{ color: '#94a3b8' }}>
  4062	                              ${(item.price * item.quantity).toFixed(2)}
  4063	                            </span>
  4064	                          </div>
  4065	                          {/* Item modifiers */}
  4066	                          {item.modifiers && item.modifiers.length > 0 && (
  4067	                            <div style={{ marginLeft: '12px', marginTop: '2px' }}>
  4068	                              {item.modifiers.map((m, idx) => (
  4069	                                <div key={idx} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#64748b' }}>
  4070	                                  <span>+ {m.name}</span>
  4071	                                  {m.price > 0 && <span>${(m.price * item.quantity).toFixed(2)}</span>}
  4072	                                </div>
  4073	                              ))}
  4074	                            </div>
  4075	                          )}
  4076	                        </div>
  4077	                      ))}
  4078	
  4079	                      {/* Subtotal */}
  4080	                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '13px', marginTop: '12px', paddingTop: '8px', borderTop: '1px solid rgba(255, 255, 255, 0.05)' }}>
  4081	                        <span style={{ color: '#94a3b8' }}>Subtotal</span>
  4082	                        <span style={{ color: '#e2e8f0' }}>${orderSubtotal.toFixed(2)}</span>
  4083	                      </div>
  4084	
  4085	                      {/* Cash Discount */}
  4086	                      {paymentMode === 'cash' && cashDiscount > 0 && (
  4087	                        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '13px', marginTop: '4px' }}>
  4088	                          <span style={{ color: '#4ade80' }}>Cash Discount ({Math.round(CASH_DISCOUNT_RATE * 100)}%)</span>
  4089	                          <span style={{ color: '#4ade80' }}>-${cashDiscount.toFixed(2)}</span>
  4090	                        </div>
  4091	                      )}
  4092	
  4093	                      {/* Tax */}
  4094	                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '13px', marginTop: '4px' }}>
  4095	                        <span style={{ color: '#94a3b8' }}>Tax ({Math.round(TAX_RATE * 100)}%)</span>
  4096	                        <span style={{ color: '#e2e8f0' }}>${tax.toFixed(2)}</span>
  4097	                      </div>
  4098	
  4099	                      {/* Total */}
  4100	                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '15px', fontWeight: 600, marginTop: '8px', paddingTop: '8px', borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
  4101	                        <span style={{ color: '#f1f5f9' }}>Total</span>
  4102	                        <span style={{ color: '#22c55e' }}>${orderTotal.toFixed(2)}</span>
  4103	                      </div>
  4104	
  4105	                      {/* Cash savings message */}
  4106	                      {paymentMode === 'cash' && cashDiscount > 0 && (
  4107	                        <div style={{ textAlign: 'center', marginTop: '8px', fontSize: '12px', color: '#4ade80', fontWeight: 500 }}>
  4108	                          You save ${cashDiscount.toFixed(2)} with cash!
  4109	                        </div>
  4110	                      )}
  4111	                    </motion.div>
  4112	                  )}
  4113	                </AnimatePresence>
  4114	
  4115	                {/* Action Buttons */}
  4116	                <div style={{ display: 'flex', gap: '10px' }}>
  4117	                  <button
  4118	                    onClick={handleSendToKitchen}
  4119	                    disabled={inlineOrderItems.filter(i => !i.sentToKitchen && !i.isHeld).length === 0 || isSendingOrder}
  4120	                    style={{
  4121	                      flex: 1,
  4122	                      padding: '14px',
  4123	                      background: isSendingOrder ? '#475569' : '#22c55e',
  4124	                      border: 'none',
  4125	                      borderRadius: '10px',
  4126	                      color: '#fff',
  4127	                      fontSize: '14px',
  4128	                      fontWeight: 600,
  4129	                      cursor: inlineOrderItems.filter(i => !i.sentToKitchen && !i.isHeld).length === 0 || isSendingOrder ? 'not-allowed' : 'pointer',
  4130	                      opacity: inlineOrderItems.filter(i => !i.sentToKitchen && !i.isHeld).length === 0 ? 0.5 : 1,
  4131	                    }}
  4132	                  >
  4133	                    {isSendingOrder ? 'Sending...' : 'Send'}
  4134	                  </button>
  4135	
  4136	                  <button
  4137	                    onClick={handleOpenPayment}
  4138	                    disabled={!activeOrderId}
  4139	                    style={{
  4140	                      flex: 1,
  4141	                      padding: '14px',
  4142	                      background: activeOrderId ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
  4143	                      border: `1px solid ${activeOrderId ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
  4144	                      borderRadius: '10px',
  4145	                      color: activeOrderId ? '#a5b4fc' : '#64748b',
  4146	                      fontSize: '14px',
  4147	                      fontWeight: 600,
  4148	                      cursor: activeOrderId ? 'pointer' : 'not-allowed',
  4149	                    }}
  4150	                  >
  4151	                    Pay
  4152	                  </button>
  4153	                </div>
  4154	              </div>
  4155	            </motion.div>
  4156	          )}
  4157	        </AnimatePresence>
  4158	      </div>
  4159	
  4160	      {/* Virtual Combine Bar */}
  4161	      <VirtualCombineBar
  4162	        tables={tables}
  4163	        onConfirm={() => handleConfirmVirtualCombine()}
  4164	        onCancel={cancelVirtualCombineMode}
  4165	        isConfirming={isCreatingVirtualGroup}
  4166	      />
  4167	
  4168	      {/* Existing Orders Modal (for virtual combine) */}
  4169	      <ExistingOrdersModal
  4170	        isOpen={showExistingOrdersModal}
  4171	        existingOrders={pendingExistingOrders}
  4172	        primaryTableName={tables.find(t => t.id === virtualCombinePrimaryId)?.name || 'Primary'}
  4173	        onConfirm={(actions) => handleConfirmVirtualCombine(actions)}
  4174	        onCancel={() => {
  4175	          setShowExistingOrdersModal(false)
  4176	          setPendingExistingOrders([])
  4177	        }}
  4178	        onCloseOrder={(orderId) => {
  4179	          // Redirect to payment for this order
  4180	          if (onOpenPayment) {
  4181	            onOpenPayment(orderId)
  4182	          }
  4183	        }}
  4184	        isProcessing={isCreatingVirtualGroup}
  4185	      />
  4186	
  4187	      {/* Virtual Group Manager Modal (for managing/dissolving virtual groups) */}
  4188	      {virtualGroupManagerTableId && (() => {
  4189	        const managerTable = tables.find(t => t.id === virtualGroupManagerTableId)
  4190	        if (!managerTable?.virtualGroupId) return null
  4191	        const groupTables = tables.filter(t => t.virtualGroupId === managerTable.virtualGroupId)
  4192	        const primaryTable = groupTables.find(t => t.virtualGroupPrimary) || groupTables[0]
  4193	        return (
  4194	          <VirtualGroupManagerModal
  4195	            isOpen={true}
  4196	            onClose={() => setVirtualGroupManagerTableId(null)}
  4197	            groupTables={groupTables}
  4198	            primaryTableId={primaryTable?.id || managerTable.id}
  4199	            virtualGroupId={managerTable.virtualGroupId}
  4200	            locationId={locationId}
  4201	            employeeId={employeeId}
  4202	            onGroupUpdated={() => {
  4203	              loadFloorPlanData(false)
  4204	              setVirtualGroupManagerTableId(null)
  4205	            }}
  4206	          />
  4207	        )
  4208	      })()}
  4209	
  4210	      {/* Table Info Panel (for combined table management) */}
  4211	      {infoPanelTableId && (
  4212	        <TableInfoPanel
  4213	          table={tables.find(t => t.id === infoPanelTableId) || null}
  4214	          isOpen={true}
  4215	          onClose={closeInfoPanel}
  4216	          onAddItems={() => {
  4217	            const table = tables.find(t => t.id === infoPanelTableId)
  4218	            if (table) handleTableTap(table)
  4219	            closeInfoPanel()
  4220	          }}
  4221	          onViewCheck={() => {
  4222	            const table = tables.find(t => t.id === infoPanelTableId)
  4223	            if (table) handleTableTap(table)
  4224	            closeInfoPanel()
  4225	          }}
  4226	          onMarkDirty={() => {
  4227	            if (infoPanelTableId) handleUpdateStatus(infoPanelTableId, 'dirty')
  4228	          }}
  4229	          onMarkAvailable={() => {
  4230	            if (infoPanelTableId) handleUpdateStatus(infoPanelTableId, 'available')
  4231	          }}
  4232	          onResetToDefault={
  4233	            tables.find(t => t.id === infoPanelTableId)?.combinedTableIds?.length
  4234	              ? () => handleResetToDefault([infoPanelTableId])
  4235	              : undefined
  4236	          }
  4237	        />
  4238	      )}
  4239	
  4240	      {/* Notes Editor Modal */}
  4241	      <AnimatePresence>
  4242	        {editingNotesItemId && (
  4243	          <motion.div
  4244	            initial={{ opacity: 0 }}
  4245	            animate={{ opacity: 1 }}
  4246	            exit={{ opacity: 0 }}
  4247	            style={{
  4248	              position: 'fixed',
  4249	              inset: 0,
  4250	              background: 'rgba(0, 0, 0, 0.6)',
  4251	              backdropFilter: 'blur(4px)',
  4252	              display: 'flex',
  4253	              alignItems: 'center',
  4254	              justifyContent: 'center',
  4255	              zIndex: 1000,
  4256	            }}
  4257	            onClick={() => setEditingNotesItemId(null)}
  4258	          >
  4259	            <motion.div
  4260	              initial={{ scale: 0.95, opacity: 0 }}
  4261	              animate={{ scale: 1, opacity: 1 }}
  4262	              exit={{ scale: 0.95, opacity: 0 }}
  4263	              onClick={(e) => e.stopPropagation()}
  4264	              style={{
  4265	                background: 'rgba(15, 23, 42, 0.98)',
  4266	                border: '1px solid rgba(255, 255, 255, 0.1)',
  4267	                borderRadius: '16px',
  4268	                padding: '24px',
  4269	                width: '100%',
  4270	                maxWidth: '400px',
  4271	                margin: '20px',
  4272	                boxShadow: '0 20px 60px rgba(0, 0, 0, 0.5)',
  4273	              }}
  4274	            >
  4275	              <h3 style={{ fontSize: '18px', fontWeight: 600, color: '#f1f5f9', marginBottom: '16px' }}>
  4276	                Kitchen Note
  4277	              </h3>
  4278	              <p style={{ fontSize: '12px', color: '#64748b', marginBottom: '12px' }}>
  4279	                This note will be sent to the kitchen with the order.
  4280	              </p>
  4281	              <textarea
  4282	                value={editingNotesText}
  4283	                onChange={(e) => setEditingNotesText(e.target.value)}
  4284	                placeholder="e.g., No onions, extra pickles, allergic to nuts..."
  4285	                autoFocus
  4286	                style={{
  4287	                  width: '100%',
  4288	                  minHeight: '100px',
  4289	                  padding: '12px',
  4290	                  background: 'rgba(255, 255, 255, 0.05)',
  4291	                  border: '1px solid rgba(255, 255, 255, 0.1)',
  4292	                  borderRadius: '10px',
  4293	                  color: '#e2e8f0',
  4294	                  fontSize: '14px',
  4295	                  resize: 'vertical',
  4296	                  outline: 'none',
  4297	                }}
  4298	                onKeyDown={(e) => {
  4299	                  if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
  4300	                    handleSaveNotes()
  4301	                  }
  4302	                  if (e.key === 'Escape') {
  4303	                    setEditingNotesItemId(null)
  4304	                  }
  4305	                }}
  4306	              />
  4307	              <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
  4308	                <button
  4309	                  onClick={() => setEditingNotesItemId(null)}
  4310	                  style={{
  4311	                    flex: 1,
  4312	                    padding: '12px',
  4313	                    background: 'rgba(255, 255, 255, 0.05)',
  4314	                    border: '1px solid rgba(255, 255, 255, 0.1)',
  4315	                    borderRadius: '10px',
  4316	                    color: '#94a3b8',
  4317	                    fontSize: '14px',
  4318	                    fontWeight: 500,
  4319	                    cursor: 'pointer',
  4320	                  }}
  4321	                >
  4322	                  Cancel
  4323	                </button>
  4324	                <button
  4325	                  onClick={handleSaveNotes}
  4326	                  style={{
  4327	                    flex: 1,
  4328	                    padding: '12px',
  4329	                    background: '#f59e0b',
  4330	                    border: 'none',
  4331	                    borderRadius: '10px',
  4332	                    color: '#fff',
  4333	                    fontSize: '14px',
  4334	                    fontWeight: 600,
  4335	                    cursor: 'pointer',
  4336	                  }}
  4337	                >
  4338	                  Save Note
  4339	                </button>
  4340	              </div>
  4341	              <p style={{ fontSize: '11px', color: '#475569', marginTop: '12px', textAlign: 'center' }}>
  4342	                Press +Enter to save  Esc to cancel
  4343	              </p>
  4344	            </motion.div>
  4345	          </motion.div>
  4346	        )}
  4347	      </AnimatePresence>
  4348	
  4349	      {/* Menu Item Context Menu (right-click) */}
  4350	      {contextMenu && (
  4351	        <MenuItemContextMenu
  4352	          x={contextMenu.x}
  4353	          y={contextMenu.y}
  4354	          itemId={contextMenu.item.id}
  4355	          itemName={contextMenu.item.name}
  4356	          isInQuickBar={isInQuickBar(contextMenu.item.id)}
  4357	          onClose={closeContextMenu}
  4358	          onAddToQuickBar={() => addToQuickBar(contextMenu.item.id)}
  4359	          onRemoveFromQuickBar={() => removeFromQuickBar(contextMenu.item.id)}
  4360	        />
  4361	      )}
  4362	
  4363	      {/* Room Reorder Modal */}
  4364	      <RoomReorderModal
  4365	        isOpen={showRoomReorderModal}
  4366	        onClose={() => setShowRoomReorderModal(false)}
  4367	        rooms={sections.map(s => ({ id: s.id, name: s.name, color: s.color }))}
  4368	        currentOrder={preferredRoomOrder}
  4369	        onSave={handleSaveRoomOrder}
  4370	      />
  4371	    </div>
  4372	  )
  4373	}

================================================================================
LIB/UTILS
================================================================================

================================================================================
FILE: /src/lib/seat-generation.ts
================================================================================
     1	/**
     2	 * GWI POS - Seat Position Generation Utilities
     3	 *
     4	 * Pure functions for calculating seat positions around tables.
     5	 * All positions are in PIXELS relative to table center.
     6	 *
     7	 * Coordinate System:
     8	 * - (0, 0) = Table center
     9	 * - Positive X = Right
    10	 * - Positive Y = Down
    11	 * - Angle: 0 = Up, 90 = Right, 180 = Down, 270 = Left
    12	 */
    13	
    14	import { SEAT_RADIUS, SEAT_DEFAULT_OFFSET, ANGLE } from '@/lib/floorplan/constants';
    15	
    16	// =============================================================================
    17	// TYPES
    18	// =============================================================================
    19	
    20	export type TableShape = 'rectangle' | 'square' | 'round' | 'oval' | 'booth';
    21	export type SeatPattern =
    22	  | 'all_around'
    23	  | 'two_sides'
    24	  | 'one_side'
    25	  | 'booth'
    26	  | 'heads_only'
    27	  | 'custom';
    28	
    29	export interface SeatPosition {
    30	  seatNumber: number; // 1-based
    31	  relativeX: number; // Offset from table center (pixels)
    32	  relativeY: number; // Offset from table center (pixels)
    33	  angle: number; // Facing direction (0 = up, 90 = right, 180 = down, 270 = left)
    34	}
    35	
    36	export interface GenerateSeatPositionsParams {
    37	  shape: TableShape;
    38	  pattern: SeatPattern;
    39	  capacity: number;
    40	  width: number; // Table width in pixels
    41	  height: number; // Table height in pixels
    42	  seatRadius?: number; // Default 15px
    43	  seatGap?: number; // Min gap between seats, default 5px
    44	}
    45	
    46	// =============================================================================
    47	// CONSTANTS
    48	// =============================================================================
    49	
    50	const DEFAULT_SEAT_GAP = 5; // pixels
    51	const CLEARANCE = SEAT_DEFAULT_OFFSET; // Distance from table edge to seat center
    52	
    53	// =============================================================================
    54	// MAIN FUNCTION
    55	// =============================================================================
    56	
    57	/**
    58	 * Generate seat positions for a table based on shape and pattern
    59	 */
    60	export function generateSeatPositions(
    61	  params: GenerateSeatPositionsParams
    62	): SeatPosition[] {
    63	  const { shape, pattern } = params;
    64	
    65	  // Route to shape-specific generator
    66	  if (shape === 'round') {
    67	    return generateRoundSeats(params);
    68	  }
    69	
    70	  if (shape === 'oval') {
    71	    return generateOvalSeats(params);
    72	  }
    73	
    74	  if (shape === 'booth') {
    75	    return generateBoothSeats(params);
    76	  }
    77	
    78	  // Rectangle and square use same logic
    79	  return generateRectangleSeats(params);
    80	}
    81	
    82	// =============================================================================
    83	// RECTANGLE / SQUARE SEATS
    84	// =============================================================================
    85	
    86	/**
    87	 * Generate seats for rectangle/square tables
    88	 * Clockwise distribution: top  right  bottom  left
    89	 */
    90	export function generateRectangleSeats(
    91	  params: GenerateSeatPositionsParams
    92	): SeatPosition[] {
    93	  const {
    94	    pattern,
    95	    capacity,
    96	    width,
    97	    height,
    98	    seatRadius = SEAT_RADIUS,
    99	    seatGap = DEFAULT_SEAT_GAP,
   100	  } = params;
   101	
   102	  const seats: SeatPosition[] = [];
   103	  const halfW = width / 2;
   104	  const halfH = height / 2;
   105	
   106	  // Special patterns
   107	  if (pattern === 'heads_only') {
   108	    // Only 2 seats at short ends
   109	    seats.push({
   110	      seatNumber: 1,
   111	      relativeX: 0,
   112	      relativeY: -(halfH + CLEARANCE),
   113	      angle: ANGLE.DOWN, // Face down toward table
   114	    });
   115	    seats.push({
   116	      seatNumber: 2,
   117	      relativeX: 0,
   118	      relativeY: halfH + CLEARANCE,
   119	      angle: ANGLE.UP, // Face up toward table
   120	    });
   121	    return seats;
   122	  }
   123	
   124	  if (pattern === 'one_side') {
   125	    // All seats on top edge
   126	    return distributeSeatsOnEdge(
   127	      capacity,
   128	      width,
   129	      0,
   130	      -(halfH + CLEARANCE),
   131	      180,
   132	      seatRadius,
   133	      seatGap
   134	    );
   135	  }
   136	
   137	  if (pattern === 'two_sides') {
   138	    // Split between top and bottom
   139	    const seatsPerSide = Math.ceil(capacity / 2);
   140	    const topSeats = distributeSeatsOnEdge(
   141	      seatsPerSide,
   142	      width,
   143	      0,
   144	      -(halfH + CLEARANCE),
   145	      180,
   146	      seatRadius,
   147	      seatGap
   148	    );
   149	    const bottomSeats = distributeSeatsOnEdge(
   150	      capacity - seatsPerSide,
   151	      width,
   152	      0,
   153	      halfH + CLEARANCE,
   154	      0,
   155	      seatRadius,
   156	      seatGap,
   157	      seatsPerSide + 1
   158	    );
   159	    return [...topSeats, ...bottomSeats];
   160	  }
   161	
   162	  if (pattern === 'booth') {
   163	    // One seat at each head + rest on long sides
   164	    const headSeats = 2;
   165	    const sideSeats = capacity - headSeats;
   166	    const seatsPerSide = Math.ceil(sideSeats / 2);
   167	
   168	    seats.push({
   169	      seatNumber: 1,
   170	      relativeX: 0,
   171	      relativeY: -(halfH + CLEARANCE),
   172	      angle: ANGLE.DOWN,
   173	    });
   174	
   175	    const rightSeats = distributeSeatsOnEdge(
   176	      seatsPerSide,
   177	      height,
   178	      halfW + CLEARANCE,
   179	      0,
   180	      270,
   181	      seatRadius,
   182	      seatGap,
   183	      2,
   184	      true
   185	    );
   186	    seats.push(...rightSeats);
   187	
   188	    seats.push({
   189	      seatNumber: 2 + seatsPerSide,
   190	      relativeX: 0,
   191	      relativeY: halfH + CLEARANCE,
   192	      angle: ANGLE.UP,
   193	    });
   194	
   195	    const leftSeats = distributeSeatsOnEdge(
   196	      sideSeats - seatsPerSide,
   197	      height,
   198	      -(halfW + CLEARANCE),
   199	      0,
   200	      90,
   201	      seatRadius,
   202	      seatGap,
   203	      3 + seatsPerSide,
   204	      true
   205	    );
   206	    seats.push(...leftSeats);
   207	
   208	    return seats;
   209	  }
   210	
   211	  // Default: all_around pattern
   212	  // Calculate perimeter and distribute proportionally
   213	  const perimeter = 2 * (width + height);
   214	  const topCount = Math.round((width / perimeter) * capacity);
   215	  const rightCount = Math.round((height / perimeter) * capacity);
   216	  const bottomCount = Math.round((width / perimeter) * capacity);
   217	  const leftCount = capacity - topCount - rightCount - bottomCount;
   218	
   219	  let seatNum = 1;
   220	
   221	  // Top edge (left to right)
   222	  const topSeats = distributeSeatsOnEdge(
   223	    topCount,
   224	    width,
   225	    0,
   226	    -(halfH + CLEARANCE),
   227	    180,
   228	    seatRadius,
   229	    seatGap,
   230	    seatNum
   231	  );
   232	  seats.push(...topSeats);
   233	  seatNum += topCount;
   234	
   235	  // Right edge (top to bottom)
   236	  const rightSeats = distributeSeatsOnEdge(
   237	    rightCount,
   238	    height,
   239	    halfW + CLEARANCE,
   240	    0,
   241	    270,
   242	    seatRadius,
   243	    seatGap,
   244	    seatNum,
   245	    true
   246	  );
   247	  seats.push(...rightSeats);
   248	  seatNum += rightCount;
   249	
   250	  // Bottom edge (right to left)
   251	  const bottomSeats = distributeSeatsOnEdge(
   252	    bottomCount,
   253	    width,
   254	    0,
   255	    halfH + CLEARANCE,
   256	    0,
   257	    seatRadius,
   258	    seatGap,
   259	    seatNum,
   260	    false,
   261	    true // Reverse for right-to-left
   262	  );
   263	  seats.push(...bottomSeats);
   264	  seatNum += bottomCount;
   265	
   266	  // Left edge (bottom to top)
   267	  const leftSeats = distributeSeatsOnEdge(
   268	    leftCount,
   269	    height,
   270	    -(halfW + CLEARANCE),
   271	    0,
   272	    90,
   273	    seatRadius,
   274	    seatGap,
   275	    seatNum,
   276	    true,
   277	    true // Reverse for bottom-to-top
   278	  );
   279	  seats.push(...leftSeats);
   280	
   281	  return seats;
   282	}
   283	
   284	/**
   285	 * Helper: Distribute seats evenly along an edge
   286	 */
   287	function distributeSeatsOnEdge(
   288	  count: number,
   289	  edgeLength: number,
   290	  baseX: number,
   291	  baseY: number,
   292	  angle: number,
   293	  seatRadius: number,
   294	  seatGap: number,
   295	  startSeatNum = 1,
   296	  vertical = false,
   297	  reverse = false
   298	): SeatPosition[] {
   299	  if (count === 0) return [];
   300	
   301	  const seats: SeatPosition[] = [];
   302	  const seatDiameter = seatRadius * 2;
   303	  const availableSpace = edgeLength - seatDiameter;
   304	  const spacing = count > 1 ? availableSpace / (count - 1) : 0;
   305	
   306	  for (let i = 0; i < count; i++) {
   307	    const index = reverse ? count - 1 - i : i;
   308	    const offset = count === 1 ? 0 : -availableSpace / 2 + index * spacing;
   309	
   310	    seats.push({
   311	      seatNumber: startSeatNum + i,
   312	      relativeX: vertical ? baseX : baseX + offset,
   313	      relativeY: vertical ? baseY + offset : baseY,
   314	      angle: angle,
   315	    });
   316	  }
   317	
   318	  return seats;
   319	}
   320	
   321	// =============================================================================
   322	// ROUND SEATS
   323	// =============================================================================
   324	
   325	/**
   326	 * Generate seats for round tables
   327	 * Evenly distributed around circumference, starting at top (12 o'clock)
   328	 */
   329	export function generateRoundSeats(
   330	  params: GenerateSeatPositionsParams
   331	): SeatPosition[] {
   332	  const {
   333	    capacity,
   334	    width,
   335	    height,
   336	    seatRadius = SEAT_RADIUS,
   337	  } = params;
   338	
   339	  const seats: SeatPosition[] = [];
   340	  const radius = Math.min(width, height) / 2 + CLEARANCE;
   341	
   342	  // Start at top (12 o'clock = -90 degrees = -PI/2)
   343	  const startAngle = -Math.PI / 2;
   344	  const angleStep = (2 * Math.PI) / capacity;
   345	
   346	  for (let i = 0; i < capacity; i++) {
   347	    const angle = startAngle + i * angleStep;
   348	    const x = radius * Math.cos(angle);
   349	    const y = radius * Math.sin(angle);
   350	
   351	    // Calculate facing angle (toward center)
   352	    // Angle in our system: 0 = up, 90 = right, 180 = down, 270 = left
   353	    const facingAngle = ((angle + Math.PI) * 180) / Math.PI;
   354	    const normalizedAngle = ((facingAngle % 360) + 360) % 360;
   355	
   356	    seats.push({
   357	      seatNumber: i + 1,
   358	      relativeX: Math.round(x),
   359	      relativeY: Math.round(y),
   360	      angle: Math.round(normalizedAngle),
   361	    });
   362	  }
   363	
   364	  return seats;
   365	}
   366	
   367	// =============================================================================
   368	// OVAL SEATS
   369	// =============================================================================
   370	
   371	/**
   372	 * Generate seats for oval tables
   373	 * Similar to round but with stretched ellipse
   374	 */
   375	export function generateOvalSeats(
   376	  params: GenerateSeatPositionsParams
   377	): SeatPosition[] {
   378	  const {
   379	    capacity,
   380	    width,
   381	    height,
   382	    seatRadius = SEAT_RADIUS,
   383	  } = params;
   384	
   385	  const seats: SeatPosition[] = [];
   386	  const radiusX = width / 2 + CLEARANCE;
   387	  const radiusY = height / 2 + CLEARANCE;
   388	
   389	  // Start at top (12 o'clock = -90 degrees = -PI/2)
   390	  const startAngle = -Math.PI / 2;
   391	  const angleStep = (2 * Math.PI) / capacity;
   392	
   393	  for (let i = 0; i < capacity; i++) {
   394	    const angle = startAngle + i * angleStep;
   395	    const x = radiusX * Math.cos(angle);
   396	    const y = radiusY * Math.sin(angle);
   397	
   398	    // Calculate facing angle (toward center)
   399	    const facingAngle = ((angle + Math.PI) * 180) / Math.PI;
   400	    const normalizedAngle = ((facingAngle % 360) + 360) % 360;
   401	
   402	    seats.push({
   403	      seatNumber: i + 1,
   404	      relativeX: Math.round(x),
   405	      relativeY: Math.round(y),
   406	      angle: Math.round(normalizedAngle),
   407	    });
   408	  }
   409	
   410	  return seats;
   411	}
   412	
   413	// =============================================================================
   414	// BOOTH SEATS
   415	// =============================================================================
   416	
   417	/**
   418	 * Generate seats for booth tables
   419	 * All seats on front (open) side
   420	 */
   421	export function generateBoothSeats(
   422	  params: GenerateSeatPositionsParams
   423	): SeatPosition[] {
   424	  const {
   425	    capacity,
   426	    width,
   427	    seatRadius = SEAT_RADIUS,
   428	    seatGap = DEFAULT_SEAT_GAP,
   429	  } = params;
   430	
   431	  // All seats on bottom edge (open side)
   432	  return distributeSeatsOnEdge(
   433	    capacity,
   434	    width,
   435	    0,
   436	    params.height / 2 + CLEARANCE,
   437	    0, // Face up toward table
   438	    seatRadius,
   439	    seatGap
   440	  );
   441	}
   442	
   443	// =============================================================================
   444	// UTILITY FUNCTIONS
   445	// =============================================================================
   446	
   447	/**
   448	 * Redistribute seats when capacity changes
   449	 * Maintains clockwise ordering, recalculates positions
   450	 */
   451	export function redistributeSeats(
   452	  existingPositions: SeatPosition[],
   453	  newSeatCount: number,
   454	  shape: TableShape,
   455	  width: number,
   456	  height: number
   457	): SeatPosition[] {
   458	  // Generate fresh positions with new count
   459	  return generateSeatPositions({
   460	    shape,
   461	    pattern: 'all_around',
   462	    capacity: newSeatCount,
   463	    width,
   464	    height,
   465	  });
   466	}
   467	
   468	/**
   469	 * Insert a new seat at a specific index
   470	 * Renumbers all seats and redistributes positions
   471	 */
   472	export function insertSeatAt(
   473	  existingPositions: SeatPosition[],
   474	  insertAtIndex: number, // 0-based
   475	  shape: TableShape,
   476	  width: number,
   477	  height: number
   478	): SeatPosition[] {
   479	  const newCapacity = existingPositions.length + 1;
   480	
   481	  // Generate positions for new capacity
   482	  const newPositions = generateSeatPositions({
   483	    shape,
   484	    pattern: 'all_around',
   485	    capacity: newCapacity,
   486	    width,
   487	    height,
   488	  });
   489	
   490	  // Renumber to reflect insertion point
   491	  const result: SeatPosition[] = [];
   492	
   493	  for (let i = 0; i < newPositions.length; i++) {
   494	    if (i < insertAtIndex) {
   495	      // Before insertion point - keep original numbering
   496	      result.push({
   497	        ...newPositions[i],
   498	        seatNumber: i + 1,
   499	      });
   500	    } else if (i === insertAtIndex) {
   501	      // New seat at insertion point
   502	      result.push({
   503	        ...newPositions[i],
   504	        seatNumber: insertAtIndex + 1,
   505	      });
   506	    } else {
   507	      // After insertion point - increment numbering
   508	      result.push({
   509	        ...newPositions[i],
   510	        seatNumber: i + 1,
   511	      });
   512	    }
   513	  }
   514	
   515	  return result;
   516	}

================================================================================
FILE: /src/lib/virtual-group-seats.ts
================================================================================
     1	/**
     2	 * Virtual Group Seat Numbering Logic
     3	 *
     4	 * Handles seat renumbering and labeling when tables are virtually combined.
     5	 * Virtual groups link tables logically without moving them physically.
     6	 */
     7	
     8	export interface VirtualSeatInfo {
     9	  seatId: string
    10	  tableId: string
    11	  tableName: string
    12	  originalSeatNumber: number // Number within original table (1, 2, 3...)
    13	  virtualSeatNumber: number // Sequential number within group (1..N)
    14	  originalLabel: string // Original label before grouping
    15	  virtualLabel: string // Display label with table prefix ("T1-3")
    16	}
    17	
    18	export interface TableWithSeats {
    19	  id: string
    20	  name: string
    21	  posX: number
    22	  posY: number
    23	  seats: Array<{
    24	    id: string
    25	    seatNumber: number
    26	    label: string
    27	    relativeX: number
    28	    relativeY: number
    29	  }>
    30	}
    31	
    32	/**
    33	 * Calculate virtual seat numbers for a group of tables
    34	 *
    35	 * Algorithm:
    36	 * 1. Primary table's seats come first (1, 2, 3...)
    37	 * 2. Secondary tables ordered by position (top-left clockwise)
    38	 * 3. Each table's seats ordered by seatNumber
    39	 * 4. Returns mapping for each seat
    40	 */
    41	export function calculateVirtualSeatNumbers(
    42	  primaryTableId: string,
    43	  tables: TableWithSeats[]
    44	): VirtualSeatInfo[] {
    45	  const result: VirtualSeatInfo[] = []
    46	
    47	  // Find primary table
    48	  const primaryTable = tables.find((t) => t.id === primaryTableId)
    49	  if (!primaryTable) {
    50	    throw new Error(`Primary table ${primaryTableId} not found`)
    51	  }
    52	
    53	  // Sort secondary tables by position (top-left first, then clockwise)
    54	  const secondaryTables = tables
    55	    .filter((t) => t.id !== primaryTableId)
    56	    .sort((a, b) => {
    57	      // Calculate angle from primary table center to secondary table center
    58	      const primaryCenterX = primaryTable.posX
    59	      const primaryCenterY = primaryTable.posY
    60	
    61	      const angleA = Math.atan2(a.posY - primaryCenterY, a.posX - primaryCenterX)
    62	      const angleB = Math.atan2(b.posY - primaryCenterY, b.posX - primaryCenterX)
    63	
    64	      // Convert to 0-360 degrees, starting from top (12 o'clock) going clockwise
    65	      const degreesA = ((angleA * 180) / Math.PI + 90 + 360) % 360
    66	      const degreesB = ((angleB * 180) / Math.PI + 90 + 360) % 360
    67	
    68	      return degreesA - degreesB
    69	    })
    70	
    71	  // Combine tables in order: primary first, then secondaries
    72	  const orderedTables = [primaryTable, ...secondaryTables]
    73	
    74	  let virtualSeatNumber = 1
    75	
    76	  // Process each table's seats
    77	  for (const table of orderedTables) {
    78	    // Sort seats by seat number
    79	    const sortedSeats = [...table.seats].sort((a, b) => a.seatNumber - b.seatNumber)
    80	
    81	    for (const seat of sortedSeats) {
    82	      result.push({
    83	        seatId: seat.id,
    84	        tableId: table.id,
    85	        tableName: table.name,
    86	        originalSeatNumber: seat.seatNumber,
    87	        virtualSeatNumber,
    88	        originalLabel: seat.label,
    89	        virtualLabel: `${table.name}-${seat.seatNumber}`,
    90	      })
    91	
    92	      virtualSeatNumber++
    93	    }
    94	  }
    95	
    96	  return result
    97	}
    98	
    99	/**
   100	 * Restore original seat numbers after dissolving a virtual group
   101	 */
   102	export function restoreOriginalSeatNumbers(
   103	  virtualSeats: VirtualSeatInfo[]
   104	): Map<string, { seatNumber: number; label: string }> {
   105	  const result = new Map<string, { seatNumber: number; label: string }>()
   106	
   107	  for (const virtualSeat of virtualSeats) {
   108	    result.set(virtualSeat.seatId, {
   109	      seatNumber: virtualSeat.originalSeatNumber,
   110	      label: virtualSeat.originalLabel,
   111	    })
   112	  }
   113	
   114	  return result
   115	}
   116	
   117	/**
   118	 * Get display label for a virtual seat
   119	 *
   120	 * @param virtualInfo - Virtual seat info
   121	 * @param showTablePrefix - If true, returns "T1-3", if false returns "3"
   122	 */
   123	export function getVirtualSeatLabel(
   124	  virtualInfo: VirtualSeatInfo,
   125	  showTablePrefix: boolean
   126	): string {
   127	  if (showTablePrefix) {
   128	    return virtualInfo.virtualLabel
   129	  }
   130	  return String(virtualInfo.originalSeatNumber)
   131	}
   132	
   133	/**
   134	 * Calculate total seat count for a virtual group
   135	 */
   136	export function getVirtualGroupSeatCount(tables: TableWithSeats[]): number {
   137	  return tables.reduce((total, table) => total + table.seats.length, 0)
   138	}
   139	
   140	/**
   141	 * Get seat distribution summary (useful for display)
   142	 */
   143	export function getVirtualGroupSeatSummary(
   144	  tables: TableWithSeats[]
   145	): Array<{ tableName: string; seatCount: number; seatRange: string }> {
   146	  const primaryTable = tables[0] // Assumes primary is first
   147	  const secondaryTables = tables.slice(1)
   148	  const orderedTables = [primaryTable, ...secondaryTables]
   149	
   150	  let startNumber = 1
   151	  const summary = []
   152	
   153	  for (const table of orderedTables) {
   154	    const seatCount = table.seats.length
   155	    const endNumber = startNumber + seatCount - 1
   156	    const seatRange = seatCount === 1 ? `${startNumber}` : `${startNumber}-${endNumber}`
   157	
   158	    summary.push({
   159	      tableName: table.name,
   160	      seatCount,
   161	      seatRange,
   162	    })
   163	
   164	    startNumber = endNumber + 1
   165	  }
   166	
   167	  return summary
   168	}

================================================================================
TYPES
================================================================================

================================================================================
FILE: /src/types/floor-plan.ts
================================================================================
FILE NOT FOUND

================================================================================
PRISMA SCHEMA - FLOOR PLAN MODELS
================================================================================

Extracting: Table, Seat, Section, FloorPlanElement, VirtualTableGroup models

     1	model Table {
     2	  id         String   @id @default(cuid())
     3	  locationId String
     4	  location   Location @relation(fields: [locationId], references: [id])
     5	  sectionId  String?
     6	  section    Section? @relation(fields: [sectionId], references: [id])
     7	
     8	  name         String  // "Table 1", "Bar 3", "Patio A"
     9	  abbreviation String? // Short display name for floor plan: "T1", "B3", "PA"
    10	  capacity     Int     @default(4) // DEPRECATED: Use _count.seats or seats.length instead
    11	  //  This field can drift from actual seat count. Always use seatCount from API responses.
    12	
    13	  // Floor plan position (Skill 80)
    14	  posX     Int    @default(0)
    15	  posY     Int    @default(0)
    16	  width    Int    @default(80)
    17	  height   Int    @default(80)
    18	  rotation Int    @default(0) // Degrees 0-359
    19	  shape       String @default("rectangle") // rectangle, circle, square, booth, bar
    20	  seatPattern String @default("all_around") // all_around, front_only, three_sides, two_sides, inside
    21	
    22	  // For timed rentals (pool tables, dart boards)
    23	  isTimedRental Boolean @default(false)
    24	  timedItemId   String? // Links to MenuItem for pricing
    25	
    26	  // Status
    27	  status   String  @default("available") // available, occupied, reserved, dirty, in_use
    28	  isActive Boolean @default(true)
    29	
    30	  // Table Combine (Skill 106/107)
    31	  combinedWithId   String? // Points to primary table when this table is combined
    32	  combinedTableIds Json?   // JSON array of table IDs that are combined into this one (on primary)
    33	  originalName     String? // Stores original name when combined for restoration on split
    34	
    35	  // Position before combine (for undo/split operations)
    36	  originalPosX     Int?    // Position before combine
    37	  originalPosY     Int?    // Position before combine
    38	
    39	  // Default layout (admin-defined, used for reset-to-default)
    40	  // Set via "Save as Default Layout" button in floor plan admin
    41	  defaultPosX      Int?    // Admin-defined default X position
    42	  defaultPosY      Int?    // Admin-defined default Y position
    43	  defaultSectionId String? // Admin-defined default section
    44	
    45	  // Locked items (T019) - bolted down furniture that cannot be moved
    46	  isLocked         Boolean @default(false)
    47	
    48	  // Virtual Table Combine - tables logically grouped without physically moving
    49	  virtualGroupId        String?   // UUID shared by all tables in group
    50	  virtualGroupPrimary   Boolean   @default(false) // Is this the primary (master) table?
    51	  virtualGroupColor     String?   // Hex color for matching pulsing glow
    52	  virtualGroupCreatedAt DateTime? // When group was created (for EOD cleanup/debugging)
    53	
    54	  createdAt DateTime @default(now())
    55	  updatedAt DateTime @updatedAt
    56	  // Sync fields (for cloud sync and soft deletes)
    57	  deletedAt DateTime?
    58	  syncedAt  DateTime?
    59	
    60	  orders                 Order[]
    61	  reservations           Reservation[]
    62	  timedSessions          TimedSession[]
    63	  seats                  Seat[]
    64	  tickets                Ticket[]
    65	  eventConfigurations    EventTableConfig[]
    66	  sourceTableOrderItems  OrderItem[] @relation("SourceTableOrderItems") // Items ordered from this table (virtual combine T-S notation)
    67	  entertainmentWaitlist  EntertainmentWaitlist[]
    68	
    69	  @@index([locationId])
    70	  @@index([sectionId])
    71	  @@index([status])
    72	  @@index([virtualGroupId])
    73	}

     1	model Seat {
     2	  id         String   @id @default(cuid())
     3	  locationId String
     4	  location   Location @relation(fields: [locationId], references: [id])
     5	  tableId    String
     6	  table      Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
     7	
     8	  // Identity
     9	  label      String // "1", "A", "A1" - displayed on floor plan
    10	  seatNumber Int // Sequential within table (1, 2, 3...)
    11	
    12	  // Relative positioning within table (offset from table center in pixels)
    13	  relativeX Int @default(0)
    14	  relativeY Int @default(0)
    15	  angle     Int @default(0) // Facing direction (0-359 degrees)
    16	
    17	  // Original positions from floor plan builder (for restore after combine/split)
    18	  originalRelativeX Int? // Saved X position before combine
    19	  originalRelativeY Int? // Saved Y position before combine
    20	  originalAngle     Int? // Saved angle before combine
    21	
    22	  // Seat properties
    23	  seatType String @default("standard") // standard, premium, accessible, booth_end
    24	
    25	  // Virtual Group (for combined tables)
    26	  virtualGroupId        String?   // Matches Table.virtualGroupId when combined
    27	  virtualSeatNumber     Int?      // Seat number within combined group (1-13 for 8+5)
    28	  virtualGroupCreatedAt DateTime? // When this seat joined a virtual group
    29	
    30	  // Status tracking
    31	  status             String  @default("available") // available, occupied, reserved
    32	  currentOrderItemId String? // Currently active order item at this seat
    33	
    34	  // Historical tracking
    35	  lastOccupiedAt DateTime? // When seat was last occupied
    36	  lastOccupiedBy String?   // Customer name or order reference
    37	
    38	  // Status
    39	  isActive Boolean @default(true)
    40	
    41	  createdAt DateTime @default(now())
    42	  updatedAt DateTime @updatedAt
    43	  // Sync fields (for cloud sync and soft deletes)
    44	  deletedAt DateTime?
    45	  syncedAt  DateTime?
    46	
    47	  // Relations
    48	  tickets Ticket[]
    49	
    50	  @@unique([tableId, seatNumber])
    51	  @@index([locationId])
    52	  @@index([tableId])
    53	  @@index([virtualGroupId])
    54	}

     1	model Section {
     2	  id         String   @id @default(cuid())
     3	  locationId String
     4	  location   Location @relation(fields: [locationId], references: [id])
     5	
     6	  name  String // "Bar", "Patio", "Main Floor"
     7	  color String?
     8	
     9	  // Floor plan (Skill 80)
    10	  posX        Int    @default(0)
    11	  posY        Int    @default(0)
    12	  width       Int    @default(400)
    13	  height      Int    @default(300)
    14	  shape       String @default("rectangle") // rectangle, polygon
    15	  coordinates Json? // For polygon: [{x, y}, {x, y}, ...]
    16	
    17	  // Floor plan dimensions in feet (for editor grid snapping)
    18	  widthFeet    Float  @default(40)   // Room width in feet
    19	  heightFeet   Float  @default(30)   // Room height in feet
    20	  gridSizeFeet Float  @default(0.25) // Grid snap size in feet (0.25 = 3 inch)
    21	
    22	  sortOrder Int     @default(0)
    23	  isVisible Boolean @default(true)
    24	
    25	  createdAt DateTime @default(now())
    26	  updatedAt DateTime @updatedAt
    27	  // Sync fields (for cloud sync and soft deletes)
    28	  deletedAt DateTime?
    29	  syncedAt  DateTime?
    30	
    31	  tables            Table[]
    32	  assignments       SectionAssignment[]
    33	  floorPlanElements FloorPlanElement[]
    34	
    35	  @@index([locationId])
    36	}

     1	model FloorPlanElement {
     2	  id         String   @id @default(cuid())
     3	  locationId String
     4	  location   Location @relation(fields: [locationId], references: [id])
     5	  sectionId  String?
     6	  section    Section? @relation(fields: [sectionId], references: [id])
     7	
     8	  name         String   // "Pool Table 1", "Dartboard A"
     9	  abbreviation String?  // Short display name: "PT1", "DB-A"
    10	
    11	  // Element classification
    12	  elementType  String   @default("entertainment") // "entertainment", "decoration", "barrier", "stage"
    13	  visualType   String   // "pool_table", "dartboard", "arcade", "foosball", "shuffleboard", etc.
    14	
    15	  // Link to menu item (for entertainment items with pricing/sessions)
    16	  linkedMenuItemId String?
    17	  linkedMenuItem   MenuItem? @relation(fields: [linkedMenuItemId], references: [id])
    18	
    19	  // Position & dimensions (in pixels, for rectangle/circle elements)
    20	  posX     Int @default(100)
    21	  posY     Int @default(100)
    22	  width    Int @default(120)
    23	  height   Int @default(80)
    24	  rotation Int @default(0)
    25	
    26	  // Geometry in feet (for wall/line elements, replaces posX/posY for lines)
    27	  // JSON: { "type": "line", "start": { "x": 0, "y": 0 }, "end": { "x": 10, "y": 0 } }
    28	  // Or: { "type": "rectangle", "x": 0, "y": 0, "width": 5, "height": 3 }
    29	  // Or: { "type": "circle", "x": 5, "y": 5, "radius": 2 }
    30	  geometry    Json?
    31	  thickness   Float   @default(0.5) // Wall thickness in feet
    32	
    33	  // Visual customization
    34	  fillColor   String? // Override default SVG fill
    35	  strokeColor String? // Override default SVG stroke
    36	  opacity     Float   @default(1.0)
    37	
    38	  // Status (for entertainment)
    39	  status          String    @default("available") // "available", "in_use", "reserved", "maintenance"
    40	  currentOrderId  String?   // Active order using this element
    41	  sessionStartedAt DateTime?
    42	  sessionExpiresAt DateTime?
    43	
    44	  sortOrder Int     @default(0)
    45	  isVisible Boolean @default(true)
    46	  isLocked  Boolean @default(false) // Prevent moving
    47	
    48	  createdAt DateTime  @default(now())
    49	  updatedAt DateTime  @updatedAt
    50	  deletedAt DateTime?
    51	  syncedAt  DateTime?
    52	
    53	  waitlistEntries EntertainmentWaitlist[]
    54	
    55	  @@index([locationId])
    56	  @@index([sectionId])
    57	  @@index([linkedMenuItemId])
    58	  @@index([status])
    59	}

