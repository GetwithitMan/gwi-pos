════════════════════════════════════════════════════════════════
  SOCKET LAYER + FETCH CONSOLIDATION — CODE EXPORT
  Generated: Mon Feb  9 16:55:30 MST 2026
════════════════════════════════════════════════════════════════


================================================================
  FILE 1: src/hooks/useOrderSockets.ts (NEW — Phase 2E)
================================================================

'use client'

import { useEffect, useState, useRef } from 'react'

// Socket.io client type
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type SocketCallback = (...args: any[]) => void
type Socket = {
  connected: boolean
  emit: (event: string, data?: unknown) => void
  on: (event: string, callback: SocketCallback) => void
  off: (event: string, callback?: SocketCallback) => void
  connect: () => void
  disconnect: () => void
}

interface UseOrderSocketsOptions {
  locationId: string | undefined
  enabled?: boolean
  onOpenOrdersChanged?: (data: { locationId: string; trigger: string; orderId?: string }) => void
  onOrderTotalsUpdated?: (data: {
    orderId: string
    totals: {
      subtotal: number
      taxTotal: number
      tipTotal: number
      discountTotal: number
      total: number
    }
  }) => void
  onEntertainmentStatusChanged?: (data: {
    itemId: string
    entertainmentStatus: string
    currentOrderId: string | null
  }) => void
}

export function useOrderSockets(options: UseOrderSocketsOptions): { isConnected: boolean } {
  const { locationId, enabled = true } = options

  const [isConnected, setIsConnected] = useState(false)
  const socketRef = useRef<Socket | null>(null)

  // Store callbacks in a ref so socket listeners always call the latest version
  // without triggering reconnection when callbacks change
  const callbacksRef = useRef(options)
  callbacksRef.current = options

  useEffect(() => {
    if (!locationId || !enabled) return

    let socket: Socket | null = null

    async function initSocket() {
      try {
        const { io } = await import('socket.io-client')

        const serverUrl = process.env.NEXT_PUBLIC_SOCKET_URL || window.location.origin

        socket = io(serverUrl, {
          path: '/api/socket',
          transports: ['websocket', 'polling'],
          reconnection: true,
          reconnectionAttempts: 10,
          reconnectionDelay: 1000,
          reconnectionDelayMax: 5000,
        }) as Socket

        socketRef.current = socket

        // Connection events
        socket.on('connect', () => {
          console.log('[Order Socket] Connected')
          setIsConnected(true)

          // Join location room via join_station (server joins location:{locationId} room)
          socket!.emit('join_station', {
            locationId,
            tags: [],
            terminalId: 'pos-' + Date.now(),
          })
        })

        socket.on('disconnect', () => {
          console.log('[Order Socket] Disconnected')
          setIsConnected(false)
        })

        socket.on('connect_error', (error: unknown) => {
          console.error('[Order Socket] Connection error:', error)
        })

        // Order list changed (items added, status changed, etc.)
        socket.on('orders:list-changed', (data: unknown) => {
          const payload = data as { locationId: string; trigger: string; orderId?: string }
          callbacksRef.current.onOpenOrdersChanged?.(payload)
        })

        // Order totals updated (payment, tip, discount changes)
        socket.on('order:totals-updated', (data: unknown) => {
          const payload = data as {
            orderId: string
            totals: {
              subtotal: number
              taxTotal: number
              tipTotal: number
              discountTotal: number
              total: number
            }
          }
          callbacksRef.current.onOrderTotalsUpdated?.(payload)
        })

        // Entertainment status changed
        socket.on('entertainment:status-changed', (data: unknown) => {
          const payload = data as {
            itemId: string
            entertainmentStatus: string
            currentOrderId: string | null
          }
          callbacksRef.current.onEntertainmentStatusChanged?.(payload)
        })

        // New order created - treat as an open orders change
        socket.on('order:created', (data: unknown) => {
          const payload = data as { orderId?: string } | undefined
          callbacksRef.current.onOpenOrdersChanged?.({
            locationId: locationId!,
            trigger: 'created',
            orderId: payload?.orderId,
          })
        })

        // Confirmation of room join
        socket.on('joined', (response: { success: boolean; rooms: number }) => {
          console.log('[Order Socket] Joined rooms:', response.rooms)
        })
      } catch (error) {
        console.error('[Order Socket] Failed to initialize:', error)
      }
    }

    initSocket()

    // Cleanup on unmount or when locationId/enabled changes
    return () => {
      if (socket) {
        socket.disconnect()
        socketRef.current = null
      }
    }
  }, [locationId, enabled])

  return { isConnected }
}


================================================================
  FILE 2: src/app/(pos)/orders/page.tsx
  (Phase 1A-1D, Phase 2F)
================================================================

'use client'

import { useEffect, useState, useCallback, useMemo, useRef } from 'react'
import { useRouter } from 'next/navigation'
import {
  DndContext,
  KeyboardSensor,
  PointerSensor,
  TouchSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  sortableKeyboardCoordinates,
} from '@dnd-kit/sortable'
import { Button } from '@/components/ui/button'
import { useAuthStore } from '@/stores/auth-store'
import { useOrderStore } from '@/stores/order-store'
import { useDevStore } from '@/stores/dev-store'
import { useOrderSettings } from '@/hooks/useOrderSettings'
import { usePOSDisplay } from '@/hooks/usePOSDisplay'
import { usePOSLayout } from '@/hooks/usePOSLayout'
import { useActiveOrder } from '@/hooks/useActiveOrder'
import { usePricing } from '@/hooks/usePricing'
import { useOrderPanelItems } from '@/hooks/useOrderPanelItems'
import { POSDisplaySettingsModal } from '@/components/orders/POSDisplaySettings'
import { formatCurrency } from '@/lib/utils'
import { calculateCardPrice } from '@/lib/pricing'
import { getPizzaBasePrice, debugPizzaPricing } from '@/lib/pizza-helpers'
import { PaymentModal } from '@/components/payment/PaymentModal'
import { DiscountModal } from '@/components/orders/DiscountModal'
import { CompVoidModal } from '@/components/orders/CompVoidModal'
import { ItemTransferModal } from '@/components/orders/ItemTransferModal'
import { SplitTicketManager } from '@/components/orders/SplitTicketManager'
import { OpenOrdersPanel, type OpenOrder } from '@/components/orders/OpenOrdersPanel'
import { TimeClockModal } from '@/components/time-clock/TimeClockModal'
import { ShiftStartModal } from '@/components/shifts/ShiftStartModal'
import { ShiftCloseoutModal } from '@/components/shifts/ShiftCloseoutModal'
import { ReceiptModal } from '@/components/receipt'
import type { OrderTypeConfig, OrderCustomFields, WorkflowRules } from '@/types/order-types'
import type { IngredientModificationType } from '@/types/orders'
import { ModifierModal } from '@/components/modifiers/ModifierModal'
import { PizzaBuilderModal } from '@/components/pizza/PizzaBuilderModal'
import { EntertainmentSessionStart } from '@/components/entertainment/EntertainmentSessionStart'
import type { PrepaidPackage } from '@/lib/entertainment-pricing'
import { AdminNav } from '@/components/admin/AdminNav'
import { FloorPlanHome } from '@/components/floor-plan'
import { BartenderView } from '@/components/bartender'
import { OrderPanel, type OrderPanelItemData } from '@/components/orders/OrderPanel'
import { QuickPickStrip } from '@/components/orders/QuickPickStrip'
import { useQuickPick } from '@/hooks/useQuickPick'
import { useOrderPanelCallbacks } from '@/hooks/useOrderPanelCallbacks'
import { useOrderingEngine } from '@/hooks/useOrderingEngine'
import { toast } from '@/stores/toast-store'
import { useOrderSockets } from '@/hooks/useOrderSockets'
import TipAdjustmentOverlay from '@/components/tips/TipAdjustmentOverlay'
import { CardFirstTabFlow } from '@/components/tabs/CardFirstTabFlow'
import type { Category, MenuItem, ModifierGroup, SelectedModifier, PizzaOrderConfig, OrderItem } from '@/types'

export default function OrdersPage() {
  const router = useRouter()
  const { employee, isAuthenticated, logout } = useAuthStore()
  const { currentOrder, startOrder, updateOrderType, loadOrder, addItem, updateItem, removeItem, updateQuantity, clearOrder } = useOrderStore()
  const { hasDevAccess, setHasDevAccess } = useDevStore()

  // Shared handlers from useActiveOrder hook
  const activeOrderFull = useActiveOrder({
    locationId: employee?.location?.id,
    employeeId: employee?.id,
  })
  const {
    expandedItemId,
    handleHoldToggle: sharedHoldToggle,
    handleNoteEdit: sharedNoteEdit,
    handleCourseChange: sharedCourseChange,
    handleSeatChange: sharedSeatChange,
    handleResend: sharedResend,
    handleToggleExpand,
  } = activeOrderFull

  const [categories, setCategories] = useState<Category[]>([])
  const [menuItems, setMenuItems] = useState<MenuItem[]>([])
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [showAdminNav, setShowAdminNav] = useState(false)

  // Floor Plan integration (T019)
  // viewMode: 'floor-plan' = default HOME view, 'bartender' = speed-optimized bar view
  // T023: FloorPlanHome is now the default for ALL users including bartenders
  // T024: Bartenders can switch to bartender view for faster tab management
  const isBartender = employee?.role?.name?.toLowerCase() === 'bartender'
  const [viewMode, setViewMode] = useState<'floor-plan' | 'bartender'>('floor-plan')

  // Check if user has admin/manager permissions
  // Handle both array permissions (new format) and role name check
  const permissionsArray = Array.isArray(employee?.permissions) ? employee.permissions : []

  // Full manager access (can do everything)
  const isManager = employee?.role?.name && ['Manager', 'Owner', 'Admin'].includes(employee.role.name) ||
    permissionsArray.some(p => ['admin', 'manage_menu', 'manage_employees'].includes(p))

  // Can access admin nav (reports, settings, etc.) - more inclusive
  const canAccessAdmin = isManager ||
    permissionsArray.some(p => p.startsWith('reports.') || p.startsWith('settings.') || p.startsWith('tips.'))

  // Modifier selection state
  const [showModifierModal, setShowModifierModal] = useState(false)
  const [selectedItem, setSelectedItem] = useState<MenuItem | null>(null)
  const [itemModifierGroups, setItemModifierGroups] = useState<ModifierGroup[]>([])
  const [loadingModifiers, setLoadingModifiers] = useState(false)
  const [editingOrderItem, setEditingOrderItem] = useState<{
    id: string
    menuItemId: string
    modifiers: { id: string; name: string; price: number; depth: number; parentModifierId?: string }[]
    ingredientModifications?: { ingredientId: string; name: string; modificationType: 'no' | 'lite' | 'on_side' | 'extra' | 'swap'; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[]
    specialNotes?: string
    pizzaConfig?: PizzaOrderConfig
  } | null>(null)

  // Ref for handleOpenModifiersShared — defined later but needed by useOrderingEngine
  const handleOpenModifiersSharedRef = useRef<((...args: any[]) => void) | null>(null)

  // T023: Inline ordering modifier callback ref
  const inlineModifierCallbackRef = useRef<((modifiers: { id: string; name: string; price: number; depth?: number; preModifier?: string | null; modifierId?: string | null; spiritTier?: string | null; linkedBottleProductId?: string | null; parentModifierId?: string | null }[], ingredientModifications?: { ingredientId: string; name: string; modificationType: string; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[]) => void) | null>(null)
  // T023: Inline ordering timed rental callback ref
  const inlineTimedRentalCallbackRef = useRef<((price: number, blockMinutes: number) => void) | null>(null)
  // T023: Inline ordering pizza builder callback ref
  const inlinePizzaCallbackRef = useRef<((config: PizzaOrderConfig) => void) | null>(null)

  // Pizza builder state
  const [showPizzaModal, setShowPizzaModal] = useState(false)
  const [selectedPizzaItem, setSelectedPizzaItem] = useState<MenuItem | null>(null)
  const [editingPizzaItem, setEditingPizzaItem] = useState<{
    id: string
    pizzaConfig?: PizzaOrderConfig
  } | null>(null)

  // Settings loaded from API via custom hook
  const { dualPricing, paymentSettings, priceRounding, taxRate, receiptSettings, taxInclusiveLiquor, taxInclusiveFood, requireCardForTab } = useOrderSettings()
  const { settings: displaySettings, menuItemClass, gridColsClass, orderPanelClass, categorySize, categoryColorMode, categoryButtonBgColor, categoryButtonTextColor, showPriceOnMenuItems, updateSetting, updateSettings } = usePOSDisplay()

  // POS Layout (Bar/Food mode, favorites, category order)
  // All logged-in employees can customize their personal layout colors
  // This is a fun personalization feature for servers
  const hasLayoutPermission = !!employee?.id
  const {
    currentMode,
    setMode,
    favorites,
    addFavorite,
    removeFavorite,
    reorderFavorites,
    canCustomize,
    layout,
    categoryOrder,
    setCategoryOrder,
    categoryColors,
    setCategoryColor,
    resetCategoryColor,
    resetAllCategoryColors,
    menuItemColors,
    setMenuItemStyle,
    resetMenuItemStyle,
    resetAllMenuItemStyles,
    // Quick Bar (T035)
    quickBar,
    quickBarEnabled,
    addToQuickBar,
    removeFromQuickBar,
    isInQuickBar,
    updateSetting: updateLayoutSetting,
  } = usePOSLayout({
    employeeId: employee?.id,
    locationId: employee?.location?.id,
    permissions: hasLayoutPermission ? { posLayout: ['customize_personal'] } : undefined,
  })

  const [paymentMethod, setPaymentMethod] = useState<'cash' | 'card'>('cash')

  // Unified pricing calculations
  const pricing = usePricing({
    subtotal: currentOrder?.subtotal || 0,
    discountTotal: currentOrder?.discountTotal || 0,
    tipTotal: currentOrder?.tipTotal || 0,
    paymentMethod,
  })

  // Display settings modal
  const [showDisplaySettings, setShowDisplaySettings] = useState(false)
  const [showSettingsDropdown, setShowSettingsDropdown] = useState(false)
  const [isEditingFavorites, setIsEditingFavorites] = useState(false)
  const [isEditingMenuItems, setIsEditingMenuItems] = useState(false)

  // Quick Bar items with full data (T035)
  const [quickBarItems, setQuickBarItems] = useState<{
    id: string
    name: string
    price: number
    bgColor?: string | null
    textColor?: string | null
  }[]>([])

  // Payment modal state
  const [showPaymentModal, setShowPaymentModal] = useState(false)
  const [initialPayMethod, setInitialPayMethod] = useState<'cash' | 'credit' | undefined>(undefined)
  const [orderToPayId, setOrderToPayId] = useState<string | null>(null)
  const [paymentTabCards, setPaymentTabCards] = useState<Array<{ id: string; cardType: string; cardLast4: string; cardholderName?: string | null; authAmount: number; isDefault: boolean }>>([])

  // Order to load into FloorPlanHome (for editing from Open Orders panel)
  const [orderToLoad, setOrderToLoad] = useState<{ id: string; orderNumber: number; tableId?: string; tabName?: string; orderType: string } | null>(null)

  // BartenderView tab deselect callback (registered via onRegisterDeselectTab)
  const bartenderDeselectTabRef = useRef<(() => void) | null>(null)
  // FloorPlanHome table deselect callback (registered via onRegisterDeselectTable)
  const floorPlanDeselectTableRef = useRef<(() => void) | null>(null)

  // Receipt modal state
  const [showReceiptModal, setShowReceiptModal] = useState(false)
  const [receiptOrderId, setReceiptOrderId] = useState<string | null>(null)

  // Order that was just paid - triggers FloorPlanHome to clear its state
  const [paidOrderId, setPaidOrderId] = useState<string | null>(null)

  // Split check modal state
  const [showSplitModal, setShowSplitModal] = useState(false)
  const [splitPaymentAmount, setSplitPaymentAmount] = useState<number | null>(null)
  const [evenSplitAmounts, setEvenSplitAmounts] = useState<{ splitNumber: number; amount: number }[] | null>(null)
  const [currentSplitIndex, setCurrentSplitIndex] = useState(0)

  // Discount modal state
  const [showDiscountModal, setShowDiscountModal] = useState(false)
  const [appliedDiscounts, setAppliedDiscounts] = useState<{ id: string; name: string; amount: number; percent?: number | null }[]>([])

  // Tab name prompt state
  const [showTabNamePrompt, setShowTabNamePrompt] = useState(false)
  const [tabNameInput, setTabNameInput] = useState('')
  const [tabNameCallback, setTabNameCallback] = useState<(() => void) | null>(null)

  // Card-first tab flow state
  const [showCardTabFlow, setShowCardTabFlow] = useState(false)
  const [cardTabOrderId, setCardTabOrderId] = useState<string | null>(null)
  const [tabCardInfo, setTabCardInfo] = useState<{ cardholderName?: string; cardLast4?: string; cardType?: string } | null>(null)

  // Clear tab card info only when order transitions FROM something TO null
  // (not when currentOrder is already null — avoids race with async order loading)
  const prevOrderRef = useRef(currentOrder)
  useEffect(() => {
    if (prevOrderRef.current && !currentOrder) {
      setTabCardInfo(null)
      setCardTabOrderId(null)
    }
    prevOrderRef.current = currentOrder
  }, [currentOrder])

  // Comp/Void modal state
  const [showCompVoidModal, setShowCompVoidModal] = useState(false)

  // Resend modal state (replaces blocking prompt/alert)
  const [resendModal, setResendModal] = useState<{ itemId: string; itemName: string } | null>(null)
  const [resendNote, setResendNote] = useState('')
  const [resendLoading, setResendLoading] = useState(false)
  const [compVoidItem, setCompVoidItem] = useState<{
    id: string
    menuItemId?: string
    name: string
    quantity: number
    price: number
    modifiers: { id: string; name: string; price: number; depth?: number; preModifier?: string | null; modifierId?: string | null; spiritTier?: string | null; linkedBottleProductId?: string | null; parentModifierId?: string | null }[]
    status?: string
    voidReason?: string
  } | null>(null)

  // Item Transfer modal state
  const [showItemTransferModal, setShowItemTransferModal] = useState(false)

  // Split Ticket Manager state
  const [showSplitTicketManager, setShowSplitTicketManager] = useState(false)

  // Tabs panel state
  const [showTabsPanel, setShowTabsPanel] = useState(false)
  const [isTabManagerExpanded, setIsTabManagerExpanded] = useState(false)
  const [showTipAdjustment, setShowTipAdjustment] = useState(false)
  const [tabsRefreshTrigger, setTabsRefreshTrigger] = useState(0)

  // Saved order state
  const [savedOrderId, setSavedOrderId] = useState<string | null>(null)
  const [isSendingOrder, setIsSendingOrder] = useState(false)
  const [orderSent, setOrderSent] = useState(false)

  // Sync savedOrderId with Zustand store — FloorPlanHome/BartenderView load orders
  // directly into Zustand via store.loadOrder(), bypassing setSavedOrderId.
  // This ensures Split/CompVoid/Resend modals can render (they depend on savedOrderId).
  useEffect(() => {
    const storeOrderId = currentOrder?.id ?? null
    if (storeOrderId !== savedOrderId) {
      setSavedOrderId(storeOrderId)
    }
  }, [currentOrder?.id]) // eslint-disable-line react-hooks/exhaustive-deps

  // Order type state (configurable order types)
  const [orderTypes, setOrderTypes] = useState<OrderTypeConfig[]>([])
  const [selectedOrderType, setSelectedOrderType] = useState<OrderTypeConfig | null>(null)
  const [orderCustomFields, setOrderCustomFields] = useState<OrderCustomFields>({})

  // Open orders count for badge
  const [openOrdersCount, setOpenOrdersCount] = useState(0)

  // Item notes modal state (for quick note editing)
  const [editingNotesItemId, setEditingNotesItemId] = useState<string | null>(null)
  const [editingNotesText, setEditingNotesText] = useState('')

  // Time clock modal state
  const [showTimeClockModal, setShowTimeClockModal] = useState(false)

  // Shift management state
  const [currentShift, setCurrentShift] = useState<{
    id: string
    startedAt: string
    startingCash: number
    employee: { id: string; name: string; roleId?: string }
    locationId?: string
  } | null>(null)
  const [showShiftStartModal, setShowShiftStartModal] = useState(false)
  const [showShiftCloseoutModal, setShowShiftCloseoutModal] = useState(false)
  const [shiftChecked, setShiftChecked] = useState(false)

  // Combo selection state
  const [showComboModal, setShowComboModal] = useState(false)
  const [selectedComboItem, setSelectedComboItem] = useState<MenuItem | null>(null)
  const [comboTemplate, setComboTemplate] = useState<{
    id: string
    basePrice: number
    comparePrice?: number | null
    components: {
      id: string
      slotName: string
      displayName: string
      isRequired: boolean
      minSelections: number
      maxSelections: number
      menuItemId?: string | null
      menuItem?: {
        id: string
        name: string
        price: number
        modifierGroups?: {
          modifierGroup: {
            id: string
            name: string
            displayName?: string | null
            minSelections: number
            maxSelections: number
            isRequired: boolean
            modifiers: {
              id: string
              name: string
              price: number
              childModifierGroupId?: string | null
            }[]
          }
        }[]
      } | null
      itemPriceOverride?: number | null
      modifierPriceOverrides?: Record<string, number> | null
      // Legacy fields
      options: { id: string; menuItemId: string; name: string; upcharge: number; isAvailable: boolean }[]
    }[]
  } | null>(null)
  // comboSelections maps componentId -> groupId -> modifierIds
  const [comboSelections, setComboSelections] = useState<Record<string, Record<string, string[]>>>({})

  // Timed rental state
  const [showTimedRentalModal, setShowTimedRentalModal] = useState(false)
  const [selectedTimedItem, setSelectedTimedItem] = useState<MenuItem | null>(null)
  const [selectedRateType, setSelectedRateType] = useState<'per15Min' | 'per30Min' | 'perHour'>('perHour')
  const [activeSessions, setActiveSessions] = useState<{
    id: string
    menuItemId: string
    menuItemName: string
    startedAt: string
    rateType: string
    rateAmount: number
    orderItemId?: string
  }[]>([])
  const [loadingSession, setLoadingSession] = useState(false)

  // Entertainment session start modal state
  const [showEntertainmentStart, setShowEntertainmentStart] = useState(false)
  const [entertainmentItem, setEntertainmentItem] = useState<{
    id: string
    name: string
    ratePerMinute?: number
    prepaidPackages?: PrepaidPackage[]
    happyHourEnabled?: boolean
    happyHourPrice?: number
  } | null>(null)

  // Menu search state (legacy order-entry mode removed — FloorPlanHome/BartenderView have their own search)

  // OrderPanel data mapping
  const orderPanelItems = useOrderPanelItems(menuItems)

  // Quick Pick: selection state for fast quantity setting
  const {
    selectedItemId: quickPickSelectedId,
    selectedItemIds: quickPickSelectedIds,
    selectItem: selectQuickPickItem,
    setSelectedItemId: setQuickPickSelectedId,
    clearSelection: clearQuickPick,
    multiSelectMode: quickPickMultiSelect,
    toggleMultiSelect: toggleQuickPickMultiSelect,
    selectAllPending: selectAllPendingQuickPick,
  } = useQuickPick(orderPanelItems)

  // Unified ordering engine for OrderPanel callbacks (floor-plan + bartender views)
  const engine = useOrderingEngine({
    locationId: employee?.location?.id || '',
    employeeId: employee?.id,
    onOpenModifiers: ((...args: any[]) => handleOpenModifiersSharedRef.current?.(...args)) as any,
    onOpenPizzaBuilder: (item, onComplete) => {
      inlinePizzaCallbackRef.current = onComplete
      setSelectedPizzaItem(item as MenuItem)
      setEditingPizzaItem(null)
      setShowPizzaModal(true)
    },
    onOpenTimedRental: (item, onComplete) => {
      inlineTimedRentalCallbackRef.current = onComplete
      setSelectedTimedItem(item as MenuItem)
      setShowTimedRentalModal(true)
    },
  })

  // Unified OrderPanel callbacks (shared between floor-plan and bartender)
  const panelCallbacks = useOrderPanelCallbacks({
    engine,
    activeOrder: activeOrderFull,
    onOpenCompVoid: (item) => {
      const orderId = useOrderStore.getState().currentOrder?.id || savedOrderId
      if (!orderId) {
        console.error('[CompVoid] No order ID found — cannot open comp/void modal')
        return
      }
      setOrderToPayId(orderId)
      setCompVoidItem(item)
      setShowCompVoidModal(true)
    },
    onOpenResend: (itemId, itemName) => {
      setResendNote('')
      setResendModal({ itemId, itemName })
    },
    onOpenSplit: () => {
      setShowSplitTicketManager(true)
    },
  })

  // Multi-digit entry: tapping 1 then 0 quickly = 10
  const ordersDigitBufferRef = useRef<string>('')
  const ordersDigitTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)

  const handleQuickPickNumber = useCallback((num: number) => {
    if (!quickPickSelectedId) return
    // Read latest items from store to avoid stale closure on rapid taps
    const storeOrder = useOrderStore.getState().currentOrder
    const item = storeOrder?.items.find(i => i.id === quickPickSelectedId)
    if (!item || item.sentToKitchen) return

    if (ordersDigitTimerRef.current) clearTimeout(ordersDigitTimerRef.current)
    ordersDigitBufferRef.current += String(num)
    const pendingQty = parseInt(ordersDigitBufferRef.current, 10)

    if (pendingQty === 0) {
      ordersDigitBufferRef.current = ''
      removeItem(quickPickSelectedId)
      return
    }

    const delta = pendingQty - item.quantity
    if (delta !== 0) updateQuantity(quickPickSelectedId, delta)

    ordersDigitTimerRef.current = setTimeout(() => {
      ordersDigitBufferRef.current = ''
    }, 600)
  }, [quickPickSelectedId, updateQuantity, removeItem])

  // Clear digit buffer on selection change
  useEffect(() => {
    ordersDigitBufferRef.current = ''
    if (ordersDigitTimerRef.current) clearTimeout(ordersDigitTimerRef.current)
  }, [quickPickSelectedId])

  // OrderPanel calculations (from usePricing hook)
  // Tax-inclusive liquor/food is handled inside usePricing + server-side calculateOrderTotals.
  // After save, syncServerTotals overwrites these with the server's authoritative values.
  const subtotal = pricing.subtotal
  const taxAmount = pricing.tax
  const totalDiscounts = pricing.discounts + pricing.cashDiscount
  const grandTotal = pricing.total

  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/login')
    }
  }, [isAuthenticated, router])

  // Load menu with cache-busting
  const loadMenu = useCallback(async () => {
    if (!employee?.location?.id) return
    try {
      const timestamp = Date.now()
      const params = new URLSearchParams({ locationId: employee.location.id, _t: timestamp.toString() })
      const response = await fetch(`/api/menu?${params}`, {
        cache: 'no-store',
        headers: { 'Cache-Control': 'no-cache' },
      })
      if (response.ok) {
        const data = await response.json()
        setCategories(data.categories)
        setMenuItems([...data.items]) // Force new array reference
        if (data.categories.length > 0 && !selectedCategory) {
          setSelectedCategory(data.categories[0].id)
        }
      }
    } catch (error) {
      console.error('Failed to load menu:', error)
    } finally {
      setIsLoading(false)
    }
  }, [employee?.location?.id, selectedCategory])

  // Load order types
  const loadOrderTypes = useCallback(async () => {
    if (!employee?.location?.id) return
    try {
      const response = await fetch(`/api/order-types?locationId=${employee.location.id}`)
      if (response.ok) {
        const data = await response.json()
        setOrderTypes(data.orderTypes || [])
      }
    } catch (error) {
      console.error('Failed to load order types:', error)
    }
  }, [employee?.location?.id])

  useEffect(() => {
    if (employee?.location?.id) {
      loadMenu()
      loadOrderTypes()
      loadActiveSessions()
    }
  }, [employee?.location?.id, loadMenu, loadOrderTypes])

  // Throttled loadMenu — coalesces rapid calls from entertainment handlers
  const menuRefreshingRef = useRef(false)
  const menuRefreshQueuedRef = useRef(false)
  const throttledLoadMenu = useCallback(() => {
    if (menuRefreshingRef.current) {
      menuRefreshQueuedRef.current = true
      return
    }
    menuRefreshingRef.current = true
    loadMenu().finally(() => {
      menuRefreshingRef.current = false
      if (menuRefreshQueuedRef.current) {
        menuRefreshQueuedRef.current = false
        loadMenu()
      }
    })
  }, [loadMenu])

  // Socket-based real-time updates for open orders + entertainment status
  useOrderSockets({
    locationId: employee?.location?.id,
    onOpenOrdersChanged: () => {
      loadOpenOrdersCount()
    },
    onEntertainmentStatusChanged: (data) => {
      setMenuItems(prev => prev.map(item =>
        item.id === data.itemId
          ? { ...item, entertainmentStatus: data.entertainmentStatus as MenuItem['entertainmentStatus'], currentOrderId: data.currentOrderId }
          : item
      ))
    },
  })

  // Visibility-change fallback for entertainment status (tab refocus)
  const selectedCategoryData = categories.find(c => c.id === selectedCategory)
  useEffect(() => {
    if (selectedCategoryData?.categoryType !== 'entertainment') return

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') loadMenu()
    }

    document.addEventListener('visibilitychange', handleVisibilityChange)
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [selectedCategoryData?.categoryType, loadMenu])

  const loadActiveSessions = async () => {
    if (!employee?.location?.id) return
    try {
      const params = new URLSearchParams({ locationId: employee.location.id, status: 'active' })
      const response = await fetch(`/api/timed-sessions?${params}`)
      if (response.ok) {
        const data = await response.json()
        setActiveSessions(data.sessions || [])
      }
    } catch (error) {
      console.error('Failed to load active sessions:', error)
    }
  }

  // Check for open shift on load
  useEffect(() => {
    if (employee?.id && employee?.location?.id && !shiftChecked) {
      checkOpenShift()
    }
  }, [employee?.id, employee?.location?.id, shiftChecked])

  const checkOpenShift = async () => {
    if (!employee?.id || !employee?.location?.id) return
    try {
      const params = new URLSearchParams({
        locationId: employee.location.id,
        employeeId: employee.id,
        status: 'open',
      })
      const response = await fetch(`/api/shifts?${params}`)
      if (response.ok) {
        const data = await response.json()
        if (data.shifts && data.shifts.length > 0) {
          // Enrich shift data with roleId and locationId for tip distribution
          setCurrentShift({
            ...data.shifts[0],
            employee: {
              ...data.shifts[0].employee,
              roleId: employee?.role?.id,
            },
            locationId: employee?.location?.id,
          })
        } else {
          // No open shift - prompt to start one
          setShowShiftStartModal(true)
        }
      }
    } catch (error) {
      console.error('Failed to check shift:', error)
    } finally {
      setShiftChecked(true)
    }
  }

  // Load open orders count (debounced — many call sites trigger tabsRefreshTrigger)
  const loadOpenOrdersCountRef = useRef<ReturnType<typeof setTimeout>>(undefined)
  const loadOpenOrdersCount = useCallback(() => {
    if (!employee?.location?.id) return
    clearTimeout(loadOpenOrdersCountRef.current)
    loadOpenOrdersCountRef.current = setTimeout(async () => {
      try {
        const params = new URLSearchParams({ locationId: employee.location.id })
        const response = await fetch(`/api/orders/open?${params}`)
        if (response.ok) {
          const data = await response.json()
          setOpenOrdersCount(data.orders?.length || 0)
        }
      } catch (error) {
        console.error('Failed to load open orders count:', error)
      }
    }, 300)
  }, [employee?.location?.id])

  useEffect(() => {
    if (employee?.location?.id) {
      loadOpenOrdersCount()
    }
  }, [employee?.location?.id, tabsRefreshTrigger, loadOpenOrdersCount])

  useEffect(() => {
    if (!currentOrder) {
      startOrder('dine_in', { guestCount: 1 })
    }
  }, [currentOrder, startOrder])

  // Load quick bar items when quickBar changes (T035)
  useEffect(() => {
    if (!quickBar || quickBar.length === 0) {
      setQuickBarItems([])
      return
    }

    let cancelled = false

    const loadQuickBarItems = async () => {
      try {
        const itemPromises = quickBar.map(async (itemId) => {
          try {
            const res = await fetch(`/api/menu/items/${itemId}`)
            if (!cancelled && res.ok) {
              const data = await res.json()
              const customStyle = menuItemColors[itemId]
              return {
                id: data.item.id,
                name: data.item.name,
                price: Number(data.item.price),
                bgColor: customStyle?.bgColor || null,
                textColor: customStyle?.textColor || null,
              }
            }
          } catch {
            // Individual item fetch failed — skip it
          }
          return null
        })

        const items = await Promise.all(itemPromises)
        if (!cancelled) {
          setQuickBarItems(items.filter(Boolean) as typeof quickBarItems)
        }
      } catch {
        // Quick bar load failed — non-critical, ignore
      }
    }

    loadQuickBarItems()

    return () => { cancelled = true }
  }, [quickBar, menuItemColors])

  const handleLogout = async () => {
    // Check for open shift and prompt for closeout
    if (employee?.id) {
      try {
        const res = await fetch(`/api/shifts?employeeId=${employee.id}&status=open`)
        if (res.ok) {
          const data = await res.json()
          if (data.data?.length > 0) {
            const closeShift = window.confirm(
              'You have an open shift. Would you like to close your shift before logging out?'
            )
            if (closeShift) {
              router.push('/reports/shift')
              return
            }
          }
        }
      } catch {
        // Shift check failed — proceed with logout anyway
      }
    }
    clearOrder()
    setHasDevAccess(false)
    logout()
    router.push('/login')
  }

  // Save order to database (create new or update existing)
  const saveOrderToDatabase = async (): Promise<string | null> => {
    if (!currentOrder?.items.length || !employee) return null

    try {
      // If we already have a saved order ID, use POST append for items (prevents race conditions)
      if (savedOrderId) {
        // Step 1: Update metadata (if any changed)
        const metadataChanged = currentOrder.tabName !== undefined ||
          currentOrder.guestCount !== undefined ||
          currentOrder.notes !== undefined

        if (metadataChanged) {
          const metadataResponse = await fetch(`/api/orders/${savedOrderId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              tabName: currentOrder.tabName,
              guestCount: currentOrder.guestCount,
              notes: currentOrder.notes,
            }),
          })

          if (!metadataResponse.ok) {
            const err = await metadataResponse.json()
            throw new Error(err.error || 'Failed to update order metadata')
          }
        }

        // Step 2: Append items via POST (atomic, race-safe)
        // NOTE: This is a simplified migration. In production, you'd track which items
        // are new vs existing and only POST new items. For now, this maintains backward
        // compatibility with the old PUT behavior by re-creating all items.
        // TODO: Implement proper item tracking to only POST new/changed items
        const itemsResponse = await fetch(`/api/orders/${savedOrderId}/items`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: currentOrder.items.map(item => ({
              menuItemId: item.menuItemId,
              name: item.name,
              price: item.price,
              quantity: item.quantity,
              modifiers: item.modifiers.map(mod => ({
                modifierId: (mod.id || mod.modifierId) ?? '',
                name: mod.name,
                price: Number(mod.price),
                depth: mod.depth ?? 0,
                preModifier: mod.preModifier ?? null,
                spiritTier: mod.spiritTier ?? null,
                linkedBottleProductId: mod.linkedBottleProductId ?? null,
                parentModifierId: mod.parentModifierId ?? null,
              })),
              ingredientModifications: item.ingredientModifications?.map(ing => ({
                ingredientId: ing.ingredientId,
                name: ing.name,
                modificationType: ing.modificationType,
                priceAdjustment: ing.priceAdjustment,
                swappedTo: ing.swappedTo,
              })),
              specialNotes: item.specialNotes,
              pizzaConfig: item.pizzaConfig,
            })),
          }),
        })

        if (!itemsResponse.ok) {
          const err = await itemsResponse.json()
          throw new Error(err.error || 'Failed to update order items')
        }

        // Sync server-calculated totals back to store
        const updatedOrder = await itemsResponse.json()
        if (updatedOrder.subtotal !== undefined) {
          useOrderStore.getState().syncServerTotals({
            subtotal: updatedOrder.subtotal,
            discountTotal: updatedOrder.discountTotal ?? 0,
            taxTotal: updatedOrder.taxTotal ?? 0,
            tipTotal: updatedOrder.tipTotal,
            total: updatedOrder.total,
          })
        }

        return savedOrderId
      }

      // Create new order
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          employeeId: employee.id,
          locationId: employee.location?.id,
          orderType: currentOrder.orderType,
          orderTypeId: currentOrder.orderTypeId,
          tableId: currentOrder.tableId,
          tabName: currentOrder.tabName || currentOrder.tableName,
          guestCount: currentOrder.guestCount,
          items: currentOrder.items.map(item => ({
            menuItemId: item.menuItemId,
            name: item.name,
            price: item.price,
            quantity: item.quantity,
            modifiers: item.modifiers.map(mod => ({
              id: (mod.id || mod.modifierId) ?? '',
              modifierId: mod.modifierId,
              name: mod.name,
              price: Number(mod.price),
              depth: mod.depth ?? 0,
              preModifier: mod.preModifier ?? null,
              spiritTier: mod.spiritTier ?? null,
              linkedBottleProductId: mod.linkedBottleProductId ?? null,
              parentModifierId: mod.parentModifierId ?? null,
            })),
            ingredientModifications: item.ingredientModifications?.map(ing => ({
              ingredientId: ing.ingredientId,
              name: ing.name,
              modificationType: ing.modificationType,
              priceAdjustment: ing.priceAdjustment,
              swappedTo: ing.swappedTo,
            })),
            specialNotes: item.specialNotes,
            pizzaConfig: item.pizzaConfig, // Include pizza configuration
          })),
          notes: currentOrder.notes,
          customFields: currentOrder.customFields || orderCustomFields,
        }),
      })

      if (!response.ok) {
        const err = await response.json()
        throw new Error(err.error || 'Failed to save order')
      }

      const savedOrder = await response.json()

      // Sync server-assigned ID + order number
      const store = useOrderStore.getState()
      store.updateOrderId(savedOrder.id, savedOrder.orderNumber)

      // Sync server-calculated totals back to store (tax, discounts, dual pricing)
      if (savedOrder.subtotal !== undefined) {
        store.syncServerTotals({
          subtotal: savedOrder.subtotal,
          discountTotal: savedOrder.discountTotal ?? 0,
          taxTotal: savedOrder.taxTotal ?? 0,
          tipTotal: savedOrder.tipTotal,
          total: savedOrder.total,
        })
      }

      return savedOrder.id
    } catch (error) {
      console.error('Failed to save order:', error)
      alert(error instanceof Error ? error.message : 'Failed to save order')
      return null
    }
  }

  // Handle order type selection
  const handleOrderTypeSelect = (orderType: OrderTypeConfig, customFields?: OrderCustomFields) => {
    setSelectedOrderType(orderType)
    if (customFields) {
      setOrderCustomFields(customFields)
    }

    // Sync bar/food category mode with order type
    if (orderType.slug === 'bar_tab') {
      setMode('bar')
    } else {
      // All non-bar order types (dine_in, takeout, delivery, drive_thru, custom) default to food mode
      setMode('food')
    }

    // If order type requires table selection, open table picker
    const workflowRules = (orderType.workflowRules || {}) as WorkflowRules
    if (workflowRules.requireTableSelection) {
      toast.warning('Please select a table from the floor plan')
    } else {
      // Convert OrderCustomFields to Record<string, string> (filter out undefined)
      const cleanFields: Record<string, string> = {}
      if (customFields) {
        Object.entries(customFields).forEach(([key, value]) => {
          if (value !== undefined) {
            cleanFields[key] = value
          }
        })
      }

      // If there's an existing order with items, update the order type instead of starting fresh
      if (currentOrder?.items.length) {
        updateOrderType(orderType.slug, {
          tabName: customFields?.customerName,
          orderTypeId: orderType.id,
          customFields: Object.keys(cleanFields).length > 0 ? cleanFields : undefined,
        })
      } else {
        // Start new order with the selected type
        startOrder(orderType.slug, {
          tabName: customFields?.customerName,
          orderTypeId: orderType.id,
          customFields: Object.keys(cleanFields).length > 0 ? cleanFields : undefined,
        })
      }
    }
  }

  // Validate order before sending to kitchen based on workflow rules
  const validateBeforeSend = (): { valid: boolean; message?: string } => {
    if (!currentOrder) return { valid: false, message: 'No order to send' }

    // Find the order type config
    const orderTypeConfig = orderTypes.find(t => t.slug === currentOrder.orderType)
    if (!orderTypeConfig) {
      // No config found, allow sending (backward compatibility)
      return { valid: true }
    }

    const workflowRules = (orderTypeConfig.workflowRules || {}) as WorkflowRules

    // If table is required but none selected, block and prompt for table picker
    if (workflowRules.requireTableSelection && !currentOrder.tableId) {
      return { valid: false, message: 'TABLE_REQUIRED' }
    }

    // Check customer name requirement
    if (workflowRules.requireCustomerName && !currentOrder.tabName && !orderCustomFields.customerName) {
      return { valid: false, message: 'TAB_NAME_REQUIRED' }
    }

    // Check payment requirement (for takeout/delivery)
    if (workflowRules.requirePaymentBeforeSend) {
      // This would check if payment has been made
      // For now, we'll prompt user to pay first
      return { valid: false, message: 'Payment is required before sending this order type to kitchen. Please collect payment first.' }
    }

    return { valid: true }
  }

  // Send to Kitchen handler
  const handleSendToKitchen = async () => {
    if (!currentOrder?.items.length) return

    // Validate based on workflow rules
    const validation = validateBeforeSend()
    if (!validation.valid) {
      if (validation.message === 'TABLE_REQUIRED') {
        toast.warning('Please select a table for this order')
        toast.warning('Please select a table from the floor plan')
        return
      }
      if (validation.message === 'TAB_NAME_REQUIRED') {
        // Show tab name prompt, then retry send after name is entered
        setTabNameInput('')
        setTabNameCallback(() => () => handleSendToKitchen())
        setShowTabNamePrompt(true)
        return
      }
      // If payment is required, open payment modal
      const orderTypeConfig = orderTypes.find(t => t.slug === currentOrder.orderType)
      const workflowRules = (orderTypeConfig?.workflowRules || {}) as WorkflowRules
      if (workflowRules.requirePaymentBeforeSend) {
        toast.warning('Payment is required before sending this order')
        handleOpenPayment()
      } else {
        toast.warning(validation.message || 'Cannot send order')
      }
      return
    }

    setIsSendingOrder(true)
    try {
      const orderId = await saveOrderToDatabase()
      if (orderId) {
        // Start timers for any entertainment/timed rental items
        await startEntertainmentTimers(orderId)

        // Print kitchen ticket
        await printKitchenTicket(orderId)

        // Show brief confirmation
        const orderNum = orderId.slice(-6).toUpperCase()

        // Clear the order so user can start the next one
        clearOrder()
        setSavedOrderId(null)
        setOrderSent(false)
        setSelectedOrderType(null)
        setOrderCustomFields({})

        // Refresh the open orders panel and count
        setTabsRefreshTrigger(prev => prev + 1)

        // Return to floor plan (if not bartender)
        if (!isBartender) {
          setViewMode('floor-plan')
        }

        // Show confirmation with instructions
        alert(`Order #${orderNum} sent to kitchen!\n\nClick "Open Orders" button to view or add more items.`)
      }
    } finally {
      setIsSendingOrder(false)
    }
  }

  // Print kitchen ticket when order is sent
  const printKitchenTicket = async (orderId: string) => {
    try {
      const response = await fetch('/api/print/kitchen', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ orderId }),
      })

      if (!response.ok) {
        console.error('Failed to print kitchen ticket')
      }
    } catch (err) {
      console.error('Failed to print kitchen ticket:', err)
    }
  }

  // Start timers for entertainment items when order is sent
  // Reads from store instead of refetching — order was just saved
  const startEntertainmentTimers = async (_orderId: string) => {
    try {
      const storeItems = useOrderStore.getState().currentOrder?.items || []

      for (const item of storeItems) {
        const menuItem = menuItems.find(m => m.id === item.menuItemId)

        if (menuItem?.itemType === 'timed_rental' && !item.blockTimeStartedAt) {
          const blockMinutes = menuItem.blockTimeMinutes || 60

          await fetch('/api/entertainment/block-time', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              orderItemId: item.id,
              minutes: blockMinutes,
            }),
          })
        }
      }
    } catch (err) {
      console.error('Failed to start entertainment timers:', err)
    }
  }

  // Handle resending an item to the kitchen (KDS) - opens modal
  const handleResendItem = (itemId: string, itemName: string) => {
    setResendNote('')
    setResendModal({ itemId, itemName })
  }

  // Actually perform the resend after modal confirmation
  const confirmResendItem = async () => {
    if (!resendModal) return

    setResendLoading(true)
    try {
      const response = await fetch('/api/kds', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          itemIds: [resendModal.itemId],
          action: 'resend',
          resendNote: resendNote.trim() || undefined,
        }),
      })

      if (response.ok) {
        // Success - close modal (no blocking alert)
        setResendModal(null)
        setResendNote('')
      } else {
        console.error('Failed to resend item')
      }
    } catch (error) {
      console.error('Failed to resend item:', error)
    } finally {
      setResendLoading(false)
    }
  }

  // Handle selecting an open order to continue working on it
  const handleSelectOpenOrder = (order: OpenOrder) => {
    // Load the order into the current order state
    loadOrder({
      id: order.id,
      orderNumber: order.orderNumber,
      orderType: order.orderType,
      tableId: order.tableId || undefined,
      tableName: order.table?.name || undefined,
      tabName: order.tabName || undefined,
      guestCount: order.guestCount,
      items: order.items,
      subtotal: order.subtotal,
      taxTotal: order.taxTotal,
      total: order.total,
    })

    // Track that this is a saved order (but allow sending updates)
    setSavedOrderId(order.id)
    setOrderSent(false) // Allow sending updates to kitchen

    // Restore tab card info from pre-auth data (so "Add to Tab" works correctly)
    if (order.hasPreAuth && order.preAuth?.last4) {
      setTabCardInfo({
        cardholderName: order.cardholderName || undefined,
        cardLast4: order.preAuth.last4,
        cardType: order.preAuth.cardBrand,
      })
    }

    // Close the panel
    setShowTabsPanel(false)
  }

  // Payment handlers
  const handleOpenPayment = async () => {
    // Allow payment if there are items OR if the order has a total (split orders)
    const hasItems = currentOrder?.items.length && currentOrder.items.length > 0
    const hasSplitTotal = currentOrder?.total && currentOrder.total > 0 && !hasItems
    if (!hasItems && !hasSplitTotal) return

    // If order hasn't been saved yet, save it first
    let orderId = savedOrderId
    if (!orderId) {
      setIsSendingOrder(true)
      try {
        orderId = await saveOrderToDatabase()
        if (orderId) {
          setSavedOrderId(orderId)
        }
      } finally {
        setIsSendingOrder(false)
      }
    }

    if (orderId) {
      setOrderToPayId(orderId)
      // Fetch pre-authed tab cards for "Charge existing card" option
      fetch(`/api/orders/${orderId}/cards`)
        .then(r => r.ok ? r.json() : { data: [] })
        .then(d => setPaymentTabCards((d.data || []).filter((c: { status: string }) => c.status === 'authorized')))
        .catch(() => setPaymentTabCards([]))
      setShowPaymentModal(true)
    }
  }

  const handleReceiptClose = () => {
    setShowReceiptModal(false)
    setReceiptOrderId(null)
    // Clear order after receipt is dismissed
    setSavedOrderId(null)
    setOrderSent(false)
    clearOrder()
    // Return to floor plan (if not bartender)
    if (!isBartender) {
      setViewMode('floor-plan')
    }
  }

  // Handle order settings save (tab name, guests, gratuity)
  const handleOrderSettingsSave = async (settings: {
    tabName?: string
    guestCount?: number
    tipTotal?: number
    separateChecks?: boolean
  }) => {
    if (!savedOrderId) return

    const response = await fetch(`/api/orders/${savedOrderId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(settings),
    })

    if (!response.ok) {
      const data = await response.json()
      throw new Error(data.error || 'Failed to save settings')
    }

    // Reload the order from API to get updated values
    const orderResponse = await fetch(`/api/orders/${savedOrderId}`)
    if (orderResponse.ok) {
      const orderData = await orderResponse.json()
      loadOrder(orderData)
    }

    // Refresh tabs panel
    setTabsRefreshTrigger(prev => prev + 1)
  }

  // Handle split check result
  const handleSplitComplete = (result: {
    type: 'even' | 'by_item' | 'by_seat' | 'by_table' | 'custom_amount' | 'split_item'
    originalOrderId: string
    splits?: { splitNumber: number; amount: number }[]
    newOrderId?: string
    newOrderNumber?: number
    splitAmount?: number
    itemSplits?: { itemId: string; itemName: string; splitNumber: number; amount: number }[]
    seatSplits?: { seatNumber: number; total: number; splitOrderId: string }[]
    tableSplits?: { tableId: string; tableName: string; total: number; splitOrderId: string }[]
  }) => {
    setShowSplitModal(false)

    if (result.type === 'even' && result.splits) {
      // Store the split amounts and start payment flow
      setEvenSplitAmounts(result.splits)
      setCurrentSplitIndex(0)
      setSplitPaymentAmount(result.splits[0].amount)
      setOrderToPayId(result.originalOrderId)
      setShowPaymentModal(true)
    } else if (result.type === 'split_item' && result.splits) {
      // Split single item among guests - same payment flow as even split
      setEvenSplitAmounts(result.splits)
      setCurrentSplitIndex(0)
      setSplitPaymentAmount(result.splits[0].amount)
      setOrderToPayId(result.originalOrderId)
      setShowPaymentModal(true)
    } else if (result.type === 'by_item') {
      // Reload the current order to reflect changes
      alert(`New check #${result.newOrderNumber} created with selected items.\n\nView it in Open Orders.`)
      setTabsRefreshTrigger(prev => prev + 1)
      // Clear current order since items were moved
      clearOrder()
      setSavedOrderId(null)
    } else if (result.type === 'by_seat' && result.seatSplits) {
      // Split by seat - multiple checks created
      const seatCount = result.seatSplits.length
      alert(`${seatCount} separate checks created (one per seat).\n\nView them in Open Orders.`)
      setTabsRefreshTrigger(prev => prev + 1)
      // Clear current order since items were moved to seat-specific checks
      clearOrder()
      setSavedOrderId(null)
    } else if (result.type === 'by_table' && result.tableSplits) {
      // Split by table - multiple checks created (for virtual combined tables)
      const tableCount = result.tableSplits.length
      const tableNames = result.tableSplits.map(s => s.tableName).join(', ')
      alert(`${tableCount} separate checks created (one per table: ${tableNames}).\n\nView them in Open Orders.`)
      setTabsRefreshTrigger(prev => prev + 1)
      // Clear current order since items were moved to table-specific checks
      clearOrder()
      setSavedOrderId(null)
    } else if (result.type === 'custom_amount' && result.splitAmount) {
      // Open payment modal with custom amount
      setSplitPaymentAmount(result.splitAmount)
      setOrderToPayId(result.originalOrderId)
      setShowPaymentModal(true)
    }
  }

  // Handle navigating to a different split order
  const handleNavigateToSplit = async (splitOrderId: string) => {
    try {
      const response = await fetch(`/api/orders/${splitOrderId}`)
      if (!response.ok) {
        throw new Error('Failed to fetch split order')
      }
      const orderData = await response.json()

      // Load the split order into the current order state
      loadOrder({
        id: orderData.id,
        orderNumber: orderData.orderNumber,
        orderType: orderData.orderType,
        tableId: orderData.tableId || undefined,
        tableName: orderData.tableName || undefined,
        tabName: orderData.tabName || undefined,
        guestCount: orderData.guestCount || 1,
        status: orderData.status,
        items: orderData.items.map((item: {
          id: string
          menuItemId: string
          name: string
          price: number
          quantity: number
          specialNotes?: string
          isCompleted?: boolean
          seatNumber?: number
          sentToKitchen?: boolean
          modifiers?: { id: string; modifierId: string; name: string; price: number; preModifier?: string | null; depth?: number; spiritTier?: string | null; linkedBottleProductId?: string | null; parentModifierId?: string | null }[]
        }) => ({
          id: item.id,
          menuItemId: item.menuItemId,
          name: item.name,
          price: Number(item.price),
          quantity: item.quantity,
          specialNotes: item.specialNotes || '',
          isCompleted: item.isCompleted || false,
          seatNumber: item.seatNumber,
          sentToKitchen: item.sentToKitchen || false,
          modifiers: (item.modifiers || []).map(mod => ({
            id: (mod.id || mod.modifierId) ?? '',
            modifierId: mod.modifierId,
            name: mod.name,
            price: Number(mod.price),
            depth: mod.depth ?? 0,
            preModifier: mod.preModifier ?? null,
            spiritTier: mod.spiritTier ?? null,
            linkedBottleProductId: mod.linkedBottleProductId ?? null,
            parentModifierId: mod.parentModifierId ?? null,
          })),
        })),
        subtotal: Number(orderData.subtotal) || 0,
        discountTotal: Number(orderData.discountTotal) || 0,
        taxTotal: Number(orderData.taxTotal) || 0,
        total: Number(orderData.total) || 0,
      })

      // Update saved order ID
      setSavedOrderId(splitOrderId)
      setOrderSent(orderData.status === 'sent' || orderData.status === 'in_progress')

      // Close the tabs panel if open
      setShowTabsPanel(false)
    } catch (error) {
      console.error('Failed to navigate to split order:', error)
      alert('Failed to load split order')
    }
  }

  // Handle opening split check
  const handleOpenSplit = async () => {
    if (!currentOrder?.items.length) return

    // If order hasn't been saved yet, save it first
    let orderId = savedOrderId
    if (!orderId) {
      setIsSendingOrder(true)
      try {
        orderId = await saveOrderToDatabase()
        if (orderId) {
          setSavedOrderId(orderId)
        }
      } finally {
        setIsSendingOrder(false)
      }
    }

    if (orderId) {
      setOrderToPayId(orderId)
      setShowSplitModal(true)
    }
  }

  // Handle opening split ticket manager (to create separate tickets)
  const handleOpenSplitTicket = async () => {
    if (!currentOrder?.items.length) return

    // If order hasn't been saved yet, save it first
    let orderId = savedOrderId
    if (!orderId) {
      setIsSendingOrder(true)
      try {
        orderId = await saveOrderToDatabase()
        if (orderId) {
          setSavedOrderId(orderId)
        }
      } finally {
        setIsSendingOrder(false)
      }
    }

    if (orderId) {
      setShowSplitTicketManager(true)
    }
  }

  // Handle split ticket completion
  const handleSplitTicketComplete = () => {
    // Clear the current order and reload
    clearOrder()
    setSavedOrderId(null)
    setOrderSent(false)
    setAppliedDiscounts([])
    setShowSplitTicketManager(false)
  }

  // Handle opening discount modal
  const handleOpenDiscount = async () => {
    if (!currentOrder?.items.length) return

    // If order hasn't been saved yet, save it first
    let orderId = savedOrderId
    if (!orderId) {
      setIsSendingOrder(true)
      try {
        orderId = await saveOrderToDatabase()
        if (orderId) {
          setSavedOrderId(orderId)
        }
      } finally {
        setIsSendingOrder(false)
      }
    }

    if (orderId) {
      // Load existing discounts for this order
      try {
        const response = await fetch(`/api/orders/${orderId}/discount`)
        if (response.ok) {
          const data = await response.json()
          setAppliedDiscounts(data.discounts || [])
        }
      } catch (err) {
        console.error('Failed to load discounts:', err)
      }
      setOrderToPayId(orderId)
      setShowDiscountModal(true)
    }
  }

  // Handle discount applied
  const handleDiscountApplied = (newTotals: {
    discountTotal: number
    taxTotal: number
    total: number
  }) => {
    // Reload the order discounts
    if (orderToPayId) {
      fetch(`/api/orders/${orderToPayId}/discount`)
        .then(res => res.json())
        .then(data => {
          setAppliedDiscounts(data.discounts || [])
        })
        .catch(console.error)
    }
    // Trigger a refresh of the tabs/orders to update totals
    setTabsRefreshTrigger(prev => prev + 1)
  }

  // Comp/Void handlers
  const handleOpenCompVoid = async (item: OrderItem) => {
    // If order hasn't been saved yet, save it first
    let orderId = savedOrderId
    if (!orderId) {
      setIsSendingOrder(true)
      try {
        orderId = await saveOrderToDatabase()
        if (orderId) {
          setSavedOrderId(orderId)
        }
      } finally {
        setIsSendingOrder(false)
      }
    }

    if (orderId) {
      setOrderToPayId(orderId)
      setCompVoidItem(item)
      setShowCompVoidModal(true)
    }
  }

  const handleCompVoidComplete = async (result: {
    action: 'comp' | 'void' | 'restore'
    item?: { id: string }
    orderTotals: {
      subtotal: number
      discountTotal: number
      taxTotal: number
      total: number
    }
  }) => {
    // Trigger a refresh to update order display
    setTabsRefreshTrigger(prev => prev + 1)
    setShowCompVoidModal(false)

    // Reload full order from API so voided/comped items show updated status
    const orderId = savedOrderId || orderToPayId
    if (orderId) {
      try {
        const res = await fetch(`/api/orders/${orderId}`)
        if (res.ok) {
          const data = await res.json()
          loadOrder(data)
        }
      } catch (err) {
        console.error('Failed to reload order after comp/void:', err)
      }
    }
    setCompVoidItem(null)
  }

  // OrderPanel item control handlers
  // Shared handlers (useActiveOrder) already call the API AND update the Zustand store.
  // No need to refetch the full order afterwards.
  const handleHoldToggle = async (itemId: string) => {
    await sharedHoldToggle(itemId)
  }

  const handleNoteEdit = async (itemId: string, currentNote?: string) => {
    await sharedNoteEdit(itemId, currentNote)
  }

  const handleCourseChange = async (itemId: string, course: number | null) => {
    await sharedCourseChange(itemId, course)
  }

  const handleEditModifiers = (itemId: string) => {
    const fullItem = currentOrder?.items.find(i => i.id === itemId)
    if (fullItem) {
      handleEditOrderItem(fullItem)
    }
  }

  const handleCompVoid = async (item: OrderPanelItemData) => {
    await handleOpenCompVoid({
      id: item.id,
      menuItemId: item.menuItemId || '',
      name: item.name,
      quantity: item.quantity,
      price: Number(item.price),
      modifiers: item.modifiers?.map(m => ({
        id: m.id,
        name: m.name,
        price: Number(m.price)
      })) || [],
    })
  }

  const handleResend = async (item: OrderPanelItemData) => {
    // sharedResend already calls loadOrder() internally
    await sharedResend(item.id)
  }

  const handleSplit = async (itemId: string) => {
    // Open split ticket manager
    await handleOpenSplitTicket()
  }

  // handleToggleExpand now comes from useActiveOrder hook — no local function needed

  const handleSeatChange = async (itemId: string, seat: number | null) => {
    await sharedSeatChange(itemId, seat)
  }

  const handleAddItem = async (item: MenuItem) => {
    if (!item.isAvailable) return

    // Handle combo items
    if (item.itemType === 'combo') {
      setSelectedComboItem(item)
      setComboSelections({})
      setShowComboModal(true)

      // Load combo template
      try {
        const response = await fetch(`/api/combos/${item.id}`)
        if (response.ok) {
          const data = await response.json()
          setComboTemplate(data.template)
        }
      } catch (error) {
        console.error('Failed to load combo template:', error)
      }
      return
    }

    // Handle timed rental items
    if (item.itemType === 'timed_rental') {
      // If item is in use, show toast instead of adding
      if (item.entertainmentStatus === 'in_use') {
        toast.warning(`${item.name} is currently in use`)
        return
      }
      // Otherwise show the normal rental modal
      setSelectedTimedItem(item)
      setSelectedRateType('perHour')
      setShowTimedRentalModal(true)
      return
    }

    // Handle pizza items - check if item is in a pizza category
    if (selectedCategoryData?.categoryType === 'pizza') {
      setSelectedPizzaItem(item)
      setShowPizzaModal(true)
      return
    }

    // Check if item has modifiers
    if (item.modifierGroupCount && item.modifierGroupCount > 0) {
      setSelectedItem(item)
      setLoadingModifiers(true)
      setShowModifierModal(true)

      try {
        const response = await fetch(`/api/menu/items/${item.id}/modifier-groups`)
        if (response.ok) {
          const data = await response.json()
          setItemModifierGroups(data.data || [])
        }
      } catch (error) {
        console.error('Failed to load modifiers:', error)
      } finally {
        setLoadingModifiers(false)
      }
    } else {
      // No modifiers, add directly
      addItem({
        menuItemId: item.id,
        name: item.name,
        price: item.price,
        quantity: 1,
        modifiers: [],
      })
    }
  }

  // Handle quick bar item click - add to order (T035)
  const handleQuickBarItemClick = async (itemId: string) => {
    try {
      const res = await fetch(`/api/menu/items/${itemId}`)
      if (!res.ok) return

      const { item } = await res.json()
      handleAddItem({
        id: item.id,
        name: item.name,
        price: Number(item.price),
        categoryId: item.categoryId,
        isAvailable: item.isAvailable ?? true,
        itemType: item.itemType,
        modifierGroupCount: item.modifierGroups?.length || 0,
      } as MenuItem)
    } catch (error) {
      console.error('[Orders] Quick bar item load error:', error)
    }
  }

  const handleAddItemWithModifiers = (modifiers: SelectedModifier[], specialNotes?: string, pourSize?: string, pourMultiplier?: number, ingredientModifications?: { ingredientId: string; name: string; modificationType: string; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[]) => {
    if (!selectedItem) return

    // T023: If there's an inline modifier callback, call it and return
    // This is used when adding items from the floor plan inline ordering
    if (inlineModifierCallbackRef.current) {
      const applyToMods = selectedItem.applyPourToModifiers && pourMultiplier
      const simplifiedModifiers = modifiers.map(mod => ({
        id: mod.id ?? '',
        modifierId: mod.id,
        name: mod.name,
        price: applyToMods && pourMultiplier ? mod.price * pourMultiplier : mod.price,
        depth: mod.depth ?? 0,
        preModifier: mod.preModifier ?? null,
        spiritTier: mod.spiritTier ?? null,
        linkedBottleProductId: mod.linkedBottleProductId ?? null,
        parentModifierId: mod.parentModifierId ?? null,
      }))
      inlineModifierCallbackRef.current(simplifiedModifiers, ingredientModifications)
      inlineModifierCallbackRef.current = null
      setShowModifierModal(false)
      setSelectedItem(null)
      setItemModifierGroups([])
      setEditingOrderItem(null)
      return
    }

    // Apply pour multiplier to base price
    // Note: pourMultiplier applies to spirit modifiers only, not ingredient priceAdjustments.
    // Ingredient pricing is always flat. Liquor pricing is handled by the Liquor Builder (future).
    const basePrice = pourMultiplier ? selectedItem.price * pourMultiplier : selectedItem.price
    const applyToMods = selectedItem.applyPourToModifiers && pourMultiplier

    // Build item name with pour size
    const itemName = pourSize
      ? `${selectedItem.name} (${pourSize.charAt(0).toUpperCase() + pourSize.slice(1)})`
      : selectedItem.name

    addItem({
      menuItemId: selectedItem.id,
      name: itemName,
      price: basePrice,
      quantity: 1,
      specialNotes,
      modifiers: modifiers.map(mod => ({
        id: mod.id ?? '',
        modifierId: mod.id,
        name: mod.name,
        price: applyToMods ? mod.price * pourMultiplier : mod.price,
        depth: mod.depth ?? 0,
        preModifier: mod.preModifier ?? null,
        spiritTier: mod.spiritTier ?? null,
        linkedBottleProductId: mod.linkedBottleProductId ?? null,
        parentModifierId: mod.parentModifierId ?? null,
      })),
      ingredientModifications: ingredientModifications?.map(mod => ({
        ingredientId: mod.ingredientId,
        name: mod.name,
        modificationType: mod.modificationType as IngredientModificationType,
        priceAdjustment: mod.priceAdjustment,
        swappedTo: mod.swappedTo,
      })),
    })

    setShowModifierModal(false)
    setSelectedItem(null)
    setItemModifierGroups([])
    setEditingOrderItem(null)
  }

  // Handle adding pizza to order
  const handleAddPizzaToOrder = (config: PizzaOrderConfig) => {
    if (!selectedPizzaItem) return

    // T023: Check if this is inline ordering callback
    if (inlinePizzaCallbackRef.current) {
      inlinePizzaCallbackRef.current(config)
      inlinePizzaCallbackRef.current = null
      setShowPizzaModal(false)
      setSelectedPizzaItem(null)
      setEditingPizzaItem(null)
      return
    }

    // Build display name with size info
    const itemName = selectedPizzaItem.name

    // Build modifiers array organized by section boxes (like pizza builder)
    const pizzaModifiers: { id: string; name: string; price: number; preModifier?: string; depth: number }[] = []
    const maxSections = 24
    const halfSize = maxSections / 2
    const quarterSize = maxSections / 4
    const sixthSize = maxSections / 6
    const eighthSize = maxSections / 8

    // Define all box section ranges
    const boxSections: Record<string, number[]> = {
      'WHOLE': Array.from({ length: maxSections }, (_, i) => i),
      'RIGHT HALF': Array.from({ length: halfSize }, (_, i) => i),
      'LEFT HALF': Array.from({ length: halfSize }, (_, i) => halfSize + i),
      'TOP RIGHT': Array.from({ length: quarterSize }, (_, i) => i),
      'BOTTOM RIGHT': Array.from({ length: quarterSize }, (_, i) => quarterSize + i),
      'BOTTOM LEFT': Array.from({ length: quarterSize }, (_, i) => quarterSize * 2 + i),
      'TOP LEFT': Array.from({ length: quarterSize }, (_, i) => quarterSize * 3 + i),
    }
    // Add sixths
    for (let i = 0; i < 6; i++) {
      boxSections[`1/6-${i + 1}`] = Array.from({ length: sixthSize }, (_, j) => i * sixthSize + j)
    }
    // Add eighths
    for (let i = 0; i < 8; i++) {
      boxSections[`1/8-${i + 1}`] = Array.from({ length: eighthSize }, (_, j) => i * eighthSize + j)
    }

    // Collect all items with their sections
    type PizzaItem = { type: string; id: string; name: string; sections: number[]; price: number; amount?: string }
    const allItems: PizzaItem[] = []

    if (config.sauces) {
      config.sauces.forEach(s => {
        const prefix = s.amount === 'light' ? 'Light ' : s.amount === 'extra' ? 'Extra ' : ''
        allItems.push({ type: 'sauce', id: s.sauceId, name: `${prefix}${s.name}`, sections: s.sections, price: s.price || 0 })
      })
    }
    if (config.cheeses) {
      config.cheeses.forEach(c => {
        const prefix = c.amount === 'light' ? 'Light ' : c.amount === 'extra' ? 'Extra ' : ''
        allItems.push({ type: 'cheese', id: c.cheeseId, name: `${prefix}${c.name}`, sections: c.sections, price: c.price || 0 })
      })
    }
    config.toppings.forEach(t => {
      const prefix = t.amount === 'light' ? 'Light ' : t.amount === 'extra' ? 'Extra ' : ''
      allItems.push({ type: 'topping', id: t.toppingId, name: `${prefix}${t.name}`, sections: t.sections, price: t.price })
    })

    // Determine section mode based on items (find smallest sections used)
    let sectionMode = 1 // Default to whole
    allItems.forEach(item => {
      if (item.sections.length < maxSections) {
        if (item.sections.length <= eighthSize) sectionMode = Math.max(sectionMode, 8)
        else if (item.sections.length <= sixthSize) sectionMode = Math.max(sectionMode, 6)
        else if (item.sections.length <= quarterSize) sectionMode = Math.max(sectionMode, 4)
        else if (item.sections.length <= halfSize) sectionMode = Math.max(sectionMode, 2)
      }
    })

    // Helper to check if sections exactly match a box
    const exactlyCovers = (itemSections: number[], boxName: string): boolean => {
      const boxSecs = boxSections[boxName]
      if (!boxSecs || itemSections.length !== boxSecs.length) return false
      const sorted = [...itemSections].sort((a, b) => a - b)
      return boxSecs.every((s, i) => sorted[i] === s)
    }

    // Helper to check if item sections cover a box's sections
    const coversBox = (itemSections: number[], boxName: string): boolean => {
      const boxSecs = boxSections[boxName]
      if (!boxSecs) return false
      return boxSecs.every(s => itemSections.includes(s))
    }

    // Group items into boxes
    const boxContents: Record<string, { items: string[]; totalPrice: number }> = {}

    // Initialize all boxes we'll show
    const boxOrder = [
      'WHOLE',
      'LEFT HALF', 'RIGHT HALF',
      'TOP LEFT', 'TOP RIGHT', 'BOTTOM LEFT', 'BOTTOM RIGHT',
      '1/6-1', '1/6-2', '1/6-3', '1/6-4', '1/6-5', '1/6-6',
      '1/8-1', '1/8-2', '1/8-3', '1/8-4', '1/8-5', '1/8-6', '1/8-7', '1/8-8',
    ]

    boxOrder.forEach(box => {
      boxContents[box] = { items: [], totalPrice: 0 }
    })

    // Place each item in the appropriate box(es)
    allItems.forEach(item => {
      // Find the best (largest) box this item exactly covers
      let placed = false

      // Check from largest to smallest
      if (exactlyCovers(item.sections, 'WHOLE')) {
        boxContents['WHOLE'].items.push(item.name)
        boxContents['WHOLE'].totalPrice += item.price
        placed = true
      } else if (exactlyCovers(item.sections, 'LEFT HALF')) {
        boxContents['LEFT HALF'].items.push(item.name)
        boxContents['LEFT HALF'].totalPrice += item.price
        placed = true
      } else if (exactlyCovers(item.sections, 'RIGHT HALF')) {
        boxContents['RIGHT HALF'].items.push(item.name)
        boxContents['RIGHT HALF'].totalPrice += item.price
        placed = true
      } else {
        // Check quarters
        for (const q of ['TOP LEFT', 'TOP RIGHT', 'BOTTOM LEFT', 'BOTTOM RIGHT']) {
          if (exactlyCovers(item.sections, q)) {
            boxContents[q].items.push(item.name)
            boxContents[q].totalPrice += item.price
            placed = true
            break
          }
        }
      }

      if (!placed) {
        // Check sixths
        for (let i = 1; i <= 6; i++) {
          if (exactlyCovers(item.sections, `1/6-${i}`)) {
            boxContents[`1/6-${i}`].items.push(item.name)
            boxContents[`1/6-${i}`].totalPrice += item.price
            placed = true
            break
          }
        }
      }

      if (!placed) {
        // Check eighths
        for (let i = 1; i <= 8; i++) {
          if (exactlyCovers(item.sections, `1/8-${i}`)) {
            boxContents[`1/8-${i}`].items.push(item.name)
            boxContents[`1/8-${i}`].totalPrice += item.price
            placed = true
            break
          }
        }
      }

      if (!placed) {
        // Non-standard grouping - place in each smallest box it covers
        const smallestBoxes = sectionMode === 8 ? ['1/8-1', '1/8-2', '1/8-3', '1/8-4', '1/8-5', '1/8-6', '1/8-7', '1/8-8'] :
          sectionMode === 6 ? ['1/6-1', '1/6-2', '1/6-3', '1/6-4', '1/6-5', '1/6-6'] :
          sectionMode === 4 ? ['TOP LEFT', 'TOP RIGHT', 'BOTTOM LEFT', 'BOTTOM RIGHT'] :
          ['LEFT HALF', 'RIGHT HALF']

        smallestBoxes.forEach(boxName => {
          if (coversBox(item.sections, boxName)) {
            boxContents[boxName].items.push(item.name)
            // Don't add price multiple times for split items
          }
        })
      }
    })

    // Determine which rows to show based on section mode
    const rows: string[][] = [['WHOLE', 'LEFT HALF', 'RIGHT HALF']]
    if (sectionMode >= 4) rows.push(['TOP LEFT', 'TOP RIGHT', 'BOTTOM LEFT', 'BOTTOM RIGHT'])
    if (sectionMode >= 6) rows.push(['1/6-1', '1/6-2', '1/6-3', '1/6-4', '1/6-5', '1/6-6'])
    if (sectionMode >= 8) {
      rows.push(['1/8-1', '1/8-2', '1/8-3', '1/8-4'])
      rows.push(['1/8-5', '1/8-6', '1/8-7', '1/8-8'])
    }

    // Build modifiers from boxes - show ALL boxes in relevant rows
    rows.forEach((row, rowIdx) => {
      row.forEach(boxName => {
        // Skip halves row if mode is 1 (whole only)
        if (sectionMode === 1 && (boxName === 'LEFT HALF' || boxName === 'RIGHT HALF')) return

        const content = boxContents[boxName]
        const itemsText = content.items.length > 0 ? content.items.join(', ') : '-'

        pizzaModifiers.push({
          id: `pizza-box-${boxName.replace(/\s+/g, '-').toLowerCase()}`,
          name: `${boxName}: ${itemsText}`,
          price: content.totalPrice,
          depth: 0,
        })
      })
    })

    // Add cooking instructions
    if (config.cookingInstructions) {
      pizzaModifiers.push({
        id: 'pizza-cooking',
        name: config.cookingInstructions,
        price: 0,
        depth: 0,
      })
    }

    // Add cut style
    if (config.cutStyle && config.cutStyle !== 'Normal Cut') {
      pizzaModifiers.push({
        id: 'pizza-cut',
        name: config.cutStyle,
        price: 0,
        depth: 0,
      })
    }

    // FIX-004: Use base price only (size + crust + sauce + cheese)
    // Toppings are in modifiers, not in item.price
    const basePrice = getPizzaBasePrice(config)

    // Development validation
    if (process.env.NODE_ENV === 'development') {
      const tempItem = {
        id: 'temp',
        menuItemId: selectedPizzaItem.id,
        name: itemName,
        price: basePrice,
        quantity: 1,
        modifiers: pizzaModifiers.map(m => ({ ...m, quantity: 1 })),
        pizzaConfig: config,
      } as any
      debugPizzaPricing(tempItem, 'orders-page-add')
    }

    if (editingPizzaItem) {
      // Update existing item
      updateItem(editingPizzaItem.id, {
        name: itemName,
        price: basePrice,  // ✅ FIX-004: Base price only, not totalPrice
        specialNotes: config.specialNotes,
        modifiers: pizzaModifiers,
        pizzaConfig: config,
      })
    } else {
      // Add new item
      addItem({
        menuItemId: selectedPizzaItem.id,
        name: itemName,
        price: basePrice,  // ✅ FIX-004: Base price only, not totalPrice
        quantity: 1,
        specialNotes: config.specialNotes,
        modifiers: pizzaModifiers,
        pizzaConfig: config,
      })
    }

    setShowPizzaModal(false)
    setSelectedPizzaItem(null)
    setEditingPizzaItem(null)
  }

  // Handle adding combo to order with selections from ComboStepFlow
  const handleAddComboToOrderWithSelections = (selections: Record<string, Record<string, string[]>>) => {
    if (!selectedComboItem || !comboTemplate) return

    // Calculate total with upcharges and build modifiers for KDS display
    let totalUpcharge = 0
    const comboModifiers: SelectedModifier[] = []

    for (const component of comboTemplate.components) {
      // New structure: component has menuItem with modifierGroups
      if (component.menuItem) {
        // Add the item itself as a modifier line for KDS
        comboModifiers.push({
          id: `combo-item-${component.id}`,
          name: component.displayName,
          price: 0, // Item price is included in combo base
          depth: 0,
        })

        // Process each modifier group for this item
        const componentSelections = selections[component.id] || {}
        for (const mg of component.menuItem.modifierGroups || []) {
          const groupSelections = componentSelections[mg.modifierGroup.id] || []
          for (const modifierId of groupSelections) {
            const modifier = mg.modifierGroup.modifiers.find(m => m.id === modifierId)
            if (modifier) {
              // Check for price override - in combos, modifiers are included ($0) unless explicitly set as upcharge
              const overridePrice = component.modifierPriceOverrides?.[modifier.id]
              const price = overridePrice !== undefined ? overridePrice : 0
              totalUpcharge += price
              comboModifiers.push({
                id: `combo-${component.id}-${modifier.id}`,
                name: `  - ${modifier.name}`,
                price: price,
                depth: 1,
              })
            }
          }
        }
      } else if (component.options && component.options.length > 0) {
        // Legacy: use options array (flat structure)
        const legacySelections = (selections[component.id] as unknown as string[]) || []
        for (const optionId of legacySelections) {
          const option = component.options.find(o => o.id === optionId)
          if (option) {
            totalUpcharge += option.upcharge
            comboModifiers.push({
              id: `combo-${component.id}-${option.id}`,
              name: `${component.displayName}: ${option.name}`,
              price: option.upcharge,
              depth: 0,
            })
          }
        }
      }
    }

    addItem({
      menuItemId: selectedComboItem.id,
      name: selectedComboItem.name,
      price: comboTemplate.basePrice,  // Base price only - modifier upcharges are added separately
      quantity: 1,
      modifiers: comboModifiers,
    })

    setShowComboModal(false)
    setSelectedComboItem(null)
    setComboTemplate(null)
    setComboSelections({})
  }

  // Handle adding combo to order (legacy inline modal - kept for backward compatibility)
  const handleAddComboToOrder = () => {
    handleAddComboToOrderWithSelections(comboSelections)
  }

  // Handle starting a timed rental session
  const handleStartTimedSession = async () => {
    if (!selectedTimedItem || !employee?.location?.id) return

    const pricing = selectedTimedItem.timedPricing as { per15Min?: number; per30Min?: number; perHour?: number; minimum?: number } | null

    // Get the rate - try selected type first, then fall back
    let rateAmount = selectedTimedItem.price
    if (pricing) {
      rateAmount = pricing[selectedRateType] || pricing.perHour || pricing.per30Min || pricing.per15Min || selectedTimedItem.price
    }

    // Calculate block time in minutes based on selected rate type
    let blockMinutes = 60 // default to 1 hour
    if (selectedRateType === 'per15Min') blockMinutes = 15
    else if (selectedRateType === 'per30Min') blockMinutes = 30
    else if (selectedRateType === 'perHour') blockMinutes = 60

    // T023: Check if this is inline ordering callback - skip API session creation
    if (inlineTimedRentalCallbackRef.current) {
      inlineTimedRentalCallbackRef.current(rateAmount, blockMinutes)
      inlineTimedRentalCallbackRef.current = null
      setShowTimedRentalModal(false)
      setSelectedTimedItem(null)
      return
    }

    setLoadingSession(true)
    try {
      const response = await fetch('/api/timed-sessions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId: employee.location.id,
          menuItemId: selectedTimedItem.id,
          rateType: selectedRateType,
          rateAmount,
          startedById: employee.id,
        }),
      })

      if (response.ok) {
        const session = await response.json()

        // Add to active sessions tracking
        setActiveSessions(prev => [...prev, {
          id: session.id,
          menuItemId: selectedTimedItem.id,
          menuItemName: selectedTimedItem.name,
          startedAt: session.startedAt,
          rateType: selectedRateType,
          rateAmount,
        }])

        // Add a placeholder item to the order showing active session
        const rateLabel = selectedRateType.replace('per', '').replace('Min', ' min').replace('Hour', '/hr')
        addItem({
          menuItemId: selectedTimedItem.id,
          name: `⏱️ ${selectedTimedItem.name} (Active)`,
          price: 0, // Price calculated when stopped
          quantity: 1,
          modifiers: [],
          specialNotes: `Session ID: ${session.id} | Rate: ${formatCurrency(rateAmount)}${rateLabel}`,
        })

        setShowTimedRentalModal(false)
        setSelectedTimedItem(null)

        // Refresh menu to update entertainment item status
        throttledLoadMenu()
      } else {
        const data = await response.json()
        alert(data.error || 'Failed to start session')
      }
    } catch (error) {
      console.error('Failed to start timed session:', error)
      alert('Failed to start session')
    } finally {
      setLoadingSession(false)
    }
  }

  // Handle stopping a timed session and billing
  const handleStopTimedSession = async (sessionId: string) => {
    if (!confirm('Stop this session and calculate charges?')) return

    try {
      const response = await fetch(`/api/timed-sessions/${sessionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'stop' }),
      })

      if (response.ok) {
        const result = await response.json()
        const session = activeSessions.find(s => s.id === sessionId)

        if (session) {
          // Find the order item with session ID in notes
          const orderItem = currentOrder?.items.find(item =>
            item.specialNotes?.includes(`Session ID: ${sessionId}`)
          )

          if (orderItem) {
            // Update the existing placeholder item with final price
            updateItem(orderItem.id, {
              name: `${session.menuItemName} (${result.totalMinutes} min)`,
              price: result.totalAmount || result.totalCharge,
              specialNotes: `Billed: ${result.totalMinutes} min @ ${formatCurrency(session.rateAmount)}`,
            })
          } else if (currentOrder) {
            // Add a new item to the current order with the final charges
            addItem({
              menuItemId: session.menuItemId,
              name: `${session.menuItemName} (${result.totalMinutes} min)`,
              price: result.totalAmount || result.totalCharge,
              quantity: 1,
              modifiers: [],
              specialNotes: `Billed: ${result.totalMinutes} min @ ${formatCurrency(session.rateAmount)}`,
            })
          }
        }

        // Remove from active sessions
        setActiveSessions(prev => prev.filter(s => s.id !== sessionId))

        // Refresh menu to update entertainment item status
        throttledLoadMenu()
      } else {
        const data = await response.json()
        alert(data.error || 'Failed to stop session')
      }
    } catch (error) {
      console.error('Failed to stop session:', error)
      alert('Failed to stop session')
    }
  }

  // Handle opening entertainment session start modal
  // Shared handler for opening modifier modal from FloorPlanHome/BartenderView inline ordering
  // Called by useOrderingEngine via onOpenModifiers(item, onComplete, existingModifiers, existingIngredientMods)
  const handleOpenModifiersShared = useCallback(async (
    item: MenuItem,
    onComplete: (modifiers: { id: string; name: string; price: number; depth?: number; preModifier?: string | null }[], ingredientModifications?: { ingredientId: string; name: string; modificationType: string; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[]) => void,
    existingModifiers?: { id: string; name: string; price: number; depth?: number; preModifier?: string | null }[],
    existingIngredientMods?: { ingredientId: string; name: string; modificationType: string; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[]
  ) => {
    try {
      inlineModifierCallbackRef.current = onComplete
      setLoadingModifiers(true)
      setSelectedItem(item)

      // If editing (existingModifiers provided), set editingOrderItem so ModifierModal restores selections
      if ((existingModifiers && existingModifiers.length > 0) || existingIngredientMods) {
        setEditingOrderItem({
          id: 'inline-edit',
          menuItemId: item.id,
          modifiers: (existingModifiers || []).map((m: Record<string, unknown>) => ({
            id: String(m.id || ''),
            name: String(m.name || ''),
            price: Number(m.price || 0),
            depth: Number(m.depth ?? 0),
            parentModifierId: m.parentModifierId ? String(m.parentModifierId) : undefined,
          })),
          ingredientModifications: existingIngredientMods as { ingredientId: string; name: string; modificationType: 'no' | 'lite' | 'on_side' | 'extra' | 'swap'; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[],
        })
      }
      setShowModifierModal(true)

      const response = await fetch(`/api/menu/items/${item.id}/modifier-groups`)
      if (response.ok) {
        const data = await response.json()
        setItemModifierGroups(data.data || [])
      }
      setLoadingModifiers(false)
    } catch (error) {
      console.error('Failed to load modifiers:', error)
      setLoadingModifiers(false)
      inlineModifierCallbackRef.current = null
    }
  }, [])
  // Wire up the ref so useOrderingEngine can call it
  handleOpenModifiersSharedRef.current = handleOpenModifiersShared

  const handleOpenTimedRental = (
    item: any,
    onComplete: (price: number, blockMinutes: number) => void
  ) => {
    // Store item info for the modal
    setEntertainmentItem({
      id: item.id,
      name: item.name,
      ratePerMinute: (item as any).ratePerMinute || 0.25,
      prepaidPackages: (item as any).prepaidPackages || [],
      happyHourEnabled: (item as any).happyHourEnabled || false,
      happyHourPrice: (item as any).happyHourPrice || null,
    })
    setShowEntertainmentStart(true)
    // Store callback for later use if needed
    inlineTimedRentalCallbackRef.current = onComplete
  }

  // Handle starting entertainment with new tab
  const handleStartEntertainmentWithNewTab = async (tabName: string, pkg?: PrepaidPackage) => {
    if (!entertainmentItem || !employee?.location?.id) return

    try {
      // 1. Create new order
      const orderRes = await fetch('/api/orders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId: employee.location.id,
          employeeId: employee.id,
          orderType: 'bar_tab',
          tabName,
        }),
      })
      const orderData = await orderRes.json()
      const orderId = orderData.data?.id

      if (!orderId) throw new Error('Failed to create order')

      // 2. Add entertainment item to order
      const itemRes = await fetch(`/api/orders/${orderId}/items`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          menuItemId: entertainmentItem.id,
          quantity: 1,
          price: pkg?.price || 0,
          blockTimeMinutes: pkg?.minutes || 0,
        }),
      })
      const itemData = await itemRes.json()

      // 3. Start the timer if prepaid
      if (pkg && itemData.data?.id) {
        await fetch('/api/entertainment/block-time', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            orderItemId: itemData.data.id,
            locationId: employee.location.id,
            minutes: pkg.minutes,
          }),
        })
      }

      setShowEntertainmentStart(false)
      setEntertainmentItem(null)
      throttledLoadMenu()
    } catch (err) {
      console.error('Failed to start entertainment session:', err)
      alert('Failed to start session')
    }
  }

  // Handle starting entertainment with existing tab
  const handleStartEntertainmentWithExistingTab = async (orderId: string, pkg?: PrepaidPackage) => {
    if (!entertainmentItem || !employee?.location?.id) return

    try {
      // Add item to existing order
      const itemRes = await fetch(`/api/orders/${orderId}/items`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          menuItemId: entertainmentItem.id,
          quantity: 1,
          price: pkg?.price || 0,
          blockTimeMinutes: pkg?.minutes || 0,
        }),
      })
      const itemData = await itemRes.json()

      // Start timer if prepaid
      if (pkg && itemData.data?.id) {
        await fetch('/api/entertainment/block-time', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            orderItemId: itemData.data.id,
            locationId: employee.location.id,
            minutes: pkg.minutes,
          }),
        })
      }

      setShowEntertainmentStart(false)
      setEntertainmentItem(null)
      throttledLoadMenu()
    } catch (err) {
      console.error('Failed to add entertainment to order:', err)
      alert('Failed to add to order')
    }
  }

  // Handle starting entertainment with current order
  const handleStartEntertainmentWithCurrentOrder = async (pkg?: PrepaidPackage) => {
    // Use savedOrderId if available
    const orderId = savedOrderId
    if (orderId) {
      await handleStartEntertainmentWithExistingTab(orderId, pkg)
    }
  }

  // Handle editing an existing order item
  const handleEditOrderItem = async (orderItem: NonNullable<typeof currentOrder>['items'][0]) => {
    // Find the menu item
    const menuItem = menuItems.find(m => m.id === orderItem.menuItemId)
    if (!menuItem) return

    // Check if this is a pizza item (has pizzaConfig)
    if (orderItem.pizzaConfig) {
      setSelectedPizzaItem(menuItem)
      setEditingPizzaItem({
        id: orderItem.id,
        pizzaConfig: orderItem.pizzaConfig,
      })
      setShowPizzaModal(true)
      return
    }

    if (menuItem.modifierGroupCount && menuItem.modifierGroupCount > 0) {
      setSelectedItem(menuItem)
      setEditingOrderItem({
        id: orderItem.id,
        menuItemId: orderItem.menuItemId,
        modifiers: orderItem.modifiers.map(m => ({
          id: m.id,
          name: m.name,
          price: m.price,
          depth: m.depth ?? 0,
          parentModifierId: m.parentModifierId ?? undefined,
        })),
        ingredientModifications: orderItem.ingredientModifications,
        specialNotes: orderItem.specialNotes,
      })
      setLoadingModifiers(true)
      setShowModifierModal(true)

      try {
        const response = await fetch(`/api/menu/items/${menuItem.id}/modifiers`)
        if (response.ok) {
          const data = await response.json()
          setItemModifierGroups(data.modifierGroups || [])
        }
      } catch (error) {
        console.error('Failed to load modifiers:', error)
      } finally {
        setLoadingModifiers(false)
      }
    }
  }

  const handleUpdateItemWithModifiers = (modifiers: SelectedModifier[], specialNotes?: string, pourSize?: string, pourMultiplier?: number, ingredientModifications?: { ingredientId: string; name: string; modificationType: string; priceAdjustment: number; swappedTo?: { modifierId: string; name: string; price: number } }[]) => {
    if (!selectedItem || !editingOrderItem) return

    // Apply pour multiplier to base price
    // Note: pourMultiplier applies to spirit modifiers only, not ingredient priceAdjustments.
    // Ingredient pricing is always flat. Liquor pricing is handled by the Liquor Builder (future).
    const basePrice = pourMultiplier ? selectedItem.price * pourMultiplier : selectedItem.price
    const applyToMods = selectedItem.applyPourToModifiers && pourMultiplier

    // Build item name with pour size
    const itemName = pourSize
      ? `${selectedItem.name} (${pourSize.charAt(0).toUpperCase() + pourSize.slice(1)})`
      : selectedItem.name

    updateItem(editingOrderItem.id, {
      name: itemName,
      price: basePrice,
      specialNotes,
      modifiers: modifiers.map(mod => ({
        id: mod.id ?? '',
        modifierId: mod.id,
        name: mod.name,
        price: applyToMods ? mod.price * pourMultiplier : mod.price,
        depth: mod.depth ?? 0,
        preModifier: mod.preModifier ?? null,
        spiritTier: mod.spiritTier ?? null,
        linkedBottleProductId: mod.linkedBottleProductId ?? null,
        parentModifierId: mod.parentModifierId ?? null,
      })),
      ingredientModifications: ingredientModifications?.map(mod => ({
        ingredientId: mod.ingredientId,
        name: mod.name,
        modificationType: mod.modificationType as IngredientModificationType,
        priceAdjustment: mod.priceAdjustment,
        swappedTo: mod.swappedTo,
      })),
    })

    setShowModifierModal(false)
    setSelectedItem(null)
    setItemModifierGroups([])
    setEditingOrderItem(null)
  }

  // Quick notes editing for any item
  const handleOpenNotesEditor = (itemId: string, currentNotes?: string) => {
    setEditingNotesItemId(itemId)
    setEditingNotesText(currentNotes || '')
  }

  const handleSaveNotes = () => {
    if (editingNotesItemId) {
      updateItem(editingNotesItemId, {
        specialNotes: editingNotesText.trim() || undefined,
      })
    }
    setEditingNotesItemId(null)
    setEditingNotesText('')
  }

  // State for editing categories order
  const [isEditingCategories, setIsEditingCategories] = useState(false)

  // DnD sensors for category reordering
  const categorySensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 5 } }),
    useSensor(TouchSensor, { activationConstraint: { delay: 150, tolerance: 5 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  )

  // Sort categories based on custom order or default mode-based sorting
  const sortedCategories = useMemo(() => {
    // If there's a custom order saved, use it
    if (categoryOrder && categoryOrder.length > 0) {
      const orderedCategories: Category[] = []
      const remainingCategories = [...categories]

      // Add categories in the saved order
      for (const id of categoryOrder) {
        const index = remainingCategories.findIndex(c => c.id === id)
        if (index !== -1) {
          orderedCategories.push(remainingCategories[index])
          remainingCategories.splice(index, 1)
        }
      }

      // Add any new categories that aren't in the saved order
      return [...orderedCategories, ...remainingCategories]
    }

    // Default sorting by mode
    const barTypes = ['liquor', 'drinks', 'cocktails', 'beer', 'wine']
    const foodTypes = ['food', 'combos', 'appetizers', 'entrees']

    return [...categories].sort((a, b) => {
      const aType = a.categoryType || 'food'
      const bType = b.categoryType || 'food'

      if (currentMode === 'bar') {
        const aIsBar = barTypes.includes(aType)
        const bIsBar = barTypes.includes(bType)
        if (aIsBar && !bIsBar) return -1
        if (!aIsBar && bIsBar) return 1
      } else {
        const aIsFood = foodTypes.includes(aType) || !barTypes.includes(aType)
        const bIsFood = foodTypes.includes(bType) || !barTypes.includes(bType)
        if (aIsFood && !bIsFood) return -1
        if (!aIsFood && bIsFood) return 1
      }

      return 0
    })
  }, [categories, currentMode, categoryOrder])

  // Handle category drag end
  const handleCategoryDragEnd = (event: DragEndEvent) => {
    const { active, over } = event
    if (over && active.id !== over.id) {
      const oldIndex = sortedCategories.findIndex(c => c.id === active.id)
      const newIndex = sortedCategories.findIndex(c => c.id === over.id)
      const newOrder = arrayMove(sortedCategories, oldIndex, newIndex).map(c => c.id)
      setCategoryOrder(newOrder)
    }
  }

  const filteredItems = menuItems.filter(
    item => item.categoryId === selectedCategory && item.isAvailable
  )
  const unavailableItems = menuItems.filter(
    item => item.categoryId === selectedCategory && !item.isAvailable
  )

  // Helper to format price display - shows both card and cash prices when dual pricing enabled
  const discountPercent = dualPricing.cashDiscountPercent || 4.0
  const formatItemPrice = (storedPrice: number) => {
    if (!dualPricing.enabled) {
      return <span className="text-sm font-medium">{formatCurrency(storedPrice)}</span>
    }
    // Card price is default display; cash price shown smaller
    const cardPrice = calculateCardPrice(storedPrice, discountPercent)
    return (
      <span className="text-sm font-medium">{formatCurrency(cardPrice)}</span>
    )
  }

  if (!isAuthenticated || !employee) {
    return null
  }

  // Combined Floor Plan + Bartender view with shared OrderPanel and modals
  // Shared OrderPanel element — passed as children to whichever view is active
  const sharedOrderPanel = (viewMode === 'floor-plan' || viewMode === 'bartender') && employee.location?.id ? (
    <div className="flex h-full">
    <OrderPanel
            orderId={currentOrder?.id || savedOrderId}
            orderNumber={currentOrder?.orderNumber}
            orderType={currentOrder?.orderType || (viewMode === 'bartender' ? 'bar_tab' : undefined)}
            tabName={currentOrder?.tabName}
            tableId={currentOrder?.tableId}
            locationId={employee.location.id}
            items={orderPanelItems}
            subtotal={pricing.subtotal}
            cashSubtotal={pricing.cashSubtotal}
            cardSubtotal={pricing.cardSubtotal}
            tax={pricing.tax}
            total={pricing.total}
            showItemControls={true}
            showEntertainmentTimers={true}
            onItemClick={panelCallbacks.onItemClick}
            onItemRemove={panelCallbacks.onItemRemove}
            onQuantityChange={panelCallbacks.onQuantityChange}
            onItemHoldToggle={panelCallbacks.onItemHoldToggle}
            onItemNoteEdit={panelCallbacks.onItemNoteEdit}
            onItemCourseChange={panelCallbacks.onItemCourseChange}
            onItemEditModifiers={panelCallbacks.onItemEditModifiers}
            onItemCompVoid={panelCallbacks.onItemCompVoid}
            onItemResend={panelCallbacks.onItemResend}
            onItemSplit={panelCallbacks.onItemSplit}
            onItemSeatChange={panelCallbacks.onItemSeatChange}
            expandedItemId={panelCallbacks.expandedItemId}
            onItemToggleExpand={panelCallbacks.onItemToggleExpand}
            onSend={handleSendToKitchen}
            onPay={async (method) => {
              // Ensure order is saved to DB before opening payment
              const orderId = savedOrderId || useOrderStore.getState().currentOrder?.id || await saveOrderToDatabase()
              if (orderId) {
                setInitialPayMethod(method)
                setOrderToPayId(orderId)
                setShowPaymentModal(true)
              }
            }}
            onPrintCheck={async () => {
              const orderId = savedOrderId || useOrderStore.getState().currentOrder?.id || await saveOrderToDatabase()
              if (orderId) {
                try {
                  await fetch('/api/print/receipt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orderId, type: 'check' }),
                  })
                  toast.success('Check sent to printer')
                } catch {
                  toast.error('Failed to print check')
                }
              }
            }}
            isSending={isSendingOrder}
            viewMode={viewMode === 'floor-plan' ? 'floor-plan' : viewMode === 'bartender' ? 'bartender' : 'legacy'}
            hasActiveTab={!!(tabCardInfo?.cardLast4 || currentOrder?.tabName)}
            requireCardForTab={requireCardForTab}
            tabCardLast4={tabCardInfo?.cardLast4}
            onStartTab={async () => {
              // Read fresh state — avoids stale closure issues
              const store = useOrderStore.getState()
              const items = store.currentOrder?.items
              if (!items?.length) return

              // Get existing order ID from Zustand (always current) or React state
              const existingOrderId = store.currentOrder?.id || savedOrderId

              // ── Existing tab with saved order → check for card & re-auth ──
              if (existingOrderId) {
                setIsSendingOrder(true)
                try {
                  // Check server for card on file (source of truth — avoids stale tabCardInfo)
                  let cardLast4 = ''
                  try {
                    const cardsRes = await fetch(`/api/orders/${existingOrderId}/cards`)
                    if (cardsRes.ok) {
                      const cardsData = await cardsRes.json()
                      const activeCard = (cardsData.data || []).find((c: { status: string }) => c.status === 'authorized')
                      if (activeCard) {
                        cardLast4 = activeCard.cardLast4 || ''
                        setTabCardInfo({
                          cardholderName: activeCard.cardholderName || undefined,
                          cardLast4: activeCard.cardLast4,
                          cardType: activeCard.cardType,
                        })
                      }
                    }
                  } catch { /* fall through to new tab flow */ }

                  if (cardLast4) {
                    // Card on file → append new items, send to kitchen, auto-increment
                    // Only POST unsent items (items already sent have sentToKitchen: true)
                    const newItems = items.filter(i => !i.sentToKitchen)
                    if (newItems.length > 0) {
                      const appendRes = await fetch(`/api/orders/${existingOrderId}/items`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                          items: newItems.map(item => ({
                            menuItemId: item.menuItemId,
                            name: item.name,
                            price: item.price,
                            quantity: item.quantity,
                            modifiers: (item.modifiers || []).map(mod => ({
                              modifierId: (mod.id || mod.modifierId) ?? '',
                              name: mod.name,
                              price: Number(mod.price),
                              depth: mod.depth ?? 0,
                              preModifier: mod.preModifier ?? null,
                              spiritTier: mod.spiritTier ?? null,
                              linkedBottleProductId: mod.linkedBottleProductId ?? null,
                              parentModifierId: mod.parentModifierId ?? null,
                            })),
                            specialNotes: item.specialNotes,
                          })),
                        }),
                      })
                      if (!appendRes.ok) {
                        toast.error('Failed to save new items')
                        return
                      }
                    }

                    // Send unsent items to kitchen
                    const sendRes = await fetch(`/api/orders/${existingOrderId}/send`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ employeeId: employee?.id }),
                    })
                    if (sendRes.ok) {
                      // Await IncrementalAuthByRecordNo — show approval/decline to user
                      try {
                        const authRes = await fetch(`/api/orders/${existingOrderId}/auto-increment`, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ employeeId: employee?.id, force: true }),
                        })
                        if (authRes.ok) {
                          const d = await authRes.json()
                          if (d.data?.incremented) {
                            toast.success(`Re-auth approved — hold now $${d.data.newAuthorizedTotal.toFixed(2)} •••${cardLast4}`)
                          } else if (d.data?.action === 'below_threshold') {
                            toast.success(`Sent to tab •••${cardLast4} — hold $${d.data.totalAuthorized.toFixed(2)} still covers`)
                          } else if (d.data?.action === 'increment_failed') {
                            toast.error(`Re-auth DECLINED •••${cardLast4} — hold remains $${d.data.totalAuthorized.toFixed(2)}`)
                          } else if (d.data?.action === 'no_card') {
                            toast.warning(`Sent to tab — no card on file for re-auth`)
                          } else {
                            toast.success(`Added to tab •••${cardLast4}`)
                          }
                        } else {
                          toast.success(`Added to tab •••${cardLast4}`)
                        }
                      } catch {
                        toast.success(`Added to tab •••${cardLast4}`)
                      }

                      clearOrder()
                      setSavedOrderId(null)
                      setOrderSent(false)
                      setSelectedOrderType(null)
                      setOrderCustomFields({})
                      setTabsRefreshTrigger(prev => prev + 1)
                    } else {
                      toast.error('Failed to send to kitchen')
                    }
                    return
                  }
                  // Card not found on existing order — fall through to new tab flow below
                } finally {
                  setIsSendingOrder(false)
                }
              }

              // ── New tab (no existing order or no card on file) → card auth flow ──
              const currentStore = useOrderStore.getState()
              if (currentStore.currentOrder && currentStore.currentOrder.orderType !== 'bar_tab') {
                currentStore.updateOrderType('bar_tab')
              }

              const orderId = existingOrderId || await saveOrderToDatabase()
              if (orderId) {
                setSavedOrderId(orderId)
                setCardTabOrderId(orderId)
                setShowCardTabFlow(true)
              } else {
                toast.error('Failed to save order — please try again')
              }
            }}
            onOtherPayment={async () => {
              // Open PaymentModal at method selection step (gift card, house account, etc.)
              const orderId = savedOrderId || useOrderStore.getState().currentOrder?.id || await saveOrderToDatabase()
              if (orderId) {
                setInitialPayMethod(undefined)
                setOrderToPayId(orderId)
                setShowPaymentModal(true)
              }
            }}
            cashDiscountPct={pricing.cashDiscountRate}
            taxPct={Math.round(pricing.taxRate * 100)}
            cashTotal={pricing.cashTotal}
            cardTotal={pricing.cardTotal}
            cashDiscountAmount={pricing.isDualPricingEnabled ? pricing.cardTotal - pricing.cashTotal : 0}
            hasTaxInclusiveItems={taxInclusiveLiquor || taxInclusiveFood}
            roundingAdjustment={pricing.cashRoundingDelta !== 0 ? pricing.cashRoundingDelta : undefined}
            hasSentItems={currentOrder?.items?.some(i => i.sentToKitchen) ?? false}
            onCancelOrder={() => {
              clearOrder()
              setSavedOrderId(null)
              setSelectedOrderType(null)
              setOrderCustomFields({})
              setOrderSent(false)
              setAppliedDiscounts([])
            }}
            onHide={() => {
              // Deselect tab/table in the active view
              if (viewMode === 'bartender') {
                bartenderDeselectTabRef.current?.()
              } else {
                floorPlanDeselectTableRef.current?.()
              }
              setSavedOrderId(null)
              setSelectedOrderType(null)
              setOrderCustomFields({})
              setOrderSent(false)
            }}
            selectedItemId={layout.quickPickEnabled ? quickPickSelectedId : undefined}
            selectedItemIds={layout.quickPickEnabled ? quickPickSelectedIds : undefined}
            onItemSelect={layout.quickPickEnabled ? selectQuickPickItem : undefined}
            multiSelectMode={quickPickMultiSelect}
            onToggleMultiSelect={toggleQuickPickMultiSelect}
            onSelectAllPending={selectAllPendingQuickPick}
            pendingDelay={currentOrder?.pendingDelay ?? undefined}
            delayStartedAt={currentOrder?.delayStartedAt ?? undefined}
            delayFiredAt={currentOrder?.delayFiredAt ?? undefined}
            onFireDelayed={async () => {
              const store = useOrderStore.getState()
              const orderId = store.currentOrder?.id || savedOrderId
              if (!orderId) return
              try {
                const res = await fetch(`/api/orders/${orderId}/send`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ employeeId: employee?.id }),
                })
                if (res.ok) {
                  store.markDelayFired()
                  if (store.currentOrder) {
                    for (const item of store.currentOrder.items) {
                      if (!item.sentToKitchen) store.updateItem(item.id, { sentToKitchen: true })
                    }
                  }
                }
              } catch (err) {
                console.error('[OrdersPage] Failed to fire delayed:', err)
              }
            }}
            onCancelDelay={() => useOrderStore.getState().setPendingDelay(null)}
            onFireItem={async (itemId) => {
              const store = useOrderStore.getState()
              const orderId = store.currentOrder?.id || savedOrderId
              if (!orderId) return
              try {
                const res = await fetch(`/api/orders/${orderId}/send`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ employeeId: employee?.id, itemIds: [itemId] }),
                })
                if (res.ok) {
                  store.markItemDelayFired(itemId)
                  store.updateItem(itemId, { sentToKitchen: true })
                }
              } catch (err) {
                console.error('[OrdersPage] Failed to fire delayed item:', err)
              }
            }}
            onCancelItemDelay={(itemId) => useOrderStore.getState().setItemDelay([itemId], null)}
            reopenedAt={currentOrder?.reopenedAt}
            reopenReason={currentOrder?.reopenReason}
            hideHeader={viewMode === 'floor-plan'}
            className={viewMode === 'bartender' ? 'w-[360px] flex-shrink-0' : 'flex-1 min-h-0 !h-auto'}
          />
      {/* Quick Pick Strip — right side of order panel */}
      {layout.quickPickEnabled && (
        <QuickPickStrip
          selectedItemId={quickPickSelectedId}
          selectedItemQty={quickPickSelectedId ? orderPanelItems.find(i => i.id === quickPickSelectedId)?.quantity : undefined}
          selectedCount={quickPickSelectedIds.size}
          onNumberTap={handleQuickPickNumber}
          multiSelectMode={quickPickMultiSelect}
          onToggleMultiSelect={toggleQuickPickMultiSelect}
          onHoldToggle={quickPickSelectedId ? () => {
            const item = currentOrder?.items.find(i => i.id === quickPickSelectedId)
            if (item) updateItem(quickPickSelectedId, { isHeld: !item.isHeld })
          } : undefined}
          isHeld={quickPickSelectedId ? currentOrder?.items.find(i => i.id === quickPickSelectedId)?.isHeld : false}
          onSetDelay={(minutes) => {
            const selectedIds = Array.from(quickPickSelectedIds)
            if (selectedIds.length > 0) {
              const store = useOrderStore.getState()
              const allHaveThisDelay = selectedIds.every(id => {
                const item = store.currentOrder?.items.find(i => i.id === id)
                return item?.delayMinutes === minutes
              })
              store.setItemDelay(selectedIds, allHaveThisDelay ? null : minutes)
            } else {
              const current = currentOrder?.pendingDelay
              useOrderStore.getState().setPendingDelay(current === minutes ? null : minutes)
            }
          }}
          activeDelay={(() => {
            const selectedIds = Array.from(quickPickSelectedIds)
            if (selectedIds.length === 0) return currentOrder?.pendingDelay ?? null
            const firstItem = currentOrder?.items.find(i => i.id === selectedIds[0])
            return firstItem?.delayMinutes ?? null
          })()}
        />
      )}
    </div>
  ) : null

  if ((viewMode === 'floor-plan' || viewMode === 'bartender') && employee.location?.id) {
    return (
      <>
        {viewMode === 'floor-plan' && (
          <FloorPlanHome
            locationId={employee.location.id}
            employeeId={employee.id}
            employeeName={employee.displayName}
            employeeRole={employee.role?.name}
            isManager={canAccessAdmin}
            onLogout={logout}
            onSwitchUser={() => { logout() }}
            onOpenSettings={() => setShowDisplaySettings(true)}
            onOpenAdminNav={() => setShowAdminNav(true)}
            onSwitchToBartenderView={() => {
              // Preserve current order context when switching views
              const order = useOrderStore.getState().currentOrder
              if (order?.orderType === 'bar_tab') setMode('bar')
              setViewMode('bartender')
            }}
            onOpenPayment={(orderId) => {
              setOrderToPayId(orderId)
              setShowPaymentModal(true)
            }}
            onOpenModifiers={handleOpenModifiersShared as any}
            onOpenOrdersPanel={() => { setShowTabsPanel(true) }}
            onOpenTimedRental={handleOpenTimedRental}
            onOpenPizzaBuilder={(item, onComplete) => {
              inlinePizzaCallbackRef.current = onComplete
              setSelectedPizzaItem(item as MenuItem)
              setEditingPizzaItem(null)
              setShowPizzaModal(true)
            }}
            orderToLoad={orderToLoad}
            onOrderLoaded={() => setOrderToLoad(null)}
            paidOrderId={paidOrderId}
            onPaidOrderCleared={() => setPaidOrderId(null)}
            onRegisterDeselectTable={(fn) => { floorPlanDeselectTableRef.current = fn }}
          >
            {sharedOrderPanel}
          </FloorPlanHome>
        )}
        {viewMode === 'bartender' && (
          <BartenderView
            locationId={employee.location.id}
            employeeId={employee.id}
            employeeName={employee.displayName}
            employeePermissions={permissionsArray}
            onRegisterDeselectTab={(fn) => { bartenderDeselectTabRef.current = fn }}
            onLogout={logout}
            onSwitchToFloorPlan={() => {
              // Preserve current order context when switching views
              const order = useOrderStore.getState().currentOrder
              if (order?.id && order.tableId) {
                setOrderToLoad({ id: order.id, orderNumber: order.orderNumber || 0, orderType: order.orderType })
              }
              if (order?.orderType !== 'bar_tab') setMode('food')
              setViewMode('floor-plan')
            }}
            onOpenCompVoid={(item) => {
              const orderId = useOrderStore.getState().currentOrder?.id || savedOrderId
              if (!orderId) {
                console.error('[BartenderView CompVoid] No order ID found')
                return
              }
              setOrderToPayId(orderId)
              setCompVoidItem({
                ...item,
                modifiers: item.modifiers.map(m => ({
                  id: m.id,
                  modifierId: m.id,
                  name: m.name,
                  price: m.price,
                  depth: 0,
                  preModifier: null,
                  spiritTier: null,
                  linkedBottleProductId: null,
                  parentModifierId: null,
                })),
              })
              setShowCompVoidModal(true)
            }}
            onOpenPayment={(orderId) => {
              setOrderToPayId(orderId)
              setShowPaymentModal(true)
            }}
            onOpenModifiers={handleOpenModifiersShared as any}
            requireNameWithoutCard={false}
            tapCardBehavior="close"
          >
            {sharedOrderPanel}
          </BartenderView>
        )}

        {/* Shared Modals — one set for both views */}
        {showAdminNav && (
          <AdminNav
            forceOpen={true}
            onClose={() => setShowAdminNav(false)}
            permissions={employee?.permissions || []}
            onAction={(action) => { if (action === 'tip_adjustments') setShowTipAdjustment(true) }}
          />
        )}
        <POSDisplaySettingsModal
          isOpen={showDisplaySettings}
          onClose={() => setShowDisplaySettings(false)}
          settings={displaySettings}
          onUpdate={updateSetting}
          onBatchUpdate={updateSettings}
        />
        {showTabsPanel && (
          <>
            {!isTabManagerExpanded && (
              <div
                className="fixed inset-0 bg-black/30 z-40"
                onClick={() => setShowTabsPanel(false)}
              />
            )}
            <div className={isTabManagerExpanded ? '' : 'fixed left-0 top-0 bottom-0 w-80 bg-slate-900 shadow-xl z-50'}>
              <OpenOrdersPanel
                locationId={employee.location.id}
                employeeId={employee.id}
                employeePermissions={permissionsArray}
                refreshTrigger={tabsRefreshTrigger}
                isExpanded={isTabManagerExpanded}
                onToggleExpand={() => setIsTabManagerExpanded(!isTabManagerExpanded)}
                onSelectOrder={(order) => {
                  setOrderToLoad({
                    id: order.id,
                    orderNumber: order.orderNumber,
                    tableId: order.tableId || undefined,
                    tabName: order.tabName || undefined,
                    orderType: order.orderType,
                  })
                  // Restore tab card info from pre-auth data
                  if (order.hasPreAuth && order.preAuth?.last4) {
                    setTabCardInfo({
                      cardholderName: order.cardholderName || undefined,
                      cardLast4: order.preAuth.last4,
                      cardType: order.preAuth.cardBrand,
                    })
                  }
                  setSavedOrderId(order.id)
                  setShowTabsPanel(false)
                  setIsTabManagerExpanded(false)
                }}
                onViewOrder={(order) => {
                  setOrderToLoad({
                    id: order.id,
                    orderNumber: order.orderNumber,
                    tableId: order.tableId || undefined,
                    tabName: order.tabName || undefined,
                    orderType: order.orderType,
                  })
                  // Restore tab card info from pre-auth data
                  if (order.hasPreAuth && order.preAuth?.last4) {
                    setTabCardInfo({
                      cardholderName: order.cardholderName || undefined,
                      cardLast4: order.preAuth.last4,
                      cardType: order.preAuth.cardBrand,
                    })
                  }
                  setSavedOrderId(order.id)
                  setShowTabsPanel(false)
                  setIsTabManagerExpanded(false)
                }}
                onNewTab={() => {
                  setShowTabsPanel(false)
                  setIsTabManagerExpanded(false)
                }}
                onClosedOrderAction={() => setTabsRefreshTrigger(prev => prev + 1)}
                onOpenTipAdjustment={() => setShowTipAdjustment(true)}
                onViewReceipt={(orderId) => {
                  setReceiptOrderId(orderId)
                  setShowReceiptModal(true)
                }}
              />
            </div>
          </>
        )}
        {showModifierModal && selectedItem && (
          <ModifierModal
            item={selectedItem}
            modifierGroups={itemModifierGroups}
            loading={loadingModifiers}
            editingItem={editingOrderItem}
            dualPricing={dualPricing}
            initialNotes={editingOrderItem?.specialNotes}
            onConfirm={editingOrderItem && !inlineModifierCallbackRef.current ? handleUpdateItemWithModifiers : handleAddItemWithModifiers}
            onCancel={() => {
              setShowModifierModal(false)
              setSelectedItem(null)
              setItemModifierGroups([])
              setEditingOrderItem(null)
              inlineModifierCallbackRef.current = null
            }}
          />
        )}
        {showPizzaModal && selectedPizzaItem && (
          <PizzaBuilderModal
            item={selectedPizzaItem}
            editingItem={editingPizzaItem}
            onConfirm={handleAddPizzaToOrder}
            onCancel={() => {
              setShowPizzaModal(false)
              setSelectedPizzaItem(null)
              setEditingPizzaItem(null)
              inlinePizzaCallbackRef.current = null
            }}
          />
        )}
        {showEntertainmentStart && entertainmentItem && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <EntertainmentSessionStart
              itemName={entertainmentItem.name}
              itemId={entertainmentItem.id}
              locationId={employee?.location?.id || ''}
              ratePerMinute={entertainmentItem.ratePerMinute || 0.25}
              prepaidPackages={entertainmentItem.prepaidPackages}
              happyHour={entertainmentItem.happyHourEnabled ? {
                enabled: true,
                discount: 0,
                start: '',
                end: '',
                days: [],
              } : undefined}
              currentOrderId={savedOrderId || null}
              currentOrderName={currentOrder?.tabName || null}
              openTabs={[]}
              onStartWithCurrentOrder={handleStartEntertainmentWithCurrentOrder}
              onStartWithNewTab={handleStartEntertainmentWithNewTab}
              onStartWithExistingTab={handleStartEntertainmentWithExistingTab}
              onClose={() => {
                setShowEntertainmentStart(false)
                setEntertainmentItem(null)
              }}
            />
          </div>
        )}
        {showTimedRentalModal && selectedTimedItem && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg shadow-xl w-full max-w-md">
              <div className="p-4 border-b bg-purple-50">
                <h2 className="text-lg font-bold text-purple-800">{selectedTimedItem.name}</h2>
                <p className="text-sm text-purple-600">Start a timed session</p>
              </div>
              <div className="p-6">
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Select Rate
                  </label>
                  <div className="space-y-2">
                    {selectedTimedItem.timedPricing?.per15Min ? (
                      <button
                        onClick={() => setSelectedRateType('per15Min')}
                        className={`w-full p-3 rounded-lg border-2 text-left flex justify-between items-center ${
                          selectedRateType === 'per15Min'
                            ? 'border-purple-500 bg-purple-50'
                            : 'border-gray-200 hover:border-gray-300'
                        }`}
                      >
                        <span>Per 15 minutes</span>
                        <span className="font-bold">{formatCurrency(selectedTimedItem.timedPricing.per15Min)}</span>
                      </button>
                    ) : null}
                    {selectedTimedItem.timedPricing?.per30Min ? (
                      <button
                        onClick={() => setSelectedRateType('per30Min')}
                        className={`w-full p-3 rounded-lg border-2 text-left flex justify-between items-center ${
                          selectedRateType === 'per30Min'
                            ? 'border-purple-500 bg-purple-50'
                            : 'border-gray-200 hover:border-gray-300'
                        }`}
                      >
                        <span>Per 30 minutes</span>
                        <span className="font-bold">{formatCurrency(selectedTimedItem.timedPricing.per30Min)}</span>
                      </button>
                    ) : null}
                    {selectedTimedItem.timedPricing?.perHour ? (
                      <button
                        onClick={() => setSelectedRateType('perHour')}
                        className={`w-full p-3 rounded-lg border-2 text-left flex justify-between items-center ${
                          selectedRateType === 'perHour'
                            ? 'border-purple-500 bg-purple-50'
                            : 'border-gray-200 hover:border-gray-300'
                        }`}
                      >
                        <span>Per hour</span>
                        <span className="font-bold">{formatCurrency(selectedTimedItem.timedPricing.perHour)}</span>
                      </button>
                    ) : null}
                    {!selectedTimedItem.timedPricing?.per15Min &&
                     !selectedTimedItem.timedPricing?.per30Min &&
                     !selectedTimedItem.timedPricing?.perHour && (
                      <button
                        onClick={() => setSelectedRateType('perHour')}
                        className="w-full p-3 rounded-lg border-2 text-left flex justify-between items-center border-purple-500 bg-purple-50"
                      >
                        <span>Per hour (base rate)</span>
                        <span className="font-bold">{formatCurrency(selectedTimedItem.price)}</span>
                      </button>
                    )}
                  </div>
                </div>
                {selectedTimedItem.timedPricing?.minimum && (
                  <p className="text-sm text-gray-500 mb-4">
                    Minimum: {selectedTimedItem.timedPricing.minimum} minutes
                  </p>
                )}
              </div>
              <div className="p-4 border-t bg-gray-50 flex gap-3">
                <Button
                  variant="outline"
                  onClick={() => {
                    setShowTimedRentalModal(false)
                    setSelectedTimedItem(null)
                    inlineTimedRentalCallbackRef.current = null
                  }}
                  className="flex-1"
                >
                  Cancel
                </Button>
                <Button
                  onClick={handleStartTimedSession}
                  disabled={loadingSession}
                  className="flex-1 bg-purple-500 hover:bg-purple-600"
                >
                  {loadingSession ? 'Starting...' : 'Start Timer'}
                </Button>
              </div>
            </div>
          </div>
        )}
        {showPaymentModal && orderToPayId && (
          <PaymentModal
            isOpen={showPaymentModal}
            initialMethod={initialPayMethod}
            onClose={() => {
              setShowPaymentModal(false)
              setOrderToPayId(null)
              setInitialPayMethod(undefined)
            }}
            orderId={orderToPayId}
            orderTotal={currentOrder?.total ?? 0}
            subtotal={currentOrder?.subtotal}
            remainingBalance={currentOrder?.total ?? 0}
            tabCards={paymentTabCards}
            dualPricing={dualPricing}
            paymentSettings={paymentSettings}
            priceRounding={priceRounding}
            onPaymentComplete={async () => {
              const paidId = orderToPayId
              setShowPaymentModal(false)
              setOrderToPayId(null)
              setInitialPayMethod(undefined)
              if (paidId) {
                setReceiptOrderId(paidId)
                setShowReceiptModal(true)
              }
              // Clear the order panel after payment
              clearOrder()
              setSavedOrderId(null)
              setOrderSent(false)
              setSelectedOrderType(null)
              setOrderCustomFields({})
              setTabsRefreshTrigger(prev => prev + 1)
            }}
            employeeId={employee?.id}
            terminalId="terminal-1"
            locationId={employee?.location?.id}
          />
        )}
        <ReceiptModal
          isOpen={showReceiptModal}
          onClose={() => {
            if (receiptOrderId) {
              setPaidOrderId(receiptOrderId)
            }
            setShowReceiptModal(false)
            setReceiptOrderId(null)
          }}
          orderId={receiptOrderId}
          locationId={employee.location?.id || ''}
          receiptSettings={receiptSettings}
        />
        <TipAdjustmentOverlay
          isOpen={showTipAdjustment}
          onClose={() => setShowTipAdjustment(false)}
          locationId={employee?.location?.id}
          employeeId={employee?.id}
        />

        {/* Card-First Tab Flow Modal */}
        {showCardTabFlow && cardTabOrderId && employee && (
          <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50">
            <div className="rounded-2xl shadow-2xl w-full max-w-md overflow-hidden" style={{ background: 'rgba(15, 23, 42, 0.95)', border: '1px solid rgba(255,255,255,0.1)' }}>
              <CardFirstTabFlow
                orderId={cardTabOrderId}
                readerId="reader-1"
                employeeId={employee.id}
                onComplete={async (result) => {
                  setShowCardTabFlow(false)
                  if (result.approved) {
                    setTabCardInfo({
                      cardholderName: result.cardholderName,
                      cardLast4: result.cardLast4,
                      cardType: result.cardType,
                    })
                    const store = useOrderStore.getState()
                    if (store.currentOrder && result.cardholderName) {
                      store.currentOrder.tabName = result.cardholderName
                    }
                    setTabNameInput(result.cardholderName || '')
                    setTabNameCallback(() => async () => {
                      // Direct send — bypass validateBeforeSend since card is already authorized
                      const store = useOrderStore.getState()
                      const items = store.currentOrder?.items
                      if (!items?.length) return
                      setIsSendingOrder(true)
                      try {
                        const orderId = savedOrderId || store.currentOrder?.id || await saveOrderToDatabase()
                        if (orderId) {
                          // Update metadata (tab name) on the saved order
                          await fetch(`/api/orders/${orderId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ tabName: store.currentOrder?.tabName }),
                          })
                          const sendRes = await fetch(`/api/orders/${orderId}/send`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ employeeId: employee?.id }),
                          })
                          if (sendRes.ok) {
                            // Fire auto-increment in background
                            fetch(`/api/orders/${orderId}/auto-increment`, {
                              method: 'POST',
                              headers: { 'Content-Type': 'application/json' },
                              body: JSON.stringify({ employeeId: employee?.id }),
                            }).catch(() => {})
                            toast.success(`Tab opened — •••${result.cardLast4}`)
                            clearOrder()
                            setSavedOrderId(null)
                            setOrderSent(false)
                            setSelectedOrderType(null)
                            setOrderCustomFields({})
                            setTabsRefreshTrigger(prev => prev + 1)
                          } else {
                            toast.error('Failed to send to kitchen')
                          }
                        }
                      } finally {
                        setIsSendingOrder(false)
                      }
                    })
                    setShowTabNamePrompt(true)
                  } else {
                    setCardTabOrderId(null)
                  }
                }}
                onCancel={() => {
                  setShowCardTabFlow(false)
                  setCardTabOrderId(null)
                }}
              />
            </div>
          </div>
        )}

        {/* Tab Name Prompt Modal */}
        {/* Discount Modal */}
        {showDiscountModal && currentOrder && savedOrderId && employee && (
          <DiscountModal
            isOpen={showDiscountModal}
            onClose={() => setShowDiscountModal(false)}
            orderId={savedOrderId}
            orderSubtotal={currentOrder.subtotal || 0}
            locationId={employee.location?.id || ''}
            employeeId={employee.id}
            appliedDiscounts={appliedDiscounts}
            onDiscountApplied={handleDiscountApplied}
          />
        )}

        {/* Comp/Void Modal */}
        {showCompVoidModal && (savedOrderId || orderToPayId) && compVoidItem && employee && (
          <CompVoidModal
            isOpen={showCompVoidModal}
            onClose={() => {
              setShowCompVoidModal(false)
              setCompVoidItem(null)
            }}
            orderId={(savedOrderId || orderToPayId)!}
            item={compVoidItem as OrderItem}
            employeeId={employee.id}
            locationId={employee.location?.id || ''}
            onComplete={handleCompVoidComplete}
          />
        )}

        {/* Resend to Kitchen Modal */}
        {resendModal && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white rounded-xl shadow-xl w-full max-w-md p-6">
              <h3 className="text-lg font-bold mb-2">Resend to Kitchen</h3>
              <p className="text-gray-600 mb-4">
                Resend &quot;{resendModal.itemName}&quot; to kitchen?
              </p>
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Note for kitchen (optional)
                </label>
                <input
                  type="text"
                  value={resendNote}
                  onChange={(e) => setResendNote(e.target.value)}
                  placeholder="e.g., Make it well done"
                  className="w-full p-3 border rounded-lg text-lg"
                  autoFocus
                />
              </div>
              <div className="flex gap-3">
                <Button
                  variant="outline"
                  className="flex-1"
                  onClick={() => {
                    setResendModal(null)
                    setResendNote('')
                  }}
                  disabled={resendLoading}
                >
                  Cancel
                </Button>
                <Button
                  className="flex-1 bg-blue-600 hover:bg-blue-700"
                  onClick={confirmResendItem}
                  disabled={resendLoading}
                >
                  {resendLoading ? 'Sending...' : 'Resend'}
                </Button>
              </div>
            </div>
          </div>
        )}

        {/* Item Transfer Modal */}
        {showItemTransferModal && savedOrderId && employee && (
          <ItemTransferModal
            isOpen={showItemTransferModal}
            onClose={() => setShowItemTransferModal(false)}
            currentOrderId={savedOrderId}
            items={currentOrder?.items.map((item) => ({
              id: item.id,
              tempId: item.id,
              name: item.name,
              price: item.price,
              quantity: item.quantity,
              modifiers: item.modifiers.map((mod) => ({
                name: mod.name,
                price: mod.price,
              })),
              sent: item.sentToKitchen,
            })) || []}
            locationId={employee.location?.id || ''}
            employeeId={employee.id}
            onTransferComplete={async (transferredItemIds) => {
              try {
                const response = await fetch(`/api/orders/${savedOrderId}`)
                if (response.ok) {
                  const orderData = await response.json()
                  loadOrder({
                    id: orderData.id,
                    orderNumber: orderData.orderNumber,
                    orderType: orderData.orderType,
                    tableId: orderData.tableId || undefined,
                    tableName: orderData.tableName || undefined,
                    tabName: orderData.tabName || undefined,
                    guestCount: orderData.guestCount,
                    items: orderData.items,
                    subtotal: orderData.subtotal,
                    taxTotal: orderData.taxTotal,
                    total: orderData.total,
                    notes: orderData.notes,
                  })
                }
              } catch (error) {
                console.error('Failed to reload order:', error)
              }
            }}
          />
        )}

        {/* Split Ticket Manager */}
        {showSplitTicketManager && savedOrderId && currentOrder && (
          <SplitTicketManager
            isOpen={showSplitTicketManager}
            onClose={() => setShowSplitTicketManager(false)}
            orderId={savedOrderId}
            orderNumber={currentOrder.orderNumber || 0}
            items={currentOrder.items.map(item => ({
              id: item.id,
              tempId: item.id,
              name: item.name,
              price: item.price,
              quantity: item.quantity,
              modifiers: item.modifiers.map(mod => ({
                id: (mod.id || mod.modifierId) ?? '',
                modifierId: mod.modifierId,
                name: mod.name,
                price: Number(mod.price),
                depth: mod.depth ?? 0,
                preModifier: mod.preModifier ?? null,
                spiritTier: mod.spiritTier ?? null,
                linkedBottleProductId: mod.linkedBottleProductId ?? null,
                parentModifierId: mod.parentModifierId ?? null,
              })),
            }))}
            orderDiscount={appliedDiscounts.reduce((sum, d) => sum + d.amount, 0)}
            taxRate={taxRate}
            roundTo={priceRounding.enabled ? priceRounding.increment : 'none'}
            onSplitComplete={handleSplitTicketComplete}
          />
        )}

        {showTabNamePrompt && (
          <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50">
            <div className="rounded-2xl shadow-2xl w-full max-w-sm p-6" style={{ background: 'rgba(15, 23, 42, 0.95)', border: '1px solid rgba(255,255,255,0.1)' }}>
              {tabCardInfo?.cardLast4 ? (
                <>
                  <h3 className="text-lg font-bold text-white mb-2">Tab Started</h3>
                  <div className="flex items-center gap-2 mb-3 px-3 py-2 rounded-lg" style={{ background: 'rgba(34, 197, 94, 0.15)', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <span className="text-green-400 text-sm">✓</span>
                    <span className="text-green-300 text-sm font-medium">
                      {tabCardInfo.cardType} •••{tabCardInfo.cardLast4}
                    </span>
                    {tabCardInfo.cardholderName && (
                      <span className="text-green-300 text-sm ml-auto font-medium">{tabCardInfo.cardholderName}</span>
                    )}
                  </div>
                  <p className="text-sm text-gray-400 mb-3">Add a nickname? (shown above cardholder name)</p>
                  <input
                    autoFocus
                    type="text"
                    placeholder="e.g. Blue shirt, Patio group..."
                    value={tabNameInput}
                    onChange={(e) => setTabNameInput(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        const store = useOrderStore.getState()
                        if (store.currentOrder && tabNameInput.trim()) {
                          store.currentOrder.tabName = `${tabNameInput.trim()} — ${tabCardInfo.cardholderName || ''}`
                        }
                        setShowTabNamePrompt(false)
                        tabNameCallback?.()
                      }
                    }}
                    className="w-full px-4 py-3 rounded-xl text-white text-lg"
                    style={{ background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)' }}
                  />
                  <div className="flex gap-3 mt-4">
                    <button
                      onClick={() => { setShowTabNamePrompt(false); tabNameCallback?.() }}
                      className="flex-1 py-3 rounded-xl text-gray-300 font-semibold"
                      style={{ background: 'rgba(255,255,255,0.08)' }}
                    >
                      Skip
                    </button>
                    <button
                      onClick={() => {
                        const store = useOrderStore.getState()
                        if (store.currentOrder && tabNameInput.trim()) {
                          store.currentOrder.tabName = `${tabNameInput.trim()} — ${tabCardInfo.cardholderName || ''}`
                        }
                        setShowTabNamePrompt(false)
                        tabNameCallback?.()
                      }}
                      className="flex-1 py-3 rounded-xl text-white font-bold"
                      style={{ background: tabNameInput.trim() ? '#8b5cf6' : 'rgba(255,255,255,0.1)', opacity: tabNameInput.trim() ? 1 : 0.5 }}
                    >
                      Send to Tab
                    </button>
                  </div>
                </>
              ) : (
                <>
                  <h3 className="text-lg font-bold text-white mb-1">Tab Name</h3>
                  <p className="text-sm text-gray-400 mb-4">Enter a name for this tab</p>
                  <input
                    autoFocus
                    type="text"
                    placeholder="e.g. John, Table 5, etc."
                    value={tabNameInput}
                    onChange={(e) => setTabNameInput(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && tabNameInput.trim()) {
                        const store = useOrderStore.getState()
                        if (store.currentOrder) { store.currentOrder.tabName = tabNameInput.trim() }
                        setShowTabNamePrompt(false)
                        tabNameCallback?.()
                      }
                    }}
                    className="w-full px-4 py-3 rounded-xl text-white text-lg"
                    style={{ background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)' }}
                  />
                  <div className="flex gap-3 mt-4">
                    <button
                      onClick={() => { setShowTabNamePrompt(false); setTabNameCallback(null) }}
                      className="flex-1 py-3 rounded-xl text-gray-400 font-semibold"
                      style={{ background: 'rgba(255,255,255,0.05)' }}
                    >
                      Cancel
                    </button>
                    <button
                      onClick={() => {
                        if (!tabNameInput.trim()) return
                        const store = useOrderStore.getState()
                        if (store.currentOrder) { store.currentOrder.tabName = tabNameInput.trim() }
                        setShowTabNamePrompt(false)
                        tabNameCallback?.()
                      }}
                      disabled={!tabNameInput.trim()}
                      className="flex-1 py-3 rounded-xl text-white font-bold"
                      style={{ background: tabNameInput.trim() ? '#8b5cf6' : 'rgba(255,255,255,0.1)', opacity: tabNameInput.trim() ? 1 : 0.5 }}
                    >
                      Start Tab
                    </button>
                  </div>
                </>
              )}
            </div>
          </div>
        )}

        {/* Time Clock Modal */}
        <TimeClockModal
          isOpen={showTimeClockModal}
          onClose={() => setShowTimeClockModal(false)}
          employeeId={employee?.id || ''}
          employeeName={employee?.displayName || `${employee?.firstName} ${employee?.lastName}` || ''}
          locationId={employee?.location?.id || ''}
        />

        {/* Shift Start Modal */}
        <ShiftStartModal
          isOpen={showShiftStartModal}
          onClose={() => setShowShiftStartModal(false)}
          employeeId={employee?.id || ''}
          employeeName={employee?.displayName || `${employee?.firstName} ${employee?.lastName}` || ''}
          locationId={employee?.location?.id || ''}
          onShiftStarted={(shiftId) => {
            fetch(`/api/shifts/${shiftId}`)
              .then(res => res.json())
              .then(data => {
                setCurrentShift({
                  id: data.shift.id,
                  startedAt: data.shift.startedAt,
                  startingCash: data.shift.startingCash,
                  employee: {
                    ...data.shift.employee,
                    roleId: employee?.role?.id,
                  },
                  locationId: employee?.location?.id,
                })
              })
              .catch(err => console.error('Failed to fetch shift:', err))
          }}
        />

        {/* Shift Closeout Modal */}
        {currentShift && (
          <ShiftCloseoutModal
            isOpen={showShiftCloseoutModal}
            onClose={() => setShowShiftCloseoutModal(false)}
            shift={currentShift}
            onCloseoutComplete={() => {
              setCurrentShift(null)
            }}
            permissions={permissionsArray}
          />
        )}
      </>
    )
  }

  // Fallback — should not be reached since viewMode is always 'floor-plan' or 'bartender'
  return null
}


================================================================
  FILE 3: src/components/orders/OpenOrdersPanel.tsx (Phase 2G)
================================================================

'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { Button } from '@/components/ui/button'
import { formatCurrency } from '@/lib/utils'
import { formatCardDisplay } from '@/lib/payment'
import { useOrderSockets } from '@/hooks/useOrderSockets'
import { ClosedOrderActionsModal } from './ClosedOrderActionsModal'

interface OpenOrder {
  id: string
  orderNumber: number
  displayNumber?: string
  isSplitTicket?: boolean
  orderType: string
  orderTypeConfig?: {
    name: string
    color?: string
    icon?: string
  } | null
  customFields?: Record<string, string> | null
  tabName: string | null
  tabStatus: string | null
  cardholderName: string | null
  tableId: string | null
  table?: {
    id: string
    name: string
    section: string | null
  } | null
  customer?: {
    id: string
    name: string
  } | null
  guestCount: number
  status: string
  employee: {
    id: string
    name: string
  }
  items: {
    id: string
    menuItemId: string
    name: string
    price: number
    quantity: number
    itemTotal: number
    specialNotes: string | null
    isCompleted?: boolean
    completedAt?: string | null
    resendCount?: number
    blockTimeMinutes?: number | null
    blockTimeStartedAt?: string | null
    blockTimeExpiresAt?: string | null
    modifiers: {
      id: string
      modifierId: string
      name: string
      price: number
      preModifier: string | null
    }[]
  }[]
  itemCount: number
  subtotal: number
  taxTotal: number
  tipTotal?: number
  total: number
  hasPreAuth: boolean
  preAuth: {
    cardBrand: string
    last4: string
    amount: number | null
    expiresAt: string
  } | null
  createdAt: string
  openedAt: string
  closedAt?: string | null
  paidAmount: number
  paymentMethods?: string[]
  payments?: {
    id: string
    amount: number
    tipAmount: number
    totalAmount: number
    paymentMethod: string
    cardBrand: string | null
    cardLast4: string | null
    status?: string
    datacapRecordNo?: string | null
  }[]
  hasCardPayment?: boolean
  needsTip?: boolean
  waitlist?: { position: number; menuItemName: string }[]
  isOnWaitlist?: boolean
  entertainment?: { menuItemId: string; menuItemName: string; status: string; orderItemId: string | null }[]
  hasActiveEntertainment?: boolean
  hasHeldItems?: boolean
  hasCoursingEnabled?: boolean
  hasDelayedItems?: boolean
  courseMode?: string | null
  reopenedAt?: string | null
  reopenReason?: string | null
}

interface OpenOrdersPanelProps {
  locationId?: string
  employeeId?: string
  employeePermissions?: string[]
  onSelectOrder: (order: OpenOrder) => void
  onViewOrder?: (order: OpenOrder) => void
  onNewTab?: () => void
  refreshTrigger?: number
  onViewReceipt?: (orderId: string) => void
  onClosedOrderAction?: () => void
  onOpenTipAdjustment?: () => void
  isExpanded?: boolean
  onToggleExpand?: () => void
  forceDark?: boolean
}

type SortOption = 'newest' | 'oldest' | 'alpha_first' | 'alpha_last' | 'total_high' | 'total_low' | 'employee'
type DatePreset = 'today' | 'yesterday' | 'this_week' | 'custom'

const SORT_OPTIONS: { value: SortOption; label: string }[] = [
  { value: 'newest', label: 'Newest' },
  { value: 'oldest', label: 'Oldest' },
  { value: 'alpha_first', label: 'A → Z' },
  { value: 'alpha_last', label: 'Z → A' },
  { value: 'total_high', label: 'Highest $' },
  { value: 'total_low', label: 'Lowest $' },
  { value: 'employee', label: 'Employee' },
]

const ORDER_TYPE_CONFIG: Record<string, { icon: string; label: string; color: string; darkColor: string }> = {
  dine_in: { icon: '🍽️', label: 'Dine In', color: 'bg-blue-100 text-blue-800', darkColor: 'bg-blue-600/30 text-blue-300 border-blue-500/30' },
  takeout: { icon: '📦', label: 'Takeout', color: 'bg-orange-100 text-orange-800', darkColor: 'bg-orange-600/30 text-orange-300 border-orange-500/30' },
  delivery: { icon: '🚗', label: 'Delivery', color: 'bg-green-100 text-green-800', darkColor: 'bg-green-600/30 text-green-300 border-green-500/30' },
  bar_tab: { icon: '🍺', label: 'Bar Tab', color: 'bg-purple-100 text-purple-800', darkColor: 'bg-purple-600/30 text-purple-300 border-purple-500/30' },
  drive_thru: { icon: '🚗', label: 'Drive Thru', color: 'bg-cyan-100 text-cyan-800', darkColor: 'bg-cyan-600/30 text-cyan-300 border-cyan-500/30' },
  call_in: { icon: '📞', label: 'Call-in', color: 'bg-teal-100 text-teal-800', darkColor: 'bg-teal-600/30 text-teal-300 border-teal-500/30' },
}

function getOrderTypeDisplay(order: OpenOrder, dark: boolean): { icon: string; label: string; color: string } {
  if (order.orderTypeConfig) {
    const iconMap: Record<string, string> = {
      table: '🍽️', wine: '🍷', bag: '📦', truck: '🚚', phone: '📞', car: '🚗',
    }
    const icon = order.orderTypeConfig.icon ? (iconMap[order.orderTypeConfig.icon] || '📋') : '📋'
    return {
      icon,
      label: order.orderTypeConfig.name,
      color: dark ? 'bg-slate-600/30 text-slate-300 border-slate-500/30' : 'bg-gray-100 text-gray-800',
    }
  }
  const config = ORDER_TYPE_CONFIG[order.orderType]
  if (config) {
    return { icon: config.icon, label: config.label, color: dark ? config.darkColor : config.color }
  }
  return {
    icon: '📋',
    label: order.orderType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
    color: dark ? 'bg-slate-600/30 text-slate-300 border-slate-500/30' : 'bg-gray-100 text-gray-800',
  }
}

export function OpenOrdersPanel({
  locationId, employeeId, employeePermissions = [], onSelectOrder, onViewOrder, onNewTab,
  refreshTrigger, onViewReceipt, onClosedOrderAction, onOpenTipAdjustment, isExpanded = false, onToggleExpand, forceDark = false,
}: OpenOrdersPanelProps) {
  const [orders, setOrders] = useState<OpenOrder[]>([])
  const [closedOrders, setClosedOrders] = useState<OpenOrder[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [filter, setFilter] = useState<'all' | 'mine'>('all')
  const [typeFilter, setTypeFilter] = useState<string | null>(null)
  const [viewMode, setViewMode] = useState<'open' | 'closed'>('open')
  const [searchQuery, setSearchQuery] = useState('')
  const [isSearchOpen, setIsSearchOpen] = useState(false)
  const [sortBy, setSortBy] = useState<SortOption>('newest')
  const [showSortMenu, setShowSortMenu] = useState(false)
  const [viewStyle, setViewStyle] = useState<'card' | 'condensed'>('card')
  const [datePreset, setDatePreset] = useState<DatePreset>('today')
  const [closedOrderModalOrder, setClosedOrderModalOrder] = useState<OpenOrder | null>(null)
  const [closedCursor, setClosedCursor] = useState<string | null>(null)
  const [hasMoreClosed, setHasMoreClosed] = useState(false)
  const searchInputRef = useRef<HTMLInputElement>(null)

  const dark = isExpanded || forceDark

  useEffect(() => {
    if (locationId) loadOrders()
  }, [locationId, refreshTrigger])

  // Socket-based real-time open orders updates (replaces 3s polling)
  const handleSocketOrdersChanged = useCallback(() => {
    if (viewMode === 'open') loadOrders()
  }, [viewMode])

  useOrderSockets({
    locationId,
    enabled: viewMode === 'open',
    onOpenOrdersChanged: handleSocketOrdersChanged,
  })

  // Visibility-change fallback (tab refocus)
  useEffect(() => {
    if (!locationId || viewMode !== 'open') return
    const handleVisibilityChange = () => { if (document.visibilityState === 'visible') loadOrders() }
    document.addEventListener('visibilitychange', handleVisibilityChange)
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [locationId, viewMode])

  useEffect(() => {
    if (locationId && viewMode === 'closed') {
      setClosedOrders([])
      setClosedCursor(null)
      loadClosedOrders(null)
    }
  }, [locationId, viewMode, datePreset])

  const loadOrders = async () => {
    if (!locationId) return
    try {
      const params = new URLSearchParams({ locationId, _t: Date.now().toString() })
      const response = await fetch(`/api/orders/open?${params}`, {
        cache: 'no-store',
        headers: { 'Cache-Control': 'no-cache' },
      })
      if (response.ok) {
        const data = await response.json()
        setOrders(data.orders)
      }
    } catch (error) {
      console.error('Failed to load orders:', error)
    } finally {
      setIsLoading(false)
    }
  }

  const loadClosedOrders = async (cursor: string | null) => {
    if (!locationId) return
    setIsLoading(true)
    try {
      const params = new URLSearchParams({ locationId, limit: '50' })

      // Date range from preset (use local date, not UTC)
      const now = new Date()
      const toLocal = (d: Date) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`
      if (datePreset === 'today') {
        params.set('dateFrom', toLocal(now))
      } else if (datePreset === 'yesterday') {
        const yesterday = new Date(now)
        yesterday.setDate(yesterday.getDate() - 1)
        params.set('dateFrom', toLocal(yesterday))
        params.set('dateTo', toLocal(yesterday))
      } else if (datePreset === 'this_week') {
        const weekStart = new Date(now)
        weekStart.setDate(weekStart.getDate() - weekStart.getDay())
        params.set('dateFrom', toLocal(weekStart))
      }

      if (cursor) params.set('cursor', cursor)

      const sortMap: Record<SortOption, string> = {
        newest: 'newest', oldest: 'oldest', total_high: 'total_high', total_low: 'total_low',
        alpha_first: 'newest', alpha_last: 'newest', employee: 'newest',
      }
      params.set('sortBy', sortMap[sortBy] || 'newest')

      const response = await fetch(`/api/orders/closed?${params}`)
      if (response.ok) {
        const data = await response.json()
        if (cursor) {
          setClosedOrders(prev => [...prev, ...data.orders])
        } else {
          setClosedOrders(data.orders)
        }
        setClosedCursor(data.pagination?.nextCursor || null)
        setHasMoreClosed(data.pagination?.hasMore || false)
      }
    } catch (error) {
      console.error('Failed to load closed orders:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // Sort and filter
  const displayOrders = viewMode === 'open' ? orders : closedOrders
  let filteredOrders = [...displayOrders]

  if (filter === 'mine' && employeeId) {
    filteredOrders = filteredOrders.filter(o => o.employee.id === employeeId)
  }
  if (typeFilter) {
    filteredOrders = filteredOrders.filter(o => o.orderType === typeFilter)
  }
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase().trim()
    filteredOrders = filteredOrders.filter(o => {
      const tabName = o.tabName?.toLowerCase() || ''
      const tableName = o.table?.name?.toLowerCase() || ''
      const customerName = o.customer?.name?.toLowerCase() || ''
      const cardholderName = o.cardholderName?.toLowerCase() || ''
      const cardLast4 = o.preAuth?.last4 || ''
      const orderNum = String(o.orderNumber)
      const displayNum = o.displayNumber || ''
      const empName = o.employee.name?.toLowerCase() || ''
      return tabName.includes(query) || tableName.includes(query) || customerName.includes(query) ||
        cardholderName.includes(query) || cardLast4.includes(query) ||
        orderNum.includes(query) || displayNum.includes(query) || empName.includes(query)
    })
  }

  // Client-side sort (for fields not supported by API sort)
  filteredOrders.sort((a, b) => {
    const nameA = (a.tabName || a.customer?.name || `Order #${a.orderNumber}`).toLowerCase()
    const nameB = (b.tabName || b.customer?.name || `Order #${b.orderNumber}`).toLowerCase()
    switch (sortBy) {
      case 'newest': return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      case 'oldest': return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      case 'alpha_first': return nameA.localeCompare(nameB)
      case 'alpha_last': return nameB.localeCompare(nameA)
      case 'total_high': return b.total - a.total
      case 'total_low': return a.total - b.total
      case 'employee': return a.employee.name.localeCompare(b.employee.name)
      default: return 0
    }
  })

  const formatTime = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })
  }

  const getOrderDisplayName = (order: OpenOrder): { primary: string; secondary: string | null } => {
    let primary = `Order #${order.displayNumber || order.orderNumber}`
    let secondary: string | null = null
    if (order.tabName) {
      primary = order.tabName
      // Show cardholder name as secondary if different from tab name
      if (order.cardholderName && order.cardholderName !== order.tabName) {
        secondary = order.cardholderName
      }
    }
    else if (order.customer?.name) primary = order.customer.name
    if (order.table) {
      secondary = order.table.section ? `${order.table.section} - ${order.table.name}` : order.table.name
    }
    return { primary, secondary }
  }

  const typeCounts = displayOrders.reduce((acc, o) => {
    acc[o.orderType] = (acc[o.orderType] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  const getTimeRemaining = (item: { blockTimeExpiresAt?: string | null }) => {
    if (!item.blockTimeExpiresAt) return null
    const remainingMs = new Date(item.blockTimeExpiresAt).getTime() - Date.now()
    if (remainingMs <= 0) return 'EXPIRED'
    const mins = Math.floor(remainingMs / 60000)
    const secs = Math.floor((remainingMs % 60000) / 1000)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  // ── Render helpers ──

  const renderSearchIcon = () => (
    <div className="relative flex items-center">
      <AnimatePresence>
        {isSearchOpen ? (
          <motion.div
            initial={{ width: 0, opacity: 0 }}
            animate={{ width: isExpanded ? 300 : 180, opacity: 1 }}
            exit={{ width: 0, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            <input
              ref={searchInputRef}
              type="text"
              placeholder="Search..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onBlur={() => { if (!searchQuery) setIsSearchOpen(false) }}
              onKeyDown={(e) => { if (e.key === 'Escape') { setSearchQuery(''); setIsSearchOpen(false) } }}
              className={`w-full px-3 py-2 rounded-lg text-sm font-medium focus:outline-none ${
                dark
                  ? 'bg-white/10 border border-white/20 text-white placeholder-slate-400 focus:border-indigo-500'
                  : 'border-2 border-gray-300 focus:border-blue-500'
              }`}
              autoFocus
            />
          </motion.div>
        ) : (
          <motion.button
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            onClick={() => { setIsSearchOpen(true); setTimeout(() => searchInputRef.current?.focus(), 50) }}
            className={`p-2 rounded-lg transition-colors ${
              dark ? 'hover:bg-white/10 text-slate-400 hover:text-white' : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            }`}
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </motion.button>
        )}
      </AnimatePresence>
    </div>
  )

  const renderOrderCard = (order: OpenOrder) => {
    const config = getOrderTypeDisplay(order, dark)
    const displayName = getOrderDisplayName(order)
    const hasWaitlist = order.isOnWaitlist && order.waitlist && order.waitlist.length > 0
    const hasEntertainment = order.hasActiveEntertainment && order.entertainment && order.entertainment.length > 0
    const entertainmentItems = order.items.filter(item => item.blockTimeMinutes || item.blockTimeExpiresAt)

    if (viewStyle === 'condensed') {
      return (
        <div
          key={order.id}
          onClick={() => onViewOrder ? onViewOrder(order) : onSelectOrder(order)}
          className={`flex items-center gap-3 px-3 py-2.5 rounded-lg cursor-pointer transition-all ${
            dark
              ? 'bg-white/5 hover:bg-white/10 border border-white/10'
              : 'bg-white hover:bg-gray-50 border border-gray-200'
          }`}
        >
          <span className="text-sm">{config.icon}</span>
          <div className="flex-1 min-w-0">
            <span className={`font-semibold text-sm truncate block ${dark ? 'text-white' : 'text-gray-900'}`}>
              {displayName.primary}
            </span>
            <span className={`text-xs ${dark ? 'text-slate-400' : 'text-gray-500'}`}>
              #{order.displayNumber || order.orderNumber} • {order.employee.name} • {formatTime(order.createdAt)}
              {order.hasPreAuth && order.preAuth && (
                <> • •••{order.preAuth.last4}{order.preAuth.amount != null && ` ${formatCurrency(order.preAuth.amount)}`}</>
              )}
            </span>
            {order.tabStatus === 'pending_auth' && (
              <span className={`inline-block mt-0.5 px-1.5 py-0.5 rounded text-xs font-bold animate-pulse ${dark ? 'bg-amber-600/30 text-amber-300' : 'bg-amber-100 text-amber-700'}`}>
                Authorizing...
              </span>
            )}
            {order.reopenedAt && (
              <span className={`inline-block mt-0.5 px-1.5 py-0.5 rounded text-xs font-bold ${dark ? 'bg-orange-600/30 text-orange-300' : 'bg-orange-100 text-orange-700'}`}>
                🔓 Reopened
              </span>
            )}
          </div>
          <span className={`font-bold text-sm ${dark ? 'text-green-400' : 'text-gray-900'}`}>
            {formatCurrency(order.total)}
          </span>
          {viewMode === 'open' && (
            <button
              onClick={(e) => { e.stopPropagation(); onSelectOrder(order) }}
              className="px-3 py-1.5 bg-green-600 hover:bg-green-500 rounded text-xs font-bold text-white transition-colors"
            >
              Pay
            </button>
          )}
        </div>
      )
    }

    const isPaidOrClosed = order.status === 'paid' || order.status === 'closed'

    return (
      <div
        key={order.id}
        onClick={() => {
          if (isPaidOrClosed) { setClosedOrderModalOrder(order); return }
          onViewOrder ? onViewOrder(order) : onSelectOrder(order)
        }}
        className={`p-3 rounded-xl transition-all border ${
          isPaidOrClosed
            ? dark
              ? 'bg-green-900/20 border-green-500/30 opacity-80'
              : 'bg-green-50 border-green-300 border-2 opacity-90'
            : dark
              ? `bg-white/5 hover:bg-white/10 cursor-pointer ${
                  hasEntertainment ? 'border-green-500/50' : hasWaitlist ? 'border-amber-500/50' : 'border-white/10'
                }`
              : `hover:bg-gray-50 cursor-pointer border-2 ${
                  hasEntertainment ? 'border-green-500 bg-green-50' : hasWaitlist ? 'border-amber-400 bg-amber-50' : 'border-transparent bg-white'
                }`
        }`}
      >
        {/* Entertainment badges */}
        {hasEntertainment && (
          <div className="mb-2 flex flex-wrap gap-1">
            {order.entertainment!.map((e, idx) => (
              <span key={idx} className="inline-flex items-center gap-1 px-2 py-1 bg-green-600 text-white text-xs font-bold rounded-full">
                🎱 {e.menuItemName}
                {entertainmentItems.find(item => item.menuItemId === e.menuItemId)?.blockTimeExpiresAt && (
                  <span className="ml-1 font-mono">({getTimeRemaining(entertainmentItems.find(item => item.menuItemId === e.menuItemId) || {})})</span>
                )}
              </span>
            ))}
          </div>
        )}

        {/* Waitlist badges */}
        {hasWaitlist && (
          <div className="mb-2 flex flex-wrap gap-1">
            {order.waitlist!.map((w, idx) => (
              <span key={idx} className="inline-flex items-center gap-1 px-2 py-1 bg-amber-500 text-white text-xs font-bold rounded-full">
                ⏳ #{w.position} for {w.menuItemName}
              </span>
            ))}
          </div>
        )}

        <div className="flex items-start justify-between mb-2">
          <div className="flex-1 min-w-0">
            <h4 className={`font-bold flex items-center gap-2 truncate ${dark ? 'text-white' : 'text-gray-900'}`}>
              <span>{config.icon}</span>
              <span className="truncate">{displayName.primary}</span>
            </h4>
            {displayName.secondary && (
              <p className={`text-sm mt-0.5 ${order.table ? (dark ? 'text-blue-400 font-semibold' : 'text-blue-700 font-semibold') : (dark ? 'text-slate-400' : 'text-gray-500')}`}>
                {order.table ? '📍 ' : ''}{displayName.secondary}
              </p>
            )}
            <p className={`text-xs mt-1 ${dark ? 'text-slate-400' : 'text-gray-500'}`}>
              #{order.displayNumber || order.orderNumber}
              {order.isSplitTicket && <span className="ml-1 text-blue-500">(split)</span>}
              {' • '}{order.employee.name} • {formatTime(order.createdAt)}
            </p>
          </div>
          <div className="ml-2 text-right">
            <span className={`font-bold text-lg ${isPaidOrClosed ? (dark ? 'text-green-400' : 'text-green-700') : (dark ? 'text-green-400' : 'text-gray-900')}`}>
              {formatCurrency(order.total)}
            </span>
            {isPaidOrClosed && (
              <div className={`text-xs font-bold ${dark ? 'text-green-400' : 'text-green-600'}`}>PAID</div>
            )}
          </div>
        </div>

        {/* Badges row */}
        <div className="flex items-center gap-2 mb-2 flex-wrap">
          <span className={`px-2 py-0.5 rounded-full text-xs font-medium border ${config.color}`}>
            {config.label}
          </span>
          {(order.status === 'paid' || order.status === 'closed') && (
            <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${dark ? 'bg-green-600/30 text-green-300' : 'bg-green-100 text-green-800'}`}>
              Paid
            </span>
          )}
          {order.needsTip && (
            <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${dark ? 'bg-amber-600/30 text-amber-300' : 'bg-amber-100 text-amber-700'}`}>
              💰 Needs Tip
            </span>
          )}
          {order.guestCount > 1 && (
            <span className={`text-xs font-medium ${dark ? 'text-slate-400' : 'text-gray-500'}`}>
              👥 {order.guestCount}
            </span>
          )}
          {order.hasDelayedItems && (
            <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${dark ? 'bg-amber-600/30 text-amber-300' : 'bg-amber-100 text-amber-700'}`}>
              ⏱ Delayed
            </span>
          )}
          {order.hasHeldItems && (
            <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${dark ? 'bg-red-600/30 text-red-300' : 'bg-red-100 text-red-700'}`}>
              ⏸ Held
            </span>
          )}
          {(order.hasCoursingEnabled || (order.courseMode && order.courseMode !== 'off')) && (
            <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${dark ? 'bg-blue-600/30 text-blue-300' : 'bg-blue-100 text-blue-700'}`}>
              CRS
            </span>
          )}
          {order.reopenedAt && (
            <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${dark ? 'bg-orange-600/30 text-orange-300 border border-orange-500/30' : 'bg-orange-100 text-orange-700'}`} title={order.reopenReason || 'Reopened'}>
              🔓 Reopened
            </span>
          )}
        </div>

        {/* Pre-auth / Tab card info */}
        {order.hasPreAuth && order.preAuth && (
          <div className={`flex items-center gap-2 text-xs font-medium mb-2 ${dark ? 'text-blue-400' : 'text-blue-600'}`}>
            <svg className="w-3 h-3 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" />
            </svg>
            <span>{formatCardDisplay(order.preAuth.cardBrand, order.preAuth.last4)}</span>
            {order.preAuth.amount != null && (
              <span className={dark ? 'text-slate-400' : 'text-gray-500'}>
                {formatCurrency(order.preAuth.amount)} hold
              </span>
            )}
          </div>
        )}
        {order.tabStatus === 'pending_auth' && (
          <div className={`flex items-center gap-1 text-xs font-bold mb-2 animate-pulse ${dark ? 'text-amber-400' : 'text-amber-600'}`}>
            <span>Authorizing card...</span>
          </div>
        )}

        {/* Items preview */}
        <div className={`text-xs mb-2 space-y-0.5 ${dark ? 'text-slate-400' : 'text-gray-600'}`}>
          {order.items.slice(0, 3).map((item, idx) => (
            <div key={idx} className="truncate">
              <span className="font-medium">{item.quantity}x</span> {item.name}
            </div>
          ))}
          {order.items.length > 3 && (
            <div className={dark ? 'text-slate-500' : 'text-gray-400'}>+{order.items.length - 3} more items</div>
          )}
        </div>

        {/* Footer */}
        <div className={`flex items-center justify-between text-sm pt-2 border-t ${dark ? 'border-white/10 text-slate-400' : 'border-gray-100 text-gray-500'}`}>
          <span className="font-medium">{order.itemCount} item{order.itemCount !== 1 ? 's' : ''}</span>
          {order.paidAmount > 0 && (
            <span className={`font-medium ${dark ? 'text-green-400' : 'text-green-600'}`}>
              Paid: {formatCurrency(order.paidAmount)}
            </span>
          )}
        </div>

        {/* Action buttons */}
        {viewMode === 'open' && !isPaidOrClosed && (
          <div className="mt-2 flex gap-2">
            <button
              onClick={(e) => { e.stopPropagation(); onSelectOrder(order) }}
              className="flex-1 flex items-center justify-center gap-1 px-3 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-bold text-white transition-colors"
            >
              Open
            </button>
          </div>
        )}
        {viewMode === 'open' && isPaidOrClosed && (
          <button
            onClick={(e) => { e.stopPropagation(); setClosedOrderModalOrder(order) }}
            className={`mt-2 w-full text-center py-2 rounded-lg text-sm font-bold transition-colors ${dark ? 'bg-green-600/20 text-green-400 hover:bg-green-600/30' : 'bg-green-100 text-green-700 hover:bg-green-200'}`}
          >
            Manage
          </button>
        )}

        {/* Closed order actions */}
        {viewMode === 'closed' && (
          <div className="mt-2 flex gap-2">
            <button
              onClick={(e) => { e.stopPropagation(); setClosedOrderModalOrder(order) }}
              className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm font-bold transition-colors ${
                dark ? 'bg-indigo-600/30 hover:bg-indigo-600/40 text-indigo-300' : 'bg-indigo-100 hover:bg-indigo-200 text-indigo-700'
              }`}
            >
              Manage
            </button>
            {onViewReceipt && (
              <button
                onClick={(e) => { e.stopPropagation(); onViewReceipt(order.id) }}
                className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                  dark ? 'bg-white/10 hover:bg-white/15 text-slate-300' : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                Receipt
              </button>
            )}
          </div>
        )}
      </div>
    )
  }

  // ── Main render ──

  const toolbarContent = (
    <>
      {/* Header */}
      <div className={`p-3 flex items-center justify-between ${dark ? 'border-b border-white/10' : 'border-b'}`}>
        <div className="flex items-center gap-2">
          <h3 className={`font-bold ${dark ? 'text-white text-lg' : 'font-semibold'}`}>
            {viewMode === 'open' ? 'Open Orders' : 'Closed Orders'}
          </h3>
          {renderSearchIcon()}
        </div>
        <div className="flex items-center gap-2">
          {viewMode === 'open' && onNewTab && (
            <Button
              variant={dark ? 'glass' : 'primary'}
              size="sm"
              onClick={onNewTab}
            >
              + New Tab
            </Button>
          )}
          {onToggleExpand && (
            <button
              onClick={onToggleExpand}
              className={`p-2 rounded-lg transition-colors ${
                dark ? 'hover:bg-white/10 text-slate-400 hover:text-white' : 'hover:bg-gray-100 text-gray-500'
              }`}
              title={isExpanded ? 'Collapse' : 'Expand'}
            >
              {isExpanded ? (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              ) : (
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                </svg>
              )}
            </button>
          )}
        </div>
      </div>

      {/* Controls row */}
      <div className={`p-2 flex gap-1 flex-wrap items-center ${dark ? 'border-b border-white/10' : 'border-b'}`}>
        {/* Open/Closed toggle */}
        <button
          onClick={() => setViewMode('open')}
          className={`px-3 py-1.5 rounded-lg text-sm font-semibold transition-all ${
            viewMode === 'open'
              ? (dark ? 'bg-indigo-600/40 text-white border border-indigo-500/50' : 'bg-blue-600 text-white')
              : (dark ? 'bg-white/5 text-slate-400 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200')
          }`}
        >
          Open ({orders.length})
        </button>
        <button
          onClick={() => setViewMode('closed')}
          className={`px-3 py-1.5 rounded-lg text-sm font-semibold transition-all ${
            viewMode === 'closed'
              ? (dark ? 'bg-indigo-600/40 text-white border border-indigo-500/50' : 'bg-blue-600 text-white')
              : (dark ? 'bg-white/5 text-slate-400 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200')
          }`}
        >
          Closed
        </button>

        <div className={`w-px h-6 mx-1 ${dark ? 'bg-white/10' : 'bg-gray-200'}`} />

        {/* Mine/All */}
        <button
          onClick={() => setFilter('all')}
          className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-all ${
            filter === 'all'
              ? (dark ? 'bg-white/15 text-white' : 'bg-gray-800 text-white')
              : (dark ? 'bg-white/5 text-slate-400 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200')
          }`}
        >
          All
        </button>
        <button
          onClick={() => setFilter('mine')}
          className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-all ${
            filter === 'mine'
              ? (dark ? 'bg-white/15 text-white' : 'bg-gray-800 text-white')
              : (dark ? 'bg-white/5 text-slate-400 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200')
          }`}
        >
          Mine
        </button>

        <div className="flex-1" />

        {/* View style toggle */}
        {isExpanded && (
          <div className="flex gap-1">
            <button
              onClick={() => setViewStyle('card')}
              className={`p-1.5 rounded transition-colors ${viewStyle === 'card' ? (dark ? 'bg-white/15 text-white' : 'bg-gray-800 text-white') : (dark ? 'text-slate-400 hover:bg-white/10' : 'text-gray-400 hover:bg-gray-100')}`}
              title="Card view"
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>
            </button>
            <button
              onClick={() => setViewStyle('condensed')}
              className={`p-1.5 rounded transition-colors ${viewStyle === 'condensed' ? (dark ? 'bg-white/15 text-white' : 'bg-gray-800 text-white') : (dark ? 'text-slate-400 hover:bg-white/10' : 'text-gray-400 hover:bg-gray-100')}`}
              title="List view"
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clipRule="evenodd" /></svg>
            </button>
          </div>
        )}

        {/* Sort dropdown */}
        <div className="relative">
          <button
            onClick={() => setShowSortMenu(!showSortMenu)}
            className={`px-3 py-1.5 rounded-lg text-sm font-medium flex items-center gap-1 transition-colors ${
              dark ? 'bg-white/5 text-slate-300 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
            }`}
          >
            Sort: {SORT_OPTIONS.find(s => s.value === sortBy)?.label}
            <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
          </button>
          {showSortMenu && (
            <div className={`absolute right-0 top-full mt-1 rounded-lg shadow-xl z-50 py-1 min-w-[140px] ${
              dark ? 'bg-slate-800 border border-white/10' : 'bg-white border border-gray-200'
            }`}>
              {SORT_OPTIONS.map(opt => (
                <button
                  key={opt.value}
                  onClick={() => { setSortBy(opt.value); setShowSortMenu(false) }}
                  className={`w-full text-left px-3 py-2 text-sm transition-colors ${
                    sortBy === opt.value
                      ? (dark ? 'bg-indigo-600/30 text-white' : 'bg-blue-50 text-blue-700')
                      : (dark ? 'text-slate-300 hover:bg-white/10' : 'text-gray-700 hover:bg-gray-50')
                  }`}
                >
                  {opt.label}
                </button>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Date preset pills (closed view only) */}
      {viewMode === 'closed' && isExpanded && (
        <div className={`p-2 flex gap-1 ${dark ? 'border-b border-white/10' : 'border-b'}`}>
          {(['today', 'yesterday', 'this_week'] as DatePreset[]).map(preset => (
            <button
              key={preset}
              onClick={() => setDatePreset(preset)}
              className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-all ${
                datePreset === preset
                  ? (dark ? 'bg-indigo-600/40 text-white border border-indigo-500/50' : 'bg-blue-600 text-white')
                  : (dark ? 'bg-white/5 text-slate-400 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200')
              }`}
            >
              {preset === 'today' ? 'Today' : preset === 'yesterday' ? 'Yesterday' : 'This Week'}
            </button>
          ))}
        </div>
      )}

      {/* Type filter pills */}
      {Object.keys(typeCounts).length > 1 && (
        <div className={`p-2 flex gap-1 flex-wrap ${dark ? 'border-b border-white/10' : 'border-b'}`}>
          <button
            className={`px-2 py-1 rounded-full text-xs font-medium transition-colors ${
              typeFilter === null
                ? (dark ? 'bg-white/15 text-white' : 'bg-gray-800 text-white')
                : (dark ? 'bg-white/5 text-slate-400 hover:bg-white/10' : 'bg-gray-100 text-gray-600 hover:bg-gray-200')
            }`}
            onClick={() => setTypeFilter(null)}
          >
            All
          </button>
          {Object.entries(ORDER_TYPE_CONFIG).map(([type, config]) => (
            typeCounts[type] ? (
              <button
                key={type}
                className={`px-2 py-1 rounded-full text-xs font-medium transition-colors border ${
                  typeFilter === type
                    ? (dark ? 'bg-white/15 text-white border-white/20' : 'bg-gray-800 text-white border-transparent')
                    : (dark ? `${config.darkColor}` : `${config.color} border-transparent hover:opacity-80`)
                }`}
                onClick={() => setTypeFilter(typeFilter === type ? null : type)}
              >
                {config.icon} {typeCounts[type]}
              </button>
            ) : null
          ))}
        </div>
      )}
    </>
  )

  const ordersList = (
    <div className={`flex-1 overflow-y-auto p-2 ${isExpanded ? 'grid grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 auto-rows-min items-start' : 'space-y-2'}`}>
      {isLoading && filteredOrders.length === 0 ? (
        <div className={`text-center py-8 ${isExpanded ? 'col-span-full' : ''} ${dark ? 'text-slate-400' : 'text-gray-500'}`}>
          Loading orders...
        </div>
      ) : filteredOrders.length === 0 ? (
        <div className={`text-center py-8 ${isExpanded ? 'col-span-full' : ''} ${dark ? 'text-slate-400' : 'text-gray-500'}`}>
          <p>No {viewMode} orders</p>
          <p className="text-sm mt-1">
            {viewMode === 'open'
              ? 'Orders will appear here after sending to kitchen'
              : 'Paid and closed orders will appear here'
            }
          </p>
        </div>
      ) : (
        <>
          {filteredOrders.map(order => renderOrderCard(order))}
          {viewMode === 'closed' && hasMoreClosed && (
            <div className={`${isExpanded ? 'col-span-full' : ''} text-center py-3`}>
              <button
                onClick={() => loadClosedOrders(closedCursor)}
                className={`px-6 py-2 rounded-lg text-sm font-semibold transition-colors ${
                  dark ? 'bg-white/10 hover:bg-white/15 text-white' : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                Load More
              </button>
            </div>
          )}
        </>
      )}
    </div>
  )

  // Expanded: full-screen overlay
  if (isExpanded) {
    return (
      <>
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex flex-col"
          style={{ background: 'rgba(15, 15, 30, 0.98)', backdropFilter: 'blur(24px)' }}
        >
          {toolbarContent}
          {ordersList}
        </motion.div>
        {closedOrderModalOrder && employeeId && (
          <ClosedOrderActionsModal
            isOpen={true}
            onClose={() => setClosedOrderModalOrder(null)}
            order={closedOrderModalOrder}
            employeeId={employeeId}
            employeePermissions={employeePermissions}
            onActionComplete={() => {
              setClosedOrderModalOrder(null)
              if (onClosedOrderAction) onClosedOrderAction()
              loadOrders()
              loadClosedOrders(null)
            }}
            onOpenTipAdjustment={onOpenTipAdjustment}
          />
        )}
      </>
    )
  }

  const closedOrderModal = closedOrderModalOrder && employeeId && (
    <ClosedOrderActionsModal
      isOpen={true}
      onClose={() => setClosedOrderModalOrder(null)}
      order={closedOrderModalOrder}
      employeeId={employeeId}
      employeePermissions={employeePermissions}
      onActionComplete={() => {
        setClosedOrderModalOrder(null)
        // Refresh both open and closed orders
        if (onClosedOrderAction) onClosedOrderAction()
        loadOrders()
        loadClosedOrders(null)
      }}
      onOpenTipAdjustment={onOpenTipAdjustment}
    />
  )

  // Collapsed: sidebar
  return (
    <>
      <div className="h-full flex flex-col">
        {toolbarContent}
        {ordersList}
      </div>
      {closedOrderModal}
    </>
  )
}

export type { OpenOrder }
