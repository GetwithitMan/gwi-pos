================================================================================
FLOOR PLAN DOMAIN - COMPLETE CODE EXPORT
Generated: Sat Feb  7 04:52:56 MST 2026
================================================================================

TABLE OF CONTENTS
================================================================================

SECTION 1: DOMAIN FILES (src/domains/floor-plan)
SECTION 2: COMPONENT FILES (src/components/floor-plan)
SECTION 3: API ROUTES - Tables
SECTION 4: API ROUTES - Seats
SECTION 5: API ROUTES - Floor Plan
SECTION 6: LIBRARY FILES
SECTION 7: DOCUMENTATION

================================================================================

================================================================================
SECTION 1: DOMAIN FILES (src/domains/floor-plan)
================================================================================

################################################################################
# FILE: src/domains/floor-plan/admin/EditorCanvas.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Editor Canvas Component
 *
 * Canvas with drawing and editing interactions for floor plan fixtures.
 */

import React, { useRef, useState, useCallback, useEffect } from 'react';
import { FloorCanvasAPI } from '../canvas';
import type { Fixture, Point, FixtureGeometry } from '../shared/types';
import type { EditorToolMode, FixtureType, EditorTable, TableShape, EditorSeat } from './types';
import { getFixtureTypeMetadata, getTableShapeMetadata } from './types';
import { TableRenderer, type ResizeHandle } from './TableRenderer';
import { SeatRenderer } from './SeatRenderer';
import { EntertainmentVisual, type EntertainmentVisualType } from '@/components/floor-plan/entertainment-visuals';
import {
  SEAT_RADIUS,
  SEAT_HIT_RADIUS,
  SEAT_COLLISION_RADIUS,
  SEAT_BOUNDARY_DISTANCE,
  SEAT_MIN_DISTANCE,
  // Canvas constants
  CANVAS_WIDTH,
  CANVAS_HEIGHT,
  ZOOM_MIN,
  ZOOM_MAX,
  ZOOM_DEFAULT,
  ZOOM_STEP,
  GRID_SIZE,
} from '@/lib/floorplan/constants';

// =============================================================================
// TYPES
// =============================================================================

// Virtual floor plan for database mode (created from Section data)
interface VirtualFloorPlan {
  id: string;
  name: string;
  widthFeet: number;
  heightFeet: number;
  gridSizeFeet: number;
}

// Available space around a table (in pixels)
interface AvailableSpace {
  top: number;    // pixels to nearest obstacle above
  bottom: number; // pixels to nearest obstacle below
  left: number;   // pixels to nearest obstacle left
  right: number;  // pixels to nearest obstacle right
}

interface EditorCanvasProps {
  roomId: string;
  toolMode: EditorToolMode;
  fixtureType: FixtureType;
  tableShape?: TableShape;
  selectedFixtureId: string | null;
  selectedTableId: string | null;
  refreshKey: number;
  onFixtureSelect: (fixtureId: string | null) => void;
  onFixtureUpdate: (fixtureId: string, updates: Partial<Fixture>) => void;
  onFixtureCreate: (fixture: Omit<Fixture, 'id'>) => void;
  onFixtureDelete: (fixtureId: string) => void;
  // Table handling
  onTableSelect?: (tableId: string | null) => void;
  onTableCreate?: (table: Omit<EditorTable, 'id'>) => void;
  onTableUpdate?: (tableId: string, updates: Partial<EditorTable>) => void;
  onTableDelete?: (tableId: string) => void;
  // Seat handling
  dbSeats?: EditorSeat[];
  onSeatSelect?: (seatId: string | null) => void;
  onSeatUpdate?: (seatId: string, updates: { relativeX?: number; relativeY?: number }) => void;
  onSeatsReflow?: (tableId: string, dimensions: {
    oldWidth: number;
    oldHeight: number;
    newWidth: number;
    newHeight: number;
  }) => void;
  // Database mode props
  useDatabase?: boolean;
  dbFixtures?: Fixture[];
  dbTables?: EditorTable[];
  dbFloorPlan?: VirtualFloorPlan; // Section data for database mode
  // Zoom control callbacks (optional - parent can use these)
  onZoomChange?: (zoom: number) => void;
  zoomControlRef?: React.MutableRefObject<{
    fitToScreen: () => void;
    resetZoom: () => void;
    setZoom: (z: number) => void;
    zoom: number;
  } | null>;
}

// =============================================================================
// COMPONENT
// =============================================================================

export function EditorCanvas({
  roomId,
  toolMode,
  fixtureType,
  tableShape = 'rectangle',
  selectedFixtureId,
  selectedTableId,
  refreshKey,
  onFixtureSelect,
  onFixtureUpdate,
  onFixtureCreate,
  onFixtureDelete,
  onTableSelect,
  onTableCreate,
  onTableUpdate,
  onTableDelete,
  dbSeats,
  onSeatSelect,
  onSeatUpdate,
  onSeatsReflow,
  useDatabase = false,
  dbFixtures,
  dbTables,
  dbFloorPlan,
  onZoomChange,
  zoomControlRef,
}: EditorCanvasProps) {
  const canvasRef = useRef<HTMLDivElement>(null);
  // In database mode, use the dbFloorPlan prop; otherwise use in-memory API
  const [floorPlan, setFloorPlan] = useState(
    useDatabase && dbFloorPlan ? dbFloorPlan : FloorCanvasAPI.getFloorPlan(roomId)
  );
  const [fixtures, setFixtures] = useState<Fixture[]>([]);
  const [tables, setTables] = useState<EditorTable[]>([]);
  const [seats, setSeats] = useState<EditorSeat[]>([]);

  // Drawing state
  const [startPoint, setStartPoint] = useState<Point | null>(null);
  const [currentPoint, setCurrentPoint] = useState<Point | null>(null);
  const [isDrawing, setIsDrawing] = useState(false);

  // Dragging state (for fixtures)
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState<Point | null>(null);

  // Resizing state (for fixtures)
  const [isResizingFixture, setIsResizingFixture] = useState(false);
  const [fixtureResizeHandle, setFixtureResizeHandle] = useState<string | null>(null);
  const [fixtureResizeStartDimensions, setFixtureResizeStartDimensions] = useState<{width?: number, height?: number, length?: number, thickness?: number} | null>(null);
  const [fixtureResizeStartPos, setFixtureResizeStartPos] = useState<{x: number, y: number} | null>(null);
  const [fixtureResizeStartMousePos, setFixtureResizeStartMousePos] = useState<Point | null>(null);

  // Dragging state (for tables)
  const [isDraggingTable, setIsDraggingTable] = useState(false);
  const [tableDragOffset, setTableDragOffset] = useState<Point | null>(null);

  // Resizing state (for tables)
  const [isResizingTable, setIsResizingTable] = useState(false);
  const [resizeHandle, setResizeHandle] = useState<string | null>(null);
  const [resizeStartDimensions, setResizeStartDimensions] = useState<{width: number, height: number} | null>(null);
  const [resizeStartPos, setResizeStartPos] = useState<{x: number, y: number} | null>(null);
  const [resizeStartMousePos, setResizeStartMousePos] = useState<Point | null>(null);

  // Rotation state (for tables)
  const [isRotatingTable, setIsRotatingTable] = useState(false);
  const [rotationStartAngle, setRotationStartAngle] = useState(0);
  const [rotationStartMouseAngle, setRotationStartMouseAngle] = useState(0);

  // Dragging state (for seats)
  const [isDraggingSeat, setIsDraggingSeat] = useState(false);
  const [draggedSeatId, setDraggedSeatId] = useState<string | null>(null);
  const [seatDragOffset, setSeatDragOffset] = useState<Point | null>(null);
  const [originalSeatPos, setOriginalSeatPos] = useState<Point | null>(null);
  const [seatDragPreview, setSeatDragPreview] = useState<{ id: string; relativeX: number; relativeY: number } | null>(null);

  // Auto-offset for new fixtures to prevent stacking
  const [placementOffset, setPlacementOffset] = useState(0);

  // Debug mode for boundary visualization (toggle with keyboard)
  const [showBoundaryDebug, setShowBoundaryDebug] = useState(false);

  // Zoom and pan state
  const [zoom, setZoom] = useState(ZOOM_DEFAULT);
  const [panOffset, setPanOffset] = useState<Point>({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [lastPanPoint, setLastPanPoint] = useState<Point | null>(null);

  // Constants imported from @/lib/floorplan/constants

  // Check if a table would collide with any fixture
  const checkTableFixtureCollision = useCallback((
    tablePosX: number,  // in pixels
    tablePosY: number,  // in pixels
    tableWidth: number, // in pixels
    tableHeight: number // in pixels
  ): boolean => {
    const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;

    for (const fixture of fixtureList) {
      if (fixture.geometry.type === 'rectangle') {
        // Convert fixture position from feet to pixels
        const fx = FloorCanvasAPI.feetToPixels(fixture.geometry.position.x);
        const fy = FloorCanvasAPI.feetToPixels(fixture.geometry.position.y);
        const fw = FloorCanvasAPI.feetToPixels(fixture.geometry.width);
        const fh = FloorCanvasAPI.feetToPixels(fixture.geometry.height);

        // AABB collision check
        if (tablePosX < fx + fw &&
            tablePosX + tableWidth > fx &&
            tablePosY < fy + fh &&
            tablePosY + tableHeight > fy) {
          return true;
        }
      } else if (fixture.geometry.type === 'circle') {
        // Convert circle center and radius from feet to pixels
        const cx = FloorCanvasAPI.feetToPixels(fixture.geometry.center.x);
        const cy = FloorCanvasAPI.feetToPixels(fixture.geometry.center.y);
        const cr = FloorCanvasAPI.feetToPixels(fixture.geometry.radius);

        // Simple bounding box check for circle
        if (tablePosX < cx + cr &&
            tablePosX + tableWidth > cx - cr &&
            tablePosY < cy + cr &&
            tablePosY + tableHeight > cy - cr) {
          return true;
        }
      }
    }
    return false;
  }, [useDatabase, dbFixtures, fixtures]);

  // Check if a table would collide with any other table
  const checkTableCollision = useCallback((
    tablePosX: number,   // in pixels
    tablePosY: number,   // in pixels
    tableWidth: number,  // in pixels
    tableHeight: number, // in pixels
    excludeTableId?: string  // Table being moved (exclude from collision check)
  ): boolean => {
    const tableList = useDatabase ? (dbTables || []) : tables;

    for (const table of tableList) {
      // Skip the table being moved
      if (excludeTableId && table.id === excludeTableId) {
        continue;
      }

      // AABB collision check
      if (tablePosX < table.posX + table.width &&
          tablePosX + tableWidth > table.posX &&
          tablePosY < table.posY + table.height &&
          tablePosY + tableHeight > table.posY) {
        return true; // Collision detected
      }
    }
    return false;
  }, [useDatabase, dbTables, tables]);

  // Check if a seat position collides with other seats
  const checkSeatCollision = useCallback((
    posX: number,
    posY: number,
    tableId: string,
    excludeSeatId?: string
  ): boolean => {
    const tableSeats = seats.filter(s => s.tableId === tableId && s.id !== excludeSeatId);
    const table = tables.find(t => t.id === tableId);
    if (!table) return false;

    const tableCenterX = table.posX + table.width / 2;
    const tableCenterY = table.posY + table.height / 2;

    for (const seat of tableSeats) {
      // Calculate absolute position of existing seat
      const seatAbsX = tableCenterX + seat.relativeX;
      const seatAbsY = tableCenterY + seat.relativeY;

      // Check distance between seat centers
      const distance = Math.hypot(posX - seatAbsX, posY - seatAbsY);

      // Collision if distance < 2 * SEAT_COLLISION_RADIUS (seats touching)
      if (distance < SEAT_COLLISION_RADIUS * 2 + 4) { // Using smaller collision radius
        return true;
      }
    }
    return false;
  }, [seats, tables, SEAT_COLLISION_RADIUS]);

  // Check if any seat of a table would collide with obstacles at a given table position
  const checkSeatsObstacleCollision = useCallback((
    tableId: string,
    newTablePosX: number,
    newTablePosY: number,
    tableWidth: number,
    tableHeight: number,
    tableRotation: number = 0
  ): boolean => {
    // Get seats for this table
    const tableSeats = seats.filter(s => s.tableId === tableId);
    if (tableSeats.length === 0) return false;

    const tableCenterX = newTablePosX + tableWidth / 2;
    const tableCenterY = newTablePosY + tableHeight / 2;
    const rotation = tableRotation * Math.PI / 180;
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);

    // Check each seat against all obstacles
    for (const seat of tableSeats) {
      // Calculate absolute seat position at the new table location
      const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
      const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
      const seatAbsX = tableCenterX + rotatedX;
      const seatAbsY = tableCenterY + rotatedY;

      // Check against other tables (exclude current table)
      const tableList = useDatabase ? (dbTables || []) : tables;
      for (const otherTable of tableList) {
        if (otherTable.id === tableId) continue;

        // Simple AABB check with seat radius
        if (seatAbsX + SEAT_RADIUS > otherTable.posX &&
            seatAbsX - SEAT_RADIUS < otherTable.posX + otherTable.width &&
            seatAbsY + SEAT_RADIUS > otherTable.posY &&
            seatAbsY - SEAT_RADIUS < otherTable.posY + otherTable.height) {
          return true; // Collision with another table
        }

        // Check against seats of other tables
        const otherTableSeats = seats.filter(s => s.tableId === otherTable.id);
        const otherTableCenterX = otherTable.posX + otherTable.width / 2;
        const otherTableCenterY = otherTable.posY + otherTable.height / 2;
        const otherRotation = (otherTable.rotation || 0) * Math.PI / 180;
        const otherCos = Math.cos(otherRotation);
        const otherSin = Math.sin(otherRotation);

        for (const otherSeat of otherTableSeats) {
          const otherRotatedX = otherSeat.relativeX * otherCos - otherSeat.relativeY * otherSin;
          const otherRotatedY = otherSeat.relativeX * otherSin + otherSeat.relativeY * otherCos;
          const otherSeatAbsX = otherTableCenterX + otherRotatedX;
          const otherSeatAbsY = otherTableCenterY + otherRotatedY;

          const distance = Math.hypot(seatAbsX - otherSeatAbsX, seatAbsY - otherSeatAbsY);
          if (distance < SEAT_COLLISION_RADIUS * 2 + 4) {
            return true; // Collision with seat from another table
          }
        }
      }

      // Check against fixtures
      const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;
      for (const fixture of fixtureList) {
        if (fixture.geometry.type === 'rectangle') {
          const fx = FloorCanvasAPI.feetToPixels(fixture.geometry.position.x);
          const fy = FloorCanvasAPI.feetToPixels(fixture.geometry.position.y);
          const fw = FloorCanvasAPI.feetToPixels(fixture.geometry.width);
          const fh = FloorCanvasAPI.feetToPixels(fixture.geometry.height);

          if (seatAbsX + SEAT_RADIUS > fx &&
              seatAbsX - SEAT_RADIUS < fx + fw &&
              seatAbsY + SEAT_RADIUS > fy &&
              seatAbsY - SEAT_RADIUS < fy + fh) {
            return true; // Collision with fixture
          }
        } else if (fixture.geometry.type === 'circle') {
          const cx = FloorCanvasAPI.feetToPixels(fixture.geometry.center.x);
          const cy = FloorCanvasAPI.feetToPixels(fixture.geometry.center.y);
          const cr = FloorCanvasAPI.feetToPixels(fixture.geometry.radius);

          const dist = Math.hypot(seatAbsX - cx, seatAbsY - cy);
          if (dist < cr + SEAT_RADIUS) {
            return true; // Collision with circular fixture
          }
        }
        // Lines (walls) - simplified bounding box check
        else if (fixture.geometry.type === 'line') {
          const { start, end } = fixture.geometry;
          const thickness = fixture.thickness || 0.5;
          const x1 = FloorCanvasAPI.feetToPixels(Math.min(start.x, end.x) - thickness);
          const x2 = FloorCanvasAPI.feetToPixels(Math.max(start.x, end.x) + thickness);
          const y1 = FloorCanvasAPI.feetToPixels(Math.min(start.y, end.y) - thickness);
          const y2 = FloorCanvasAPI.feetToPixels(Math.max(start.y, end.y) + thickness);

          if (seatAbsX + SEAT_RADIUS > x1 &&
              seatAbsX - SEAT_RADIUS < x2 &&
              seatAbsY + SEAT_RADIUS > y1 &&
              seatAbsY - SEAT_RADIUS < y2) {
            return true; // Collision with wall
          }
        }
      }
    }

    return false; // No collisions
  }, [seats, tables, fixtures, useDatabase, dbTables, dbFixtures, SEAT_RADIUS]);

  // Calculate available space around a table (in pixels)
  const calculateAvailableSpace = useCallback((
    tableId: string,
    tablePosX: number,
    tablePosY: number,
    tableWidth: number,
    tableHeight: number,
    tableRotation: number = 0
  ): AvailableSpace => {
    // Default to maximum boundary if no obstacles nearby
    const defaultSpace = SEAT_BOUNDARY_DISTANCE + SEAT_RADIUS;
    let topSpace = defaultSpace;
    let bottomSpace = defaultSpace;
    let leftSpace = defaultSpace;
    let rightSpace = defaultSpace;

    const tableList = useDatabase ? (dbTables || []) : tables;
    const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;

    // For simplicity, assume rectangular bounding box (ignore rotation for obstacle distance)
    const tableTop = tablePosY;
    const tableBottom = tablePosY + tableHeight;
    const tableLeft = tablePosX;
    const tableRight = tablePosX + tableWidth;

    // Check distance to other tables
    for (const otherTable of tableList) {
      if (otherTable.id === tableId) continue;

      const otherTop = otherTable.posY;
      const otherBottom = otherTable.posY + otherTable.height;
      const otherLeft = otherTable.posX;
      const otherRight = otherTable.posX + otherTable.width;

      // Check if tables are aligned horizontally (check top/bottom space)
      if (!(tableRight < otherLeft || tableLeft > otherRight)) {
        // Tables overlap horizontally, check vertical distance
        if (otherBottom <= tableTop) {
          // Other table is above
          const distance = tableTop - otherBottom;
          topSpace = Math.min(topSpace, distance);
        } else if (otherTop >= tableBottom) {
          // Other table is below
          const distance = otherTop - tableBottom;
          bottomSpace = Math.min(bottomSpace, distance);
        }
      }

      // Check if tables are aligned vertically (check left/right space)
      if (!(tableBottom < otherTop || tableTop > otherBottom)) {
        // Tables overlap vertically, check horizontal distance
        if (otherRight <= tableLeft) {
          // Other table is to the left
          const distance = tableLeft - otherRight;
          leftSpace = Math.min(leftSpace, distance);
        } else if (otherLeft >= tableRight) {
          // Other table is to the right
          const distance = otherLeft - tableRight;
          rightSpace = Math.min(rightSpace, distance);
        }
      }
    }

    // Check distance to fixtures
    for (const fixture of fixtureList) {
      if (fixture.geometry.type === 'rectangle') {
        const fx = FloorCanvasAPI.feetToPixels(fixture.geometry.position.x);
        const fy = FloorCanvasAPI.feetToPixels(fixture.geometry.position.y);
        const fw = FloorCanvasAPI.feetToPixels(fixture.geometry.width);
        const fh = FloorCanvasAPI.feetToPixels(fixture.geometry.height);

        const fixtureTop = fy;
        const fixtureBottom = fy + fh;
        const fixtureLeft = fx;
        const fixtureRight = fx + fw;

        // Check horizontal alignment
        if (!(tableRight < fixtureLeft || tableLeft > fixtureRight)) {
          if (fixtureBottom <= tableTop) {
            const distance = tableTop - fixtureBottom;
            topSpace = Math.min(topSpace, distance);
          } else if (fixtureTop >= tableBottom) {
            const distance = fixtureTop - tableBottom;
            bottomSpace = Math.min(bottomSpace, distance);
          }
        }

        // Check vertical alignment
        if (!(tableBottom < fixtureTop || tableTop > fixtureBottom)) {
          if (fixtureRight <= tableLeft) {
            const distance = tableLeft - fixtureRight;
            leftSpace = Math.min(leftSpace, distance);
          } else if (fixtureLeft >= tableRight) {
            const distance = fixtureLeft - tableRight;
            rightSpace = Math.min(rightSpace, distance);
          }
        }
      }
      // Simplified: treat circles and lines as not affecting space for now
      // (more complex geometry would require more sophisticated calculations)
    }

    return {
      top: Math.max(0, topSpace),
      bottom: Math.max(0, bottomSpace),
      left: Math.max(0, leftSpace),
      right: Math.max(0, rightSpace),
    };
  }, [tables, fixtures, useDatabase, dbTables, dbFixtures, SEAT_BOUNDARY_DISTANCE, SEAT_RADIUS]);

  // Compress seats to fit within available space
  const compressSeatsToFit = useCallback((
    tableId: string,
    tableSeats: EditorSeat[],
    table: EditorTable,
    availableSpace: AvailableSpace
  ): EditorSeat[] => {
    if (tableSeats.length === 0) return tableSeats;

    const halfWidth = table.width / 2;
    const halfHeight = table.height / 2;

    return tableSeats.map((seat) => {
      const absX = Math.abs(seat.relativeX);
      const absY = Math.abs(seat.relativeY);

      // Determine which side the seat is on
      const normalizedX = absX / halfWidth;
      const normalizedY = absY / halfHeight;

      let newRelativeX = seat.relativeX;
      let newRelativeY = seat.relativeY;

      // Calculate dynamic offset for each side based on available space
      const baseOffset = 25; // Default offset from table edge

      if (normalizedY >= normalizedX) {
        // Seat is on top or bottom edge
        const direction = seat.relativeY >= 0 ? 1 : -1;
        const availableOnSide = direction > 0 ? availableSpace.bottom : availableSpace.top;

        // Calculate dynamic offset (compressed if space is tight)
        const dynamicOffset = Math.max(
          SEAT_MIN_DISTANCE,
          Math.min(baseOffset, availableOnSide - SEAT_RADIUS)
        );

        // Apply dynamic offset
        newRelativeY = direction * (halfHeight + dynamicOffset);
      } else {
        // Seat is on left or right edge
        const direction = seat.relativeX >= 0 ? 1 : -1;
        const availableOnSide = direction > 0 ? availableSpace.right : availableSpace.left;

        // Calculate dynamic offset (compressed if space is tight)
        const dynamicOffset = Math.max(
          SEAT_MIN_DISTANCE,
          Math.min(baseOffset, availableOnSide - SEAT_RADIUS)
        );

        // Apply dynamic offset
        newRelativeX = direction * (halfWidth + dynamicOffset);
      }

      return {
        ...seat,
        relativeX: Math.round(newRelativeX),
        relativeY: Math.round(newRelativeY),
      };
    });
  }, [SEAT_MIN_DISTANCE, SEAT_RADIUS]);

  // Check if position is valid for a seat (boundary + not inside table)
  const isValidSeatPosition = useCallback((
    absoluteX: number,
    absoluteY: number,
    table: EditorTable,
    excludeSeatId?: string
  ): boolean => {
    const tableCenterX = table.posX + table.width / 2;
    const tableCenterY = table.posY + table.height / 2;

    // If table is rotated, transform the check point to table-local coordinates
    const rotation = (table.rotation || 0) * Math.PI / 180;
    const cos = Math.cos(-rotation);
    const sin = Math.sin(-rotation);

    // Translate to table center, rotate, translate back
    const dx = absoluteX - tableCenterX;
    const dy = absoluteY - tableCenterY;
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;

    // Now check against unrotated table bounds
    const halfWidth = table.width / 2;
    const halfHeight = table.height / 2;

    // Outer boundary (can't go beyond this)
    const outerHalfWidth = halfWidth + SEAT_BOUNDARY_DISTANCE;
    const outerHalfHeight = halfHeight + SEAT_BOUNDARY_DISTANCE;

    if (Math.abs(localX) > outerHalfWidth || Math.abs(localY) > outerHalfHeight) {
      return false; // Outside boundary
    }

    // Inner boundary (can't be inside table)
    const innerHalfWidth = halfWidth - SEAT_MIN_DISTANCE;
    const innerHalfHeight = halfHeight - SEAT_MIN_DISTANCE;

    if (Math.abs(localX) < innerHalfWidth && Math.abs(localY) < innerHalfHeight) {
      return false; // Inside table
    }

    // Check seat-to-seat collision
    if (checkSeatCollision(absoluteX, absoluteY, table.id, excludeSeatId)) {
      return false; // Collides with another seat
    }

    return true;
  }, [checkSeatCollision, SEAT_BOUNDARY_DISTANCE, SEAT_MIN_DISTANCE]);

  // Load floor plan and fixtures
  useEffect(() => {
    if (useDatabase && dbFloorPlan) {
      // Database mode: use the dbFloorPlan prop
      setFloorPlan(dbFloorPlan);
    } else if (!useDatabase) {
      // In-memory mode: use FloorCanvasAPI
      const fp = FloorCanvasAPI.getFloorPlan(roomId);
      setFloorPlan(fp);
      if (fp) {
        const fixtureList = FloorCanvasAPI.getFixtures(fp.id);
        setFixtures(fixtureList);
      }
    }
  }, [roomId, useDatabase, dbFloorPlan]);

  // Update fixtures from dbFixtures prop when in database mode
  useEffect(() => {
    if (useDatabase && dbFixtures) {
      setFixtures(dbFixtures);
    }
  }, [useDatabase, dbFixtures, refreshKey]);

  // Update tables from dbTables prop when in database mode
  useEffect(() => {
    if (useDatabase && dbTables) {
      setTables(dbTables);
    }
  }, [useDatabase, dbTables, refreshKey]);

  // Update seats from dbSeats prop when in database mode
  useEffect(() => {
    if (useDatabase && dbSeats) {
      setSeats(dbSeats);

      // Clear any stale seat references that no longer exist in the new seats array
      const seatIds = new Set(dbSeats.map(s => s.id));

      if (draggedSeatId && !seatIds.has(draggedSeatId)) {
        setDraggedSeatId(null);
        setIsDraggingSeat(false);
        setSeatDragOffset(null);
        setOriginalSeatPos(null);
        setSeatDragPreview(null);

        // Notify parent that selected seat should be cleared
        if (onSeatSelect) {
          onSeatSelect(null);
        }
      }
    }
  }, [useDatabase, dbSeats, refreshKey, draggedSeatId, onSeatSelect]);

  // Refresh fixtures when they change (in-memory mode only)
  const refreshFixtures = useCallback(() => {
    if (useDatabase) {
      // In database mode, parent handles refresh
      return;
    }
    if (floorPlan) {
      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
      setFixtures(fixtureList);
    }
  }, [floorPlan, useDatabase]);

  // Immediate refresh on refreshKey change (eliminates lag) - in-memory mode only
  useEffect(() => {
    if (useDatabase) return; // Database mode handled by dbFixtures prop
    if (floorPlan) {
      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
      setFixtures(fixtureList);
    }
  }, [refreshKey, floorPlan, useDatabase]);

  // Refresh fixtures when a selected fixture might have been updated - in-memory mode only
  useEffect(() => {
    if (useDatabase) return; // Database mode handled by dbFixtures prop
    if (selectedFixtureId && floorPlan) {
      // Refresh to pick up property changes from the Properties panel
      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
      setFixtures(fixtureList);
    }
  }, [selectedFixtureId, floorPlan, useDatabase]);

  // Fast polling to catch any external updates - in-memory mode only
  useEffect(() => {
    if (useDatabase) return; // Database mode doesn't need polling
    if (!floorPlan) return;

    const intervalId = setInterval(() => {
      const fixtureList = FloorCanvasAPI.getFixtures(floorPlan.id);
      setFixtures(fixtureList);
    }, 100); // Refresh every 100ms for smoother updates

    return () => clearInterval(intervalId);
  }, [floorPlan, useDatabase]);

  // Reset placement offset when tool mode changes
  useEffect(() => {
    setPlacementOffset(0);
  }, [toolMode]);

  // ESC to cancel seat drag
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isDraggingSeat && originalSeatPos) {
        // Cancel drag, revert to original position
        setSeatDragPreview(null);
        setIsDraggingSeat(false);
        setDraggedSeatId(null);
        setSeatDragOffset(null);
        setOriginalSeatPos(null);
      }
      if (e.key === 'b' && e.ctrlKey) {
        setShowBoundaryDebug(prev => !prev);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isDraggingSeat, originalSeatPos]);

  // Get canvas dimensions - FIXED size for stable coordinates (no drift on zoom/pan/combine)
  const canvasDimensions = {
    widthPx: CANVAS_WIDTH,
    heightPx: CANVAS_HEIGHT,
  };

  // Calculate angle from table center to mouse position
  const calculateAngle = useCallback((tableCenter: Point, mousePos: Point): number => {
    const dx = mousePos.x - tableCenter.x;
    const dy = mousePos.y - tableCenter.y;
    return Math.atan2(dy, dx) * (180 / Math.PI) + 90; // 0 degrees = up
  }, []);

  // Convert screen position to floor position (feet)
  const screenToFloor = useCallback(
    (screenX: number, screenY: number): Point => {
      if (!canvasRef.current) return { x: 0, y: 0 };
      const rect = canvasRef.current.getBoundingClientRect();
      // Account for zoom when converting screen coords to canvas coords
      const x = (screenX - rect.left) / zoom;
      const y = (screenY - rect.top) / zoom;
      const position: Point = {
        x: FloorCanvasAPI.pixelsToFeet(x),
        y: FloorCanvasAPI.pixelsToFeet(y),
      };
      // Snap to grid
      if (floorPlan) {
        return FloorCanvasAPI.snapToGrid(position, floorPlan.gridSizeFeet);
      }
      return position;
    },
    [floorPlan, zoom]
  );

  // Handle resize start for tables
  const handleResizeStart = useCallback(
    (handle: ResizeHandle) => {
      if (!selectedTableId) return;
      const table = tables.find(t => t.id === selectedTableId);
      if (!table) return;

      setIsResizingTable(true);
      setResizeHandle(handle);
      setResizeStartDimensions({ width: table.width, height: table.height });
      setResizeStartPos({ x: table.posX, y: table.posY });
      // Mouse position will be captured in the next mouse move
    },
    [selectedTableId, tables]
  );

  // Handle resize start for fixtures
  const handleFixtureResizeStart = useCallback(
    (e: React.MouseEvent, fixtureId: string, handle: string) => {
      e.stopPropagation();
      if (!fixtureId) return;
      const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;
      const fixture = fixtureList.find(f => f.id === fixtureId);
      if (!fixture) return;

      setIsResizingFixture(true);
      setFixtureResizeHandle(handle);

      if (fixture.geometry.type === 'rectangle') {
        setFixtureResizeStartDimensions({
          width: fixture.geometry.width,
          height: fixture.geometry.height
        });
        setFixtureResizeStartPos({
          x: fixture.geometry.position.x,
          y: fixture.geometry.position.y
        });
      } else if (fixture.geometry.type === 'line') {
        const { start, end } = fixture.geometry;
        setFixtureResizeStartDimensions({});
        if (handle === 'start') {
          setFixtureResizeStartPos({ x: start.x, y: start.y });
        } else {
          setFixtureResizeStartPos({ x: end.x, y: end.y });
        }
      }
    },
    [fixtures, dbFixtures, useDatabase]
  );

  // Handle mouse down
  const handleMouseDown = useCallback(
    (event: React.MouseEvent) => {
      if (!floorPlan) return;

      const point = screenToFloor(event.clientX, event.clientY);

      // SELECT mode: Check if clicking on a seat to drag
      if (toolMode === 'SELECT') {
        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        // Check if clicking on any seat
        for (const seat of seats) {
          const table = tables.find(t => t.id === seat.tableId);
          if (!table) continue;

          const tableCenterX = table.posX + table.width / 2;
          const tableCenterY = table.posY + table.height / 2;

          // Calculate absolute seat position
          const rotation = (table.rotation || 0) * Math.PI / 180;
          const cos = Math.cos(rotation);
          const sin = Math.sin(rotation);
          const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
          const rotatedY = seat.relativeX * sin + seat.relativeY * cos;

          const seatAbsX = tableCenterX + rotatedX;
          const seatAbsY = tableCenterY + rotatedY;

          // Check if click is within seat radius
          const distance = Math.hypot(pointPx.x - seatAbsX, pointPx.y - seatAbsY);
          if (distance <= SEAT_HIT_RADIUS) {
            // Start dragging seat
            setIsDraggingSeat(true);
            setDraggedSeatId(seat.id);
            setSeatDragOffset({ x: pointPx.x - seatAbsX, y: pointPx.y - seatAbsY });
            setOriginalSeatPos({ x: seat.relativeX, y: seat.relativeY });
            if (onSeatSelect) {
              onSeatSelect(seat.id);
            }
            return; // Early return to prevent selecting table/fixture
          }
        }
      }

      // SELECT mode: Check if clicking on a fixture to drag
      if (toolMode === 'SELECT' && selectedFixtureId) {
        const fixture = fixtures.find((f) => f.id === selectedFixtureId);
        if (fixture) {
          // Calculate if click is on this fixture
          let isOnFixture = false;
          if (fixture.geometry.type === 'rectangle') {
            const { position, width, height } = fixture.geometry;
            isOnFixture =
              point.x >= position.x &&
              point.x <= position.x + width &&
              point.y >= position.y &&
              point.y <= position.y + height;
            if (isOnFixture) {
              setIsDragging(true);
              setDragOffset({ x: point.x - position.x, y: point.y - position.y });
              return; // Early return to prevent re-selection
            }
          } else if (fixture.geometry.type === 'circle') {
            const { center, radius } = fixture.geometry;
            const dist = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
            isOnFixture = dist <= radius;
            if (isOnFixture) {
              setIsDragging(true);
              setDragOffset({ x: point.x - center.x, y: point.y - center.y });
              return; // Early return to prevent re-selection
            }
          }
        }
      }

      // WALL mode: Start drawing
      if (toolMode === 'WALL') {
        if (!startPoint) {
          // Snap start point to existing wall endpoints
          const snapDistance = 0.5; // feet
          let snappedStart = point;

          fixtures.forEach((f) => {
            if (f.geometry.type === 'line') {
              const { start, end } = f.geometry;
              // Check distance to start point
              if (Math.hypot(point.x - start.x, point.y - start.y) < snapDistance) {
                snappedStart = start;
              }
              // Check distance to end point
              if (Math.hypot(point.x - end.x, point.y - end.y) < snapDistance) {
                snappedStart = end;
              }
            }
          });

          setStartPoint(snappedStart);
        } else {
          // Snap end point to existing wall endpoints
          const snapDistance = 0.5; // feet
          let snappedEnd = point;

          fixtures.forEach((f) => {
            if (f.geometry.type === 'line') {
              const { start, end } = f.geometry;
              // Check distance to start point
              if (Math.hypot(point.x - start.x, point.y - start.y) < snapDistance) {
                snappedEnd = start;
              }
              // Check distance to end point
              if (Math.hypot(point.x - end.x, point.y - end.y) < snapDistance) {
                snappedEnd = end;
              }
            }
          });

          // Complete the wall
          const metadata = getFixtureTypeMetadata('wall');
          onFixtureCreate({
            floorPlanId: floorPlan.id,
            roomId: floorPlan.id,
            type: 'wall',
            category: metadata.category,
            label: metadata.label,
            geometry: { type: 'line', start: startPoint, end: snappedEnd },
            color: metadata.defaultColor,
            opacity: 1,
            thickness: metadata.defaultThickness,
            height: 'full',
            blocksPlacement: true,
            blocksMovement: true,
            snapTarget: false,
            isActive: true,
          });
          setStartPoint(null);
          refreshFixtures();
        }
        return;
      }

      // RECTANGLE mode: Start drawing
      if (toolMode === 'RECTANGLE') {
        setStartPoint(point);
        setIsDrawing(true);
        return;
      }

      // CIRCLE mode: Place circle
      if (toolMode === 'CIRCLE') {
        // Apply auto-offset to prevent stacking
        const offsetCenter = {
          x: point.x + (placementOffset * 0.5),
          y: point.y + (placementOffset * 0.5),
        };
        setPlacementOffset((prev) => (prev + 1) % 10); // Reset after 10

        const metadata = getFixtureTypeMetadata(fixtureType);
        onFixtureCreate({
          floorPlanId: floorPlan.id,
          roomId: floorPlan.id,
          type: fixtureType,
          category: metadata.category,
          label: metadata.label,
          geometry: { type: 'circle', center: offsetCenter, radius: 1 },
          color: metadata.defaultColor,
          opacity: metadata.category === 'zone' ? 0.3 : 1,
          thickness: metadata.defaultThickness,
          height: 'full',
          blocksPlacement: true,
          blocksMovement: true,
          snapTarget: false,
          isActive: true,
        });
        refreshFixtures();
        return;
      }

      // TABLE mode: Place table
      if (toolMode === 'TABLE' && onTableCreate) {
        const shapeMetadata = getTableShapeMetadata(tableShape);

        // Convert click position to pixels (tables stored in pixels in DB)
        const posX = FloorCanvasAPI.feetToPixels(point.x) - shapeMetadata.defaultWidth / 2;
        const posY = FloorCanvasAPI.feetToPixels(point.y) - shapeMetadata.defaultHeight / 2;

        // Check for collision with fixtures
        if (checkTableFixtureCollision(posX, posY, shapeMetadata.defaultWidth, shapeMetadata.defaultHeight)) {
          console.log('[EditorCanvas] Cannot place table: collision with fixture');
          return;
        }

        // Check for collision with other tables
        if (checkTableCollision(posX, posY, shapeMetadata.defaultWidth, shapeMetadata.defaultHeight)) {
          console.log('[EditorCanvas] Cannot place table: collision with another table');
          return;
        }

        // Generate table name
        const existingTableCount = tables.length;
        const tableName = `Table ${existingTableCount + 1}`;
        const abbrev = `T${existingTableCount + 1}`;

        onTableCreate({
          name: tableName,
          abbreviation: abbrev,
          capacity: shapeMetadata.defaultCapacity,
          posX,
          posY,
          width: shapeMetadata.defaultWidth,
          height: shapeMetadata.defaultHeight,
          rotation: 0,
          shape: tableShape,
          seatPattern: shapeMetadata.defaultSeatPattern,
          sectionId: roomId,
          status: 'available',
          isLocked: false,
        });
        return;
      }

      // DELETE mode: Delete fixture or table
      if (toolMode === 'DELETE') {
        // Convert point to pixels for table comparison
        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        // First check if clicking on a table
        const tableToDelete = tables.find((t) => {
          return (
            pointPx.x >= t.posX &&
            pointPx.x <= t.posX + t.width &&
            pointPx.y >= t.posY &&
            pointPx.y <= t.posY + t.height
          );
        });

        if (tableToDelete && onTableDelete) {
          onTableDelete(tableToDelete.id);
          return;
        }

        // Find fixture at this point
        const fixtureToDelete = fixtures.find((f) => {
          if (f.geometry.type === 'rectangle') {
            const { position, width, height } = f.geometry;
            return (
              point.x >= position.x &&
              point.x <= position.x + width &&
              point.y >= position.y &&
              point.y <= position.y + height
            );
          }
          if (f.geometry.type === 'circle') {
            const { center, radius } = f.geometry;
            const dist = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
            return dist <= radius;
          }
          if (f.geometry.type === 'line') {
            // Simplified: check if point is near line
            const { start, end } = f.geometry;
            const thickness = f.thickness || 0.5;
            const minX = Math.min(start.x, end.x) - thickness;
            const maxX = Math.max(start.x, end.x) + thickness;
            const minY = Math.min(start.y, end.y) - thickness;
            const maxY = Math.max(start.y, end.y) + thickness;
            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
          }
          return false;
        });

        if (fixtureToDelete) {
          onFixtureDelete(fixtureToDelete.id);
          refreshFixtures();
        }
        return;
      }

      // SELECT mode: Select fixture or table
      if (toolMode === 'SELECT') {
        // Convert point to pixels for table comparison
        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        // First check if clicking on a table
        const clickedTable = tables.find((t) => {
          return (
            pointPx.x >= t.posX &&
            pointPx.x <= t.posX + t.width &&
            pointPx.y >= t.posY &&
            pointPx.y <= t.posY + t.height
          );
        });

        if (clickedTable) {
          onFixtureSelect(null); // Deselect fixture
          if (onTableSelect) {
            onTableSelect(clickedTable.id);
            // Start dragging table if not locked
            if (!clickedTable.isLocked) {
              setIsDraggingTable(true);
              setTableDragOffset({
                x: pointPx.x - clickedTable.posX,
                y: pointPx.y - clickedTable.posY,
              });
            }
          }
          return;
        }

        // Then check fixtures
        const clickedFixture = fixtures.find((f) => {
          // Check entertainment elements (may have different geometry structure)
          if ((f as any).elementType === 'entertainment') {
            const geo = f.geometry as { type: string; position?: { x: number; y: number }; width?: number; height?: number } | undefined;
            const x = geo?.position?.x ?? (f as any).x ?? 0;
            const y = geo?.position?.y ?? (f as any).y ?? 0;
            const w = geo?.width ?? (f as any).width ?? 5;
            const h = geo?.height ?? (f as any).height ?? 3;
            return point.x >= x && point.x <= x + w && point.y >= y && point.y <= y + h;
          }

          if (f.geometry.type === 'rectangle') {
            const { position, width, height } = f.geometry;
            return (
              point.x >= position.x &&
              point.x <= position.x + width &&
              point.y >= position.y &&
              point.y <= position.y + height
            );
          }
          if (f.geometry.type === 'circle') {
            const { center, radius } = f.geometry;
            const dist = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
            return dist <= radius;
          }
          if (f.geometry.type === 'line') {
            const { start, end } = f.geometry;
            const thickness = f.thickness || 0.5;
            const minX = Math.min(start.x, end.x) - thickness;
            const maxX = Math.max(start.x, end.x) + thickness;
            const minY = Math.min(start.y, end.y) - thickness;
            const maxY = Math.max(start.y, end.y) + thickness;
            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
          }
          return false;
        });

        if (onTableSelect) {
          onTableSelect(null); // Deselect table
        }
        onFixtureSelect(clickedFixture ? clickedFixture.id : null);
      }
    },
    [
      floorPlan,
      toolMode,
      fixtureType,
      tableShape,
      selectedFixtureId,
      selectedTableId,
      startPoint,
      fixtures,
      tables,
      seats,
      screenToFloor,
      onFixtureSelect,
      onFixtureCreate,
      onFixtureDelete,
      onTableSelect,
      onTableCreate,
      onTableDelete,
      onSeatSelect,
      refreshFixtures,
      checkTableFixtureCollision,
      checkTableCollision,
      placementOffset,
      SEAT_RADIUS,
    ]
  );

  // Handle mouse move
  const handleMouseMove = useCallback(
    (event: React.MouseEvent) => {
      if (!floorPlan) return;

      const point = screenToFloor(event.clientX, event.clientY);
      setCurrentPoint(point);

      // Handle seat dragging
      if (isDraggingSeat && draggedSeatId && seatDragOffset) {
        const seat = seats.find(s => s.id === draggedSeatId);
        if (!seat) return;

        const table = tables.find(t => t.id === seat.tableId);
        if (!table) return;

        const tableCenterX = table.posX + table.width / 2;
        const tableCenterY = table.posY + table.height / 2;

        // Calculate new absolute position
        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };
        let absoluteX = pointPx.x - seatDragOffset.x;
        let absoluteY = pointPx.y - seatDragOffset.y;

        // CLAMP to valid zone instead of rejecting
        // Transform to table-local coordinates for boundary check
        const rotation = (table.rotation || 0) * Math.PI / 180;
        const cos = Math.cos(-rotation);
        const sin = Math.sin(-rotation);
        const dx = absoluteX - tableCenterX;
        const dy = absoluteY - tableCenterY;
        let localX = dx * cos - dy * sin;
        let localY = dx * sin + dy * cos;

        const halfWidth = table.width / 2;
        const halfHeight = table.height / 2;

        // Clamp to outer boundary
        const outerHalfWidth = halfWidth + SEAT_BOUNDARY_DISTANCE;
        const outerHalfHeight = halfHeight + SEAT_BOUNDARY_DISTANCE;
        localX = Math.max(-outerHalfWidth, Math.min(outerHalfWidth, localX));
        localY = Math.max(-outerHalfHeight, Math.min(outerHalfHeight, localY));

        // Push out of table body if seat is inside
        // Seat is "inside" if BOTH x and y are within table bounds
        const SEAT_CLEARANCE = 25; // Distance from table edge to seat center
        if (Math.abs(localX) < halfWidth && Math.abs(localY) < halfHeight) {
          // Seat center is INSIDE the table - push to nearest edge with clearance
          const distToLeftRight = halfWidth - Math.abs(localX);
          const distToTopBottom = halfHeight - Math.abs(localY);

          if (distToLeftRight < distToTopBottom) {
            // Closer to left/right edge - push horizontally
            localX = localX >= 0 ? (halfWidth + SEAT_CLEARANCE) : -(halfWidth + SEAT_CLEARANCE);
          } else {
            // Closer to top/bottom edge - push vertically
            localY = localY >= 0 ? (halfHeight + SEAT_CLEARANCE) : -(halfHeight + SEAT_CLEARANCE);
          }
        }

        // Use clamped local coordinates as the new relative position
        const newRelativeX = localX;
        const newRelativeY = localY;

        // Update local state immediately for smooth dragging
        setSeatDragPreview({ id: draggedSeatId, relativeX: newRelativeX, relativeY: newRelativeY });
        return;
      }

      // Handle table rotation
      if (isRotatingTable && selectedTableId && onTableUpdate) {
        const currentTable = tables.find(t => t.id === selectedTableId);
        if (!currentTable) return;

        // Convert point to pixels for angle calculation
        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        // Calculate table center in pixels
        const tableCenter = {
          x: currentTable.posX + currentTable.width / 2,
          y: currentTable.posY + currentTable.height / 2,
        };

        // Calculate current mouse angle
        const currentMouseAngle = calculateAngle(tableCenter, pointPx);
        const deltaAngle = currentMouseAngle - rotationStartMouseAngle;
        let newRotation = rotationStartAngle + deltaAngle;

        // Snap to 15 increments when holding Shift
        if (event.shiftKey) {
          newRotation = Math.round(newRotation / 15) * 15;
        }

        // Normalize to 0-360
        newRotation = ((newRotation % 360) + 360) % 360;

        // Allow rotation - collision detection is only for awareness, not blocking
        onTableUpdate(selectedTableId, { rotation: newRotation });
        return;
      }

      // Handle table dragging
      // Handle table resizing
      if (isResizingTable && selectedTableId && resizeHandle && resizeStartDimensions && resizeStartPos && onTableUpdate) {
        const currentTable = tables.find(t => t.id === selectedTableId);
        if (!currentTable) return;

        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        if (!resizeStartMousePos) {
          setResizeStartMousePos(pointPx);
          return;
        }

        // Shape-specific minimum sizes
        const getMinimumSize = (shape: TableShape): { minWidth: number; minHeight: number } => {
          switch (shape) {
            case 'bar':
              return { minWidth: 80, minHeight: 30 };  // Wide and short
            case 'booth':
              return { minWidth: 60, minHeight: 80 };  // Taller than wide
            case 'round':
            case 'square':
              return { minWidth: 50, minHeight: 50 };  // Equal dimensions
            case 'oval':
              return { minWidth: 60, minHeight: 40 };  // Slightly wide
            case 'rectangle':
            default:
              return { minWidth: 60, minHeight: 40 };
          }
        };

        const gridPx = FloorCanvasAPI.feetToPixels(floorPlan.gridSizeFeet);
        const { minWidth, minHeight } = getMinimumSize(currentTable.shape as TableShape);
        const deltaX = pointPx.x - resizeStartMousePos.x;
        const deltaY = pointPx.y - resizeStartMousePos.y;

        let newWidth = resizeStartDimensions.width;
        let newHeight = resizeStartDimensions.height;
        let newPosX = resizeStartPos.x;
        let newPosY = resizeStartPos.y;

        const maintainAspect = currentTable.shape === 'round' || currentTable.shape === 'square';

        switch (resizeHandle) {
          case 'se':
            // Southeast corner - change both dimensions
            newWidth = Math.max(minWidth, resizeStartDimensions.width + deltaX);
            newHeight = Math.max(minHeight, resizeStartDimensions.height + deltaY);
            if (maintainAspect) {
              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
              newWidth = size;
              newHeight = size;
            }
            break;
          case 'sw':
            // Southwest corner - change both dimensions
            newWidth = Math.max(minWidth, resizeStartDimensions.width - deltaX);
            newHeight = Math.max(minHeight, resizeStartDimensions.height + deltaY);
            newPosX = resizeStartPos.x + (resizeStartDimensions.width - newWidth);
            if (maintainAspect) {
              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
              newWidth = size;
              newHeight = size;
              newPosX = resizeStartPos.x + (resizeStartDimensions.width - size);
            }
            break;
          case 'ne':
            // Northeast corner - change both dimensions
            newWidth = Math.max(minWidth, resizeStartDimensions.width + deltaX);
            newHeight = Math.max(minHeight, resizeStartDimensions.height - deltaY);
            newPosY = resizeStartPos.y + (resizeStartDimensions.height - newHeight);
            if (maintainAspect) {
              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
              newWidth = size;
              newHeight = size;
              newPosY = resizeStartPos.y + (resizeStartDimensions.height - size);
            }
            break;
          case 'nw':
            // Northwest corner - change both dimensions
            newWidth = Math.max(minWidth, resizeStartDimensions.width - deltaX);
            newHeight = Math.max(minHeight, resizeStartDimensions.height - deltaY);
            newPosX = resizeStartPos.x + (resizeStartDimensions.width - newWidth);
            newPosY = resizeStartPos.y + (resizeStartDimensions.height - newHeight);
            if (maintainAspect) {
              const size = Math.max(Math.min(newWidth, newHeight), minWidth);
              newWidth = size;
              newHeight = size;
              newPosX = resizeStartPos.x + (resizeStartDimensions.width - size);
              newPosY = resizeStartPos.y + (resizeStartDimensions.height - size);
            }
            break;
          case 'e':
            // East edge - only change width
            newWidth = Math.max(minWidth, resizeStartDimensions.width + deltaX);
            newHeight = resizeStartDimensions.height; // Don't change height
            if (maintainAspect) {
              newHeight = newWidth; // For round/square, height matches width
            }
            break;
          case 'w':
            // West edge - only change width
            newWidth = Math.max(minWidth, resizeStartDimensions.width - deltaX);
            newHeight = resizeStartDimensions.height; // Don't change height
            newPosX = resizeStartPos.x + (resizeStartDimensions.width - newWidth);
            if (maintainAspect) {
              newHeight = newWidth; // For round/square, height matches width
            }
            break;
          case 's':
            // South edge - only change height
            newWidth = resizeStartDimensions.width; // Don't change width
            newHeight = Math.max(minHeight, resizeStartDimensions.height + deltaY);
            if (maintainAspect) {
              newWidth = newHeight; // For round/square, width matches height
            }
            break;
          case 'n':
            // North edge - only change height
            newWidth = resizeStartDimensions.width; // Don't change width
            newHeight = Math.max(minHeight, resizeStartDimensions.height - deltaY);
            newPosY = resizeStartPos.y + (resizeStartDimensions.height - newHeight);
            if (maintainAspect) {
              newWidth = newHeight; // For round/square, width matches height
            }
            break;
        }

        newWidth = Math.round(newWidth / gridPx) * gridPx;
        newHeight = Math.round(newHeight / gridPx) * gridPx;
        newPosX = Math.round(newPosX / gridPx) * gridPx;
        newPosY = Math.round(newPosY / gridPx) * gridPx;

        if (checkTableFixtureCollision(newPosX, newPosY, newWidth, newHeight)) return;
        if (checkTableCollision(newPosX, newPosY, newWidth, newHeight, selectedTableId)) return;

        // Note: After resize, seats are reflowed. Check if reflowed positions would collide.
        // For simplicity, check if expanded table footprint + seat boundary would hit obstacles
        const expandedWidth = newWidth + SEAT_BOUNDARY_DISTANCE * 2;
        const expandedHeight = newHeight + SEAT_BOUNDARY_DISTANCE * 2;
        const expandedPosX = newPosX - SEAT_BOUNDARY_DISTANCE;
        const expandedPosY = newPosY - SEAT_BOUNDARY_DISTANCE;

        if (checkTableFixtureCollision(expandedPosX, expandedPosY, expandedWidth, expandedHeight)) return;
        if (checkTableCollision(expandedPosX, expandedPosY, expandedWidth, expandedHeight, selectedTableId)) return;

        onTableUpdate(selectedTableId, {
          width: newWidth,
          height: newHeight,
          posX: newPosX,
          posY: newPosY,
        });
        return;
      }

      // Handle fixture resizing
      if (isResizingFixture && selectedFixtureId && fixtureResizeHandle && fixtureResizeStartDimensions && fixtureResizeStartPos && onFixtureUpdate) {
        const fixtureList = useDatabase ? (dbFixtures || []) : fixtures;
        const currentFixture = fixtureList.find(f => f.id === selectedFixtureId);
        if (!currentFixture) return;

        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        if (!fixtureResizeStartMousePos) {
          setFixtureResizeStartMousePos(pointPx);
          return;
        }

        const deltaX = FloorCanvasAPI.pixelsToFeet(pointPx.x - fixtureResizeStartMousePos.x);
        const deltaY = FloorCanvasAPI.pixelsToFeet(pointPx.y - fixtureResizeStartMousePos.y);

        if (currentFixture.geometry.type === 'rectangle') {
          const minWidth = 1;
          const minHeight = 0.5;
          let newWidth = fixtureResizeStartDimensions.width || 5;
          let newHeight = fixtureResizeStartDimensions.height || 5;
          let newPosX = fixtureResizeStartPos.x;
          let newPosY = fixtureResizeStartPos.y;

          switch (fixtureResizeHandle) {
            case 'se':
              newWidth = Math.max(minWidth, (fixtureResizeStartDimensions.width || 5) + deltaX);
              newHeight = Math.max(minHeight, (fixtureResizeStartDimensions.height || 5) + deltaY);
              break;
            case 'sw':
              newWidth = Math.max(minWidth, (fixtureResizeStartDimensions.width || 5) - deltaX);
              newHeight = Math.max(minHeight, (fixtureResizeStartDimensions.height || 5) + deltaY);
              newPosX = fixtureResizeStartPos.x + ((fixtureResizeStartDimensions.width || 5) - newWidth);
              break;
            case 'ne':
              newWidth = Math.max(minWidth, (fixtureResizeStartDimensions.width || 5) + deltaX);
              newHeight = Math.max(minHeight, (fixtureResizeStartDimensions.height || 5) - deltaY);
              newPosY = fixtureResizeStartPos.y + ((fixtureResizeStartDimensions.height || 5) - newHeight);
              break;
            case 'nw':
              newWidth = Math.max(minWidth, (fixtureResizeStartDimensions.width || 5) - deltaX);
              newHeight = Math.max(minHeight, (fixtureResizeStartDimensions.height || 5) - deltaY);
              newPosX = fixtureResizeStartPos.x + ((fixtureResizeStartDimensions.width || 5) - newWidth);
              newPosY = fixtureResizeStartPos.y + ((fixtureResizeStartDimensions.height || 5) - newHeight);
              break;
            case 'e':
              newWidth = Math.max(minWidth, (fixtureResizeStartDimensions.width || 5) + deltaX);
              break;
            case 'w':
              newWidth = Math.max(minWidth, (fixtureResizeStartDimensions.width || 5) - deltaX);
              newPosX = fixtureResizeStartPos.x + ((fixtureResizeStartDimensions.width || 5) - newWidth);
              break;
            case 's':
              newHeight = Math.max(minHeight, (fixtureResizeStartDimensions.height || 5) + deltaY);
              break;
            case 'n':
              newHeight = Math.max(minHeight, (fixtureResizeStartDimensions.height || 5) - deltaY);
              newPosY = fixtureResizeStartPos.y + ((fixtureResizeStartDimensions.height || 5) - newHeight);
              break;
          }

          // Snap to grid
          const gridSize = floorPlan.gridSizeFeet;
          newWidth = Math.round(newWidth / gridSize) * gridSize;
          newHeight = Math.round(newHeight / gridSize) * gridSize;
          newPosX = Math.round(newPosX / gridSize) * gridSize;
          newPosY = Math.round(newPosY / gridSize) * gridSize;

          onFixtureUpdate(selectedFixtureId, {
            geometry: {
              ...currentFixture.geometry,
              width: newWidth,
              height: newHeight,
              position: { x: newPosX, y: newPosY }
            }
          });
        } else if (currentFixture.geometry.type === 'line') {
          // For lines, move the selected endpoint
          const { start, end } = currentFixture.geometry;

          if (fixtureResizeHandle === 'start') {
            // Moving the start point
            const newStart = {
              x: point.x,
              y: point.y
            };
            // Snap to grid
            const gridSize = floorPlan.gridSizeFeet;
            newStart.x = Math.round(newStart.x / gridSize) * gridSize;
            newStart.y = Math.round(newStart.y / gridSize) * gridSize;

            onFixtureUpdate(selectedFixtureId, {
              geometry: {
                ...currentFixture.geometry,
                start: newStart
              }
            });
          } else if (fixtureResizeHandle === 'end') {
            // Moving the end point
            const newEnd = {
              x: point.x,
              y: point.y
            };
            // Snap to grid
            const gridSize = floorPlan.gridSizeFeet;
            newEnd.x = Math.round(newEnd.x / gridSize) * gridSize;
            newEnd.y = Math.round(newEnd.y / gridSize) * gridSize;

            onFixtureUpdate(selectedFixtureId, {
              geometry: {
                ...currentFixture.geometry,
                end: newEnd
              }
            });
          }
        }
        return;
      }

      if (isDraggingTable && selectedTableId && tableDragOffset && onTableUpdate) {
        // Convert point to pixels for table positioning
        const pointPx = {
          x: FloorCanvasAPI.feetToPixels(point.x),
          y: FloorCanvasAPI.feetToPixels(point.y),
        };

        // Snap to grid (convert grid size to pixels)
        const gridPx = FloorCanvasAPI.feetToPixels(floorPlan.gridSizeFeet);
        const newPosX = Math.round((pointPx.x - tableDragOffset.x) / gridPx) * gridPx;
        const newPosY = Math.round((pointPx.y - tableDragOffset.y) / gridPx) * gridPx;

        // Get current table dimensions
        const currentTable = tables.find(t => t.id === selectedTableId);
        if (currentTable) {
          // Check for collision with fixtures
          if (checkTableFixtureCollision(newPosX, newPosY, currentTable.width, currentTable.height)) {
            // Don't update position if collision detected
            return;
          }

          // Check for collision with other tables (exclude self)
          if (checkTableCollision(newPosX, newPosY, currentTable.width, currentTable.height, selectedTableId)) {
            // Don't allow table to overlap another table
            return;
          }

          // Calculate available space at new position
          const availableSpace = calculateAvailableSpace(
            selectedTableId,
            newPosX,
            newPosY,
            currentTable.width,
            currentTable.height,
            currentTable.rotation || 0
          );

          // Get current seats for this table
          const tableSeats = seats.filter(s => s.tableId === selectedTableId);

          // Compress seats to fit available space (preview only, don't save yet)
          if (tableSeats.length > 0) {
            const compressedSeats = compressSeatsToFit(
              selectedTableId,
              tableSeats,
              { ...currentTable, posX: newPosX, posY: newPosY },
              availableSpace
            );

            // Update local seat state for preview
            setSeats(prevSeats =>
              prevSeats.map(seat => {
                const compressed = compressedSeats.find(cs => cs.id === seat.id);
                return compressed || seat;
              })
            );
          }
        }

        onTableUpdate(selectedTableId, {
          posX: newPosX,
          posY: newPosY,
        });
        return;
      }

      // Handle fixture dragging
      if (isDragging && selectedFixtureId && dragOffset) {
        const fixture = fixtures.find((f) => f.id === selectedFixtureId);
        if (fixture && fixture.geometry.type === 'rectangle') {
          const newPosition = {
            x: point.x - dragOffset.x,
            y: point.y - dragOffset.y,
          };
          onFixtureUpdate(selectedFixtureId, {
            geometry: {
              ...fixture.geometry,
              position: newPosition,
            },
          });
        } else if (fixture && fixture.geometry.type === 'circle') {
          const newCenter = {
            x: point.x - dragOffset.x,
            y: point.y - dragOffset.y,
          };
          onFixtureUpdate(selectedFixtureId, {
            geometry: {
              ...fixture.geometry,
              center: newCenter,
            },
          });
        }
        refreshFixtures();
      }
    },
    [floorPlan, isDragging, isDraggingTable, isDraggingSeat, draggedSeatId, seatDragOffset, isRotatingTable, isResizingTable, resizeHandle, resizeStartDimensions, resizeStartPos, resizeStartMousePos, selectedFixtureId, selectedTableId, dragOffset, tableDragOffset, rotationStartAngle, rotationStartMouseAngle, fixtures, tables, seats, screenToFloor, calculateAngle, onFixtureUpdate, onTableUpdate, refreshFixtures, checkTableFixtureCollision, checkTableCollision, isValidSeatPosition]
  );

  // Handle mouse up
  const handleMouseUp = useCallback(
    (event: React.MouseEvent) => {
      if (!floorPlan) return;

      // Save seat position
      if (isDraggingSeat && draggedSeatId && seatDragPreview && onSeatUpdate) {
        const seat = seats.find(s => s.id === draggedSeatId);
        const table = seat ? tables.find(t => t.id === seat.tableId) : null;

        if (seat && table) {
          const tableCenterX = table.posX + table.width / 2;
          const tableCenterY = table.posY + table.height / 2;
          const rotation = (table.rotation || 0) * Math.PI / 180;

          // Calculate absolute position from preview
          let finalRelX = seatDragPreview.relativeX;
          let finalRelY = seatDragPreview.relativeY;

          // Convert to absolute for collision check
          const absX = tableCenterX + (finalRelX * Math.cos(rotation) - finalRelY * Math.sin(rotation));
          const absY = tableCenterY + (finalRelX * Math.sin(rotation) + finalRelY * Math.cos(rotation));

          // Check if final position collides with another seat
          if (checkSeatCollision(absX, absY, table.id, draggedSeatId)) {
            // Find the colliding seat
            const otherSeats = seats.filter(s => s.tableId === table.id && s.id !== draggedSeatId);
            let collidingSeat: typeof seat | undefined;

            for (const other of otherSeats) {
              const otherAbsX = tableCenterX + (other.relativeX * Math.cos(rotation) - other.relativeY * Math.sin(rotation));
              const otherAbsY = tableCenterY + (other.relativeX * Math.sin(rotation) + other.relativeY * Math.cos(rotation));
              const dist = Math.hypot(absX - otherAbsX, absY - otherAbsY);
              if (dist < SEAT_COLLISION_RADIUS * 2 + 8) {
                collidingSeat = other;
                break;
              }
            }

            if (collidingSeat) {
              // PUSH-SWAP: Move colliding seat to dragged seat's original position
              // This creates a natural "swap" effect
              if (originalSeatPos && onSeatUpdate) {
                onSeatUpdate(collidingSeat.id, {
                  relativeX: Math.round(originalSeatPos.x),
                  relativeY: Math.round(originalSeatPos.y),
                });
              }
            }
            // Use the preview position (where user dropped it)
            // The colliding seat was pushed to our old spot
          }

          // Save final position
          onSeatUpdate(draggedSeatId, {
            relativeX: Math.round(finalRelX),
            relativeY: Math.round(finalRelY),
          });
        }

        // Clear drag state
        setIsDraggingSeat(false);
        setDraggedSeatId(null);
        setSeatDragOffset(null);
        setOriginalSeatPos(null);
        setSeatDragPreview(null);
        return;
      }

      // End table rotation
      if (isRotatingTable) {
        setIsRotatingTable(false);
        setRotationStartAngle(0);
        setRotationStartMouseAngle(0);
        return;
      }

      // End table dragging
      // End table resizing
      if (isResizingTable) {
        // Trigger seat reflow if dimensions changed
        if (selectedTableId && resizeStartDimensions && onSeatsReflow) {
          const tableList = useDatabase ? (dbTables || []) : tables;
          const table = tableList.find(t => t.id === selectedTableId);
          if (table) {
            const widthChanged = table.width !== resizeStartDimensions.width;
            const heightChanged = table.height !== resizeStartDimensions.height;

            if (widthChanged || heightChanged) {
              onSeatsReflow(selectedTableId, {
                oldWidth: resizeStartDimensions.width,
                oldHeight: resizeStartDimensions.height,
                newWidth: table.width,
                newHeight: table.height,
              });
            }
          }
        }

        setIsResizingTable(false);
        setResizeHandle(null);
        setResizeStartDimensions(null);
        setResizeStartPos(null);
        setResizeStartMousePos(null);
        return;
      }

      // End fixture resizing
      if (isResizingFixture) {
        setIsResizingFixture(false);
        setFixtureResizeHandle(null);
        setFixtureResizeStartDimensions(null);
        setFixtureResizeStartPos(null);
        setFixtureResizeStartMousePos(null);
        return;
      }

      if (isDraggingTable && selectedTableId) {
        // Save compressed seat positions to database
        const currentTable = (useDatabase ? (dbTables || []) : tables).find(t => t.id === selectedTableId);
        if (currentTable && onSeatUpdate) {
          // Calculate available space at final position
          const availableSpace = calculateAvailableSpace(
            selectedTableId,
            currentTable.posX,
            currentTable.posY,
            currentTable.width,
            currentTable.height,
            currentTable.rotation || 0
          );

          // Get current seats for this table
          const tableSeats = seats.filter(s => s.tableId === selectedTableId);

          // Compress seats if needed
          if (tableSeats.length > 0) {
            const compressedSeats = compressSeatsToFit(
              selectedTableId,
              tableSeats,
              currentTable,
              availableSpace
            );

            // Save compressed positions to database
            compressedSeats.forEach(seat => {
              // Only update if position changed
              const originalSeat = tableSeats.find(s => s.id === seat.id);
              if (originalSeat &&
                  (originalSeat.relativeX !== seat.relativeX || originalSeat.relativeY !== seat.relativeY)) {
                onSeatUpdate(seat.id, {
                  relativeX: seat.relativeX,
                  relativeY: seat.relativeY,
                });
              }
            });
          }
        }

        setIsDraggingTable(false);
        setTableDragOffset(null);
        return;
      }

      // End fixture dragging
      if (isDragging) {
        setIsDragging(false);
        setDragOffset(null);
        return;
      }

      // RECTANGLE mode: Complete drawing
      if (toolMode === 'RECTANGLE' && isDrawing && startPoint) {
        const point = screenToFloor(event.clientX, event.clientY);
        const width = Math.abs(point.x - startPoint.x);
        const height = Math.abs(point.y - startPoint.y);

        // Only create if has some size
        if (width > 0.5 && height > 0.5) {
          // Apply auto-offset to prevent stacking
          const basePosition = {
            x: Math.min(startPoint.x, point.x),
            y: Math.min(startPoint.y, point.y),
          };
          const position = {
            x: basePosition.x + (placementOffset * 0.5),
            y: basePosition.y + (placementOffset * 0.5),
          };
          setPlacementOffset((prev) => (prev + 1) % 10); // Reset after 10

          const metadata = getFixtureTypeMetadata(fixtureType);
          onFixtureCreate({
            floorPlanId: floorPlan.id,
            roomId: floorPlan.id,
            type: fixtureType,
            category: metadata.category,
            label: metadata.label,
            geometry: { type: 'rectangle', position, width, height, rotation: 0 },
            color: metadata.defaultColor,
            opacity: metadata.category === 'zone' ? 0.3 : 1,
            thickness: metadata.defaultThickness,
            height: metadata.category === 'surface' ? 'counter' : null,
            blocksPlacement: true,
            blocksMovement: metadata.category !== 'zone',
            snapTarget: metadata.category === 'surface',
            isActive: true,
          });
          refreshFixtures();
        }

        setStartPoint(null);
        setIsDrawing(false);
      }
    },
    [floorPlan, isDragging, isDraggingTable, isDraggingSeat, draggedSeatId, seatDragPreview, isRotatingTable, isResizingTable, toolMode, isDrawing, startPoint, fixtureType, placementOffset, screenToFloor, onFixtureCreate, onSeatUpdate, onSeatsReflow, selectedTableId, resizeStartDimensions, useDatabase, dbTables, tables, refreshFixtures]
  );

  // Render preview for current drawing
  const renderPreview = () => {
    if (!currentPoint) return null;

    // WALL mode: Preview line from start point to current
    if (toolMode === 'WALL' && startPoint) {
      const start = startPoint;
      const end = currentPoint;
      const dx = end.x - start.x;
      const dy = end.y - start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);

      return (
        <div
          style={{
            position: 'absolute',
            left: FloorCanvasAPI.feetToPixels(start.x),
            top: FloorCanvasAPI.feetToPixels(start.y - 0.25),
            width: FloorCanvasAPI.feetToPixels(length),
            height: FloorCanvasAPI.feetToPixels(0.5),
            backgroundColor: '#3498db',
            opacity: 0.5,
            transform: `rotate(${angle}deg)`,
            transformOrigin: 'left center',
            pointerEvents: 'none',
          }}
        />
      );
    }

    // RECTANGLE mode: Preview rectangle
    if (toolMode === 'RECTANGLE' && isDrawing && startPoint) {
      const width = Math.abs(currentPoint.x - startPoint.x);
      const height = Math.abs(currentPoint.y - startPoint.y);
      const position = {
        x: Math.min(startPoint.x, currentPoint.x),
        y: Math.min(startPoint.y, currentPoint.y),
      };

      return (
        <div
          style={{
            position: 'absolute',
            left: FloorCanvasAPI.feetToPixels(position.x),
            top: FloorCanvasAPI.feetToPixels(position.y),
            width: FloorCanvasAPI.feetToPixels(width),
            height: FloorCanvasAPI.feetToPixels(height),
            backgroundColor: getFixtureTypeMetadata(fixtureType).defaultColor,
            opacity: 0.5,
            border: '2px dashed #3498db',
            pointerEvents: 'none',
          }}
        />
      );
    }

    return null;
  };

  // =============================================================================
  // ZOOM AND PAN HANDLERS
  // =============================================================================

  // Zoom handler (wheel event)
  const handleWheel = useCallback((e: React.WheelEvent) => {
    // Only zoom if Ctrl/Cmd is held
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
      setZoom(prev => Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, prev + delta)));
    }
  }, []);

  // Pan handlers (middle mouse or Alt+drag)
  const handlePanStart = useCallback((e: React.PointerEvent) => {
    // Middle mouse button OR Alt key held
    if (e.button === 1 || (e.button === 0 && e.altKey)) {
      e.preventDefault();
      setIsPanning(true);
      setLastPanPoint({ x: e.clientX, y: e.clientY });
      (e.target as HTMLElement).setPointerCapture(e.pointerId);
    }
  }, []);

  const handlePanMove = useCallback((e: React.PointerEvent) => {
    if (!isPanning || !lastPanPoint) return;

    const dx = e.clientX - lastPanPoint.x;
    const dy = e.clientY - lastPanPoint.y;

    setPanOffset(prev => ({
      x: prev.x + dx,
      y: prev.y + dy,
    }));
    setLastPanPoint({ x: e.clientX, y: e.clientY });
  }, [isPanning, lastPanPoint]);

  const handlePanEnd = useCallback((e: React.PointerEvent) => {
    if (isPanning) {
      setIsPanning(false);
      setLastPanPoint(null);
      (e.target as HTMLElement).releasePointerCapture(e.pointerId);
    }
  }, [isPanning]);

  // Fit to screen - calculate zoom to fit canvas in viewport
  const fitToScreen = useCallback(() => {
    if (!canvasRef.current) return;
    const container = canvasRef.current.parentElement;
    if (!container) return;

    const containerWidth = container.clientWidth - 48; // padding
    const containerHeight = container.clientHeight - 48;

    const scaleX = containerWidth / CANVAS_WIDTH;
    const scaleY = containerHeight / CANVAS_HEIGHT;
    const newZoom = Math.min(scaleX, scaleY, ZOOM_MAX);

    setZoom(Math.max(ZOOM_MIN, newZoom));
    setPanOffset({ x: 0, y: 0 });
  }, []);

  // Reset zoom
  const resetZoom = useCallback(() => {
    setZoom(ZOOM_DEFAULT);
    setPanOffset({ x: 0, y: 0 });
  }, []);

  // Expose zoom controls to parent
  useEffect(() => {
    if (zoomControlRef) {
      zoomControlRef.current = {
        fitToScreen,
        resetZoom,
        setZoom,
        zoom,
      };
    }
  }, [zoomControlRef, fitToScreen, resetZoom, zoom]);

  // Notify parent of zoom changes
  useEffect(() => {
    onZoomChange?.(zoom);
  }, [zoom, onZoomChange]);

  // =============================================================================
  // RENDER FUNCTIONS
  // =============================================================================

  // Render fixtures with selection highlight
  const renderFixtures = () => {
    return fixtures.map((fixture) => {
      const isSelected = fixture.id === selectedFixtureId;
      const baseStyle: React.CSSProperties = {
        position: 'absolute',
        backgroundColor: fixture.color,
        opacity: fixture.opacity,
        cursor: toolMode === 'SELECT' ? 'move' : toolMode === 'DELETE' ? 'pointer' : 'default',
        border: isSelected ? '2px solid #3498db' : 'none',
        boxShadow: isSelected ? '0 0 8px rgba(52, 152, 219, 0.5)' : 'none',
      };

      if (fixture.geometry.type === 'rectangle') {
        const { position, width, height, rotation } = fixture.geometry;
        const widthPx = FloorCanvasAPI.feetToPixels(width);
        const heightPx = FloorCanvasAPI.feetToPixels(height);

        return (
          <div
            key={fixture.id}
            style={{
              ...baseStyle,
              left: FloorCanvasAPI.feetToPixels(position.x),
              top: FloorCanvasAPI.feetToPixels(position.y),
              width: widthPx,
              height: heightPx,
              transform: `rotate(${rotation}deg)`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
            title={fixture.label}
          >
            <span
              style={{
                fontSize: 10,
                fontWeight: 600,
                color: '#fff',
                textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                pointerEvents: 'none',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                maxWidth: '90%',
                textAlign: 'center',
              }}
            >
              {fixture.label}
            </span>

            {/* Resize handles */}
            {isSelected && toolMode === 'SELECT' && (
              <>
                {/* Corner handles */}
                <div
                  className="resize-handle nw"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'nw')}
                  style={{
                    position: 'absolute',
                    top: -4,
                    left: -4,
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'nw-resize',
                    zIndex: 10,
                  }}
                />
                <div
                  className="resize-handle ne"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'ne')}
                  style={{
                    position: 'absolute',
                    top: -4,
                    right: -4,
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'ne-resize',
                    zIndex: 10,
                  }}
                />
                <div
                  className="resize-handle sw"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'sw')}
                  style={{
                    position: 'absolute',
                    bottom: -4,
                    left: -4,
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'sw-resize',
                    zIndex: 10,
                  }}
                />
                <div
                  className="resize-handle se"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'se')}
                  style={{
                    position: 'absolute',
                    bottom: -4,
                    right: -4,
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'se-resize',
                    zIndex: 10,
                  }}
                />
                {/* Edge handles */}
                <div
                  className="resize-handle n"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'n')}
                  style={{
                    position: 'absolute',
                    top: -4,
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'n-resize',
                    zIndex: 10,
                  }}
                />
                <div
                  className="resize-handle s"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 's')}
                  style={{
                    position: 'absolute',
                    bottom: -4,
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 's-resize',
                    zIndex: 10,
                  }}
                />
                <div
                  className="resize-handle e"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'e')}
                  style={{
                    position: 'absolute',
                    right: -4,
                    top: '50%',
                    transform: 'translateY(-50%)',
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'e-resize',
                    zIndex: 10,
                  }}
                />
                <div
                  className="resize-handle w"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'w')}
                  style={{
                    position: 'absolute',
                    left: -4,
                    top: '50%',
                    transform: 'translateY(-50%)',
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'w-resize',
                    zIndex: 10,
                  }}
                />
              </>
            )}
          </div>
        );
      }

      if (fixture.geometry.type === 'circle') {
        const { center, radius } = fixture.geometry;
        return (
          <div
            key={fixture.id}
            style={{
              ...baseStyle,
              left: FloorCanvasAPI.feetToPixels(center.x - radius),
              top: FloorCanvasAPI.feetToPixels(center.y - radius),
              width: FloorCanvasAPI.feetToPixels(radius * 2),
              height: FloorCanvasAPI.feetToPixels(radius * 2),
              borderRadius: '50%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
            title={fixture.label}
          >
            <span
              style={{
                fontSize: 10,
                fontWeight: 600,
                color: '#fff',
                textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                pointerEvents: 'none',
                whiteSpace: 'nowrap',
                textAlign: 'center',
              }}
            >
              {fixture.label}
            </span>
          </div>
        );
      }

      if (fixture.geometry.type === 'line') {
        const { start, end } = fixture.geometry;
        const thickness = fixture.thickness || 0.5;
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);

        return (
          <div
            key={fixture.id}
            style={{
              ...baseStyle,
              left: FloorCanvasAPI.feetToPixels(start.x),
              top: FloorCanvasAPI.feetToPixels(start.y - thickness / 2),
              width: FloorCanvasAPI.feetToPixels(length),
              height: FloorCanvasAPI.feetToPixels(thickness),
              transform: `rotate(${angle}deg)`,
              transformOrigin: 'left center',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
            title={fixture.label}
          >
            <span
              style={{
                fontSize: 10,
                fontWeight: 600,
                color: '#fff',
                textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                pointerEvents: 'none',
                whiteSpace: 'nowrap',
                backgroundColor: 'rgba(0,0,0,0.3)',
                padding: '2px 6px',
                borderRadius: 3,
              }}
            >
              {fixture.label}
            </span>

            {/* Resize handles for line endpoints */}
            {isSelected && toolMode === 'SELECT' && (
              <>
                <div
                  className="resize-handle start"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'start')}
                  style={{
                    position: 'absolute',
                    left: -4,
                    top: '50%',
                    transform: 'translateY(-50%)',
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'ew-resize',
                    zIndex: 10,
                    borderRadius: '50%',
                  }}
                />
                <div
                  className="resize-handle end"
                  onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'end')}
                  style={{
                    position: 'absolute',
                    right: -4,
                    top: '50%',
                    transform: 'translateY(-50%)',
                    width: 8,
                    height: 8,
                    background: 'white',
                    border: '1px solid #3498db',
                    cursor: 'ew-resize',
                    zIndex: 10,
                    borderRadius: '50%',
                  }}
                />
              </>
            )}
          </div>
        );
      }

      return null;
    });
  };

  // Render entertainment elements
  const renderEntertainmentElements = () => {
    // Filter entertainment from fixtures (they come from dbElements via props)
    const entertainmentFixtures = fixtures.filter(f =>
      (f as any).elementType === 'entertainment'
    );

    return entertainmentFixtures.map((fixture) => {
      const isSelected = fixture.id === selectedFixtureId;
      const visualType = ((fixture as any).visualType || 'game_table') as EntertainmentVisualType;

      // Get position from fixture geometry or direct props
      const geo = fixture.geometry as { type: string; position?: { x: number; y: number }; width?: number; height?: number } | undefined;
      const posX = geo?.position?.x ?? (fixture as any).x ?? 0;
      const posY = geo?.position?.y ?? (fixture as any).y ?? 0;
      const width = geo?.width ?? (fixture as any).width ?? 5;
      const height = geo?.height ?? (fixture as any).height ?? 3;
      const rotation = (fixture as any).rotation ?? 0;

      const pixelX = FloorCanvasAPI.feetToPixels(posX);
      const pixelY = FloorCanvasAPI.feetToPixels(posY);
      const pixelWidth = FloorCanvasAPI.feetToPixels(width);
      const pixelHeight = FloorCanvasAPI.feetToPixels(height);

      return (
        <div
          key={fixture.id}
          style={{
            position: 'absolute',
            left: pixelX,
            top: pixelY,
            width: pixelWidth,
            height: pixelHeight,
            transform: `rotate(${rotation}deg)`,
            transformOrigin: 'center center',
            cursor: toolMode === 'SELECT' ? 'move' : toolMode === 'DELETE' ? 'pointer' : 'default',
            zIndex: isSelected ? 100 : 10,
            border: isSelected ? '2px solid #9333ea' : 'none',
            boxShadow: isSelected ? '0 0 12px rgba(147, 51, 234, 0.5)' : 'none',
            borderRadius: 8,
          }}
        >
          {/* SVG Visual */}
          <EntertainmentVisual
            visualType={visualType}
            status="available"
            width={pixelWidth}
            height={pixelHeight}
          />

          {/* Label below */}
          <div style={{
            position: 'absolute',
            bottom: -20,
            left: '50%',
            transform: `translateX(-50%) rotate(-${rotation}deg)`,
            backgroundColor: 'rgba(0,0,0,0.8)',
            color: 'white',
            padding: '2px 8px',
            borderRadius: 4,
            fontSize: 10,
            fontWeight: 600,
            whiteSpace: 'nowrap',
          }}>
            {fixture.label || (fixture as any).name}
          </div>

          {/* Resize handles when selected */}
          {isSelected && toolMode === 'SELECT' && (
            <>
              {/* NW handle */}
              <div
                onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'nw')}
                style={{
                  position: 'absolute', top: -4, left: -4,
                  width: 8, height: 8, background: 'white',
                  border: '1px solid #9333ea', cursor: 'nw-resize', zIndex: 10,
                }}
              />
              {/* NE handle */}
              <div
                onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'ne')}
                style={{
                  position: 'absolute', top: -4, right: -4,
                  width: 8, height: 8, background: 'white',
                  border: '1px solid #9333ea', cursor: 'ne-resize', zIndex: 10,
                }}
              />
              {/* SW handle */}
              <div
                onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'sw')}
                style={{
                  position: 'absolute', bottom: -4, left: -4,
                  width: 8, height: 8, background: 'white',
                  border: '1px solid #9333ea', cursor: 'sw-resize', zIndex: 10,
                }}
              />
              {/* SE handle */}
              <div
                onMouseDown={(e) => handleFixtureResizeStart(e, fixture.id, 'se')}
                style={{
                  position: 'absolute', bottom: -4, right: -4,
                  width: 8, height: 8, background: 'white',
                  border: '1px solid #9333ea', cursor: 'se-resize', zIndex: 10,
                }}
              />
            </>
          )}
        </div>
      );
    });
  };

  // Render tables
  const renderTables = () => {
    return tables.map((table) => (
      <TableRenderer
        key={table.id}
        table={table}
        isSelected={table.id === selectedTableId}
        isDragging={isDraggingTable && table.id === selectedTableId}
        isRotating={isRotatingTable && table.id === selectedTableId}
        onSelect={() => {
          if (onTableSelect) {
            onTableSelect(table.id);
          }
        }}
        onRotateStart={(e) => {
          if (!onTableSelect || !onTableUpdate) return;

          // Select this table
          onTableSelect(table.id);

          // Start rotation
          setIsRotatingTable(true);

          // Store initial rotation angle
          setRotationStartAngle(table.rotation);

          // Calculate initial mouse angle relative to table center
          const pointFeet = screenToFloor(e.clientX, e.clientY);
          const pointPx = {
            x: FloorCanvasAPI.feetToPixels(pointFeet.x),
            y: FloorCanvasAPI.feetToPixels(pointFeet.y),
          };
          const tableCenter = {
            x: table.posX + table.width / 2,
            y: table.posY + table.height / 2,
          };
          const initialMouseAngle = calculateAngle(tableCenter, pointPx);
          setRotationStartMouseAngle(initialMouseAngle);
        }}
        isResizing={isResizingTable && table.id === selectedTableId}
        onResizeStart={handleResizeStart}
      />
    ));
  };

  // Render seats
  const renderSeats = () => {
    return seats.map((seat) => {
      const table = tables.find(t => t.id === seat.tableId);
      if (!table) return null;

      const tableCenterX = table.posX + table.width / 2;
      const tableCenterY = table.posY + table.height / 2;

      // Use preview position if dragging this seat
      const seatData = (isDraggingSeat && draggedSeatId === seat.id && seatDragPreview)
        ? { ...seat, relativeX: seatDragPreview.relativeX, relativeY: seatDragPreview.relativeY }
        : seat;

      // Calculate absolute position with table rotation
      const rotation = (table.rotation || 0) * Math.PI / 180;
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const rotatedX = seatData.relativeX * cos - seatData.relativeY * sin;
      const rotatedY = seatData.relativeX * sin + seatData.relativeY * cos;

      const seatAbsX = tableCenterX + rotatedX;
      const seatAbsY = tableCenterY + rotatedY;

      return (
        <div
          key={seat.id}
          style={{
            position: 'absolute',
            left: seatAbsX - 10, // Center the 20px SeatRenderer
            top: seatAbsY - 10,
            width: 20,  // Match SeatRenderer's seatSize (20px)
            height: 20,
            cursor: toolMode === 'SELECT' ? 'move' : 'default',
            pointerEvents: 'auto',
          }}
        >
          <SeatRenderer
            seat={seatData}
            tableRotation={table.rotation || 0}
            isSelected={draggedSeatId === seat.id}
            isHighlighted={false}
            hasItems={false}
          />
        </div>
      );
    });
  };

  // Grid is now rendered via CSS backgroundImage on the canvas div
  // No SVG grid needed - this improves performance and avoids visual conflicts

  if (!floorPlan) {
    return (
      <div style={{ padding: 24, textAlign: 'center', color: '#999' }}>
        No floor plan found. Please select a room.
      </div>
    );
  }

  return (
    <div
      style={{
        width: '100%',
        height: 'calc(100vh - 280px)',
        overflow: 'auto',
        position: 'relative',
        backgroundColor: '#e9ecef',
        borderRadius: 8,
        cursor: isPanning ? 'grabbing' : 'default',
      }}
      onWheel={handleWheel}
    >
      <div
        style={{
          transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoom})`,
          transformOrigin: 'top left',
          transition: isPanning ? 'none' : 'transform 0.1s ease-out',
        }}
      >
        <div
          ref={canvasRef}
          onPointerDown={(e) => {
            // Check for pan first
            if (e.button === 1 || (e.button === 0 && e.altKey)) {
              handlePanStart(e);
              return;
            }
            handleMouseDown(e as unknown as React.MouseEvent);
          }}
          onPointerMove={(e) => {
            if (isPanning) {
              handlePanMove(e);
              return;
            }
            handleMouseMove(e as unknown as React.MouseEvent);
          }}
          onPointerUp={(e) => {
            if (isPanning) {
              handlePanEnd(e);
              return;
            }
            handleMouseUp(e as unknown as React.MouseEvent);
          }}
          style={{
            position: 'relative',
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            backgroundColor: '#f8f9fa',
            backgroundImage: `
              linear-gradient(rgba(0,0,0,0.08) 1px, transparent 1px),
              linear-gradient(90deg, rgba(0,0,0,0.08) 1px, transparent 1px)
            `,
            backgroundSize: `${GRID_SIZE}px ${GRID_SIZE}px`,
            border: '2px solid #ccc',
            borderRadius: 8,
            overflow: 'hidden',
            cursor: toolMode === 'SELECT' ? 'default' : 'crosshair',
            userSelect: 'none',
            WebkitUserSelect: 'none',
          }}
        >
      {/* Grid is rendered via CSS backgroundImage - no SVG needed */}

      {/* Fixtures */}
      {renderFixtures()}

      {/* Entertainment Elements */}
      {renderEntertainmentElements()}

      {/* Tables */}
      {renderTables()}

      {/* Seats */}
      {renderSeats()}

      {/* Boundary visualization when dragging a seat */}
      {isDraggingSeat && draggedSeatId && (() => {
        const seat = seats.find(s => s.id === draggedSeatId);
        const table = seat ? tables.find(t => t.id === seat.tableId) : null;
        if (!table) return null;

        const tableCenterX = table.posX + table.width / 2;
        const tableCenterY = table.posY + table.height / 2;
        const halfW = table.width / 2;
        const halfH = table.height / 2;
        const rotation = table.rotation || 0;

        // Get other seats on this table for collision zone visualization
        const otherSeats = seats.filter(s => s.tableId === table.id && s.id !== draggedSeatId);

        return (
          <>
            {/* Inner boundary - table edge (red dashed) */}
            <div
              style={{
                position: 'absolute',
                left: table.posX,
                top: table.posY,
                width: table.width,
                height: table.height,
                border: '2px dashed rgba(239, 68, 68, 0.7)',
                borderRadius: table.shape === 'round' ? '50%' : 8,
                transform: `rotate(${rotation}deg)`,
                transformOrigin: 'center center',
                pointerEvents: 'none',
                zIndex: 998,
              }}
            />

            {/* Outer boundary - max drag distance (blue dashed) */}
            <div
              style={{
                position: 'absolute',
                left: table.posX - SEAT_BOUNDARY_DISTANCE,
                top: table.posY - SEAT_BOUNDARY_DISTANCE,
                width: table.width + SEAT_BOUNDARY_DISTANCE * 2,
                height: table.height + SEAT_BOUNDARY_DISTANCE * 2,
                border: '2px dashed rgba(59, 130, 246, 0.5)',
                borderRadius: table.shape === 'round' ? '50%' : 12,
                transform: `rotate(${rotation}deg)`,
                transformOrigin: 'center center',
                pointerEvents: 'none',
                zIndex: 997,
              }}
            />

            {/* Valid zone - between inner and outer (green fill) */}
            <div
              style={{
                position: 'absolute',
                left: table.posX - SEAT_BOUNDARY_DISTANCE,
                top: table.posY - SEAT_BOUNDARY_DISTANCE,
                width: table.width + SEAT_BOUNDARY_DISTANCE * 2,
                height: table.height + SEAT_BOUNDARY_DISTANCE * 2,
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                borderRadius: table.shape === 'round' ? '50%' : 12,
                transform: `rotate(${rotation}deg)`,
                transformOrigin: 'center center',
                pointerEvents: 'none',
                zIndex: 996,
              }}
            />

            {/* Collision zones around other seats (orange circles) */}
            {otherSeats.map((otherSeat) => {
              const rot = rotation * Math.PI / 180;
              const cos = Math.cos(rot);
              const sin = Math.sin(rot);
              const rotatedX = otherSeat.relativeX * cos - otherSeat.relativeY * sin;
              const rotatedY = otherSeat.relativeX * sin + otherSeat.relativeY * cos;
              const seatAbsX = tableCenterX + rotatedX;
              const seatAbsY = tableCenterY + rotatedY;
              const collisionDiameter = SEAT_COLLISION_RADIUS * 2 + 4;

              return (
                <div
                  key={`collision-${otherSeat.id}`}
                  style={{
                    position: 'absolute',
                    left: seatAbsX - collisionDiameter / 2,
                    top: seatAbsY - collisionDiameter / 2,
                    width: collisionDiameter,
                    height: collisionDiameter,
                    border: '2px dashed rgba(249, 115, 22, 0.6)',
                    borderRadius: '50%',
                    backgroundColor: 'rgba(249, 115, 22, 0.1)',
                    pointerEvents: 'none',
                    zIndex: 999,
                  }}
                />
              );
            })}
          </>
        );
      })()}

      {/* Debug: Show all seat collision zones */}
      {showBoundaryDebug && seats.map((seat) => {
        const table = tables.find(t => t.id === seat.tableId);
        if (!table) return null;

        const tableCenterX = table.posX + table.width / 2;
        const tableCenterY = table.posY + table.height / 2;
        const rotation = (table.rotation || 0) * Math.PI / 180;
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
        const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
        const seatAbsX = tableCenterX + rotatedX;
        const seatAbsY = tableCenterY + rotatedY;

        return (
          <div
            key={`debug-${seat.id}`}
            style={{
              position: 'absolute',
              left: seatAbsX - SEAT_COLLISION_RADIUS,
              top: seatAbsY - SEAT_COLLISION_RADIUS,
              width: SEAT_COLLISION_RADIUS * 2,
              height: SEAT_COLLISION_RADIUS * 2,
              borderRadius: '50%',
              border: '1px dashed rgba(255, 100, 100, 0.6)',
              backgroundColor: 'rgba(255, 100, 100, 0.1)',
              pointerEvents: 'none',
              zIndex: 999,
            }}
          />
        );
      })}

      {/* Debug: Show table inner boundary (no-go zone) */}
      {showBoundaryDebug && tables.map((table) => (
        <div
          key={`debug-inner-${table.id}`}
          style={{
            position: 'absolute',
            left: table.posX,
            top: table.posY,
            width: table.width,
            height: table.height,
            border: '2px solid rgba(255, 0, 0, 0.4)',
            backgroundColor: 'rgba(255, 0, 0, 0.05)',
            transform: `rotate(${table.rotation || 0}deg)`,
            transformOrigin: 'center center',
            pointerEvents: 'none',
            zIndex: 998,
          }}
        />
      ))}

      {/* Debug mode indicator */}
      {showBoundaryDebug && (
        <div
          style={{
            position: 'absolute',
            top: 8,
            left: 8,
            padding: '4px 8px',
            backgroundColor: 'rgba(255, 100, 100, 0.9)',
            color: 'white',
            borderRadius: 4,
            fontSize: 11,
            fontWeight: 600,
            pointerEvents: 'none',
            zIndex: 2000,
          }}
        >
          DEBUG: Boundaries (Ctrl+B to toggle)
        </div>
      )}

      {/* Preview */}
      {renderPreview()}

      {/* Room info */}
      <div
        style={{
          position: 'absolute',
          bottom: 8,
          left: 8,
          padding: '4px 8px',
          backgroundColor: 'rgba(0, 0, 0, 0.6)',
          color: 'white',
          borderRadius: 4,
          fontSize: 12,
          pointerEvents: 'none',
        }}
      >
        {floorPlan.name} ({floorPlan.widthFeet}ft x {floorPlan.heightFeet}ft)
      </div>

      {/* Cursor position */}
      {currentPoint && (
        <div
          style={{
            position: 'absolute',
            top: 8,
            right: 8,
            padding: '4px 8px',
            backgroundColor: 'rgba(0, 0, 0, 0.6)',
            color: 'white',
            borderRadius: 4,
            fontSize: 12,
            pointerEvents: 'none',
            fontFamily: 'monospace',
          }}
        >
          ({currentPoint.x.toFixed(1)}, {currentPoint.y.toFixed(1)})
        </div>
      )}
        </div>
      </div>
    </div>
  );
}

export default EditorCanvas;



################################################################################
# FILE: src/domains/floor-plan/admin/EditorCanvasDB.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Editor Canvas (Database-Backed)
 *
 * Canvas with drawing and editing interactions for floor plan elements.
 * Uses pixels per foot conversion for grid snapping.
 */

import React, { useRef, useState, useCallback } from 'react';
import type { EditorToolMode, FixtureType } from './types';
import { getFixtureTypeMetadata } from './types';

// =============================================================================
// CONSTANTS
// =============================================================================

const PIXELS_PER_FOOT = 20; // 20 pixels = 1 foot

// =============================================================================
// TYPES
// =============================================================================

interface Section {
  id: string;
  name: string;
  widthFeet: number;
  heightFeet: number;
  gridSizeFeet: number;
}

interface Point {
  x: number;
  y: number;
}

interface LineGeometry {
  type: 'line';
  start: Point;
  end: Point;
}

interface RectGeometry {
  type: 'rectangle';
  x: number;
  y: number;
  width: number;
  height: number;
}

interface CircleGeometry {
  type: 'circle';
  x: number;
  y: number;
  radius: number;
}

type Geometry = LineGeometry | RectGeometry | CircleGeometry;

interface FloorPlanElement {
  id: string;
  name: string;
  elementType: string;
  visualType: string;
  geometry: unknown; // Cast to Geometry when needed
  posX: number;
  posY: number;
  width: number;
  height: number;
  rotation: number;
  thickness: number;
  fillColor: string | null;
  opacity: number;
  isLocked: boolean;
}

interface EditorCanvasDBProps {
  section: Section;
  elements: FloorPlanElement[];
  toolMode: EditorToolMode;
  fixtureType: FixtureType;
  selectedElementId: string | null;
  onElementSelect: (elementId: string | null) => void;
  onElementUpdate: (elementId: string, updates: Partial<FloorPlanElement>) => void;
  onElementCreate: (element: Partial<FloorPlanElement>) => void;
  onElementDelete: (elementId: string) => void;
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

function feetToPixels(feet: number): number {
  return feet * PIXELS_PER_FOOT;
}

function pixelsToFeet(pixels: number): number {
  return pixels / PIXELS_PER_FOOT;
}

function snapToGrid(point: Point, gridSizeFeet: number): Point {
  return {
    x: Math.round(point.x / gridSizeFeet) * gridSizeFeet,
    y: Math.round(point.y / gridSizeFeet) * gridSizeFeet,
  };
}

// =============================================================================
// COMPONENT
// =============================================================================

export function EditorCanvasDB({
  section,
  elements,
  toolMode,
  fixtureType,
  selectedElementId,
  onElementSelect,
  onElementUpdate,
  onElementCreate,
  onElementDelete,
}: EditorCanvasDBProps) {
  const canvasRef = useRef<HTMLDivElement>(null);

  // Drawing state
  const [startPoint, setStartPoint] = useState<Point | null>(null);
  const [currentPoint, setCurrentPoint] = useState<Point | null>(null);
  const [isDrawing, setIsDrawing] = useState(false);

  // Dragging state
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState<Point | null>(null);

  // Auto-offset for new elements to prevent stacking
  const [placementOffset, setPlacementOffset] = useState(0);

  // Canvas dimensions in pixels
  const canvasWidthPx = feetToPixels(section.widthFeet);
  const canvasHeightPx = feetToPixels(section.heightFeet);

  // Convert screen position to floor position (feet)
  const screenToFloor = useCallback(
    (screenX: number, screenY: number): Point => {
      if (!canvasRef.current) return { x: 0, y: 0 };
      const rect = canvasRef.current.getBoundingClientRect();
      const x = screenX - rect.left;
      const y = screenY - rect.top;
      const position: Point = {
        x: pixelsToFeet(x),
        y: pixelsToFeet(y),
      };
      // Snap to grid
      return snapToGrid(position, section.gridSizeFeet);
    },
    [section.gridSizeFeet]
  );

  // Get element bounds in feet
  const getElementBounds = useCallback((element: FloorPlanElement) => {
    if (element.geometry) {
      const geo = element.geometry as Geometry;
      if (geo.type === 'rectangle') {
        return {
          x: geo.x,
          y: geo.y,
          width: geo.width,
          height: geo.height,
        };
      }
      if (geo.type === 'circle') {
        return {
          x: geo.x - geo.radius,
          y: geo.y - geo.radius,
          width: geo.radius * 2,
          height: geo.radius * 2,
        };
      }
      if (geo.type === 'line') {
        const thickness = element.thickness || 0.5;
        const minX = Math.min(geo.start.x, geo.end.x) - thickness;
        const maxX = Math.max(geo.start.x, geo.end.x) + thickness;
        const minY = Math.min(geo.start.y, geo.end.y) - thickness;
        const maxY = Math.max(geo.start.y, geo.end.y) + thickness;
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
        };
      }
    }
    // Fallback to pixel-based position (convert to feet)
    return {
      x: pixelsToFeet(element.posX),
      y: pixelsToFeet(element.posY),
      width: pixelsToFeet(element.width),
      height: pixelsToFeet(element.height),
    };
  }, []);

  // Check if point is inside element
  const isPointInElement = useCallback(
    (point: Point, element: FloorPlanElement): boolean => {
      if (element.geometry) {
        const geo = element.geometry as Geometry;
        if (geo.type === 'rectangle') {
          return (
            point.x >= geo.x &&
            point.x <= geo.x + geo.width &&
            point.y >= geo.y &&
            point.y <= geo.y + geo.height
          );
        }
        if (geo.type === 'circle') {
          const dist = Math.sqrt(Math.pow(point.x - geo.x, 2) + Math.pow(point.y - geo.y, 2));
          return dist <= geo.radius;
        }
        if (geo.type === 'line') {
          const thickness = element.thickness || 0.5;
          const bounds = getElementBounds(element);
          return (
            point.x >= bounds.x &&
            point.x <= bounds.x + bounds.width &&
            point.y >= bounds.y &&
            point.y <= bounds.y + bounds.height
          );
        }
      }
      // Fallback
      const bounds = getElementBounds(element);
      return (
        point.x >= bounds.x &&
        point.x <= bounds.x + bounds.width &&
        point.y >= bounds.y &&
        point.y <= bounds.y + bounds.height
      );
    },
    [getElementBounds]
  );

  // Handle mouse down
  const handleMouseDown = useCallback(
    (event: React.MouseEvent) => {
      const point = screenToFloor(event.clientX, event.clientY);

      // SELECT mode: Check if clicking on an element to drag
      if (toolMode === 'SELECT' && selectedElementId) {
        const element = elements.find((e) => e.id === selectedElementId);
        if (element && !element.isLocked && isPointInElement(point, element)) {
          const bounds = getElementBounds(element);
          setIsDragging(true);
          setDragOffset({ x: point.x - bounds.x, y: point.y - bounds.y });
          return;
        }
      }

      // WALL mode: Start drawing
      if (toolMode === 'WALL') {
        if (!startPoint) {
          // Snap start point to existing wall endpoints
          let snappedStart = point;
          const snapDistance = 0.5;

          elements.forEach((el) => {
            if (el.geometry && (el.geometry as Geometry).type === 'line') {
              const geo = el.geometry as LineGeometry;
              if (Math.hypot(point.x - geo.start.x, point.y - geo.start.y) < snapDistance) {
                snappedStart = geo.start;
              }
              if (Math.hypot(point.x - geo.end.x, point.y - geo.end.y) < snapDistance) {
                snappedStart = geo.end;
              }
            }
          });

          setStartPoint(snappedStart);
        } else {
          // Snap end point to existing wall endpoints
          let snappedEnd = point;
          const snapDistance = 0.5;

          elements.forEach((el) => {
            if (el.geometry && (el.geometry as Geometry).type === 'line') {
              const geo = el.geometry as LineGeometry;
              if (Math.hypot(point.x - geo.start.x, point.y - geo.start.y) < snapDistance) {
                snappedEnd = geo.start;
              }
              if (Math.hypot(point.x - geo.end.x, point.y - geo.end.y) < snapDistance) {
                snappedEnd = geo.end;
              }
            }
          });

          // Complete the wall
          const metadata = getFixtureTypeMetadata('wall');
          onElementCreate({
            name: metadata.label,
            elementType: 'barrier',
            visualType: 'wall',
            geometry: {
              type: 'line',
              start: startPoint,
              end: snappedEnd,
            },
            thickness: metadata.defaultThickness,
            fillColor: metadata.defaultColor,
            opacity: 1,
          });
          setStartPoint(null);
        }
        return;
      }

      // RECTANGLE mode: Start drawing
      if (toolMode === 'RECTANGLE') {
        setStartPoint(point);
        setIsDrawing(true);
        return;
      }

      // CIRCLE mode: Place circle
      if (toolMode === 'CIRCLE') {
        // Apply auto-offset to prevent stacking
        const offsetCenter = {
          x: point.x + placementOffset * 0.5,
          y: point.y + placementOffset * 0.5,
        };
        setPlacementOffset((prev) => (prev + 1) % 10);

        const metadata = getFixtureTypeMetadata(fixtureType);
        onElementCreate({
          name: metadata.label,
          elementType: metadata.category === 'zone' ? 'decoration' : 'barrier',
          visualType: fixtureType,
          geometry: {
            type: 'circle',
            x: offsetCenter.x,
            y: offsetCenter.y,
            radius: 1,
          },
          fillColor: metadata.defaultColor,
          opacity: metadata.category === 'zone' ? 0.3 : 1,
        });
        return;
      }

      // DELETE mode: Delete element
      if (toolMode === 'DELETE') {
        const elementToDelete = elements.find((el) => isPointInElement(point, el));
        if (elementToDelete) {
          onElementDelete(elementToDelete.id);
        }
        return;
      }

      // SELECT mode: Select element
      if (toolMode === 'SELECT') {
        const clickedElement = elements.find((el) => isPointInElement(point, el));
        onElementSelect(clickedElement ? clickedElement.id : null);
      }
    },
    [
      toolMode,
      fixtureType,
      selectedElementId,
      startPoint,
      elements,
      placementOffset,
      screenToFloor,
      isPointInElement,
      getElementBounds,
      onElementSelect,
      onElementCreate,
      onElementDelete,
    ]
  );

  // Handle mouse move
  const handleMouseMove = useCallback(
    (event: React.MouseEvent) => {
      const point = screenToFloor(event.clientX, event.clientY);
      setCurrentPoint(point);

      // Handle dragging
      if (isDragging && selectedElementId && dragOffset) {
        const element = elements.find((e) => e.id === selectedElementId);
        if (element && element.geometry) {
          const geo = element.geometry as Geometry;
          const newX = point.x - dragOffset.x;
          const newY = point.y - dragOffset.y;

          if (geo.type === 'rectangle') {
            onElementUpdate(selectedElementId, {
              geometry: { ...geo, x: newX, y: newY },
            });
          } else if (geo.type === 'circle') {
            onElementUpdate(selectedElementId, {
              geometry: { ...geo, x: newX + geo.radius, y: newY + geo.radius },
            });
          }
        }
      }
    },
    [screenToFloor, isDragging, selectedElementId, dragOffset, elements, onElementUpdate]
  );

  // Handle mouse up
  const handleMouseUp = useCallback(
    (event: React.MouseEvent) => {
      // End dragging
      if (isDragging) {
        setIsDragging(false);
        setDragOffset(null);
        return;
      }

      // RECTANGLE mode: Complete drawing
      if (toolMode === 'RECTANGLE' && isDrawing && startPoint) {
        const point = screenToFloor(event.clientX, event.clientY);
        const width = Math.abs(point.x - startPoint.x);
        const height = Math.abs(point.y - startPoint.y);

        // Only create if has some size
        if (width > 0.5 && height > 0.5) {
          const position = {
            x: Math.min(startPoint.x, point.x) + placementOffset * 0.5,
            y: Math.min(startPoint.y, point.y) + placementOffset * 0.5,
          };
          setPlacementOffset((prev) => (prev + 1) % 10);

          const metadata = getFixtureTypeMetadata(fixtureType);
          onElementCreate({
            name: metadata.label,
            elementType: metadata.category === 'zone' ? 'decoration' : 'barrier',
            visualType: fixtureType,
            geometry: {
              type: 'rectangle',
              x: position.x,
              y: position.y,
              width,
              height,
            },
            fillColor: metadata.defaultColor,
            opacity: metadata.category === 'zone' ? 0.3 : 1,
          });
        }

        setStartPoint(null);
        setIsDrawing(false);
      }
    },
    [isDragging, toolMode, isDrawing, startPoint, fixtureType, placementOffset, screenToFloor, onElementCreate]
  );

  // Render preview for current drawing
  const renderPreview = () => {
    if (!currentPoint) return null;

    // WALL mode: Preview line from start point to current
    if (toolMode === 'WALL' && startPoint) {
      const dx = currentPoint.x - startPoint.x;
      const dy = currentPoint.y - startPoint.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);

      return (
        <div
          style={{
            position: 'absolute',
            left: feetToPixels(startPoint.x),
            top: feetToPixels(startPoint.y - 0.25),
            width: feetToPixels(length),
            height: feetToPixels(0.5),
            backgroundColor: '#3498db',
            opacity: 0.5,
            transform: `rotate(${angle}deg)`,
            transformOrigin: 'left center',
            pointerEvents: 'none',
          }}
        />
      );
    }

    // RECTANGLE mode: Preview rectangle
    if (toolMode === 'RECTANGLE' && isDrawing && startPoint) {
      const width = Math.abs(currentPoint.x - startPoint.x);
      const height = Math.abs(currentPoint.y - startPoint.y);
      const position = {
        x: Math.min(startPoint.x, currentPoint.x),
        y: Math.min(startPoint.y, currentPoint.y),
      };

      return (
        <div
          style={{
            position: 'absolute',
            left: feetToPixels(position.x),
            top: feetToPixels(position.y),
            width: feetToPixels(width),
            height: feetToPixels(height),
            backgroundColor: getFixtureTypeMetadata(fixtureType).defaultColor,
            opacity: 0.5,
            border: '2px dashed #3498db',
            pointerEvents: 'none',
          }}
        />
      );
    }

    return null;
  };

  // Render elements
  const renderElements = () => {
    return elements.map((element) => {
      const isSelected = element.id === selectedElementId;
      const baseStyle: React.CSSProperties = {
        position: 'absolute',
        backgroundColor: element.fillColor || '#888',
        opacity: element.opacity,
        cursor: toolMode === 'SELECT' ? (element.isLocked ? 'not-allowed' : 'move') : toolMode === 'DELETE' ? 'pointer' : 'default',
        border: isSelected ? '2px solid #3498db' : 'none',
        boxShadow: isSelected ? '0 0 8px rgba(52, 152, 219, 0.5)' : 'none',
      };

      if (element.geometry) {
        const geo = element.geometry as Geometry;

        if (geo.type === 'rectangle') {
          return (
            <div
              key={element.id}
              style={{
                ...baseStyle,
                left: feetToPixels(geo.x),
                top: feetToPixels(geo.y),
                width: feetToPixels(geo.width),
                height: feetToPixels(geo.height),
                transform: `rotate(${element.rotation}deg)`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
              title={element.name}
            >
              <span
                style={{
                  fontSize: 10,
                  fontWeight: 600,
                  color: '#fff',
                  textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                  pointerEvents: 'none',
                  whiteSpace: 'nowrap',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  maxWidth: '90%',
                  textAlign: 'center',
                }}
              >
                {element.name}
              </span>
            </div>
          );
        }

        if (geo.type === 'circle') {
          return (
            <div
              key={element.id}
              style={{
                ...baseStyle,
                left: feetToPixels(geo.x - geo.radius),
                top: feetToPixels(geo.y - geo.radius),
                width: feetToPixels(geo.radius * 2),
                height: feetToPixels(geo.radius * 2),
                borderRadius: '50%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
              title={element.name}
            >
              <span
                style={{
                  fontSize: 10,
                  fontWeight: 600,
                  color: '#fff',
                  textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                  pointerEvents: 'none',
                  whiteSpace: 'nowrap',
                  textAlign: 'center',
                }}
              >
                {element.name}
              </span>
            </div>
          );
        }

        if (geo.type === 'line') {
          const thickness = element.thickness || 0.5;
          const dx = geo.end.x - geo.start.x;
          const dy = geo.end.y - geo.start.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * (180 / Math.PI);

          return (
            <div
              key={element.id}
              style={{
                ...baseStyle,
                left: feetToPixels(geo.start.x),
                top: feetToPixels(geo.start.y - thickness / 2),
                width: feetToPixels(length),
                height: feetToPixels(thickness),
                transform: `rotate(${angle}deg)`,
                transformOrigin: 'left center',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
              title={element.name}
            >
              <span
                style={{
                  fontSize: 10,
                  fontWeight: 600,
                  color: '#fff',
                  textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                  pointerEvents: 'none',
                  whiteSpace: 'nowrap',
                  backgroundColor: 'rgba(0,0,0,0.3)',
                  padding: '2px 6px',
                  borderRadius: 3,
                }}
              >
                {element.name}
              </span>
            </div>
          );
        }
      }

      // Fallback: use pixel-based positioning
      return (
        <div
          key={element.id}
          style={{
            ...baseStyle,
            left: element.posX,
            top: element.posY,
            width: element.width,
            height: element.height,
            transform: `rotate(${element.rotation}deg)`,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
          title={element.name}
        >
          <span
            style={{
              fontSize: 10,
              fontWeight: 600,
              color: '#fff',
              textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
              pointerEvents: 'none',
            }}
          >
            {element.name}
          </span>
        </div>
      );
    });
  };

  // Render grid
  const renderGrid = () => {
    const gridSizePx = feetToPixels(section.gridSizeFeet);
    const verticalLines: number[] = [];
    const horizontalLines: number[] = [];

    for (let x = 0; x <= canvasWidthPx; x += gridSizePx) {
      verticalLines.push(x);
    }
    for (let y = 0; y <= canvasHeightPx; y += gridSizePx) {
      horizontalLines.push(y);
    }

    return (
      <svg
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: canvasWidthPx,
          height: canvasHeightPx,
          pointerEvents: 'none',
        }}
      >
        {verticalLines.map((x) => (
          <line
            key={`v-${x}`}
            x1={x}
            y1={0}
            x2={x}
            y2={canvasHeightPx}
            stroke="#e0e0e0"
            strokeWidth={1}
          />
        ))}
        {horizontalLines.map((y) => (
          <line
            key={`h-${y}`}
            x1={0}
            y1={y}
            x2={canvasWidthPx}
            y2={y}
            stroke="#e0e0e0"
            strokeWidth={1}
          />
        ))}
      </svg>
    );
  };

  return (
    <div
      ref={canvasRef}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      style={{
        position: 'relative',
        width: canvasWidthPx,
        height: canvasHeightPx,
        backgroundColor: '#f5f5f5',
        border: '2px solid #ccc',
        borderRadius: 8,
        overflow: 'hidden',
        cursor: toolMode === 'SELECT' ? 'default' : 'crosshair',
      }}
    >
      {/* Grid */}
      {renderGrid()}

      {/* Elements */}
      {renderElements()}

      {/* Preview */}
      {renderPreview()}

      {/* Room info */}
      <div
        style={{
          position: 'absolute',
          bottom: 8,
          left: 8,
          padding: '4px 8px',
          backgroundColor: 'rgba(0, 0, 0, 0.6)',
          color: 'white',
          borderRadius: 4,
          fontSize: 12,
          pointerEvents: 'none',
        }}
      >
        {section.name} ({section.widthFeet}ft x {section.heightFeet}ft)
      </div>

      {/* Cursor position */}
      {currentPoint && (
        <div
          style={{
            position: 'absolute',
            top: 8,
            right: 8,
            padding: '4px 8px',
            backgroundColor: 'rgba(0, 0, 0, 0.6)',
            color: 'white',
            borderRadius: 4,
            fontSize: 12,
            pointerEvents: 'none',
            fontFamily: 'monospace',
          }}
        >
          ({currentPoint.x.toFixed(1)}, {currentPoint.y.toFixed(1)})
        </div>
      )}
    </div>
  );
}

export default EditorCanvasDB;



################################################################################
# FILE: src/domains/floor-plan/admin/EntertainmentProperties.tsx
################################################################################

'use client'

import React from 'react'
import { EntertainmentVisual, ENTERTAINMENT_VISUAL_OPTIONS, type EntertainmentVisualType } from '@/components/floor-plan/entertainment-visuals'

interface EntertainmentPropertiesProps {
  element: {
    id: string
    name: string
    visualType: string
    linkedMenuItemId?: string
    linkedMenuItem?: { name: string; price: number; blockTimeMinutes?: number }
    width: number
    height: number
    rotation: number
    status?: string
  }
  onUpdate: (updates: Partial<{ visualType: string; width: number; height: number; rotation: number }>) => void
  onDelete: () => void
}

export function EntertainmentProperties({ element, onUpdate, onDelete }: EntertainmentPropertiesProps) {
  return (
    <div className="p-4 space-y-4">
      <h3 className="text-lg font-semibold text-white flex items-center gap-2">
         Entertainment Properties
      </h3>

      {/* Preview */}
      <div className="flex justify-center p-4 bg-slate-800 rounded-lg">
        <div style={{ width: 100, height: 60 }}>
          <EntertainmentVisual
            visualType={element.visualType as EntertainmentVisualType}
            status={(element.status as 'available' | 'in_use' | 'reserved' | 'maintenance') || 'available'}
            width={100}
            height={60}
          />
        </div>
      </div>

      {/* Name (read-only) */}
      <div>
        <label className="block text-sm text-slate-400 mb-1">Name</label>
        <div className="px-3 py-2 bg-slate-800 rounded text-white">{element.name}</div>
      </div>

      {/* Linked Menu Item */}
      {element.linkedMenuItem && (
        <div className="p-3 bg-slate-800/50 rounded-lg space-y-1">
          <div className="text-xs text-slate-400">Linked Menu Item</div>
          <div className="text-white font-medium">{element.linkedMenuItem.name}</div>
          <div className="text-green-400">${element.linkedMenuItem.price?.toFixed(2)}</div>
          {element.linkedMenuItem.blockTimeMinutes && (
            <div className="text-slate-300 text-sm">{element.linkedMenuItem.blockTimeMinutes} min block</div>
          )}
        </div>
      )}

      {/* Visual Type Grid */}
      <div>
        <label className="block text-sm text-slate-400 mb-2">Visual Style</label>
        <div className="grid grid-cols-4 gap-2">
          {ENTERTAINMENT_VISUAL_OPTIONS.map((opt) => (
            <button
              key={opt.value}
              onClick={() => onUpdate({ visualType: opt.value })}
              className={`p-2 rounded-lg border-2 transition-colors ${
                element.visualType === opt.value
                  ? 'border-purple-500 bg-purple-500/20'
                  : 'border-slate-700 hover:border-slate-500'
              }`}
              title={opt.label}
            >
              <EntertainmentVisual visualType={opt.value} status="available" width={40} height={32} />
            </button>
          ))}
        </div>
      </div>

      {/* Dimensions */}
      <div className="grid grid-cols-2 gap-3">
        <div>
          <label className="block text-sm text-slate-400 mb-1">Width</label>
          <input
            type="number"
            value={element.width}
            onChange={(e) => onUpdate({ width: Number(e.target.value) })}
            className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded text-white"
          />
        </div>
        <div>
          <label className="block text-sm text-slate-400 mb-1">Height</label>
          <input
            type="number"
            value={element.height}
            onChange={(e) => onUpdate({ height: Number(e.target.value) })}
            className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded text-white"
          />
        </div>
      </div>

      {/* Rotation */}
      <div>
        <label className="block text-sm text-slate-400 mb-1">Rotation: {element.rotation}</label>
        <input
          type="range"
          min="0"
          max="360"
          step="15"
          value={element.rotation}
          onChange={(e) => onUpdate({ rotation: Number(e.target.value) })}
          className="w-full"
        />
      </div>

      {/* Delete */}
      <button
        onClick={onDelete}
        className="w-full mt-4 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg"
      >
        Remove from Floor Plan
      </button>
      <p className="text-xs text-slate-500 text-center">Removes from floor plan only. Menu item remains.</p>
    </div>
  )
}



################################################################################
# FILE: src/domains/floor-plan/admin/FixtureProperties.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Fixture Properties Panel
 *
 * Panel for editing selected fixture properties.
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import type { Fixture } from '../shared/types';
import { FloorCanvasAPI } from '../canvas';
import { FIXTURE_TYPES, getFixtureTypeMetadata } from './types';

// =============================================================================
// TYPES
// =============================================================================

interface FixturePropertiesProps {
  fixtureId: string | null;
  onUpdate: (fixtureId: string, updates: Partial<Fixture>) => void;
  onDelete: (fixtureId: string) => void;
  // Database mode props
  useDatabase?: boolean;
  dbFixtures?: Fixture[];
}

// =============================================================================
// COMPONENT
// =============================================================================

export function FixtureProperties({
  fixtureId,
  onUpdate,
  onDelete,
  useDatabase = false,
  dbFixtures,
}: FixturePropertiesProps) {
  const [fixture, setFixture] = useState<Fixture | null>(null);
  const [label, setLabel] = useState('');
  const [color, setColor] = useState('#424242');
  const [thickness, setThickness] = useState(0.5);
  const [opacity, setOpacity] = useState(1);
  const rotationIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Load fixture data when selection changes
  useEffect(() => {
    if (!fixtureId) {
      setFixture(null);
      return;
    }

    let foundFixture: Fixture | null = null;

    if (useDatabase && dbFixtures) {
      // Database mode: find from props
      foundFixture = dbFixtures.find((f) => f.id === fixtureId) || null;
    } else {
      // In-memory mode: find from API
      const allRooms = FloorCanvasAPI.getAllRooms();
      for (const room of allRooms) {
        const fixtures = FloorCanvasAPI.getFixtures(room.id);
        foundFixture = fixtures.find((f) => f.id === fixtureId) || null;
        if (foundFixture) break;
      }
    }

    if (foundFixture) {
      setFixture(foundFixture);
      setLabel(foundFixture.label);
      setColor(foundFixture.color);
      setThickness(foundFixture.thickness);
      setOpacity(foundFixture.opacity);
    }
  }, [fixtureId, useDatabase, dbFixtures]);

  // Keep fixture state fresh with fast polling (for slider thumb to move) - in-memory mode only
  useEffect(() => {
    if (!fixtureId) return;
    if (useDatabase) return; // Database mode uses dbFixtures prop

    const intervalId = setInterval(() => {
      const allRooms = FloorCanvasAPI.getAllRooms();
      let foundFixture: Fixture | null = null;

      for (const room of allRooms) {
        const fixtures = FloorCanvasAPI.getFixtures(room.id);
        foundFixture = fixtures.find((f) => f.id === fixtureId) || null;
        if (foundFixture) break;
      }

      if (foundFixture) {
        setFixture(foundFixture);
      }
    }, 50); // Fast polling to keep slider thumb position updated

    return () => clearInterval(intervalId);
  }, [fixtureId, useDatabase]);

  // Handle property updates
  const handleLabelChange = (value: string) => {
    setLabel(value);
    if (fixtureId) {
      onUpdate(fixtureId, { label: value });
    }
  };

  const handleColorChange = (value: string) => {
    setColor(value);
    if (fixtureId) {
      onUpdate(fixtureId, { color: value });
    }
  };

  const handleThicknessChange = (value: number) => {
    setThickness(value);
    if (fixtureId) {
      onUpdate(fixtureId, { thickness: value });
    }
  };

  const handleOpacityChange = (value: number) => {
    setOpacity(value);
    if (fixtureId) {
      onUpdate(fixtureId, { opacity: value });
    }
  };

  const handleRotationChange = (value: number) => {
    if (fixtureId && fixture && fixture.geometry.type === 'rectangle') {
      onUpdate(fixtureId, {
        geometry: {
          ...fixture.geometry,
          rotation: value,
        },
      });
    }
  };

  const handleRadiusChange = (value: number) => {
    if (fixtureId && fixture && fixture.geometry.type === 'circle') {
      onUpdate(fixtureId, {
        geometry: {
          ...fixture.geometry,
          radius: value,
        },
      });
    }
  };

  const handleTypeChange = (newType: string) => {
    if (fixtureId) {
      const metadata = getFixtureTypeMetadata(newType as any);
      onUpdate(fixtureId, {
        type: newType as any,
        label: metadata.label,
      });
    }
  };

  // Rotation adjustment functions - fetches current state to avoid stale closure
  const adjustRotation = useCallback((delta: number) => {
    if (!fixtureId || !fixture) return;

    let currentFixture: Fixture | null = null;

    if (useDatabase && dbFixtures) {
      // Database mode: find from props
      currentFixture = dbFixtures.find((f) => f.id === fixtureId) || null;
    } else {
      // In-memory mode: Get CURRENT rotation from the fixture (not from closure)
      const allRooms = FloorCanvasAPI.getAllRooms();
      for (const room of allRooms) {
        const fixtures = FloorCanvasAPI.getFixtures(room.id);
        currentFixture = fixtures.find((f) => f.id === fixtureId) || null;
        if (currentFixture) break;
      }
    }

    if (!currentFixture || currentFixture.geometry.type !== 'rectangle') return;

    const currentRotation = currentFixture.geometry.rotation || 0;
    let newRotation = currentRotation + delta;

    // Normalize to 0-360 range
    if (newRotation < 0) newRotation += 360;
    if (newRotation >= 360) newRotation -= 360;

    onUpdate(fixtureId, {
      geometry: { ...currentFixture.geometry, rotation: newRotation },
    });
  }, [fixtureId, fixture, onUpdate, useDatabase, dbFixtures]);

  const startContinuousRotation = useCallback((delta: number) => {
    // Fire immediately
    adjustRotation(delta);

    // Clear any existing interval
    if (rotationIntervalRef.current) {
      clearInterval(rotationIntervalRef.current);
    }

    // Start new interval for continuous rotation
    rotationIntervalRef.current = setInterval(() => {
      adjustRotation(delta);
    }, 50); // 50ms = 20 updates per second for smooth feel
  }, [adjustRotation]);

  const stopContinuousRotation = useCallback(() => {
    if (rotationIntervalRef.current) {
      clearInterval(rotationIntervalRef.current);
      rotationIntervalRef.current = null;
    }
  }, []);

  // Cleanup interval on unmount
  useEffect(() => {
    return () => {
      if (rotationIntervalRef.current) {
        clearInterval(rotationIntervalRef.current);
      }
    };
  }, []);

  const handleDelete = () => {
    if (fixtureId && window.confirm('Delete this fixture?')) {
      onDelete(fixtureId);
    }
  };

  if (!fixture) {
    return (
      <div
        style={{
          padding: 16,
          backgroundColor: '#f5f5f5',
          borderRadius: 8,
          height: '100%',
        }}
      >
        <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
          Properties
        </h3>
        <p style={{ color: '#999', fontSize: 12 }}>
          No fixture selected. Click a fixture to edit its properties.
        </p>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: 16,
        backgroundColor: '#f5f5f5',
        borderRadius: 8,
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        gap: 16,
      }}
    >
      <h3 style={{ margin: 0, fontSize: 14, fontWeight: 600 }}>
        Properties
      </h3>

      {/* Fixture Type */}
      <div>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Type
        </label>
        <select
          value={fixture.type}
          onChange={(e) => handleTypeChange(e.target.value)}
          style={{
            width: '100%',
            padding: '6px 8px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: 4,
            fontSize: 12,
            cursor: 'pointer',
          }}
        >
          {FIXTURE_TYPES.map((ft) => (
            <option key={ft.type} value={ft.type}>
              {ft.label}
            </option>
          ))}
        </select>
      </div>

      {/* Label */}
      <div>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Label
        </label>
        <input
          type="text"
          value={label}
          onChange={(e) => handleLabelChange(e.target.value)}
          style={{
            width: '100%',
            padding: '6px 8px',
            border: '1px solid #ccc',
            borderRadius: 4,
            fontSize: 12,
          }}
        />
      </div>

      {/* Color */}
      <div>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Color
        </label>
        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <input
            type="color"
            value={color}
            onChange={(e) => handleColorChange(e.target.value)}
            style={{
              width: 40,
              height: 32,
              border: '1px solid #ccc',
              borderRadius: 4,
              cursor: 'pointer',
            }}
          />
          <input
            type="text"
            value={color}
            onChange={(e) => handleColorChange(e.target.value)}
            style={{
              flex: 1,
              padding: '6px 8px',
              border: '1px solid #ccc',
              borderRadius: 4,
              fontSize: 12,
              fontFamily: 'monospace',
            }}
          />
        </div>
      </div>

      {/* Thickness (for lines/walls) */}
      {fixture.geometry.type === 'line' && (
        <div>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Thickness (feet)
          </label>
          <input
            type="number"
            value={thickness}
            onChange={(e) => handleThicknessChange(parseFloat(e.target.value) || 0)}
            step={0.1}
            min={0.1}
            max={5}
            style={{
              width: '100%',
              padding: '6px 8px',
              border: '1px solid #ccc',
              borderRadius: 4,
              fontSize: 12,
            }}
          />
        </div>
      )}

      {/* Opacity */}
      <div>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Opacity: {Math.round(opacity * 100)}%
        </label>
        <input
          type="range"
          value={opacity}
          onChange={(e) => handleOpacityChange(parseFloat(e.target.value))}
          min={0.1}
          max={1}
          step={0.1}
          style={{
            width: '100%',
            accentColor: '#3498db',
            cursor: 'pointer',
          }}
        />
      </div>

      {/* Radius (for circles) */}
      {fixture.geometry.type === 'circle' && (
        <div>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Radius: {fixture.geometry.radius.toFixed(1)} ft
          </label>
          <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
            <input
              type="range"
              value={fixture.geometry.radius}
              onChange={(e) => handleRadiusChange(parseFloat(e.target.value))}
              min={0.25}
              max={10}
              step={0.1}
              style={{
                flex: 1,
                accentColor: '#3498db',
                cursor: 'pointer',
              }}
            />
            <input
              type="number"
              value={fixture.geometry.radius}
              onChange={(e) => handleRadiusChange(parseFloat(e.target.value) || 0.25)}
              min={0.25}
              max={10}
              step={0.1}
              style={{
                width: 60,
                padding: '4px 6px',
                border: '1px solid #ccc',
                borderRadius: 4,
                fontSize: 12,
                textAlign: 'center',
              }}
            />
            <span style={{ fontSize: 12, color: '#666' }}>ft</span>
          </div>
        </div>
      )}

      {/* Dimensions (for rectangles) */}
      {fixture.geometry.type === 'rectangle' && (
        <div>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Dimensions
          </label>
          <div style={{ display: 'flex', gap: 8 }}>
            <div style={{ flex: 1 }}>
              <label style={{ display: 'block', fontSize: 11, color: '#666', marginBottom: 2 }}>
                Width (ft)
              </label>
              <input
                type="number"
                value={fixture.geometry.width}
                onChange={(e) => {
                  const newWidth = parseFloat(e.target.value) || 0.5;
                  if (fixtureId && fixture.geometry.type === 'rectangle') {
                    onUpdate(fixtureId, {
                      geometry: {
                        type: 'rectangle',
                        position: fixture.geometry.position,
                        width: newWidth,
                        height: fixture.geometry.height,
                        rotation: fixture.geometry.rotation,
                      },
                    });
                  }
                }}
                min={0.5}
                max={50}
                step={0.5}
                style={{
                  width: '100%',
                  padding: '4px 6px',
                  border: '1px solid #ccc',
                  borderRadius: 4,
                  fontSize: 12,
                  textAlign: 'center',
                }}
              />
            </div>
            <div style={{ flex: 1 }}>
              <label style={{ display: 'block', fontSize: 11, color: '#666', marginBottom: 2 }}>
                Height (ft)
              </label>
              <input
                type="number"
                value={fixture.geometry.height}
                onChange={(e) => {
                  const newHeight = parseFloat(e.target.value) || 0.5;
                  if (fixtureId && fixture.geometry.type === 'rectangle') {
                    onUpdate(fixtureId, {
                      geometry: {
                        type: 'rectangle',
                        position: fixture.geometry.position,
                        width: fixture.geometry.width,
                        height: newHeight,
                        rotation: fixture.geometry.rotation,
                      },
                    });
                  }
                }}
                min={0.5}
                max={50}
                step={0.5}
                style={{
                  width: '100%',
                  padding: '4px 6px',
                  border: '1px solid #ccc',
                  borderRadius: 4,
                  fontSize: 12,
                  textAlign: 'center',
                }}
              />
            </div>
          </div>
        </div>
      )}

      {/* Rotation (for rectangles) */}
      {fixture.geometry.type === 'rectangle' && (
        <div>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Rotation: {fixture.geometry.rotation || 0}
          </label>

          {/* Fine Control Buttons + Slider + Number Input */}
          <div style={{ display: 'flex', gap: 2, alignItems: 'center', marginBottom: 8 }}>
            <button
              onMouseDown={() => startContinuousRotation(-5)}
              onMouseUp={stopContinuousRotation}
              onMouseLeave={stopContinuousRotation}
              style={{
                flex: 1,
                padding: '4px 2px',
                fontSize: 10,
                border: '1px solid #ccc',
                borderRadius: 4,
                backgroundColor: 'white',
                cursor: 'pointer',
                userSelect: 'none',
              }}
            >
              -5
            </button>
            <button
              onMouseDown={() => startContinuousRotation(-1)}
              onMouseUp={stopContinuousRotation}
              onMouseLeave={stopContinuousRotation}
              style={{
                flex: 1,
                padding: '4px 2px',
                fontSize: 10,
                border: '1px solid #ccc',
                borderRadius: 4,
                backgroundColor: 'white',
                cursor: 'pointer',
                userSelect: 'none',
              }}
            >
              -1
            </button>
            <input
              type="range"
              value={fixture.geometry.rotation || 0}
              onChange={(e) => handleRotationChange(parseInt(e.target.value))}
              min={0}
              max={360}
              step={1}
              style={{
                flex: 2,
                accentColor: '#3498db',
                cursor: 'pointer',
              }}
            />
            <button
              onMouseDown={() => startContinuousRotation(1)}
              onMouseUp={stopContinuousRotation}
              onMouseLeave={stopContinuousRotation}
              style={{
                flex: 1,
                padding: '4px 2px',
                fontSize: 10,
                border: '1px solid #ccc',
                borderRadius: 4,
                backgroundColor: 'white',
                cursor: 'pointer',
                userSelect: 'none',
              }}
            >
              +1
            </button>
            <button
              onMouseDown={() => startContinuousRotation(5)}
              onMouseUp={stopContinuousRotation}
              onMouseLeave={stopContinuousRotation}
              style={{
                flex: 1,
                padding: '4px 2px',
                fontSize: 10,
                border: '1px solid #ccc',
                borderRadius: 4,
                backgroundColor: 'white',
                cursor: 'pointer',
                userSelect: 'none',
              }}
            >
              +5
            </button>
          </div>

          {/* Number Input + Degree Symbol on separate row */}
          <div style={{ display: 'flex', gap: 4, alignItems: 'center', marginBottom: 8 }}>
            <input
              type="number"
              value={fixture.geometry.rotation || 0}
              onChange={(e) => handleRotationChange(parseInt(e.target.value) || 0)}
              min={0}
              max={360}
              style={{
                flex: 1,
                padding: '4px 6px',
                border: '1px solid #ccc',
                borderRadius: 4,
                fontSize: 12,
                textAlign: 'center',
              }}
            />
            <span style={{ fontSize: 12, color: '#666' }}></span>
          </div>

          {/* Quick Angle Buttons */}
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 4 }}>
            {[0, 45, 90, 135, 180, 225, 270, 315].map((angle) => (
              <button
                key={angle}
                onClick={() => handleRotationChange(angle)}
                style={{
                  padding: '4px 8px',
                  fontSize: 11,
                  border: '1px solid #ccc',
                  borderRadius: 4,
                  backgroundColor: (fixture.geometry.type === 'rectangle' && fixture.geometry.rotation === angle) ? '#e3f2fd' : 'white',
                  cursor: 'pointer',
                  fontWeight: (fixture.geometry.type === 'rectangle' && fixture.geometry.rotation === angle) ? 600 : 400,
                }}
              >
                {angle}
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Geometry Info */}
      <div>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Geometry
        </label>
        <div
          style={{
            padding: '6px 8px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: 4,
            fontSize: 11,
            fontFamily: 'monospace',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-all',
          }}
        >
          {fixture.geometry.type === 'line' && (
            <>
              Start: ({fixture.geometry.start.x.toFixed(1)}, {fixture.geometry.start.y.toFixed(1)})<br />
              End: ({fixture.geometry.end.x.toFixed(1)}, {fixture.geometry.end.y.toFixed(1)})
            </>
          )}
          {fixture.geometry.type === 'rectangle' && (
            <>
              Position: ({fixture.geometry.position.x.toFixed(1)}, {fixture.geometry.position.y.toFixed(1)})<br />
              Size: {fixture.geometry.width.toFixed(1)} x {fixture.geometry.height.toFixed(1)}
            </>
          )}
          {fixture.geometry.type === 'circle' && (
            <>
              Center: ({fixture.geometry.center.x.toFixed(1)}, {fixture.geometry.center.y.toFixed(1)})<br />
              Radius: {fixture.geometry.radius.toFixed(1)}
            </>
          )}
        </div>
      </div>

      {/* Delete Button */}
      <button
        onClick={handleDelete}
        style={{
          marginTop: 'auto',
          padding: '8px 16px',
          backgroundColor: '#f44336',
          color: 'white',
          border: 'none',
          borderRadius: 4,
          cursor: 'pointer',
          fontSize: 12,
          fontWeight: 600,
        }}
      >
        Delete Fixture
      </button>
    </div>
  );
}

export default FixtureProperties;



################################################################################
# FILE: src/domains/floor-plan/admin/FixturePropertiesDB.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Fixture Properties Panel (Database-Backed)
 *
 * Shows and allows editing of selected element properties.
 */

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { FIXTURE_TYPE_MAP, FixtureType } from './types';

// =============================================================================
// TYPES
// =============================================================================

interface FloorPlanElement {
  id: string;
  name: string;
  elementType: string;
  visualType: string;
  geometry: unknown;
  posX: number;
  posY: number;
  width: number;
  height: number;
  rotation: number;
  thickness: number;
  fillColor: string | null;
  opacity: number;
  isLocked: boolean;
}

interface FixturePropertiesDBProps {
  element: FloorPlanElement | null;
  onUpdate: (elementId: string, updates: Partial<FloorPlanElement>) => void;
  onDelete: (elementId: string) => void;
}

// =============================================================================
// COMPONENT
// =============================================================================

export function FixturePropertiesDB({
  element,
  onUpdate,
  onDelete,
}: FixturePropertiesDBProps) {
  const [localColor, setLocalColor] = useState(element?.fillColor || '#666');
  const [localOpacity, setLocalOpacity] = useState(element?.opacity || 1);
  const [localRotation, setLocalRotation] = useState(0);
  const [localRadius, setLocalRadius] = useState(1);
  const [localThickness, setLocalThickness] = useState(0.5);

  // Interval ref for hold-to-repeat
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Update local state when element changes
  useEffect(() => {
    if (element) {
      setLocalColor(element.fillColor || '#666');
      setLocalOpacity(element.opacity);
      setLocalThickness(element.thickness || 0.5);

      // Extract rotation from geometry or element
      if (element.geometry) {
        const geo = element.geometry as { type: string; radius?: number };
        if (geo.type === 'circle' && geo.radius) {
          setLocalRadius(geo.radius);
        }
      }
      setLocalRotation(element.rotation);
    }
  }, [element]);

  // Handle color change
  const handleColorChange = useCallback(
    (color: string) => {
      setLocalColor(color);
      if (element) {
        onUpdate(element.id, { fillColor: color });
      }
    },
    [element, onUpdate]
  );

  // Handle opacity change
  const handleOpacityChange = useCallback(
    (opacity: number) => {
      setLocalOpacity(opacity);
      if (element) {
        onUpdate(element.id, { opacity });
      }
    },
    [element, onUpdate]
  );

  // Handle rotation change
  const handleRotationChange = useCallback(
    (rotation: number) => {
      const normalizedRotation = ((rotation % 360) + 360) % 360;
      setLocalRotation(normalizedRotation);
      if (element) {
        onUpdate(element.id, { rotation: normalizedRotation });
      }
    },
    [element, onUpdate]
  );

  // Handle radius change (for circles)
  const handleRadiusChange = useCallback(
    (radius: number) => {
      setLocalRadius(radius);
      if (element && element.geometry) {
        const geo = element.geometry as { type: string; x: number; y: number };
        if (geo.type === 'circle') {
          onUpdate(element.id, {
            geometry: { ...geo, radius },
          });
        }
      }
    },
    [element, onUpdate]
  );

  // Handle thickness change (for walls)
  const handleThicknessChange = useCallback(
    (thickness: number) => {
      setLocalThickness(thickness);
      if (element) {
        onUpdate(element.id, { thickness });
      }
    },
    [element, onUpdate]
  );

  // Handle type change
  const handleTypeChange = useCallback(
    (newType: FixtureType) => {
      if (element) {
        const metadata = FIXTURE_TYPE_MAP[newType];
        onUpdate(element.id, {
          name: metadata.label,
          visualType: newType,
          fillColor: metadata.defaultColor,
        });
      }
    },
    [element, onUpdate]
  );

  // Fine rotation control with hold-to-repeat
  const startRotationAdjust = useCallback(
    (delta: number) => {
      if (!element) return;

      // Immediate adjustment
      handleRotationChange(localRotation + delta);

      // Start interval for hold-to-repeat
      intervalRef.current = setInterval(() => {
        setLocalRotation((prev) => {
          const newValue = ((prev + delta) % 360 + 360) % 360;
          if (element) {
            onUpdate(element.id, { rotation: newValue });
          }
          return newValue;
        });
      }, 100);
    },
    [element, localRotation, handleRotationChange, onUpdate]
  );

  const stopRotationAdjust = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  // Clean up interval on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  // Get geometry type
  const getGeometryType = (): 'line' | 'rectangle' | 'circle' | null => {
    if (!element?.geometry) return null;
    return (element.geometry as { type: string }).type as 'line' | 'rectangle' | 'circle';
  };

  const geometryType = getGeometryType();

  if (!element) {
    return (
      <div
        style={{
          padding: 16,
          backgroundColor: '#f9f9f9',
          borderRadius: 8,
          border: '1px solid #ddd',
        }}
      >
        <h3 style={{ margin: '0 0 12px 0', fontSize: 14, fontWeight: 600 }}>
          Properties
        </h3>
        <p style={{ color: '#666', fontSize: 13 }}>
          Select an element to edit its properties
        </p>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: 16,
        backgroundColor: '#f9f9f9',
        borderRadius: 8,
        border: '1px solid #ddd',
      }}
    >
      <h3 style={{ margin: '0 0 16px 0', fontSize: 14, fontWeight: 600 }}>
        Properties
      </h3>

      {/* Name */}
      <div style={{ marginBottom: 16 }}>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Name
        </label>
        <div style={{ fontSize: 14, color: '#333' }}>{element.name}</div>
      </div>

      {/* Type Selector */}
      {geometryType === 'rectangle' && (
        <div style={{ marginBottom: 16 }}>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Type
          </label>
          <select
            value={element.visualType}
            onChange={(e) => handleTypeChange(e.target.value as FixtureType)}
            style={{
              width: '100%',
              padding: '8px 12px',
              borderRadius: 6,
              border: '1px solid #ccc',
              fontSize: 14,
            }}
          >
            {Object.entries(FIXTURE_TYPE_MAP).map(([key, value]) => (
              <option key={key} value={key}>
                {value.label}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* Color */}
      <div style={{ marginBottom: 16 }}>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Color
        </label>
        <input
          type="color"
          value={localColor}
          onChange={(e) => handleColorChange(e.target.value)}
          style={{
            width: '100%',
            height: 40,
            border: '1px solid #ccc',
            borderRadius: 6,
            cursor: 'pointer',
          }}
        />
      </div>

      {/* Opacity */}
      <div style={{ marginBottom: 16 }}>
        <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
          Opacity: {(localOpacity * 100).toFixed(0)}%
        </label>
        <input
          type="range"
          min={0.1}
          max={1}
          step={0.1}
          value={localOpacity}
          onChange={(e) => handleOpacityChange(parseFloat(e.target.value))}
          style={{ width: '100%' }}
        />
      </div>

      {/* Rotation (for rectangles) */}
      {geometryType === 'rectangle' && (
        <div style={{ marginBottom: 16 }}>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Rotation: {localRotation}
          </label>
          <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8 }}>
            <input
              type="range"
              min={0}
              max={359}
              step={1}
              value={localRotation}
              onChange={(e) => handleRotationChange(parseInt(e.target.value))}
              style={{ flex: 1 }}
            />
            <input
              type="number"
              min={0}
              max={359}
              value={localRotation}
              onChange={(e) => handleRotationChange(parseInt(e.target.value) || 0)}
              style={{
                width: 60,
                padding: '4px 8px',
                borderRadius: 4,
                border: '1px solid #ccc',
                fontSize: 12,
              }}
            />
          </div>
          {/* Fine rotation buttons */}
          <div style={{ display: 'flex', gap: 4, justifyContent: 'center' }}>
            <button
              onMouseDown={() => startRotationAdjust(-5)}
              onMouseUp={stopRotationAdjust}
              onMouseLeave={stopRotationAdjust}
              style={{
                padding: '4px 8px',
                fontSize: 11,
                borderRadius: 4,
                border: '1px solid #ccc',
                backgroundColor: '#fff',
                cursor: 'pointer',
              }}
            >
              -5
            </button>
            <button
              onMouseDown={() => startRotationAdjust(-1)}
              onMouseUp={stopRotationAdjust}
              onMouseLeave={stopRotationAdjust}
              style={{
                padding: '4px 8px',
                fontSize: 11,
                borderRadius: 4,
                border: '1px solid #ccc',
                backgroundColor: '#fff',
                cursor: 'pointer',
              }}
            >
              -1
            </button>
            <button
              onMouseDown={() => startRotationAdjust(1)}
              onMouseUp={stopRotationAdjust}
              onMouseLeave={stopRotationAdjust}
              style={{
                padding: '4px 8px',
                fontSize: 11,
                borderRadius: 4,
                border: '1px solid #ccc',
                backgroundColor: '#fff',
                cursor: 'pointer',
              }}
            >
              +1
            </button>
            <button
              onMouseDown={() => startRotationAdjust(5)}
              onMouseUp={stopRotationAdjust}
              onMouseLeave={stopRotationAdjust}
              style={{
                padding: '4px 8px',
                fontSize: 11,
                borderRadius: 4,
                border: '1px solid #ccc',
                backgroundColor: '#fff',
                cursor: 'pointer',
              }}
            >
              +5
            </button>
          </div>
        </div>
      )}

      {/* Radius (for circles) */}
      {geometryType === 'circle' && (
        <div style={{ marginBottom: 16 }}>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Radius: {localRadius.toFixed(2)} ft
          </label>
          <input
            type="range"
            min={0.25}
            max={10}
            step={0.1}
            value={localRadius}
            onChange={(e) => handleRadiusChange(parseFloat(e.target.value))}
            style={{ width: '100%' }}
          />
        </div>
      )}

      {/* Thickness (for walls) */}
      {geometryType === 'line' && (
        <div style={{ marginBottom: 16 }}>
          <label style={{ display: 'block', fontSize: 12, fontWeight: 600, marginBottom: 4 }}>
            Thickness: {localThickness.toFixed(2)} ft
          </label>
          <input
            type="range"
            min={0.25}
            max={2}
            step={0.05}
            value={localThickness}
            onChange={(e) => handleThicknessChange(parseFloat(e.target.value))}
            style={{ width: '100%' }}
          />
        </div>
      )}

      {/* Lock toggle */}
      <div style={{ marginBottom: 16 }}>
        <label style={{ display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer' }}>
          <input
            type="checkbox"
            checked={element.isLocked}
            onChange={(e) => onUpdate(element.id, { isLocked: e.target.checked })}
          />
          <span style={{ fontSize: 12 }}>Lock Position</span>
        </label>
      </div>

      {/* Delete Button */}
      <button
        onClick={() => onDelete(element.id)}
        style={{
          width: '100%',
          padding: '10px 16px',
          backgroundColor: '#f44336',
          color: 'white',
          border: 'none',
          borderRadius: 6,
          cursor: 'pointer',
          fontSize: 14,
          fontWeight: 600,
        }}
      >
        Delete Element
      </button>
    </div>
  );
}

export default FixturePropertiesDB;



################################################################################
# FILE: src/domains/floor-plan/admin/FixtureToolbar.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Fixture Toolbar Component
 *
 * Toolbar for selecting editor tools and fixture types.
 */

import React from 'react';
import type { EditorToolMode, FixtureType, TableShape } from './types';
import { FIXTURE_TYPES, TABLE_SHAPES } from './types';

// =============================================================================
// TYPES
// =============================================================================

interface FixtureToolbarProps {
  selectedTool: EditorToolMode;
  selectedFixtureType: FixtureType;
  selectedTableShape?: TableShape;
  onToolSelect: (tool: EditorToolMode) => void;
  onFixtureTypeSelect: (type: FixtureType) => void;
  onTableShapeSelect?: (shape: TableShape) => void;
}

// =============================================================================
// COMPONENT
// =============================================================================

export function FixtureToolbar({
  selectedTool,
  selectedFixtureType,
  selectedTableShape = 'rectangle',
  onToolSelect,
  onFixtureTypeSelect,
  onTableShapeSelect,
}: FixtureToolbarProps) {
  const tools: { mode: EditorToolMode; label: string; icon: React.ReactNode }[] = [
    { mode: 'SELECT', label: 'Select', icon: '' },
    {
      mode: 'TABLE',
      label: 'Table',
      icon: (
        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
          <rect x="3" y="8" width="18" height="3" rx="1" />
          <rect x="5" y="11" width="2" height="8" />
          <rect x="17" y="11" width="2" height="8" />
        </svg>
      )
    },
    { mode: 'WALL', label: 'Wall', icon: '' },
    { mode: 'RECTANGLE', label: 'Fixture', icon: '' },
    { mode: 'CIRCLE', label: 'Circle', icon: '' },
    { mode: 'DELETE', label: 'Delete', icon: '' },
  ];

  // Debug logging for tool selection
  React.useEffect(() => {
    console.log('[FixtureToolbar] selectedTool:', selectedTool);
  }, [selectedTool]);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
      {/* Tool Mode Selector */}
      <div>
        <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
          Tool Mode
        </h3>
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 4 }}>
          {tools.map((tool) => (
            <button
              key={tool.mode}
              onClick={() => onToolSelect(tool.mode)}
              style={{
                padding: '8px 4px',
                border: selectedTool === tool.mode ? '2px solid #3498db' : '1px solid #ccc',
                backgroundColor: selectedTool === tool.mode ? '#e3f2fd' : 'white',
                borderRadius: 6,
                cursor: 'pointer',
                fontSize: 11,
                fontWeight: selectedTool === tool.mode ? 600 : 400,
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: 4,
              }}
            >
              <span style={{ fontSize: 18 }}>{tool.icon}</span>
              <span>{tool.label}</span>
            </button>
          ))}
        </div>
      </div>

      {/* Table Shape Selector (shown for TABLE mode) */}
      {selectedTool === 'TABLE' && onTableShapeSelect && (
        <div>
          <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
            Table Shape
          </h3>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 4 }}>
            {TABLE_SHAPES.map((tableShape) => (
              <button
                key={tableShape.shape}
                onClick={() => onTableShapeSelect(tableShape.shape)}
                style={{
                  padding: '6px 8px',
                  border: selectedTableShape === tableShape.shape ? '2px solid #3498db' : '1px solid #ccc',
                  backgroundColor: selectedTableShape === tableShape.shape ? '#e3f2fd' : 'white',
                  borderRadius: 4,
                  cursor: 'pointer',
                  fontSize: 11,
                  fontWeight: selectedTableShape === tableShape.shape ? 600 : 400,
                  textAlign: 'left',
                  display: 'flex',
                  alignItems: 'center',
                  gap: 6,
                }}
              >
                <span style={{ fontSize: 16 }}>{tableShape.icon}</span>
                <span>{tableShape.label.split(' ')[0]}</span>
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Fixture Type Selector (shown for RECTANGLE and CIRCLE modes) */}
      {(selectedTool === 'RECTANGLE' || selectedTool === 'CIRCLE') && (
        <div>
          <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600 }}>
            Fixture Type
          </h3>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 4 }}>
            {FIXTURE_TYPES.filter((ft) => {
              // Only show rectangle types for RECTANGLE tool
              if (selectedTool === 'RECTANGLE') {
                return !['pillar'].includes(ft.type);
              }
              // Only show circle types for CIRCLE tool
              if (selectedTool === 'CIRCLE') {
                return ['pillar'].includes(ft.type);
              }
              return true;
            }).map((fixtureType) => (
              <button
                key={fixtureType.type}
                onClick={() => onFixtureTypeSelect(fixtureType.type)}
                style={{
                  padding: '6px 8px',
                  border: selectedFixtureType === fixtureType.type ? '2px solid #3498db' : '1px solid #ccc',
                  backgroundColor: selectedFixtureType === fixtureType.type ? '#e3f2fd' : 'white',
                  borderRadius: 4,
                  cursor: 'pointer',
                  fontSize: 11,
                  fontWeight: selectedFixtureType === fixtureType.type ? 600 : 400,
                  textAlign: 'left',
                  display: 'flex',
                  alignItems: 'center',
                  gap: 6,
                }}
              >
                <span
                  style={{
                    display: 'inline-block',
                    width: 16,
                    height: 16,
                    backgroundColor: fixtureType.defaultColor,
                    borderRadius: fixtureType.type === 'pillar' ? '50%' : 2,
                  }}
                />
                <span>{fixtureType.label}</span>
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Hints */}
      <div
        style={{
          padding: 8,
          backgroundColor: '#f5f5f5',
          borderRadius: 4,
          fontSize: 11,
          color: '#666',
        }}
      >
        <strong>Hints:</strong>
        <ul style={{ margin: '4px 0 0 0', paddingLeft: 16 }}>
          {selectedTool === 'SELECT' && (
            <>
              <li>Click to select fixture/table</li>
              <li>Drag to move it</li>
              <li>Press Delete to remove</li>
            </>
          )}
          {selectedTool === 'TABLE' && (
            <>
              <li>Choose shape, then click to place</li>
              <li>Seats auto-generated</li>
              <li>Edit properties on right</li>
            </>
          )}
          {selectedTool === 'WALL' && (
            <>
              <li>Click for start point</li>
              <li>Click again for end point</li>
            </>
          )}
          {selectedTool === 'RECTANGLE' && (
            <>
              <li>Click and drag to draw</li>
              <li>Release to create</li>
            </>
          )}
          {selectedTool === 'CIRCLE' && (
            <>
              <li>Click to place circle</li>
              <li>Default radius: 1 foot</li>
            </>
          )}
          {selectedTool === 'DELETE' && (
            <>
              <li>Click a fixture to delete it</li>
            </>
          )}
        </ul>
      </div>
    </div>
  );
}

export default FixtureToolbar;



################################################################################
# FILE: src/domains/floor-plan/admin/FloorPlanEditor.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Floor Plan Editor Component
 *
 * Main editor interface for creating and editing floor plans.
 * NOW WITH DATABASE PERSISTENCE!
 */

import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { FloorCanvasAPI, RoomSelector } from '../canvas';
import { EditorCanvas } from './EditorCanvas';
import { FixtureToolbar } from './FixtureToolbar';
import { FixtureProperties } from './FixtureProperties';
import { TableProperties } from './TableProperties';
import { EntertainmentProperties } from './EntertainmentProperties';
import { AddEntertainmentPalette } from '@/components/floor-plan/AddEntertainmentPalette';
import type { EditorToolMode, FixtureType, EditorTable, TableShape } from './types';
import type { Fixture } from '../shared/types';
import {
  PIXELS_PER_FOOT,
  ZOOM_MIN,
  ZOOM_MAX,
  ZOOM_STEP,
} from '@/lib/floorplan/constants';

// =============================================================================
// TYPES
// =============================================================================

interface FloorPlanEditorProps {
  initialRoomId?: string;
  locationId?: string;
  useDatabase?: boolean; // Toggle between in-memory and database mode
  onSave?: () => void;
  onExit?: () => void;
}

// Database element type
interface FloorPlanElement {
  id: string;
  name: string;
  elementType: string;
  visualType: string;
  geometry: unknown;
  posX: number;
  posY: number;
  width: number;
  height: number;
  rotation: number;
  thickness: number;
  fillColor: string | null;
  opacity: number;
  isLocked: boolean;
  // Entertainment-specific fields
  linkedMenuItemId?: string;
  linkedMenuItem?: { name: string; price: number; blockTimeMinutes?: number };
  status?: string;
}

// =============================================================================
// DATABASE  EDITOR CONVERSION
// =============================================================================
// Database stores positions in PIXELS for direct FOH rendering
// Editor canvas works in FEET (uses FloorCanvasAPI.feetToPixels for display)
// We convert: DB (pixels)  Editor (feet) using PIXELS_PER_FOOT from constants

function pixelsToFeet(pixels: number): number {
  return pixels / PIXELS_PER_FOOT;
}

function feetToPixels(feet: number): number {
  return feet * PIXELS_PER_FOOT;
}

// Convert database element (PIXELS) to Fixture (FEET) for Editor
function elementToFixture(el: FloorPlanElement, sectionId: string): Fixture {
  // For database mode, we use posX/posY/width/height as the source of truth
  // The geometry field may be out of sync, so we reconstruct it from posX/posY/width/height
  const elementType = el.elementType || 'fixture';
  const geometry = el.geometry as { type: string; [key: string]: unknown } | null;
  const geoType = geometry?.type;

  let fixtureGeometry: Fixture['geometry'];

  if (geoType === 'line') {
    // For lines, use the geometry start/end if available, otherwise derive from posX/posY/width/height
    const geoStart = geometry?.start as { x: number; y: number } | undefined;
    const geoEnd = geometry?.end as { x: number; y: number } | undefined;

    // Convert from pixels to feet
    fixtureGeometry = {
      type: 'line',
      start: geoStart
        ? { x: pixelsToFeet(geoStart.x), y: pixelsToFeet(geoStart.y) }
        : { x: pixelsToFeet(el.posX), y: pixelsToFeet(el.posY) },
      end: geoEnd
        ? { x: pixelsToFeet(geoEnd.x), y: pixelsToFeet(geoEnd.y) }
        : { x: pixelsToFeet(el.posX + el.width), y: pixelsToFeet(el.posY) },
    };
  } else if (geoType === 'circle') {
    // For circles, reconstruct from posX/posY/width/height (more reliable)
    // posX/posY is top-left of bounding box, width=height=diameter
    const centerX = el.posX + el.width / 2;
    const centerY = el.posY + el.height / 2;
    const radius = el.width / 2;

    fixtureGeometry = {
      type: 'circle',
      center: { x: pixelsToFeet(centerX), y: pixelsToFeet(centerY) },
      radius: pixelsToFeet(radius),
    };
  } else {
    // Rectangle - use posX/posY/width/height (always reliable)
    fixtureGeometry = {
      type: 'rectangle',
      position: { x: pixelsToFeet(el.posX), y: pixelsToFeet(el.posY) },
      width: pixelsToFeet(el.width),
      height: pixelsToFeet(el.height),
      rotation: el.rotation || 0,
    };
  }

  return {
    id: el.id,
    floorPlanId: sectionId,
    roomId: sectionId,
    type: (el.visualType || 'custom_fixture') as Fixture['type'],
    category: 'barrier',
    label: el.name,
    geometry: fixtureGeometry,
    color: el.fillColor || '#666666',
    opacity: el.opacity,
    thickness: pixelsToFeet(el.thickness || 10), // Convert thickness too
    height: null,
    blocksPlacement: true,
    blocksMovement: true,
    snapTarget: false,
    isActive: true,
  };
}

// Convert Fixture (FEET) to database element (PIXELS) for storage
function fixtureToElement(fixture: Omit<Fixture, 'id'> | Fixture): Partial<FloorPlanElement> & { geometry: unknown } {
  let posX = 0, posY = 0, width = 1, height = 1;

  // Extract positions in feet from fixture geometry
  if (fixture.geometry.type === 'rectangle') {
    posX = fixture.geometry.position.x;
    posY = fixture.geometry.position.y;
    width = fixture.geometry.width;
    height = fixture.geometry.height;
  } else if (fixture.geometry.type === 'circle') {
    // For circle, posX/posY should be top-left of bounding box
    posX = fixture.geometry.center.x - fixture.geometry.radius;
    posY = fixture.geometry.center.y - fixture.geometry.radius;
    width = fixture.geometry.radius * 2;
    height = fixture.geometry.radius * 2;
  } else if (fixture.geometry.type === 'line') {
    posX = Math.min(fixture.geometry.start.x, fixture.geometry.end.x);
    posY = Math.min(fixture.geometry.start.y, fixture.geometry.end.y);
    width = Math.abs(fixture.geometry.end.x - fixture.geometry.start.x) || 0.05; // minimum 1px
    height = Math.abs(fixture.geometry.end.y - fixture.geometry.start.y) || (fixture.thickness || 0.5);
  }

  // Build geometry in PIXELS for storage
  let dbGeometry: unknown;
  if (fixture.geometry.type === 'line') {
    dbGeometry = {
      type: 'line',
      start: {
        x: feetToPixels(fixture.geometry.start.x),
        y: feetToPixels(fixture.geometry.start.y),
      },
      end: {
        x: feetToPixels(fixture.geometry.end.x),
        y: feetToPixels(fixture.geometry.end.y),
      },
    };
  } else if (fixture.geometry.type === 'circle') {
    dbGeometry = {
      type: 'circle',
      center: {
        x: feetToPixels(fixture.geometry.center.x),
        y: feetToPixels(fixture.geometry.center.y),
      },
      radius: feetToPixels(fixture.geometry.radius),
    };
  } else if (fixture.geometry.type === 'rectangle') {
    dbGeometry = {
      type: 'rectangle',
      position: {
        x: feetToPixels(fixture.geometry.position.x),
        y: feetToPixels(fixture.geometry.position.y),
      },
      width: feetToPixels(fixture.geometry.width),
      height: feetToPixels(fixture.geometry.height),
      rotation: fixture.geometry.rotation || 0,
    };
  } else {
    // Fallback for other geometry types (polygon, arc) - store as-is
    dbGeometry = fixture.geometry;
  }

  const rotation = fixture.geometry.type === 'rectangle' ? (fixture.geometry.rotation || 0) : 0;

  return {
    name: fixture.label,
    elementType: 'fixture',
    visualType: fixture.type,
    geometry: dbGeometry,
    posX: feetToPixels(posX),
    posY: feetToPixels(posY),
    width: feetToPixels(width),
    height: feetToPixels(height),
    rotation,
    thickness: fixture.thickness ? feetToPixels(fixture.thickness) : undefined,
    fillColor: fixture.color,
    opacity: fixture.opacity,
    isLocked: false,
  };
}

// =============================================================================
// COMPONENT
// =============================================================================

export function FloorPlanEditor({
  initialRoomId,
  locationId,
  useDatabase = false,
  onSave,
  onExit,
}: FloorPlanEditorProps) {
  // Room selection - in database mode, start empty and wait for sections to load
  const [selectedRoomId, setSelectedRoomId] = useState<string>(
    useDatabase ? (initialRoomId || '') : (initialRoomId || FloorCanvasAPI.getActiveRoom() || '')
  );

  // Tool mode
  const [toolMode, setToolMode] = useState<EditorToolMode>('SELECT');
  const [fixtureType, setFixtureType] = useState<FixtureType>('bar_counter');
  const [tableShape, setTableShape] = useState<TableShape>('rectangle');

  // Selection
  const [selectedFixtureId, setSelectedFixtureId] = useState<string | null>(null);
  const [selectedTableId, setSelectedTableId] = useState<string | null>(null);
  const [selectedSeatId, setSelectedSeatId] = useState<string | null>(null);

  // Entertainment palette state
  const [isEntertainmentPaletteOpen, setIsEntertainmentPaletteOpen] = useState(false);
  const [placedEntertainmentIds, setPlacedEntertainmentIds] = useState<string[]>([]);

  // Force refresh key for immediate updates (eliminates polling lag)
  const [refreshKey, setRefreshKey] = useState(0);

  // Zoom control state and ref
  const [currentZoom, setCurrentZoom] = useState(1);
  const zoomControlRef = useRef<{
    fitToScreen: () => void;
    resetZoom: () => void;
    setZoom: (z: number) => void;
    zoom: number;
  } | null>(null);

  // Database state
  const [dbElements, setDbElements] = useState<FloorPlanElement[]>([]);
  const [dbTables, setDbTables] = useState<EditorTable[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  // Database sections (rooms)
  interface DbSection {
    id: string;
    name: string;
    color: string | null;
    widthFeet: number;
    heightFeet: number;
    gridSizeFeet: number;
  }
  const [dbSections, setDbSections] = useState<DbSection[]>([]);

  // Check if selected fixture is entertainment
  const selectedEntertainmentElement = useMemo(() => {
    if (!selectedFixtureId) return null;

    // Check dbElements for entertainment type
    const element = dbElements.find(el =>
      el.id === selectedFixtureId &&
      el.elementType === 'entertainment'
    );

    return element || null;
  }, [selectedFixtureId, dbElements]);

  // Fetch sections from database
  const fetchSections = useCallback(async () => {
    if (!useDatabase || !locationId) return;

    try {
      const response = await fetch(`/api/sections?locationId=${locationId}`);
      if (response.ok) {
        const data = await response.json();
        setDbSections(data.sections || []);
        // Auto-select first section if none selected
        if (data.sections?.length > 0 && !selectedRoomId) {
          setSelectedRoomId(data.sections[0].id);
        }
      }
    } catch (error) {
      console.error('Failed to fetch sections:', error);
    }
  }, [useDatabase, locationId, selectedRoomId]);

  // Load sections when in database mode
  useEffect(() => {
    if (useDatabase) {
      fetchSections();
    }
  }, [useDatabase, fetchSections]);

  // Fetch elements from database
  const fetchElements = useCallback(async () => {
    if (!useDatabase || !selectedRoomId || !locationId) return;

    try {
      const response = await fetch(`/api/floor-plan-elements?locationId=${locationId}&sectionId=${selectedRoomId}`);
      if (response.ok) {
        const data = await response.json();
        setDbElements(data.elements || []);
      }
    } catch (error) {
      console.error('Failed to fetch floor plan elements:', error);
    }
  }, [useDatabase, selectedRoomId, locationId]);

  // Load elements when room changes (database mode)
  useEffect(() => {
    if (useDatabase) {
      fetchElements();
    }
  }, [useDatabase, fetchElements]);

  // Fetch tables from database
  const fetchTables = useCallback(async () => {
    if (!useDatabase || !selectedRoomId || !locationId) return;

    try {
      const response = await fetch(`/api/tables?locationId=${locationId}&sectionId=${selectedRoomId}&includeSeats=true`);
      if (response.ok) {
        const data = await response.json();
        // Map API response to EditorTable format
        const editorTables: EditorTable[] = (data.tables || []).map((t: Record<string, unknown>) => ({
          id: t.id as string,
          name: t.name as string,
          abbreviation: t.abbreviation as string | null,
          capacity: t.capacity as number,
          posX: t.posX as number,
          posY: t.posY as number,
          width: t.width as number,
          height: t.height as number,
          rotation: t.rotation as number,
          shape: (t.shape as TableShape) || 'rectangle',
          seatPattern: (t.seatPattern as EditorTable['seatPattern']) || 'all_around',
          sectionId: t.section ? (t.section as { id: string }).id : null,
          status: (t.status as string) || 'available',
          isLocked: (t.isLocked as boolean) || false,
          seats: (t.seats as EditorTable['seats']) || [],
        }));
        setDbTables(editorTables);
      }
    } catch (error) {
      console.error('Failed to fetch tables:', error);
    }
  }, [useDatabase, selectedRoomId, locationId]);

  // Load tables when room changes (database mode)
  useEffect(() => {
    if (useDatabase) {
      fetchTables();
    }
  }, [useDatabase, fetchTables]);

  // Handle room change
  const handleRoomChange = useCallback((roomId: string) => {
    setSelectedRoomId(roomId);
    if (!useDatabase) {
      FloorCanvasAPI.setActiveRoom(roomId);
    }
    setSelectedFixtureId(null);
  }, [useDatabase]);

  // Track which entertainment items are already placed
  useEffect(() => {
    if (useDatabase) {
      const entertainmentIds = dbElements
        .filter(el => el.linkedMenuItemId)
        .map(el => el.linkedMenuItemId as string);
      setPlacedEntertainmentIds(entertainmentIds);
    } else {
      const fixtures = FloorCanvasAPI.getFixtures(selectedRoomId);
      const entertainmentIds = fixtures
        .filter(f => (f as any).linkedMenuItemId)
        .map(f => (f as any).linkedMenuItemId as string);
      setPlacedEntertainmentIds(entertainmentIds);
    }
  }, [useDatabase, dbElements, selectedRoomId]);

  // Handle tool change
  const handleToolChange = useCallback((tool: EditorToolMode) => {
    setToolMode(tool);
    setSelectedFixtureId(null);
    setSelectedTableId(null);
  }, []);

  // Handle fixture type change
  const handleFixtureTypeChange = useCallback((type: FixtureType) => {
    setFixtureType(type);
  }, []);

  // Handle table shape change
  const handleTableShapeChange = useCallback((shape: TableShape) => {
    setTableShape(shape);
  }, []);

  // Handle fixture selection
  const handleFixtureSelect = useCallback((fixtureId: string | null) => {
    setSelectedFixtureId(fixtureId);
    if (fixtureId) {
      setToolMode('SELECT');
      setSelectedTableId(null); // Deselect table when fixture selected
    }
  }, []);

  // Handle table selection
  const handleTableSelect = useCallback((tableId: string | null) => {
    setSelectedTableId(tableId);
    if (tableId) {
      setToolMode('SELECT');
      setSelectedFixtureId(null); // Deselect fixture when table selected
    }
  }, []);

  // Handle fixture creation
  const handleFixtureCreate = useCallback(
    async (fixture: Omit<Fixture, 'id'>) => {
      if (useDatabase) {
        try {
          const elementData = fixtureToElement(fixture);
          const response = await fetch('/api/floor-plan-elements', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              sectionId: selectedRoomId,
              locationId: locationId || '',
              ...elementData,
            }),
          });
          if (response.ok) {
            await fetchElements();
            setRefreshKey((prev) => prev + 1);
          }
        } catch (error) {
          console.error('Failed to create element:', error);
        }
      } else {
        FloorCanvasAPI.addFixture(fixture);
      }
      setSelectedFixtureId(null);
    },
    [useDatabase, selectedRoomId, locationId, fetchElements]
  );

  // Handle fixture update
  const handleFixtureUpdate = useCallback(
    async (fixtureId: string, updates: Partial<Fixture>) => {
      if (useDatabase) {
        try {
          // Get current element to merge updates
          const currentElement = dbElements.find(el => el.id === fixtureId);
          if (!currentElement) return;

          // Convert current element to fixture, apply updates, then convert back
          const currentFixture = elementToFixture(currentElement, selectedRoomId);
          const updatedFixture = { ...currentFixture, ...updates };

          // If geometry is being updated, merge it properly
          if (updates.geometry) {
            updatedFixture.geometry = updates.geometry;
          }

          const elementData = fixtureToElement(updatedFixture);

          const response = await fetch(`/api/floor-plan-elements/${fixtureId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              locationId: locationId || '',
              ...elementData,
            }),
          });

          if (response.ok) {
            // Update local state immediately for responsiveness
            setDbElements(prev => prev.map(el =>
              el.id === fixtureId
                ? { ...el, ...elementData } as FloorPlanElement
                : el
            ));
            setRefreshKey((prev) => prev + 1);
          }
        } catch (error) {
          console.error('Failed to update element:', error);
        }
      } else {
        FloorCanvasAPI.updateFixture(fixtureId, updates);
        setRefreshKey((prev) => prev + 1);
      }
    },
    [useDatabase, dbElements, selectedRoomId, locationId]
  );

  // Handle fixture deletion
  const handleFixtureDelete = useCallback(
    async (fixtureId: string) => {
      if (useDatabase) {
        try {
          const response = await fetch(`/api/floor-plan-elements/${fixtureId}?locationId=${locationId}`, {
            method: 'DELETE',
          });
          if (response.ok) {
            setDbElements(prev => prev.filter(el => el.id !== fixtureId));
            setRefreshKey((prev) => prev + 1);
          }
        } catch (error) {
          console.error('Failed to delete element:', error);
        }
      } else {
        FloorCanvasAPI.removeFixture(fixtureId);
      }
      setSelectedFixtureId(null);
    },
    [useDatabase, locationId]
  );

  // Handle entertainment update
  const handleEntertainmentUpdate = useCallback(async (updates: {
    visualType?: string;
    width?: number;
    height?: number;
    rotation?: number;
  }) => {
    if (!selectedEntertainmentElement || !locationId) return;

    try {
      const response = await fetch(`/api/floor-plan-elements/${selectedEntertainmentElement.id}?locationId=${locationId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          ...updates,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        setDbElements(prev => prev.map(el =>
          el.id === selectedEntertainmentElement.id ? { ...el, ...data.element } : el
        ));
        setRefreshKey(prev => prev + 1);
      }
    } catch (error) {
      console.error('Failed to update entertainment:', error);
    }
  }, [selectedEntertainmentElement, locationId]);

  // Handle entertainment delete
  const handleEntertainmentDelete = useCallback(async () => {
    if (!selectedEntertainmentElement || !locationId) return;

    try {
      const response = await fetch(`/api/floor-plan-elements/${selectedEntertainmentElement.id}?locationId=${locationId}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        // Remove from local state
        setDbElements(prev => prev.filter(el => el.id !== selectedEntertainmentElement.id));
        // Remove from placed IDs
        if (selectedEntertainmentElement.linkedMenuItemId) {
          setPlacedEntertainmentIds(prev =>
            prev.filter(id => id !== selectedEntertainmentElement.linkedMenuItemId)
          );
        }
        // Clear selection
        setSelectedFixtureId(null);
        setRefreshKey(prev => prev + 1);
      }
    } catch (error) {
      console.error('Failed to delete entertainment:', error);
    }
  }, [selectedEntertainmentElement, locationId]);

  // Handle adding entertainment element from palette
  const handleAddEntertainment = useCallback(async (element: {
    name: string;
    visualType: string;
    linkedMenuItemId: string;
    width: number;
    height: number;
  }) => {
    if (!locationId) return;

    try {
      const response = await fetch('/api/floor-plan-elements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          sectionId: selectedRoomId,
          name: element.name,
          elementType: 'entertainment',
          visualType: element.visualType,
          linkedMenuItemId: element.linkedMenuItemId,
          posX: 200,
          posY: 200,
          width: element.width,
          height: element.height,
          rotation: 0,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        const newFixture = elementToFixture(data.element, selectedRoomId || '');
        setDbElements(prev => [...prev, data.element]);
        setPlacedEntertainmentIds(prev => [...prev, element.linkedMenuItemId]);
        setRefreshKey((prev) => prev + 1);
      }
    } catch (error) {
      console.error('Failed to add entertainment:', error);
    }
  }, [locationId, selectedRoomId]);

  // Handle table creation
  const handleTableCreate = useCallback(
    async (tableData: Omit<EditorTable, 'id'>) => {
      if (!useDatabase || !locationId) return;

      try {
        const response = await fetch('/api/tables', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            locationId,
            sectionId: selectedRoomId,
            name: tableData.name,
            abbreviation: tableData.abbreviation,
            capacity: tableData.capacity,
            posX: tableData.posX,
            posY: tableData.posY,
            width: tableData.width,
            height: tableData.height,
            rotation: tableData.rotation,
            shape: tableData.shape,
            seatPattern: tableData.seatPattern,
            skipSeatGeneration: true,
          }),
        });

        if (response.ok) {
          await fetchTables();
          setRefreshKey((prev) => prev + 1);
        }
      } catch (error) {
        console.error('Failed to create table:', error);
      }
    },
    [useDatabase, locationId, selectedRoomId, fetchTables]
  );

  // Handle table update
  const handleTableUpdate = useCallback(
    async (tableId: string, updates: Partial<EditorTable>) => {
      if (!useDatabase) return;

      try {
        const response = await fetch(`/api/tables/${tableId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updates),
        });

        if (response.ok) {
          // Update local state immediately for responsiveness
          setDbTables(prev => prev.map(t =>
            t.id === tableId ? { ...t, ...updates } : t
          ));
          setRefreshKey((prev) => prev + 1);
        }
      } catch (error) {
        console.error('Failed to update table:', error);
      }
    },
    [useDatabase]
  );

  // Handle table deletion
  const handleTableDelete = useCallback(
    async (tableId: string) => {
      if (!useDatabase) return;

      try {
        const response = await fetch(`/api/tables/${tableId}`, {
          method: 'DELETE',
        });

        if (response.ok) {
          setDbTables(prev => prev.filter(t => t.id !== tableId));
          setSelectedTableId(null);
          setRefreshKey((prev) => prev + 1);
        }
      } catch (error) {
        console.error('Failed to delete table:', error);
      }
    },
    [useDatabase]
  );

  // Handle regenerate seats for a table
  const handleRegenerateSeats = useCallback(
    async (tableId: string) => {
      if (!useDatabase) return;

      // Get the current table to use its capacity and pattern
      const table = dbTables.find(t => t.id === tableId);
      if (!table) return;

      // Clear any selected seat for this table to prevent stale references
      setSelectedSeatId(null);

      try {
        const response = await fetch(`/api/tables/${tableId}/seats/auto-generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            count: table.capacity,
            seatPattern: table.seatPattern,
            replaceExisting: true,
            checkCollisions: true,
            forceGenerate: false, // Will prompt user if collisions detected
          }),
        });

        const data = await response.json();

        if (response.status === 409 && data.warning) {
          // Collision detected - ask user if they want to force generate
          const collisionCount = data.collisions?.length || 0;
          const collisionTypes = data.collisions?.map((c: { collidedWith: string }) => c.collidedWith).slice(0, 3).join(', ');
          const confirmed = window.confirm(
            ` Seat Collision Warning\n\n` +
            `${collisionCount} seat(s) would collide with: ${collisionTypes}${collisionCount > 3 ? '...' : ''}\n\n` +
            `Options:\n` +
            ` Click "Cancel" to abort and move/resize the table first\n` +
            ` Click "OK" to generate seats anyway (they may overlap)`
          );

          if (confirmed) {
            // Force generate despite collisions
            const forceResponse = await fetch(`/api/tables/${tableId}/seats/auto-generate`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                count: table.capacity,
                seatPattern: table.seatPattern,
                replaceExisting: true,
                checkCollisions: true,
                forceGenerate: true,
              }),
            });

            if (forceResponse.ok) {
              await fetchTables();
              setTimeout(() => setRefreshKey((prev) => prev + 1), 50);
            }
          }
          return;
        }

        if (response.ok) {
          // Check if there was a collision warning even with successful generation
          if (data.warning && data.collisions?.length > 0) {
            console.warn('Seats generated with collisions:', data.collisions);
          }
          // Refresh tables first, then increment key to trigger re-render
          await fetchTables();
          // Small delay to ensure state has propagated
          setTimeout(() => {
            setRefreshKey((prev) => prev + 1);
          }, 50);
        } else {
          console.error('Failed to regenerate seats:', data);
          alert('Failed to regenerate seats: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Failed to regenerate seats:', error);
        alert('Failed to regenerate seats. Check console for details.');
      }
    },
    [useDatabase, dbTables, fetchTables]
  );

  // Handle seat reflow when table is resized
  const handleSeatsReflow = useCallback(
    async (tableId: string, dimensions: {
      oldWidth: number;
      oldHeight: number;
      newWidth: number;
      newHeight: number;
    }) => {
      if (!useDatabase) return;

      try {
        const response = await fetch(`/api/tables/${tableId}/seats/reflow`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(dimensions),
        });

        if (response.ok) {
          await fetchTables();
          setRefreshKey((prev) => prev + 1);
        }
      } catch (error) {
        console.error('Failed to reflow seats:', error);
      }
    },
    [useDatabase, fetchTables]
  );

  // Handle seat update (for manual dragging)
  const handleSeatUpdate = useCallback(
    async (seatId: string, updates: { relativeX?: number; relativeY?: number }) => {
      if (!useDatabase) return;

      try {
        const response = await fetch(`/api/seats/${seatId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updates),
        });

        if (response.ok) {
          await fetchTables();
          setRefreshKey((prev) => prev + 1);
        }
      } catch (error) {
        console.error('Failed to update seat:', error);
      }
    },
    [useDatabase, fetchTables]
  );

  // Extract flat seats array from tables for EditorCanvas
  const dbSeats = React.useMemo(() => {
    if (!useDatabase) return undefined;
    return dbTables.flatMap(table =>
      (table.seats || []).map(seat => ({
        ...seat,
        tableId: table.id,
      }))
    );
  }, [useDatabase, dbTables]);

  // Handle save
  const handleSave = useCallback(() => {
    if (useDatabase) {
      alert('Floor plan is automatically saved to the database!');
    } else {
      alert('Floor plan saved! (In production, this would save to the database)');
    }
    if (onSave) onSave();
  }, [onSave, useDatabase]);

  // Handle reset
  const handleReset = useCallback(async () => {
    if (window.confirm('Reset the floor plan to default? This will delete all fixtures.')) {
      if (useDatabase) {
        // Delete all elements
        for (const el of dbElements) {
          await fetch(`/api/floor-plan-elements/${el.id}`, { method: 'DELETE' });
        }
        setDbElements([]);
      } else {
        const fixtures = FloorCanvasAPI.getFixtures(selectedRoomId);
        fixtures.forEach((f) => FloorCanvasAPI.removeFixture(f.id));
      }
      setSelectedFixtureId(null);
      setRefreshKey((prev) => prev + 1);
    }
  }, [selectedRoomId, useDatabase, dbElements]);

  // Handle keyboard shortcuts
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Delete key: delete selected fixture or table
      if (event.key === 'Delete') {
        if (selectedFixtureId) {
          handleFixtureDelete(selectedFixtureId);
        } else if (selectedTableId) {
          handleTableDelete(selectedTableId);
        }
      }

      // Escape key: deselect
      if (event.key === 'Escape') {
        setSelectedFixtureId(null);
        setSelectedTableId(null);
        setToolMode('SELECT');
      }

      // Number keys: quick tool select
      if (event.key === '1') setToolMode('SELECT');
      if (event.key === '2') setToolMode('TABLE');
      if (event.key === '3') setToolMode('WALL');
      if (event.key === '4') setToolMode('RECTANGLE');
      if (event.key === '5') setToolMode('CIRCLE');
      if (event.key === '6') setToolMode('DELETE');
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedFixtureId, selectedTableId, handleFixtureDelete, handleTableDelete]);

  return (
    <div style={{ fontFamily: 'system-ui, sans-serif', padding: 24 }}>
      {/* Header */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: 24,
        }}
      >
        <h1 style={{ margin: 0, fontSize: 24, fontWeight: 600 }}>
          Floor Plan Editor
          {useDatabase && (
            <span style={{
              fontSize: 12,
              fontWeight: 400,
              marginLeft: 12,
              padding: '2px 8px',
              backgroundColor: '#e8f5e9',
              color: '#2e7d32',
              borderRadius: 4
            }}>
              Database Mode
            </span>
          )}
        </h1>
        <div style={{ display: 'flex', gap: 8 }}>
          <button
            onClick={handleSave}
            style={{
              padding: '8px 16px',
              backgroundColor: '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: 6,
              cursor: 'pointer',
              fontSize: 14,
              fontWeight: 600,
            }}
          >
            Save
          </button>
          <button
            onClick={handleReset}
            style={{
              padding: '8px 16px',
              backgroundColor: '#f44336',
              color: 'white',
              border: 'none',
              borderRadius: 6,
              cursor: 'pointer',
              fontSize: 14,
              fontWeight: 600,
            }}
          >
            Reset
          </button>
          {onExit && (
            <button
              onClick={onExit}
              style={{
                padding: '8px 16px',
                backgroundColor: '#757575',
                color: 'white',
                border: 'none',
                borderRadius: 6,
                cursor: 'pointer',
                fontSize: 14,
                fontWeight: 600,
              }}
            >
              Exit
            </button>
          )}

          {/* Add Entertainment Button */}
          {useDatabase && (
            <button
              onClick={() => setIsEntertainmentPaletteOpen(true)}
              style={{
                padding: '8px 16px',
                backgroundColor: '#9333ea',
                color: 'white',
                border: 'none',
                borderRadius: 6,
                cursor: 'pointer',
                fontSize: 14,
                fontWeight: 600,
                display: 'flex',
                alignItems: 'center',
                gap: 6,
              }}
            >
              <span></span>
              <span>Add Entertainment</span>
            </button>
          )}

          {/* Zoom Controls */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: 8,
            marginLeft: 16,
            padding: '4px 12px',
            backgroundColor: '#f5f5f5',
            borderRadius: 6,
          }}>
            <button
              onClick={() => zoomControlRef.current?.setZoom(Math.max(ZOOM_MIN, currentZoom - ZOOM_STEP))}
              style={{
                width: 28,
                height: 28,
                border: 'none',
                borderRadius: 4,
                backgroundColor: '#e0e0e0',
                cursor: 'pointer',
                fontSize: 16,
                fontWeight: 'bold',
              }}
              title="Zoom Out"
            >
              
            </button>

            <span style={{
              minWidth: 50,
              textAlign: 'center',
              fontSize: 13,
              fontWeight: 500,
            }}>
              {Math.round(currentZoom * 100)}%
            </span>

            <button
              onClick={() => zoomControlRef.current?.setZoom(Math.min(ZOOM_MAX, currentZoom + ZOOM_STEP))}
              style={{
                width: 28,
                height: 28,
                border: 'none',
                borderRadius: 4,
                backgroundColor: '#e0e0e0',
                cursor: 'pointer',
                fontSize: 16,
                fontWeight: 'bold',
              }}
              title="Zoom In"
            >
              +
            </button>

            <div style={{ width: 1, height: 20, backgroundColor: '#ccc', margin: '0 4px' }} />

            <button
              onClick={() => zoomControlRef.current?.fitToScreen()}
              style={{
                padding: '4px 8px',
                border: 'none',
                borderRadius: 4,
                backgroundColor: '#e0e0e0',
                cursor: 'pointer',
                fontSize: 12,
              }}
              title="Fit to Screen"
            >
              Fit
            </button>

            <button
              onClick={() => zoomControlRef.current?.resetZoom()}
              style={{
                padding: '4px 8px',
                border: 'none',
                borderRadius: 4,
                backgroundColor: '#e0e0e0',
                cursor: 'pointer',
                fontSize: 12,
              }}
              title="Reset to 100%"
            >
              100%
            </button>
          </div>
        </div>
      </div>

      {/* Room Selector - Database mode shows sections, in-memory mode shows FloorCanvasAPI rooms */}
      {useDatabase ? (
        <div style={{ display: 'flex', gap: 8, marginBottom: 16, alignItems: 'center' }}>
          {dbSections.length === 0 ? (
            <div style={{ padding: '8px 16px', color: '#666', fontSize: 14 }}>
              No sections found.{' '}
              <button
                onClick={async () => {
                  const name = prompt('Enter section name:', 'Main Floor');
                  if (name && locationId) {
                    try {
                      const res = await fetch('/api/sections', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ locationId, name }),
                      });
                      if (res.ok) {
                        fetchSections();
                      }
                    } catch (e) {
                      console.error('Failed to create section:', e);
                    }
                  }
                }}
                style={{
                  padding: '4px 8px',
                  borderRadius: 4,
                  border: '1px solid #3498db',
                  backgroundColor: '#e3f2fd',
                  color: '#3498db',
                  cursor: 'pointer',
                }}
              >
                + Create Section
              </button>
            </div>
          ) : (
            <>
              {dbSections.map((section) => (
                <button
                  key={section.id}
                  onClick={() => handleRoomChange(section.id)}
                  style={{
                    minWidth: 120,
                    padding: '8px 16px',
                    borderRadius: 8,
                    border: selectedRoomId === section.id ? '2px solid #3498db' : '1px solid #ccc',
                    backgroundColor: selectedRoomId === section.id ? '#e3f2fd' : 'white',
                    cursor: 'pointer',
                    fontWeight: selectedRoomId === section.id ? 600 : 400,
                    fontSize: 14,
                  }}
                >
                  {section.name}
                </button>
              ))}
              <button
                onClick={async () => {
                  const name = prompt('Enter section name:');
                  if (name && locationId) {
                    try {
                      const res = await fetch('/api/sections', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ locationId, name }),
                      });
                      if (res.ok) {
                        fetchSections();
                      }
                    } catch (e) {
                      console.error('Failed to create section:', e);
                    }
                  }
                }}
                style={{
                  padding: '8px 16px',
                  borderRadius: 8,
                  border: '2px dashed #3498db',
                  backgroundColor: 'white',
                  color: '#3498db',
                  cursor: 'pointer',
                  fontWeight: 600,
                  fontSize: 14,
                }}
              >
                + Add Room
              </button>
            </>
          )}
        </div>
      ) : (
        <RoomSelector
          selectedRoomId={selectedRoomId}
          onRoomSelect={handleRoomChange}
        />
      )}

      {/* Main Layout */}
      <div style={{ display: 'flex', gap: 24, marginTop: 16 }}>
        {/* Left Panel: Toolbar */}
        <div style={{ width: 200, flexShrink: 0, position: 'relative', zIndex: 10 }}>
          <FixtureToolbar
            selectedTool={toolMode}
            selectedFixtureType={fixtureType}
            selectedTableShape={tableShape}
            onToolSelect={handleToolChange}
            onFixtureTypeSelect={handleFixtureTypeChange}
            onTableShapeSelect={handleTableShapeChange}
          />
        </div>

        {/* Center: Canvas */}
        <div style={{ flex: 1, overflow: 'auto', minWidth: 0, paddingLeft: 8 }}>
          <EditorCanvas
            roomId={selectedRoomId}
            toolMode={toolMode}
            fixtureType={fixtureType}
            tableShape={tableShape}
            selectedFixtureId={selectedFixtureId}
            selectedTableId={selectedTableId}
            refreshKey={refreshKey}
            onFixtureSelect={handleFixtureSelect}
            onFixtureUpdate={handleFixtureUpdate}
            onFixtureCreate={handleFixtureCreate}
            onFixtureDelete={handleFixtureDelete}
            // Table handling
            onTableSelect={handleTableSelect}
            onTableCreate={handleTableCreate}
            onTableUpdate={handleTableUpdate}
            onTableDelete={handleTableDelete}
            // Seat handling
            dbSeats={dbSeats}
            onSeatSelect={setSelectedSeatId}
            onSeatUpdate={handleSeatUpdate}
            onSeatsReflow={handleSeatsReflow}
            // Database mode props
            useDatabase={useDatabase}
            dbFixtures={useDatabase ? dbElements.map(el => elementToFixture(el, selectedRoomId)) : undefined}
            dbTables={useDatabase ? dbTables : undefined}
            dbFloorPlan={useDatabase ? (() => {
              const section = dbSections.find(s => s.id === selectedRoomId);
              if (!section) return undefined;
              return {
                id: section.id,
                name: section.name,
                widthFeet: section.widthFeet || 40,
                heightFeet: section.heightFeet || 30,
                gridSizeFeet: section.gridSizeFeet || 0.25,
              };
            })() : undefined}
            // Zoom control props
            onZoomChange={setCurrentZoom}
            zoomControlRef={zoomControlRef}
          />
        </div>

        {/* Right Panel: Properties */}
        <div style={{ width: 250, flexShrink: 0, position: 'relative', zIndex: 10 }}>
          {/* Show TableProperties when a table is selected, EntertainmentProperties when entertainment selected, otherwise FixtureProperties */}
          {selectedTableId ? (
            <TableProperties
              table={dbTables.find(t => t.id === selectedTableId) || null}
              onUpdate={handleTableUpdate}
              onDelete={handleTableDelete}
              onRegenerateSeats={handleRegenerateSeats}
            />
          ) : selectedEntertainmentElement ? (
            <EntertainmentProperties
              element={{
                id: selectedEntertainmentElement.id,
                name: selectedEntertainmentElement.name || '',
                visualType: selectedEntertainmentElement.visualType || 'game_table',
                linkedMenuItemId: selectedEntertainmentElement.linkedMenuItemId,
                linkedMenuItem: selectedEntertainmentElement.linkedMenuItem,
                width: selectedEntertainmentElement.width || 100,
                height: selectedEntertainmentElement.height || 60,
                rotation: selectedEntertainmentElement.rotation || 0,
                status: selectedEntertainmentElement.status,
              }}
              onUpdate={handleEntertainmentUpdate}
              onDelete={handleEntertainmentDelete}
            />
          ) : (
            <FixtureProperties
              fixtureId={selectedFixtureId}
              onUpdate={handleFixtureUpdate}
              onDelete={handleFixtureDelete}
              // Database mode props
              useDatabase={useDatabase}
              dbFixtures={useDatabase ? dbElements.map(el => elementToFixture(el, selectedRoomId)) : undefined}
            />
          )}
        </div>
      </div>

      {/* Keyboard Shortcuts Help */}
      <div
        style={{
          marginTop: 24,
          padding: 12,
          backgroundColor: '#f5f5f5',
          borderRadius: 8,
          fontSize: 11,
          color: '#666',
        }}
      >
        <strong>Keyboard Shortcuts:</strong>{' '}
        <span style={{ fontFamily: 'monospace' }}>
          1: Select | 2: Table | 3: Wall | 4: Fixture | 5: Circle | 6: Delete | Del: Remove | Esc: Deselect
        </span>
      </div>

      {/* Entertainment Palette Modal */}
      {useDatabase && (
        <AddEntertainmentPalette
          isOpen={isEntertainmentPaletteOpen}
          onClose={() => setIsEntertainmentPaletteOpen(false)}
          locationId={locationId || ''}
          selectedSectionId={selectedRoomId}
          placedMenuItemIds={placedEntertainmentIds}
          onAddElement={handleAddEntertainment}
        />
      )}
    </div>
  );
}

export default FloorPlanEditor;



################################################################################
# FILE: src/domains/floor-plan/admin/FloorPlanEditorDB.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Floor Plan Editor (Database-Backed)
 *
 * Main editor interface for creating and editing floor plans.
 * Uses real API routes for persistence and socket events for real-time sync.
 */

import React, { useState, useCallback, useEffect, useRef } from 'react';
import { EditorCanvasDB } from './EditorCanvasDB';
import { FixtureToolbar } from './FixtureToolbar';
import { FixturePropertiesDB } from './FixturePropertiesDB';
import type { EditorToolMode, FixtureType } from './types';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';

// =============================================================================
// TYPES
// =============================================================================

interface Section {
  id: string;
  name: string;
  color: string | null;
  widthFeet: number;
  heightFeet: number;
  gridSizeFeet: number;
}

interface FloorPlanElement {
  id: string;
  name: string;
  elementType: string;
  visualType: string;
  sectionId: string | null;
  posX: number;
  posY: number;
  width: number;
  height: number;
  rotation: number;
  geometry: unknown;
  thickness: number;
  fillColor: string | null;
  strokeColor: string | null;
  opacity: number;
  isLocked: boolean;
  isVisible: boolean;
}

interface FloorPlanEditorDBProps {
  locationId: string;
  initialSectionId?: string;
  onSave?: () => void;
  onExit?: () => void;
}

// =============================================================================
// COMPONENT
// =============================================================================

export function FloorPlanEditorDB({
  locationId,
  initialSectionId,
  onSave,
  onExit,
}: FloorPlanEditorDBProps) {
  // Section (room) data
  const [sections, setSections] = useState<Section[]>([]);
  const [selectedSectionId, setSelectedSectionId] = useState<string>(initialSectionId || '');
  const [isLoading, setIsLoading] = useState(true);

  // Tool mode
  const [toolMode, setToolMode] = useState<EditorToolMode>('SELECT');
  const [fixtureType, setFixtureType] = useState<FixtureType>('bar_counter');

  // Selection
  const [selectedElementId, setSelectedElementId] = useState<string | null>(null);

  // Elements (fixtures)
  const [elements, setElements] = useState<FloorPlanElement[]>([]);

  // Refresh key for immediate updates
  const [refreshKey, setRefreshKey] = useState(0);

  // =============================================================================
  // DATA LOADING
  // =============================================================================

  // Load sections
  useEffect(() => {
    async function loadSections() {
      try {
        const res = await fetch(`/api/sections?locationId=${locationId}`);
        if (!res.ok) throw new Error('Failed to load sections');
        const data = await res.json();
        setSections(data.sections || []);

        // Set initial section
        if (data.sections.length > 0) {
          const initialId = initialSectionId || data.sections[0].id;
          setSelectedSectionId(initialId);
        }
      } catch (error) {
        console.error('[FloorPlanEditorDB] Load sections error:', error);
      } finally {
        setIsLoading(false);
      }
    }
    loadSections();
  }, [locationId, initialSectionId]);

  // Load elements for selected section
  useEffect(() => {
    if (!selectedSectionId) return;

    async function loadElements() {
      try {
        const res = await fetch(`/api/floor-plan-elements?locationId=${locationId}&sectionId=${selectedSectionId}`);
        if (!res.ok) throw new Error('Failed to load elements');
        const data = await res.json();
        setElements(data.elements || []);
      } catch (error) {
        console.error('[FloorPlanEditorDB] Load elements error:', error);
      }
    }
    loadElements();
  }, [locationId, selectedSectionId, refreshKey]);

  // =============================================================================
  // HANDLERS
  // =============================================================================

  // Handle section change
  const handleSectionChange = useCallback((sectionId: string) => {
    setSelectedSectionId(sectionId);
    setSelectedElementId(null);
  }, []);

  // Handle tool change
  const handleToolChange = useCallback((tool: EditorToolMode) => {
    setToolMode(tool);
    setSelectedElementId(null);
  }, []);

  // Handle fixture type change
  const handleFixtureTypeChange = useCallback((type: FixtureType) => {
    setFixtureType(type);
  }, []);

  // Handle element selection
  const handleElementSelect = useCallback((elementId: string | null) => {
    setSelectedElementId(elementId);
    if (elementId) {
      setToolMode('SELECT');
    }
  }, []);

  // Handle element creation
  const handleElementCreate = useCallback(
    async (elementData: Partial<FloorPlanElement>) => {
      try {
        const res = await fetch('/api/floor-plan-elements', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            locationId,
            sectionId: selectedSectionId,
            ...elementData,
          }),
        });

        if (!res.ok) {
          const error = await res.json();
          console.error('[FloorPlanEditorDB] Create error:', error);
          return;
        }

        // Refresh elements
        setRefreshKey((prev) => prev + 1);

        // Dispatch socket event for real-time sync
        dispatchFloorPlanUpdate(locationId, { async: true });
      } catch (error) {
        console.error('[FloorPlanEditorDB] Create error:', error);
      }
    },
    [locationId, selectedSectionId]
  );

  // Handle element update
  const handleElementUpdate = useCallback(
    async (elementId: string, updates: Partial<FloorPlanElement>) => {
      try {
        const res = await fetch(`/api/floor-plan-elements/${elementId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updates),
        });

        if (!res.ok) {
          const error = await res.json();
          console.error('[FloorPlanEditorDB] Update error:', error);
          return;
        }

        // Refresh elements
        setRefreshKey((prev) => prev + 1);
      } catch (error) {
        console.error('[FloorPlanEditorDB] Update error:', error);
      }
    },
    []
  );

  // Handle element deletion
  const handleElementDelete = useCallback(
    async (elementId: string) => {
      try {
        const res = await fetch(`/api/floor-plan-elements/${elementId}`, {
          method: 'DELETE',
        });

        if (!res.ok) {
          const error = await res.json();
          console.error('[FloorPlanEditorDB] Delete error:', error);
          return;
        }

        setSelectedElementId(null);

        // Refresh elements
        setRefreshKey((prev) => prev + 1);

        // Dispatch socket event for real-time sync
        dispatchFloorPlanUpdate(locationId, { async: true });
      } catch (error) {
        console.error('[FloorPlanEditorDB] Delete error:', error);
      }
    },
    [locationId]
  );

  // Handle add section
  const handleAddSection = useCallback(async () => {
    const name = prompt('Enter room name:');
    if (!name) return;

    try {
      const res = await fetch('/api/sections', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          name,
          widthFeet: 40,
          heightFeet: 30,
          gridSizeFeet: 0.25,
        }),
      });

      if (!res.ok) throw new Error('Failed to create section');
      const data = await res.json();

      setSections((prev) => [...prev, data.section]);
      setSelectedSectionId(data.section.id);
    } catch (error) {
      console.error('[FloorPlanEditorDB] Add section error:', error);
      alert('Failed to create room');
    }
  }, [locationId]);

  // Handle save
  const handleSave = useCallback(() => {
    // Dispatch socket event to notify all terminals
    dispatchFloorPlanUpdate(locationId, { async: true });
    alert('Floor plan saved! All terminals will be updated.');
    if (onSave) onSave();
  }, [locationId, onSave]);

  // Handle reset
  const handleReset = useCallback(async () => {
    if (!window.confirm('Reset this room? This will delete all fixtures.')) return;

    try {
      // Delete all elements in this section
      for (const element of elements) {
        await fetch(`/api/floor-plan-elements/${element.id}`, { method: 'DELETE' });
      }

      setSelectedElementId(null);
      setRefreshKey((prev) => prev + 1);

      // Dispatch socket event for real-time sync
      dispatchFloorPlanUpdate(locationId, { async: true });
    } catch (error) {
      console.error('[FloorPlanEditorDB] Reset error:', error);
    }
  }, [elements, locationId]);

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Delete key: delete selected element
      if (event.key === 'Delete' && selectedElementId) {
        handleElementDelete(selectedElementId);
      }

      // Escape key: deselect
      if (event.key === 'Escape') {
        setSelectedElementId(null);
        setToolMode('SELECT');
      }

      // Number keys: quick tool select
      if (event.key === '1') setToolMode('SELECT');
      if (event.key === '2') setToolMode('WALL');
      if (event.key === '3') setToolMode('RECTANGLE');
      if (event.key === '4') setToolMode('CIRCLE');
      if (event.key === '5') setToolMode('DELETE');
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedElementId, handleElementDelete]);

  // Get current section
  const currentSection = sections.find((s) => s.id === selectedSectionId);

  if (isLoading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
          fontFamily: 'system-ui, sans-serif',
        }}
      >
        <div style={{ textAlign: 'center' }}>
          <div
            style={{
              width: 48,
              height: 48,
              border: '4px solid #f3f3f3',
              borderTop: '4px solid #3498db',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite',
              margin: '0 auto 16px',
            }}
          />
          <p style={{ color: '#666', fontSize: 14 }}>Loading Floor Plan Editor...</p>
        </div>
        <style>{`
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `}</style>
      </div>
    );
  }

  return (
    <div style={{ fontFamily: 'system-ui, sans-serif', padding: 24 }}>
      {/* Header */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: 24,
        }}
      >
        <h1 style={{ margin: 0, fontSize: 24, fontWeight: 600 }}>
          Floor Plan Editor
        </h1>
        <div style={{ display: 'flex', gap: 8 }}>
          <button
            onClick={handleSave}
            style={{
              padding: '8px 16px',
              backgroundColor: '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: 6,
              cursor: 'pointer',
              fontSize: 14,
              fontWeight: 600,
            }}
          >
            Save
          </button>
          <button
            onClick={handleReset}
            style={{
              padding: '8px 16px',
              backgroundColor: '#f44336',
              color: 'white',
              border: 'none',
              borderRadius: 6,
              cursor: 'pointer',
              fontSize: 14,
              fontWeight: 600,
            }}
          >
            Reset
          </button>
          {onExit && (
            <button
              onClick={onExit}
              style={{
                padding: '8px 16px',
                backgroundColor: '#757575',
                color: 'white',
                border: 'none',
                borderRadius: 6,
                cursor: 'pointer',
                fontSize: 14,
                fontWeight: 600,
              }}
            >
              Exit
            </button>
          )}
        </div>
      </div>

      {/* Room Selector */}
      <div
        style={{
          display: 'flex',
          gap: 8,
          marginBottom: 16,
          alignItems: 'center',
        }}
      >
        {sections.map((section) => (
          <button
            key={section.id}
            onClick={() => handleSectionChange(section.id)}
            style={{
              minWidth: 120,
              padding: '8px 16px',
              borderRadius: 8,
              border: selectedSectionId === section.id ? '2px solid #3498db' : '1px solid #ccc',
              backgroundColor: selectedSectionId === section.id ? '#e3f2fd' : 'white',
              cursor: 'pointer',
              fontWeight: selectedSectionId === section.id ? 600 : 400,
              fontSize: 14,
            }}
          >
            {section.name}
          </button>
        ))}
        <button
          onClick={handleAddSection}
          style={{
            padding: '8px 16px',
            borderRadius: 8,
            border: '2px dashed #3498db',
            backgroundColor: 'white',
            color: '#3498db',
            cursor: 'pointer',
            fontWeight: 600,
            fontSize: 14,
          }}
        >
          + Add Room
        </button>
      </div>

      {/* Main Layout */}
      <div style={{ display: 'flex', gap: 24, marginTop: 16 }}>
        {/* Left Panel: Toolbar */}
        <div style={{ width: 200, flexShrink: 0, position: 'relative', zIndex: 10 }}>
          <FixtureToolbar
            selectedTool={toolMode}
            selectedFixtureType={fixtureType}
            onToolSelect={handleToolChange}
            onFixtureTypeSelect={handleFixtureTypeChange}
          />
        </div>

        {/* Center: Canvas */}
        <div style={{ flex: 1, overflow: 'auto', minWidth: 0, paddingLeft: 8 }}>
          {currentSection && (
            <EditorCanvasDB
              section={currentSection}
              elements={elements}
              toolMode={toolMode}
              fixtureType={fixtureType}
              selectedElementId={selectedElementId}
              onElementSelect={handleElementSelect}
              onElementUpdate={handleElementUpdate}
              onElementCreate={handleElementCreate}
              onElementDelete={handleElementDelete}
            />
          )}
        </div>

        {/* Right Panel: Properties */}
        <div style={{ width: 250, flexShrink: 0, position: 'relative', zIndex: 10 }}>
          <FixturePropertiesDB
            element={elements.find((e) => e.id === selectedElementId) || null}
            onUpdate={handleElementUpdate}
            onDelete={handleElementDelete}
          />
        </div>
      </div>

      {/* Keyboard Shortcuts Help */}
      <div
        style={{
          marginTop: 24,
          padding: 12,
          backgroundColor: '#f5f5f5',
          borderRadius: 8,
          fontSize: 11,
          color: '#666',
        }}
      >
        <strong>Keyboard Shortcuts:</strong>{' '}
        <span style={{ fontFamily: 'monospace' }}>
          1-5: Switch tools | Delete: Remove selected | Esc: Deselect
        </span>
      </div>
    </div>
  );
}

export default FloorPlanEditorDB;



################################################################################
# FILE: src/domains/floor-plan/admin/index.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Admin Editor
 *
 * Public exports for the floor plan admin editor.
 */

// In-memory version (for testing)
export { FloorPlanEditor } from './FloorPlanEditor';
export { EditorCanvas } from './EditorCanvas';
export { FixtureToolbar } from './FixtureToolbar';
export { FixtureProperties } from './FixtureProperties';

// Table components
export { TableRenderer } from './TableRenderer';
export { TableProperties } from './TableProperties';

// Database-backed version (production)
export { FloorPlanEditorDB } from './FloorPlanEditorDB';
export { EditorCanvasDB } from './EditorCanvasDB';
export { FixturePropertiesDB } from './FixturePropertiesDB';

// Re-export types
export type {
  EditorToolMode,
  FixtureType,
  DrawingState,
  SelectionState,
  EditorState,
  FixtureTypeMetadata,
  // Table types
  TableShape,
  SeatPattern,
  EditorTable,
  EditorSeat,
  TableTypeMetadata,
} from './types';

export {
  FIXTURE_TYPES,
  FIXTURE_TYPE_MAP,
  getFixtureTypeMetadata,
  // Table exports
  TABLE_SHAPES,
  TABLE_SHAPE_MAP,
  getTableShapeMetadata,
} from './types';



################################################################################
# FILE: src/domains/floor-plan/admin/SeatRenderer.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Seat Renderer Component
 *
 * Renders individual seats with interaction and visual states for ordering.
 */

import React from 'react';
import type { EditorSeat } from './types';

// =============================================================================
// TYPES
// =============================================================================

interface SeatRendererProps {
  seat: EditorSeat;
  tableRotation: number;  // Parent table rotation (to counter-rotate seat label)
  isSelected: boolean;
  isHighlighted: boolean; // For order entry - which seat is active
  hasItems: boolean;      // Does this seat have order items?
  onClick?: () => void;
  onDoubleClick?: () => void; // Open seat details
}

// =============================================================================
// COMPONENT
// =============================================================================

export function SeatRenderer({
  seat,
  tableRotation,
  isSelected,
  isHighlighted,
  hasItems,
  onClick,
  onDoubleClick,
}: SeatRendererProps) {
  const seatSize = 20;

  // Determine colors based on state
  const getColors = () => {
    if (hasItems) {
      // Seat has order items - show filled
      return {
        backgroundColor: isHighlighted ? '#4CAF50' : '#66BB6A',
        borderColor: '#2e7d32',
        textColor: '#fff',
      };
    } else {
      // Empty seat
      return {
        backgroundColor: '#ffffff',
        borderColor: '#9E9E9E',
        textColor: '#666',
      };
    }
  };

  const colors = getColors();

  // Selection ring
  const selectionRing = isSelected ? (
    <div
      style={{
        position: 'absolute',
        left: -4,
        top: -4,
        width: seatSize + 8,
        height: seatSize + 8,
        borderRadius: '50%',
        border: '2px solid #3498db',
        boxShadow: '0 0 8px rgba(52, 152, 219, 0.8)',
        pointerEvents: 'none',
      }}
    />
  ) : null;

  // Highlighted glow (pulsing animation for active seat during ordering)
  const highlightGlow = isHighlighted ? (
    <div
      style={{
        position: 'absolute',
        left: -6,
        top: -6,
        width: seatSize + 12,
        height: seatSize + 12,
        borderRadius: '50%',
        backgroundColor: 'rgba(255, 193, 7, 0.3)',
        animation: 'pulse 1.5s ease-in-out infinite',
        pointerEvents: 'none',
      }}
    />
  ) : null;

  return (
    <>
      {/* CSS Animation for pulsing glow */}
      {isHighlighted && (
        <style>
          {`
            @keyframes pulse {
              0%, 100% {
                transform: scale(1);
                opacity: 0.8;
              }
              50% {
                transform: scale(1.2);
                opacity: 0.4;
              }
            }
          `}
        </style>
      )}

      {/* Seat circle container */}
      <div
        onClick={onClick ? (e) => {
          e.stopPropagation();
          onClick();
        } : undefined}
        onDoubleClick={(e) => {
          e.stopPropagation();
          onDoubleClick?.();
        }}
        style={{
          position: 'relative',
          width: seatSize,
          height: seatSize,
          cursor: onClick ? 'pointer' : 'default',
        }}
      >
        {/* Highlight glow (behind) */}
        {highlightGlow}

        {/* Selection ring (middle) */}
        {selectionRing}

        {/* Seat circle (front) */}
        <div
          style={{
            position: 'absolute',
            left: 0,
            top: 0,
            width: seatSize,
            height: seatSize,
            borderRadius: '50%',
            backgroundColor: colors.backgroundColor,
            border: `2px solid ${colors.borderColor}`,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: 11,
            fontWeight: 600,
            color: colors.textColor,
            boxShadow: hasItems ? '0 2px 4px rgba(0,0,0,0.3)' : '0 1px 2px rgba(0,0,0,0.2)',
            // Counter-rotate label to keep it upright
            transform: `rotate(-${tableRotation}deg)`,
            transition: 'all 0.2s ease',
          }}
          title={`Seat ${seat.label}${hasItems ? ' (Has items)' : ''}${isHighlighted ? ' (Active)' : ''}`}
        >
          {seat.label}
        </div>
      </div>
    </>
  );
}

export default SeatRenderer;



################################################################################
# FILE: src/domains/floor-plan/admin/TableProperties.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Table Properties Panel Component
 *
 * Properties panel for editing selected tables in the Floor Plan Editor.
 */

import React, { useState, useEffect } from 'react';
import type { EditorTable, TableShape, SeatPattern } from './types';
import { TABLE_SHAPES } from './types';

// =============================================================================
// TYPES
// =============================================================================

interface TablePropertiesProps {
  table: EditorTable | null;
  onUpdate: (tableId: string, updates: Partial<EditorTable>) => void;
  onDelete: (tableId: string) => void;
  onRegenerateSeats: (tableId: string) => void;
}

// =============================================================================
// COMPONENT
// =============================================================================

export function TableProperties({ table, onUpdate, onDelete, onRegenerateSeats }: TablePropertiesProps) {
  // Local state for editing
  const [name, setName] = useState('');
  const [abbreviation, setAbbreviation] = useState('');
  const [capacity, setCapacity] = useState(4);
  const [width, setWidth] = useState(100);
  const [height, setHeight] = useState(100);
  const [rotation, setRotation] = useState(0);
  const [shape, setShape] = useState<TableShape>('rectangle');
  const [seatPattern, setSeatPattern] = useState<SeatPattern>('all_around');
  const [isLocked, setIsLocked] = useState(false);

  // Sync with selected table
  useEffect(() => {
    if (table) {
      setName(table.name);
      setAbbreviation(table.abbreviation || '');
      setCapacity(table.capacity);
      setWidth(table.width);
      setHeight(table.height);
      setRotation(table.rotation);
      setShape(table.shape as TableShape);
      setSeatPattern(table.seatPattern as SeatPattern);
      setIsLocked(table.isLocked);
    }
  }, [table]);

  if (!table) {
    return (
      <div
        style={{
          padding: 16,
          backgroundColor: '#f9f9f9',
          borderRadius: 8,
          border: '1px solid #e0e0e0',
        }}
      >
        <h3 style={{ margin: '0 0 12px 0', fontSize: 16, fontWeight: 600, color: '#333' }}>
          Table Properties
        </h3>
        <p style={{ fontSize: 14, color: '#666', margin: 0 }}>
          Select a table to edit its properties.
        </p>
      </div>
    );
  }

  const handleUpdate = (updates: Partial<EditorTable>) => {
    onUpdate(table.id, updates);
  };

  const handleNameChange = (newName: string) => {
    setName(newName);
    handleUpdate({ name: newName });
  };

  const handleAbbreviationChange = (newAbbr: string) => {
    setAbbreviation(newAbbr);
    handleUpdate({ abbreviation: newAbbr || null });
  };

  const handleCapacityChange = (newCapacity: number) => {
    const capped = Math.max(1, Math.min(20, newCapacity));
    setCapacity(capped);
    handleUpdate({ capacity: capped });
  };

  const handleWidthChange = (newWidth: number) => {
    const capped = Math.max(40, Math.min(400, newWidth));
    setWidth(capped);
    handleUpdate({ width: capped });
  };

  const handleHeightChange = (newHeight: number) => {
    const capped = Math.max(40, Math.min(400, newHeight));
    setHeight(capped);
    handleUpdate({ height: capped });
  };

  const handleRotationChange = (newRotation: number) => {
    const normalized = ((newRotation % 360) + 360) % 360;
    setRotation(normalized);
    handleUpdate({ rotation: normalized });
  };

  const handleShapeChange = (newShape: TableShape) => {
    setShape(newShape);
    const shapeDefaults = TABLE_SHAPES.find(s => s.shape === newShape);
    if (shapeDefaults) {
      // Also update default dimensions and seat pattern for the shape
      setWidth(shapeDefaults.defaultWidth);
      setHeight(shapeDefaults.defaultHeight);
      setSeatPattern(shapeDefaults.defaultSeatPattern);
      handleUpdate({
        shape: newShape,
        width: shapeDefaults.defaultWidth,
        height: shapeDefaults.defaultHeight,
        seatPattern: shapeDefaults.defaultSeatPattern,
      });
    } else {
      handleUpdate({ shape: newShape });
    }
  };

  const handleSeatPatternChange = (newPattern: SeatPattern) => {
    setSeatPattern(newPattern);
    handleUpdate({ seatPattern: newPattern });
  };

  const handleLockedChange = (locked: boolean) => {
    setIsLocked(locked);
    handleUpdate({ isLocked: locked });
  };

  const inputStyle: React.CSSProperties = {
    width: '100%',
    padding: '6px 8px',
    fontSize: 13,
    borderRadius: 4,
    border: '1px solid #ccc',
    boxSizing: 'border-box',
  };

  const labelStyle: React.CSSProperties = {
    display: 'block',
    fontSize: 11,
    fontWeight: 600,
    color: '#555',
    marginBottom: 2,
  };

  const fieldStyle: React.CSSProperties = {
    marginBottom: 8,
  };

  return (
    <div
      style={{
        padding: 12,
        backgroundColor: '#f9f9f9',
        borderRadius: 8,
        border: '1px solid #e0e0e0',
      }}
    >
      <h3 style={{ margin: '0 0 8px 0', fontSize: 14, fontWeight: 600, color: '#333' }}>
        Table Properties
      </h3>

      {/* Name & Abbreviation - side by side */}
      <div style={{ ...fieldStyle, display: 'flex', gap: 6 }}>
        <div style={{ flex: 2 }}>
          <label style={labelStyle}>Name</label>
          <input
            type="text"
            value={name}
            onChange={(e) => handleNameChange(e.target.value)}
            placeholder="Table name"
            style={inputStyle}
          />
        </div>
        <div style={{ flex: 1 }}>
          <label style={labelStyle}>Abbr</label>
          <input
            type="text"
            value={abbreviation}
            onChange={(e) => handleAbbreviationChange(e.target.value)}
            placeholder="T1"
            maxLength={6}
            style={inputStyle}
          />
        </div>
      </div>

      {/* Shape */}
      <div style={fieldStyle}>
        <label style={labelStyle}>Shape</label>
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 4 }}>
          {TABLE_SHAPES.map((shapeOption) => (
            <button
              key={shapeOption.shape}
              onClick={() => handleShapeChange(shapeOption.shape)}
              title={shapeOption.label}
              style={{
                padding: '4px 2px',
                fontSize: 16,
                borderRadius: 4,
                border: shape === shapeOption.shape ? '2px solid #3498db' : '1px solid #ccc',
                backgroundColor: shape === shapeOption.shape ? '#e3f2fd' : 'white',
                cursor: 'pointer',
              }}
            >
              {shapeOption.icon}
            </button>
          ))}
        </div>
      </div>

      {/* Capacity */}
      <div style={fieldStyle}>
        <label style={labelStyle}>Capacity</label>
        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
          <button
            onClick={() => handleCapacityChange(capacity - 1)}
            style={{
              width: 28,
              height: 28,
              borderRadius: 4,
              border: '1px solid #ccc',
              backgroundColor: 'white',
              cursor: 'pointer',
              fontSize: 16,
              fontWeight: 700,
            }}
          >
            -
          </button>
          <input
            type="number"
            value={capacity}
            onChange={(e) => handleCapacityChange(parseInt(e.target.value, 10) || 1)}
            min={1}
            max={20}
            style={{ ...inputStyle, width: 50, textAlign: 'center', padding: '4px' }}
          />
          <button
            onClick={() => handleCapacityChange(capacity + 1)}
            style={{
              width: 28,
              height: 28,
              borderRadius: 4,
              border: '1px solid #ccc',
              backgroundColor: 'white',
              cursor: 'pointer',
              fontSize: 16,
              fontWeight: 700,
            }}
          >
            +
          </button>
        </div>
      </div>

      {/* Seat Pattern */}
      <div style={fieldStyle}>
        <label style={labelStyle}>Seat Arrangement</label>
        <select
          value={seatPattern}
          onChange={(e) => handleSeatPatternChange(e.target.value as SeatPattern)}
          style={inputStyle}
        >
          <option value="all_around">All Around</option>
          <option value="front_only">Front Only (Bar)</option>
          <option value="three_sides">Three Sides (U-shape)</option>
          <option value="two_sides">Two Sides (Corner)</option>
          <option value="inside">Inside (Booth)</option>
        </select>
      </div>

      {/* Dimensions */}
      <div style={fieldStyle}>
        <label style={labelStyle}>Size (W  H)</label>
        <div style={{ display: 'flex', gap: 4, alignItems: 'center' }}>
          <input
            type="number"
            value={width}
            onChange={(e) => handleWidthChange(parseInt(e.target.value, 10) || 40)}
            min={40}
            max={400}
            style={{ ...inputStyle, width: 60, textAlign: 'center', padding: '4px' }}
            title="Width"
          />
          <span style={{ color: '#999', fontSize: 12 }}></span>
          <input
            type="number"
            value={height}
            onChange={(e) => handleHeightChange(parseInt(e.target.value, 10) || 40)}
            min={40}
            max={400}
            style={{ ...inputStyle, width: 60, textAlign: 'center', padding: '4px' }}
            title="Height"
          />
        </div>
      </div>

      {/* Rotation */}
      <div style={fieldStyle}>
        <label style={labelStyle}>Rotation</label>
        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
          <button
            onClick={() => handleRotationChange(rotation - 5)}
            style={{
              width: 24,
              height: 24,
              borderRadius: 4,
              border: '1px solid #ccc',
              backgroundColor: 'white',
              cursor: 'pointer',
              fontSize: 11,
              fontWeight: 600,
            }}
            title="-5"
          >
            -5
          </button>
          <input
            type="range"
            value={rotation}
            onChange={(e) => handleRotationChange(parseInt(e.target.value, 10))}
            min={0}
            max={360}
            step={5}
            style={{ flex: 1, height: 4 }}
          />
          <button
            onClick={() => handleRotationChange(rotation + 5)}
            style={{
              width: 24,
              height: 24,
              borderRadius: 4,
              border: '1px solid #ccc',
              backgroundColor: 'white',
              cursor: 'pointer',
              fontSize: 11,
              fontWeight: 600,
            }}
            title="+5"
          >
            +5
          </button>
          <span style={{ width: 32, fontSize: 11, textAlign: 'right' }}>{rotation}</span>
        </div>
      </div>

      {/* Locked */}
      <div style={fieldStyle}>
        <label
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: 6,
            cursor: 'pointer',
            fontSize: 12,
          }}
        >
          <input
            type="checkbox"
            checked={isLocked}
            onChange={(e) => handleLockedChange(e.target.checked)}
            style={{ width: 14, height: 14 }}
          />
          <span>Lock Position</span>
        </label>
      </div>

      {/* Action buttons - side by side */}
      <div style={{ display: 'flex', gap: 6 }}>
        <button
          onClick={() => onRegenerateSeats(table.id)}
          style={{
            flex: 1,
            padding: '6px 8px',
            fontSize: 11,
            fontWeight: 600,
            borderRadius: 4,
            border: 'none',
            backgroundColor: '#ff9800',
            color: 'white',
            cursor: 'pointer',
          }}
        >
          Regen Seats
        </button>
        <button
          onClick={() => {
            if (window.confirm(`Delete table "${table.name}"?`)) {
              onDelete(table.id);
            }
          }}
          style={{
            flex: 1,
            padding: '6px 8px',
            fontSize: 11,
            fontWeight: 600,
            borderRadius: 4,
            border: 'none',
            backgroundColor: '#f44336',
            color: 'white',
            cursor: 'pointer',
          }}
        >
          Delete
        </button>
      </div>
    </div>
  );
}

export default TableProperties;



################################################################################
# FILE: src/domains/floor-plan/admin/TableRenderer.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Table Renderer Component
 *
 * Renders tables in the Floor Plan Editor canvas with seats and selection state.
 */

import React from 'react';
import { FloorCanvasAPI } from '../canvas';
import type { EditorTable, EditorSeat, TableShape } from './types';
import { SeatRenderer } from './SeatRenderer';

// =============================================================================
// TYPES
// =============================================================================

export type ResizeHandle = 'n' | 's' | 'e' | 'w' | 'ne' | 'nw' | 'se' | 'sw';

interface TableRendererProps {
  table: EditorTable;
  isSelected: boolean;
  onSelect: () => void;
  isDragging?: boolean;
  isRotating?: boolean;
  isResizing?: boolean;
  // Seat interaction
  selectedSeatId?: string | null;
  highlightedSeatId?: string | null;
  onSeatClick?: (seatId: string) => void;
  onSeatDoubleClick?: (seatId: string) => void;
  // Seat state (optional - for visual indicators)
  seatsWithItems?: Set<string>; // Set of seat IDs that have order items
  // Rotation interaction
  onRotateStart?: (e: React.MouseEvent) => void;
  // Resize interaction
  onResizeStart?: (handle: ResizeHandle) => void;
}

// =============================================================================
// TABLE SHAPE RENDERERS
// =============================================================================

function RoundTableShape({
  width,
  height,
  color,
  isSelected,
}: {
  width: number;
  height: number;
  color: string;
  isSelected: boolean;
}) {
  return (
    <div
      style={{
        width,
        height,
        borderRadius: '50%',
        backgroundColor: color,
        border: isSelected ? '3px solid #3498db' : '2px solid #795548',
        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
      }}
    />
  );
}

function RectangleTableShape({
  width,
  height,
  color,
  isSelected,
  borderRadius = 4,
}: {
  width: number;
  height: number;
  color: string;
  isSelected: boolean;
  borderRadius?: number;
}) {
  return (
    <div
      style={{
        width,
        height,
        borderRadius,
        backgroundColor: color,
        border: isSelected ? '3px solid #3498db' : '2px solid #795548',
        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
      }}
    />
  );
}

function OvalTableShape({
  width,
  height,
  color,
  isSelected,
}: {
  width: number;
  height: number;
  color: string;
  isSelected: boolean;
}) {
  return (
    <div
      style={{
        width,
        height,
        borderRadius: '50%',
        backgroundColor: color,
        border: isSelected ? '3px solid #3498db' : '2px solid #795548',
        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
      }}
    />
  );
}

function BoothTableShape({
  width,
  height,
  color,
  isSelected,
}: {
  width: number;
  height: number;
  color: string;
  isSelected: boolean;
}) {
  const boothBackHeight = 8;
  return (
    <div style={{ position: 'relative', width, height }}>
      {/* Booth back */}
      <div
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: boothBackHeight,
          backgroundColor: '#5D4037',
          borderRadius: '4px 4px 0 0',
        }}
      />
      {/* Table surface */}
      <div
        style={{
          position: 'absolute',
          top: boothBackHeight,
          left: 10,
          width: width - 20,
          height: height - boothBackHeight - 4,
          borderRadius: 4,
          backgroundColor: color,
          border: isSelected ? '3px solid #3498db' : '2px solid #795548',
          boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
        }}
      />
    </div>
  );
}

function BarSectionShape({
  width,
  height,
  color,
  isSelected,
}: {
  width: number;
  height: number;
  color: string;
  isSelected: boolean;
}) {
  return (
    <div
      style={{
        width,
        height,
        borderRadius: 2,
        backgroundColor: color,
        border: isSelected ? '3px solid #3498db' : '2px solid #5D4037',
        boxShadow: isSelected ? '0 0 12px rgba(52, 152, 219, 0.6)' : '0 2px 4px rgba(0,0,0,0.2)',
      }}
    />
  );
}

// =============================================================================
// RESIZE HANDLES
// =============================================================================

interface ResizeHandlesProps {
  width: number;
  height: number;
  onResizeStart: (handle: ResizeHandle) => void;
}

function ResizeHandles({ width, height, onResizeStart }: ResizeHandlesProps) {
  const handleSize = 10;
  const handleStyle: React.CSSProperties = {
    position: 'absolute',
    width: handleSize,
    height: handleSize,
    backgroundColor: 'white',
    border: '2px solid #3498db',
    borderRadius: 2,
    zIndex: 1000,
  };

  const handles: { handle: ResizeHandle; style: React.CSSProperties; cursor: string }[] = [
    // Corners
    { handle: 'nw', style: { top: -handleSize / 2, left: -handleSize / 2 }, cursor: 'nwse-resize' },
    { handle: 'ne', style: { top: -handleSize / 2, right: -handleSize / 2 }, cursor: 'nesw-resize' },
    { handle: 'sw', style: { bottom: -handleSize / 2, left: -handleSize / 2 }, cursor: 'nesw-resize' },
    { handle: 'se', style: { bottom: -handleSize / 2, right: -handleSize / 2 }, cursor: 'nwse-resize' },
    // Edges
    { handle: 'n', style: { top: -handleSize / 2, left: '50%', transform: 'translateX(-50%)' }, cursor: 'ns-resize' },
    { handle: 's', style: { bottom: -handleSize / 2, left: '50%', transform: 'translateX(-50%)' }, cursor: 'ns-resize' },
    { handle: 'w', style: { left: -handleSize / 2, top: '50%', transform: 'translateY(-50%)' }, cursor: 'ew-resize' },
    { handle: 'e', style: { right: -handleSize / 2, top: '50%', transform: 'translateY(-50%)' }, cursor: 'ew-resize' },
  ];

  return (
    <>
      {handles.map(({ handle, style, cursor }) => (
        <div
          key={handle}
          style={{ ...handleStyle, ...style, cursor }}
          onMouseDown={(e) => {
            e.stopPropagation();
            onResizeStart(handle);
          }}
          title={`Resize ${handle.toUpperCase()}`}
        />
      ))}
    </>
  );
}

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export function TableRenderer({
  table,
  isSelected,
  onSelect,
  isDragging = false,
  isRotating = false,
  isResizing = false,
  selectedSeatId = null,
  highlightedSeatId = null,
  onSeatClick,
  onSeatDoubleClick,
  seatsWithItems = new Set(),
  onRotateStart,
  onResizeStart,
}: TableRendererProps) {
  // Get table color based on status
  const getTableColor = () => {
    switch (table.status) {
      case 'occupied':
        return '#BBDEFB'; // Light blue
      case 'reserved':
        return '#F0E6FF'; // Light purple
      case 'dirty':
        return '#D7CCC8'; // Light brown
      case 'blocked':
        return '#9E9E9E'; // Grey
      default:
        return '#8D6E63'; // Default wood color
    }
  };

  const color = getTableColor();

  // Render the appropriate shape
  const renderShape = () => {
    const shapeProps = {
      width: table.width,
      height: table.height,
      color,
      isSelected,
    };

    switch (table.shape) {
      case 'round':
        return <RoundTableShape {...shapeProps} />;
      case 'oval':
        return <OvalTableShape {...shapeProps} />;
      case 'booth':
        return <BoothTableShape {...shapeProps} />;
      case 'bar':
        return <BarSectionShape {...shapeProps} />;
      case 'square':
        return <RectangleTableShape {...shapeProps} borderRadius={4} />;
      case 'rectangle':
      default:
        return <RectangleTableShape {...shapeProps} borderRadius={4} />;
    }
  };

  // Calculate table center (for seat positioning)
  const tableCenterX = table.posX + table.width / 2;
  const tableCenterY = table.posY + table.height / 2;

  return (
    <div
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
      style={{
        position: 'absolute',
        left: table.posX,
        top: table.posY,
        width: table.width,
        height: table.height,
        cursor: isDragging ? 'grabbing' : 'grab',
        transform: `rotate(${table.rotation}deg)`,
        transformOrigin: 'center center',
        opacity: isDragging ? 0.7 : 1,
        transition: isDragging ? 'none' : 'transform 0.1s ease',
        zIndex: isSelected ? 100 : 10,
      }}
      title={`${table.name} (${table.capacity} seats)`}
    >
      {/* Table shape */}
      {renderShape()}

      {/* Table label */}
      <div
        style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: `translate(-50%, -50%) rotate(-${table.rotation}deg)`,
          fontSize: 14,
          fontWeight: 700,
          color: '#fff',
          textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
          pointerEvents: 'none',
          whiteSpace: 'nowrap',
          textAlign: 'center',
        }}
      >
        {table.abbreviation || table.name}
      </div>

      {/* Capacity badge - positioned inside table */}
      <div
        style={{
          position: 'absolute',
          top: 4,
          right: 4,
          width: 18,
          height: 18,
          borderRadius: '50%',
          backgroundColor: 'rgba(76, 175, 80, 0.9)',
          color: 'white',
          fontSize: 11,
          fontWeight: 700,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          transform: `rotate(-${table.rotation}deg)`,
          pointerEvents: 'none',
          boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
        }}
      >
        {table.capacity}
      </div>

      {/* Locked indicator */}
      {table.isLocked && (
        <div
          style={{
            position: 'absolute',
            top: -8,
            left: -8,
            width: 18,
            height: 18,
            borderRadius: '50%',
            backgroundColor: '#F44336',
            color: 'white',
            fontSize: 10,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            transform: `rotate(-${table.rotation}deg)`,
            pointerEvents: 'none',
            boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
          }}
          title="Locked - Cannot be moved"
        >
          
        </div>
      )}

      {/* Rotation handle (when selected) */}
      {isSelected && onRotateStart && (
        <div
          onMouseDown={(e) => {
            e.stopPropagation();
            onRotateStart(e);
          }}
          style={{
            position: 'absolute',
            top: -40,
            left: '50%',
            transform: `translateX(-50%) rotate(-${table.rotation}deg)`,
            transformOrigin: 'center bottom',
            cursor: isRotating ? 'grabbing' : 'grab',
            pointerEvents: 'auto',
            zIndex: 1000,
          }}
          title="Drag to rotate table (hold Shift to snap to 15)"
        >
          {/* Stem line */}
          <div
            style={{
              width: 2,
              height: 30,
              backgroundColor: '#3498db',
              margin: '0 auto',
              pointerEvents: 'none',
            }}
          />
          {/* Handle circle */}
          <div
            style={{
              width: 12,
              height: 12,
              borderRadius: '50%',
              backgroundColor: 'white',
              border: '2px solid #3498db',
              margin: '0 auto',
              cursor: isRotating ? 'grabbing' : 'grab',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
            }}
          />
        </div>
      )}

      {/* Seats (rendered relative to table center) */}
      {table.seats?.map((seat) => {
        // Seat positions are relative to table center
        // Position absolute within the table container
        const seatCenterX = table.width / 2 + seat.relativeX;
        const seatCenterY = table.height / 2 + seat.relativeY;
        const seatSize = 20;

        return (
          <div
            key={seat.id}
            style={{
              position: 'absolute',
              left: seatCenterX - seatSize / 2,
              top: seatCenterY - seatSize / 2,
            }}
          >
            <SeatRenderer
              seat={seat}
              tableRotation={table.rotation}
              isSelected={selectedSeatId === seat.id}
              isHighlighted={highlightedSeatId === seat.id}
              hasItems={seatsWithItems.has(seat.id)}
              onClick={() => onSeatClick?.(seat.id)}
              onDoubleClick={() => onSeatDoubleClick?.(seat.id)}
            />
          </div>
        );
      })}

      {/* Resize handles (only when selected and not rotating) */}
      {isSelected && !isRotating && onResizeStart && (
        <ResizeHandles
          width={table.width}
          height={table.height}
          onResizeStart={onResizeStart}
        />
      )}
    </div>
  );
}

export default TableRenderer;



################################################################################
# FILE: src/domains/floor-plan/admin/types.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Admin Editor Types
 *
 * Editor-specific types for the floor plan admin interface.
 */

import type { FixtureType, FixtureCategory, Fixture, Point } from '../shared/types';

// Re-export types from shared for convenience
export type { FixtureType, Fixture, Point } from '../shared/types';

// =============================================================================
// TOOL MODES
// =============================================================================

export type EditorToolMode =
  | 'SELECT'
  | 'WALL'
  | 'RECTANGLE'
  | 'CIRCLE'
  | 'TABLE'
  | 'DELETE';

// =============================================================================
// DRAWING STATE
// =============================================================================

export interface DrawingState {
  mode: EditorToolMode;
  fixtureType: FixtureType;
  startPoint: Point | null;
  previewFixture: Fixture | null;
}

// =============================================================================
// SELECTION STATE
// =============================================================================

export interface SelectionState {
  selectedFixtureId: string | null;
  isDragging: boolean;
  dragOffset: Point | null;
}

// =============================================================================
// EDITOR STATE
// =============================================================================

export interface EditorState {
  drawing: DrawingState;
  selection: SelectionState;
  roomId: string;
}

// =============================================================================
// FIXTURE TYPE METADATA
// =============================================================================

export interface FixtureTypeMetadata {
  type: FixtureType;
  label: string;
  category: FixtureCategory;
  defaultColor: string;
  defaultThickness: number;
  icon: string;
}

// Fixture type definitions for the editor
export const FIXTURE_TYPES: FixtureTypeMetadata[] = [
  {
    type: 'wall',
    label: 'Wall',
    category: 'barrier',
    defaultColor: '#424242',
    defaultThickness: 0.5,
    icon: '',
  },
  {
    type: 'half_wall',
    label: 'Half Wall',
    category: 'barrier',
    defaultColor: '#757575',
    defaultThickness: 0.5,
    icon: '',
  },
  {
    type: 'pillar',
    label: 'Pillar',
    category: 'barrier',
    defaultColor: '#9E9E9E',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'bar_counter',
    label: 'Bar Counter',
    category: 'surface',
    defaultColor: '#8D6E63',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'service_counter',
    label: 'Service Counter',
    category: 'surface',
    defaultColor: '#A1887F',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'kitchen_boundary',
    label: 'Kitchen',
    category: 'zone',
    defaultColor: '#FFEB3B',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'restroom',
    label: 'Restroom',
    category: 'zone',
    defaultColor: '#B3E5FC',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'door',
    label: 'Door',
    category: 'passage',
    defaultColor: '#90CAF9',
    defaultThickness: 0.3,
    icon: '',
  },
  {
    type: 'window',
    label: 'Window',
    category: 'decorative',
    defaultColor: '#81D4FA',
    defaultThickness: 0.2,
    icon: '',
  },
  {
    type: 'railing',
    label: 'Railing',
    category: 'barrier',
    defaultColor: '#795548',
    defaultThickness: 0.3,
    icon: '',
  },
  {
    type: 'stairs',
    label: 'Stairs',
    category: 'passage',
    defaultColor: '#BCAAA4',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'stage_platform',
    label: 'Stage',
    category: 'zone',
    defaultColor: '#BA68C8',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'dance_floor',
    label: 'Dance Floor',
    category: 'zone',
    defaultColor: '#9C27B0',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'fire_exit',
    label: 'Fire Exit',
    category: 'clearance',
    defaultColor: '#F44336',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'ada_path',
    label: 'ADA Path',
    category: 'clearance',
    defaultColor: '#2196F3',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'planter_builtin',
    label: 'Planter',
    category: 'decorative',
    defaultColor: '#4CAF50',
    defaultThickness: 0,
    icon: '',
  },
  {
    type: 'custom_fixture',
    label: 'Custom',
    category: 'decorative',
    defaultColor: '#9E9E9E',
    defaultThickness: 0,
    icon: '',
  },
];

// Map for quick lookup
export const FIXTURE_TYPE_MAP: Record<FixtureType, FixtureTypeMetadata> = FIXTURE_TYPES.reduce(
  (acc, item) => {
    acc[item.type] = item;
    return acc;
  },
  {} as Record<FixtureType, FixtureTypeMetadata>
);

// Helper to get metadata for a fixture type
export function getFixtureTypeMetadata(type: FixtureType): FixtureTypeMetadata {
  return FIXTURE_TYPE_MAP[type] || FIXTURE_TYPES[FIXTURE_TYPES.length - 1];
}

// =============================================================================
// TABLE TYPES (for Editor Layer)
// =============================================================================

export type TableShape = 'square' | 'rectangle' | 'round' | 'oval' | 'booth' | 'bar';

export type SeatPattern = 'all_around' | 'front_only' | 'three_sides' | 'two_sides' | 'inside';

export interface EditorTable {
  id: string;
  name: string;
  abbreviation: string | null;
  capacity: number;
  posX: number; // pixels (same as fixtures in database)
  posY: number;
  width: number;
  height: number;
  rotation: number;
  shape: TableShape;
  seatPattern: SeatPattern;
  sectionId: string | null;
  // Status fields
  status: string;
  isLocked: boolean;
  // Seats (optional, for rendering)
  seats?: EditorSeat[];
}

export interface EditorSeat {
  id: string;
  tableId: string;
  label: string;
  seatNumber: number;
  relativeX: number;
  relativeY: number;
  angle: number;
  seatType: string;
}

export interface TableTypeMetadata {
  shape: TableShape;
  label: string;
  defaultWidth: number;  // pixels
  defaultHeight: number; // pixels
  defaultCapacity: number;
  defaultSeatPattern: SeatPattern;
  icon: string;
}

// Table shape definitions for the editor
export const TABLE_SHAPES: TableTypeMetadata[] = [
  {
    shape: 'square',
    label: 'Square (4-top)',
    defaultWidth: 80,
    defaultHeight: 80,
    defaultCapacity: 4,
    defaultSeatPattern: 'all_around',
    icon: '',
  },
  {
    shape: 'rectangle',
    label: 'Rectangle (6-top)',
    defaultWidth: 120,
    defaultHeight: 80,
    defaultCapacity: 6,
    defaultSeatPattern: 'all_around',
    icon: '',
  },
  {
    shape: 'round',
    label: 'Round (4-top)',
    defaultWidth: 80,
    defaultHeight: 80,
    defaultCapacity: 4,
    defaultSeatPattern: 'all_around',
    icon: '',
  },
  {
    shape: 'oval',
    label: 'Oval (8-top)',
    defaultWidth: 160,
    defaultHeight: 100,
    defaultCapacity: 8,
    defaultSeatPattern: 'all_around',
    icon: '',
  },
  {
    shape: 'booth',
    label: 'Booth',
    defaultWidth: 120,
    defaultHeight: 80,
    defaultCapacity: 4,
    defaultSeatPattern: 'inside',
    icon: '',
  },
  {
    shape: 'bar',
    label: 'Bar Section',
    defaultWidth: 200,
    defaultHeight: 40,
    defaultCapacity: 5,
    defaultSeatPattern: 'front_only',
    icon: '',
  },
];

// Map for quick lookup
export const TABLE_SHAPE_MAP: Record<TableShape, TableTypeMetadata> = TABLE_SHAPES.reduce(
  (acc, item) => {
    acc[item.shape] = item;
    return acc;
  },
  {} as Record<TableShape, TableTypeMetadata>
);

// Helper to get metadata for a table shape
export function getTableShapeMetadata(shape: TableShape): TableTypeMetadata {
  return TABLE_SHAPE_MAP[shape] || TABLE_SHAPES[0];
}



################################################################################
# FILE: src/domains/floor-plan/canvas/FloorCanvas.tsx
################################################################################

'use client';

/**
 * GWI POS - Floor Plan Domain
 * Layer 1: Floor Canvas Component
 *
 * Renders the floor plan canvas with rooms and fixtures.
 */

import React, { useRef, useEffect, useState, useCallback } from 'react';
import { FloorCanvasAPI } from './floorCanvasAPI';
import type { FloorPlan, Fixture, Point } from '../shared/types';

// =============================================================================
// TYPES
// =============================================================================

interface FloorCanvasProps {
  roomId?: string;
  width?: number;
  height?: number;
  showGrid?: boolean;
  showFixtures?: boolean;
  onPositionClick?: (position: Point) => void;
  onFixtureClick?: (fixture: Fixture) => void;
  children?: React.ReactNode;
}

// =============================================================================
// FIXTURE RENDERER
// =============================================================================

interface FixtureRendererProps {
  fixture: Fixture;
  onClick?: (fixture: Fixture) => void;
}

function FixtureRenderer({ fixture, onClick }: FixtureRendererProps) {
  const handleClick = () => {
    if (onClick) onClick(fixture);
  };

  const baseStyle: React.CSSProperties = {
    position: 'absolute',
    backgroundColor: fixture.color,
    opacity: fixture.opacity,
    cursor: onClick ? 'pointer' : 'default',
  };

  // Render based on geometry type
  if (fixture.geometry.type === 'rectangle') {
    const { position, width, height, rotation } = fixture.geometry;
    return (
      <div
        onClick={handleClick}
        style={{
          ...baseStyle,
          left: FloorCanvasAPI.feetToPixels(position.x),
          top: FloorCanvasAPI.feetToPixels(position.y),
          width: FloorCanvasAPI.feetToPixels(width),
          height: FloorCanvasAPI.feetToPixels(height),
          transform: `rotate(${rotation}deg)`,
          transformOrigin: 'center center',
        }}
        title={fixture.label}
      />
    );
  }

  if (fixture.geometry.type === 'circle') {
    const { center, radius } = fixture.geometry;
    const diameter = radius * 2;
    return (
      <div
        onClick={handleClick}
        style={{
          ...baseStyle,
          left: FloorCanvasAPI.feetToPixels(center.x - radius),
          top: FloorCanvasAPI.feetToPixels(center.y - radius),
          width: FloorCanvasAPI.feetToPixels(diameter),
          height: FloorCanvasAPI.feetToPixels(diameter),
          borderRadius: '50%',
        }}
        title={fixture.label}
      />
    );
  }

  if (fixture.geometry.type === 'line') {
    const { start, end } = fixture.geometry;
    const thickness = fixture.thickness || 0.5;

    // Calculate line dimensions
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * (180 / Math.PI);

    return (
      <div
        onClick={handleClick}
        style={{
          ...baseStyle,
          left: FloorCanvasAPI.feetToPixels(start.x),
          top: FloorCanvasAPI.feetToPixels(start.y - thickness / 2),
          width: FloorCanvasAPI.feetToPixels(length),
          height: FloorCanvasAPI.feetToPixels(thickness),
          transform: `rotate(${angle}deg)`,
          transformOrigin: 'left center',
        }}
        title={fixture.label}
      />
    );
  }

  // Polygon rendering (simplified - just show bounding box)
  if (fixture.geometry.type === 'polygon') {
    const { points } = fixture.geometry;
    if (points.length < 3) return null;

    const minX = Math.min(...points.map((p) => p.x));
    const maxX = Math.max(...points.map((p) => p.x));
    const minY = Math.min(...points.map((p) => p.y));
    const maxY = Math.max(...points.map((p) => p.y));

    // Create SVG path for polygon
    const pathD = points
      .map((p, i) => {
        const px = FloorCanvasAPI.feetToPixels(p.x - minX);
        const py = FloorCanvasAPI.feetToPixels(p.y - minY);
        return `${i === 0 ? 'M' : 'L'} ${px} ${py}`;
      })
      .join(' ') + ' Z';

    return (
      <svg
        onClick={handleClick}
        style={{
          position: 'absolute',
          left: FloorCanvasAPI.feetToPixels(minX),
          top: FloorCanvasAPI.feetToPixels(minY),
          width: FloorCanvasAPI.feetToPixels(maxX - minX),
          height: FloorCanvasAPI.feetToPixels(maxY - minY),
          overflow: 'visible',
          cursor: onClick ? 'pointer' : 'default',
        }}
      >
        <title>{fixture.label}</title>
        <path
          d={pathD}
          fill={fixture.color}
          fillOpacity={fixture.opacity}
          stroke="none"
        />
      </svg>
    );
  }

  return null;
}

// =============================================================================
// GRID RENDERER
// =============================================================================

interface GridRendererProps {
  widthPx: number;
  heightPx: number;
  gridSizeFeet: number;
}

function GridRenderer({ widthPx, heightPx, gridSizeFeet }: GridRendererProps) {
  const gridSizePx = FloorCanvasAPI.feetToPixels(gridSizeFeet);

  // Generate grid lines
  const verticalLines: number[] = [];
  const horizontalLines: number[] = [];

  for (let x = 0; x <= widthPx; x += gridSizePx) {
    verticalLines.push(x);
  }
  for (let y = 0; y <= heightPx; y += gridSizePx) {
    horizontalLines.push(y);
  }

  return (
    <svg
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: widthPx,
        height: heightPx,
        pointerEvents: 'none',
      }}
    >
      {/* Grid lines */}
      {verticalLines.map((x) => (
        <line
          key={`v-${x}`}
          x1={x}
          y1={0}
          x2={x}
          y2={heightPx}
          stroke="#e0e0e0"
          strokeWidth={1}
        />
      ))}
      {horizontalLines.map((y) => (
        <line
          key={`h-${y}`}
          x1={0}
          y1={y}
          x2={widthPx}
          y2={y}
          stroke="#e0e0e0"
          strokeWidth={1}
        />
      ))}
    </svg>
  );
}

// =============================================================================
// FLOOR CANVAS COMPONENT
// =============================================================================

export function FloorCanvas({
  roomId,
  width,
  height,
  showGrid = true,
  showFixtures = true,
  onPositionClick,
  onFixtureClick,
  children,
}: FloorCanvasProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [floorPlan, setFloorPlan] = useState<FloorPlan | null>(null);
  const [fixtures, setFixtures] = useState<Fixture[]>([]);

  // Load floor plan data
  useEffect(() => {
    const fp = FloorCanvasAPI.getFloorPlan(roomId);
    setFloorPlan(fp);

    if (fp) {
      const fixtureList = FloorCanvasAPI.getFixtures(fp.id);
      setFixtures(fixtureList);
    }
  }, [roomId]);

  // Calculate canvas dimensions - props override floor plan dimensions
  const canvasDimensions = (width && height)
    ? { widthPx: width, heightPx: height }
    : floorPlan
      ? FloorCanvasAPI.getCanvasDimensions(floorPlan.id)
      : { widthPx: 800, heightPx: 600 };

  // Handle click on canvas
  const handleCanvasClick = useCallback(
    (event: React.MouseEvent<HTMLDivElement>) => {
      if (!onPositionClick || !floorPlan) return;

      const rect = event.currentTarget.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      // Convert to feet
      const position: Point = {
        x: FloorCanvasAPI.pixelsToFeet(clickX),
        y: FloorCanvasAPI.pixelsToFeet(clickY),
      };

      // Snap to grid if grid is enabled
      if (showGrid) {
        const snapped = FloorCanvasAPI.snapToGrid(position, floorPlan.gridSizeFeet);
        onPositionClick(snapped);
      } else {
        onPositionClick(position);
      }
    },
    [onPositionClick, floorPlan, showGrid]
  );

  // Use CSS grid when showGrid is false but we have fixed dimensions (DB mode)
  const usesCssGrid = !showGrid && width && height;
  const gridSize = 32; // Match Editor GRID_SIZE

  return (
    <div
      ref={containerRef}
      onClick={handleCanvasClick}
      style={{
        position: 'relative',
        width: canvasDimensions.widthPx,
        height: canvasDimensions.heightPx,
        backgroundColor: '#f8f9fa',
        backgroundImage: usesCssGrid ? `
          linear-gradient(rgba(0,0,0,0.08) 1px, transparent 1px),
          linear-gradient(90deg, rgba(0,0,0,0.08) 1px, transparent 1px)
        ` : undefined,
        backgroundSize: usesCssGrid ? `${gridSize}px ${gridSize}px` : undefined,
        border: '2px solid #ccc',
        borderRadius: 8,
        overflow: 'hidden',
        cursor: onPositionClick ? 'crosshair' : 'default',
      }}
    >
      {/* Grid layer */}
      {showGrid && floorPlan && (
        <GridRenderer
          widthPx={canvasDimensions.widthPx}
          heightPx={canvasDimensions.heightPx}
          gridSizeFeet={floorPlan.gridSizeFeet}
        />
      )}

      {/* Fixtures layer */}
      {showFixtures &&
        fixtures.map((fixture) => (
          <FixtureRenderer
            key={fixture.id}
            fixture={fixture}
            onClick={onFixtureClick}
          />
        ))}

      {/* Children (tables, seats, etc. from other layers) */}
      {children}

      {/* Room info overlay */}
      {floorPlan && (
        <div
          style={{
            position: 'absolute',
            bottom: 8,
            left: 8,
            padding: '4px 8px',
            backgroundColor: 'rgba(0, 0, 0, 0.6)',
            color: 'white',
            borderRadius: 4,
            fontSize: 12,
            pointerEvents: 'none',
          }}
        >
          {floorPlan.name} ({floorPlan.widthFeet}ft x {floorPlan.heightFeet}ft)
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ROOM SELECTOR COMPONENT
// =============================================================================

interface RoomSelectorProps {
  selectedRoomId?: string;
  onRoomSelect: (roomId: string) => void;
}

export function RoomSelector({ selectedRoomId, onRoomSelect }: RoomSelectorProps) {
  const [rooms, setRooms] = useState<FloorPlan[]>([]);
  const [editingRoomId, setEditingRoomId] = useState<string | null>(null);
  const [editingName, setEditingName] = useState('');

  useEffect(() => {
    setRooms(FloorCanvasAPI.getAllRooms());
  }, []);

  const handleAddRoom = () => {
    // TODO: Implement room creation via FloorCanvasAPI
    alert('Add Room feature coming soon!\nThis will create a new room in the floor plan.');
  };

  const handleStartRename = (room: FloorPlan, event: React.MouseEvent) => {
    event.stopPropagation();
    setEditingRoomId(room.id);
    setEditingName(room.name);
  };

  const handleRenameSubmit = (roomId: string) => {
    if (editingName.trim()) {
      // TODO: Implement room rename via FloorCanvasAPI
      alert(`Rename feature coming soon!\nWould rename room to: ${editingName}`);
    }
    setEditingRoomId(null);
    setEditingName('');
  };

  const handleDeleteRoom = (room: FloorPlan, event: React.MouseEvent) => {
    event.stopPropagation();
    if (window.confirm(`Delete room "${room.name}"?\n\nThis will remove all fixtures in this room.`)) {
      // TODO: Implement room deletion via FloorCanvasAPI
      alert('Delete Room feature coming soon!');
    }
  };

  if (rooms.length === 0) {
    return null;
  }

  return (
    <div
      style={{
        display: 'flex',
        gap: 8,
        marginBottom: 16,
        alignItems: 'center',
      }}
    >
      {rooms.map((room) => (
        <div
          key={room.id}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: 4,
          }}
        >
          {editingRoomId === room.id ? (
            <input
              type="text"
              value={editingName}
              onChange={(e) => setEditingName(e.target.value)}
              onBlur={() => handleRenameSubmit(room.id)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') handleRenameSubmit(room.id);
                if (e.key === 'Escape') {
                  setEditingRoomId(null);
                  setEditingName('');
                }
              }}
              autoFocus
              style={{
                minWidth: 120,
                padding: '8px 16px',
                borderRadius: 8,
                border: '2px solid #3498db',
                fontSize: 14,
              }}
            />
          ) : (
            <button
              onClick={() => onRoomSelect(room.id)}
              onDoubleClick={(e) => handleStartRename(room, e)}
              style={{
                minWidth: 120,
                padding: '8px 16px',
                borderRadius: 8,
                border: selectedRoomId === room.id ? '2px solid #3498db' : '1px solid #ccc',
                backgroundColor: selectedRoomId === room.id ? '#e3f2fd' : 'white',
                cursor: 'pointer',
                fontWeight: selectedRoomId === room.id ? 600 : 400,
                fontSize: 14,
              }}
            >
              {room.name}
            </button>
          )}
          {rooms.length > 1 && selectedRoomId === room.id && (
            <button
              onClick={(e) => handleDeleteRoom(room, e)}
              style={{
                padding: '4px 8px',
                borderRadius: 4,
                border: '1px solid #f44336',
                backgroundColor: 'white',
                color: '#f44336',
                cursor: 'pointer',
                fontSize: 12,
              }}
              title="Delete room"
            >
              
            </button>
          )}
        </div>
      ))}
      <button
        onClick={handleAddRoom}
        style={{
          padding: '8px 16px',
          borderRadius: 8,
          border: '2px dashed #3498db',
          backgroundColor: 'white',
          color: '#3498db',
          cursor: 'pointer',
          fontWeight: 600,
          fontSize: 14,
        }}
      >
        + Add Room
      </button>
    </div>
  );
}

// =============================================================================
// EXPORTS
// =============================================================================

export default FloorCanvas;



################################################################################
# FILE: src/domains/floor-plan/canvas/floorCanvasAPI.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 1: Floor Canvas API
 *
 * Manages floor plans, rooms, fixtures, and collision detection.
 */

import type {
  FloorPlan,
  Fixture,
  FixtureType,
  FixtureCategory,
  Point,
} from '../shared/types';

// =============================================================================
// CONFIGURATION
// =============================================================================

const DEFAULT_PIXELS_PER_FOOT = 20; // 20px = 1 foot
let pixelsPerFoot = DEFAULT_PIXELS_PER_FOOT;

// =============================================================================
// STATE (In production, this would come from the database)
// =============================================================================

let floorPlans: Map<string, FloorPlan> = new Map();
let fixtures: Map<string, Fixture> = new Map();
let activeRoomId: string | null = null;

// =============================================================================
// COORDINATE SYSTEM
// =============================================================================

/**
 * Convert feet to pixels
 */
export function feetToPixels(feet: number): number {
  return feet * pixelsPerFoot;
}

/**
 * Convert pixels to feet
 */
export function pixelsToFeet(pixels: number): number {
  return pixels / pixelsPerFoot;
}

/**
 * Set the scale (pixels per foot)
 */
export function setScale(pxPerFoot: number): void {
  pixelsPerFoot = pxPerFoot;
}

/**
 * Get current scale
 */
export function getScale(): number {
  return pixelsPerFoot;
}

/**
 * Snap a position to the grid
 */
export function snapToGrid(position: Point, gridSizeFeet: number): Point {
  return {
    x: Math.round(position.x / gridSizeFeet) * gridSizeFeet,
    y: Math.round(position.y / gridSizeFeet) * gridSizeFeet,
  };
}

// =============================================================================
// FLOOR PLAN / ROOM MANAGEMENT
// =============================================================================

/**
 * Get a floor plan by ID
 */
export function getFloorPlan(roomId?: string): FloorPlan | null {
  const id = roomId ?? activeRoomId;
  if (!id) return null;
  return floorPlans.get(id) ?? null;
}

/**
 * Get all rooms/floor plans
 */
export function getAllRooms(): FloorPlan[] {
  return Array.from(floorPlans.values())
    .filter((fp) => fp.isActive)
    .sort((a, b) => a.sortOrder - b.sortOrder);
}

/**
 * Get the currently active room ID
 */
export function getActiveRoom(): string | null {
  return activeRoomId;
}

/**
 * Set the active room
 */
export function setActiveRoom(roomId: string): void {
  if (floorPlans.has(roomId)) {
    activeRoomId = roomId;
  }
}

/**
 * Get rooms by type
 */
export function getRoomsByType(type: string): FloorPlan[] {
  return Array.from(floorPlans.values()).filter(
    (fp) => fp.type === type && fp.isActive
  );
}

/**
 * Get canvas dimensions in pixels for a room
 */
export function getCanvasDimensions(roomId?: string): {
  widthPx: number;
  heightPx: number;
} {
  const fp = getFloorPlan(roomId);
  if (!fp) {
    return { widthPx: 0, heightPx: 0 };
  }
  return {
    widthPx: feetToPixels(fp.widthFeet),
    heightPx: feetToPixels(fp.heightFeet),
  };
}

// =============================================================================
// FLOOR PLAN CRUD
// =============================================================================

/**
 * Create a new floor plan
 */
export function createFloorPlan(
  data: Omit<FloorPlan, 'id'>
): FloorPlan {
  const id = `fp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const floorPlan: FloorPlan = {
    id,
    ...data,
  };
  floorPlans.set(id, floorPlan);

  // Set as active if it's the first one
  if (!activeRoomId) {
    activeRoomId = id;
  }

  return floorPlan;
}

/**
 * Update a floor plan
 */
export function updateFloorPlan(
  roomId: string,
  updates: Partial<FloorPlan>
): void {
  const fp = floorPlans.get(roomId);
  if (fp) {
    floorPlans.set(roomId, { ...fp, ...updates });
  }
}

/**
 * Delete a floor plan
 */
export function deleteFloorPlan(roomId: string): void {
  floorPlans.delete(roomId);
  // Also delete all fixtures in this room
  for (const [id, fixture] of fixtures) {
    if (fixture.roomId === roomId) {
      fixtures.delete(id);
    }
  }
  // Update active room if necessary
  if (activeRoomId === roomId) {
    const rooms = getAllRooms();
    activeRoomId = rooms.length > 0 ? rooms[0].id : null;
  }
}

// =============================================================================
// FIXTURE MANAGEMENT
// =============================================================================

/**
 * Get all fixtures for a room
 */
export function getFixtures(roomId: string): Fixture[] {
  return Array.from(fixtures.values()).filter(
    (f) => f.roomId === roomId && f.isActive
  );
}

/**
 * Get fixtures by type
 */
export function getFixturesByType(
  roomId: string,
  type: FixtureType
): Fixture[] {
  return getFixtures(roomId).filter((f) => f.type === type);
}

/**
 * Get fixtures by category
 */
export function getFixturesByCategory(
  roomId: string,
  category: FixtureCategory
): Fixture[] {
  return getFixtures(roomId).filter((f) => f.category === category);
}

/**
 * Get bar counters (convenience method)
 */
export function getBarCounters(roomId: string): Fixture[] {
  return getFixturesByType(roomId, 'bar_counter');
}

/**
 * Add a fixture
 */
export function addFixture(data: Omit<Fixture, 'id'>): Fixture {
  const id = `fix_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const fixture: Fixture = {
    id,
    ...data,
  };
  fixtures.set(id, fixture);
  return fixture;
}

/**
 * Update a fixture
 */
export function updateFixture(
  fixtureId: string,
  updates: Partial<Fixture>
): void {
  const fixture = fixtures.get(fixtureId);
  if (fixture) {
    fixtures.set(fixtureId, { ...fixture, ...updates });
  }
}

/**
 * Remove a fixture
 */
export function removeFixture(fixtureId: string): void {
  fixtures.delete(fixtureId);
}

// =============================================================================
// COLLISION DETECTION
// =============================================================================

/**
 * Check if a position is blocked by fixtures
 */
export function isPositionBlocked(
  roomId: string,
  position: Point,
  objectWidth: number,
  objectHeight: number
): boolean {
  const roomFixtures = getFixtures(roomId);

  // Calculate object bounds
  const objectLeft = position.x;
  const objectRight = position.x + objectWidth;
  const objectTop = position.y;
  const objectBottom = position.y + objectHeight;

  for (const fixture of roomFixtures) {
    // Skip fixtures that don't block placement
    if (!fixture.blocksPlacement) continue;

    // Check collision based on geometry type
    if (fixture.geometry.type === 'rectangle') {
      const { position: fPos, width, height, rotation } = fixture.geometry;

      // For now, ignore rotation (simplified collision)
      const fixtureLeft = fPos.x;
      const fixtureRight = fPos.x + width;
      const fixtureTop = fPos.y;
      const fixtureBottom = fPos.y + height;

      // AABB collision check
      if (
        objectLeft < fixtureRight &&
        objectRight > fixtureLeft &&
        objectTop < fixtureBottom &&
        objectBottom > fixtureTop
      ) {
        return true;
      }
    } else if (fixture.geometry.type === 'circle') {
      const { center, radius } = fixture.geometry;

      // Check if any corner of the object is inside the circle
      // Or if the circle center is inside the object bounds
      const closestX = Math.max(objectLeft, Math.min(center.x, objectRight));
      const closestY = Math.max(objectTop, Math.min(center.y, objectBottom));

      const distanceX = center.x - closestX;
      const distanceY = center.y - closestY;
      const distanceSquared = distanceX * distanceX + distanceY * distanceY;

      if (distanceSquared < radius * radius) {
        return true;
      }
    } else if (fixture.geometry.type === 'line') {
      const { start, end } = fixture.geometry;
      const thickness = fixture.thickness || 0.5; // Default wall thickness

      // Convert line to rectangle for collision
      const lineLeft = Math.min(start.x, end.x) - thickness / 2;
      const lineRight = Math.max(start.x, end.x) + thickness / 2;
      const lineTop = Math.min(start.y, end.y) - thickness / 2;
      const lineBottom = Math.max(start.y, end.y) + thickness / 2;

      if (
        objectLeft < lineRight &&
        objectRight > lineLeft &&
        objectTop < lineBottom &&
        objectBottom > lineTop
      ) {
        return true;
      }
    }
    // Add more geometry types as needed
  }

  // Also check room boundaries
  const room = getFloorPlan(roomId);
  if (room) {
    if (
      objectLeft < 0 ||
      objectTop < 0 ||
      objectRight > room.widthFeet ||
      objectBottom > room.heightFeet
    ) {
      return true;
    }
  }

  return false;
}

/**
 * Get fixtures that an object can snap to
 */
export function getSnapTargets(
  roomId: string,
  objectPosition: Point,
  snapDistance: number
): Fixture[] {
  const roomFixtures = getFixtures(roomId);

  return roomFixtures.filter((fixture) => {
    if (!fixture.snapTarget) return false;

    // Calculate distance to fixture (simplified)
    if (fixture.geometry.type === 'rectangle') {
      const { position: fPos, width, height } = fixture.geometry;
      const centerX = fPos.x + width / 2;
      const centerY = fPos.y + height / 2;

      const dx = Math.abs(objectPosition.x - centerX);
      const dy = Math.abs(objectPosition.y - centerY);

      // Check if within snap distance of any edge
      return (
        (dx < width / 2 + snapDistance && dy < height / 2) ||
        (dy < height / 2 + snapDistance && dx < width / 2)
      );
    }

    return false;
  });
}

/**
 * Get the nearest edge point of a fixture
 */
export function getNearestFixtureEdge(
  roomId: string,
  position: Point,
  fixtureId: string
): Point | null {
  const fixture = fixtures.get(fixtureId);
  if (!fixture || fixture.roomId !== roomId) return null;

  if (fixture.geometry.type === 'rectangle') {
    const { position: fPos, width, height } = fixture.geometry;

    // Calculate distances to each edge
    const edges = [
      { x: position.x, y: fPos.y }, // Top edge
      { x: position.x, y: fPos.y + height }, // Bottom edge
      { x: fPos.x, y: position.y }, // Left edge
      { x: fPos.x + width, y: position.y }, // Right edge
    ];

    // Clamp positions to be on the fixture
    edges[0].x = Math.max(fPos.x, Math.min(position.x, fPos.x + width));
    edges[1].x = Math.max(fPos.x, Math.min(position.x, fPos.x + width));
    edges[2].y = Math.max(fPos.y, Math.min(position.y, fPos.y + height));
    edges[3].y = Math.max(fPos.y, Math.min(position.y, fPos.y + height));

    // Find nearest edge
    let nearest = edges[0];
    let minDist = Infinity;

    for (const edge of edges) {
      const dist = Math.sqrt(
        Math.pow(position.x - edge.x, 2) + Math.pow(position.y - edge.y, 2)
      );
      if (dist < minDist) {
        minDist = dist;
        nearest = edge;
      }
    }

    return nearest;
  }

  return null;
}

/**
 * Get the valid placement area (room minus barriers)
 * Returns a simplified polygon of placeable area
 */
export function getPlaceableArea(roomId: string): Point[] {
  const room = getFloorPlan(roomId);
  if (!room) return [];

  // Start with room boundaries
  const area: Point[] = [
    { x: 0, y: 0 },
    { x: room.widthFeet, y: 0 },
    { x: room.widthFeet, y: room.heightFeet },
    { x: 0, y: room.heightFeet },
  ];

  // In a full implementation, we would subtract barrier fixtures
  // For now, return the room boundary
  return area;
}

// =============================================================================
// INITIALIZATION
// =============================================================================

/**
 * Initialize the canvas with floor plans from the database
 */
export function initializeFloorPlans(plans: FloorPlan[], fixtureList: Fixture[]): void {
  floorPlans.clear();
  fixtures.clear();

  for (const plan of plans) {
    floorPlans.set(plan.id, plan);
  }

  for (const fixture of fixtureList) {
    fixtures.set(fixture.id, fixture);
  }

  // Set first active room
  const activeRooms = getAllRooms();
  if (activeRooms.length > 0 && !activeRoomId) {
    activeRoomId = activeRooms[0].id;
  }
}

/**
 * Clear all data (for testing)
 */
export function clearAll(): void {
  floorPlans.clear();
  fixtures.clear();
  activeRoomId = null;
}

// =============================================================================
// EXPORT THE API
// =============================================================================

export const FloorCanvasAPI = {
  // Coordinate system
  feetToPixels,
  pixelsToFeet,
  setScale,
  getScale,
  snapToGrid,

  // Room management
  getFloorPlan,
  getAllRooms,
  getActiveRoom,
  setActiveRoom,
  getRoomsByType,
  getCanvasDimensions,

  // Floor plan CRUD
  createFloorPlan,
  updateFloorPlan,
  deleteFloorPlan,

  // Fixture management
  getFixtures,
  getFixturesByType,
  getFixturesByCategory,
  getBarCounters,
  addFixture,
  updateFixture,
  removeFixture,

  // Collision detection
  isPositionBlocked,
  getSnapTargets,
  getNearestFixtureEdge,
  getPlaceableArea,

  // Initialization
  initializeFloorPlans,
  clearAll,
};

export default FloorCanvasAPI;



################################################################################
# FILE: src/domains/floor-plan/canvas/index.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 1: Floor Canvas
 *
 * Public exports for the canvas layer.
 */

export { FloorCanvas, RoomSelector } from './FloorCanvas';
export { FloorCanvasAPI, default as floorCanvasAPI } from './floorCanvasAPI';

// Re-export types used by this layer
export type {
  FloorPlan,
  Fixture,
  FixtureType,
  FixtureCategory,
  FixtureGeometry,
  Point,
  RoomType,
} from '../shared/types';



################################################################################
# FILE: src/domains/floor-plan/groups/__tests__/mergeLogic.test.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - Merge Logic Tests
 */

import { Table } from '../../shared/types';
import {
  detectMergeOpportunity,
  calculateSnapPosition,
  areTablesAdjacent,
} from '../mergeLogic';

// Helper to create a mock table
function createTable(
  id: string,
  x: number,
  y: number,
  width: number,
  height: number
): Table {
  return {
    id,
    locationId: 'loc-1',
    floorPlanId: 'room-1',
    sectionId: null,
    label: id,
    objectType: 'dining_table',
    category: 'seatable',
    shape: 'square',
    positionX: x,
    positionY: y,
    width,
    height,
    rotation: 0,
    minCapacity: 2,
    maxCapacity: 4,
    defaultCapacity: 4,
    isActive: true,
    isReservable: true,
    sortOrder: 0,
    groupId: null,
    combinedTableIds: [],
    color: null,
    entertainmentConfig: null,
  };
}

describe('Merge Logic', () => {
  describe('detectMergeOpportunity', () => {
    it('should detect snap to right edge', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 4, 0, 3, 3);
      const dragPos = { x: 3.5, y: 0 };

      const detection = detectMergeOpportunity(table1, table2, dragPos);

      expect(detection.canMerge).toBe(true);
      expect(detection.snapEdge).toBe('left');
      expect(detection.snapPosition).toBeDefined();
    });

    it('should detect snap to bottom edge', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 0, 4, 3, 3);
      const dragPos = { x: 0, y: 3.5 };

      const detection = detectMergeOpportunity(table1, table2, dragPos);

      expect(detection.canMerge).toBe(true);
      expect(detection.snapEdge).toBe('top');
      expect(detection.snapPosition).toBeDefined();
    });

    it('should not detect merge if too far', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 10, 0, 3, 3);
      const dragPos = { x: 3, y: 0 };

      const detection = detectMergeOpportunity(table1, table2, dragPos);

      expect(detection.canMerge).toBe(false);
    });

    it('should not merge with self', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const dragPos = { x: 0, y: 0 };

      const detection = detectMergeOpportunity(table1, table1, dragPos);

      expect(detection.canMerge).toBe(false);
    });

    it('should not merge tables in different rooms', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 3, 0, 3, 3);
      table2.floorPlanId = 'room-2';
      const dragPos = { x: 3, y: 0 };

      const detection = detectMergeOpportunity(table1, table2, dragPos);

      expect(detection.canMerge).toBe(false);
    });
  });

  describe('calculateSnapPosition', () => {
    it('should calculate snap to right edge', () => {
      const target = createTable('t1', 0, 0, 3, 3);
      const dragging = createTable('t2', 5, 0, 3, 3);

      const snapPos = calculateSnapPosition(dragging, target, 'right');

      expect(snapPos).toEqual({ x: 3, y: 0 });
    });

    it('should calculate snap to left edge', () => {
      const target = createTable('t1', 5, 0, 3, 3);
      const dragging = createTable('t2', 0, 0, 3, 3);

      const snapPos = calculateSnapPosition(dragging, target, 'left');

      expect(snapPos).toEqual({ x: 2, y: 0 });
    });

    it('should calculate snap to bottom edge', () => {
      const target = createTable('t1', 0, 0, 3, 3);
      const dragging = createTable('t2', 0, 5, 3, 3);

      const snapPos = calculateSnapPosition(dragging, target, 'bottom');

      expect(snapPos).toEqual({ x: 0, y: 3 });
    });

    it('should calculate snap to top edge', () => {
      const target = createTable('t1', 0, 5, 3, 3);
      const dragging = createTable('t2', 0, 0, 3, 3);

      const snapPos = calculateSnapPosition(dragging, target, 'top');

      expect(snapPos).toEqual({ x: 0, y: 2 });
    });
  });

  describe('areTablesAdjacent', () => {
    it('should detect horizontal adjacency', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 3, 0, 3, 3);

      expect(areTablesAdjacent(table1, table2)).toBe(true);
    });

    it('should detect vertical adjacency', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 0, 3, 3, 3);

      expect(areTablesAdjacent(table1, table2)).toBe(true);
    });

    it('should not detect if not touching', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 5, 0, 3, 3);

      expect(areTablesAdjacent(table1, table2)).toBe(false);
    });

    it('should not detect if only corners touch', () => {
      const table1 = createTable('t1', 0, 0, 3, 3);
      const table2 = createTable('t2', 3, 3, 3, 3);

      expect(areTablesAdjacent(table1, table2)).toBe(false);
    });
  });
});



################################################################################
# FILE: src/domains/floor-plan/groups/__tests__/tableGroupAPI.test.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - API Tests
 */

import { tableGroupAPI } from '../tableGroupAPI';
import { clearColorAssignments } from '../colorPalette';

describe('TableGroupAPI', () => {
  beforeEach(() => {
    // Clear all groups and color assignments before each test
    tableGroupAPI.clearAll();
    clearColorAssignments();
  });

  describe('Physical Merge', () => {
    it('should create a physical merge group', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      expect(group).toBeDefined();
      expect(group.id).toBeDefined();
      expect(group.isVirtual).toBe(false);
      expect(group.tableIds).toEqual(['table-1', 'table-2']);
      expect(group.color).toBeDefined();
    });

    it('should not allow merging less than 2 tables', () => {
      expect(() => {
        tableGroupAPI.createPhysicalMerge(['table-1']);
      }).toThrow('Physical merge requires at least 2 tables');
    });

    it('should not allow merging already grouped tables', () => {
      tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      expect(() => {
        tableGroupAPI.createPhysicalMerge(['table-1', 'table-3']);
      }).toThrow('Table table-1 is already in a group');
    });
  });

  describe('Virtual Group', () => {
    it('should create a virtual group', () => {
      const group = tableGroupAPI.createVirtualGroup(['table-1', 'table-3']);

      expect(group).toBeDefined();
      expect(group.id).toBeDefined();
      expect(group.isVirtual).toBe(true);
      expect(group.tableIds).toEqual(['table-1', 'table-3']);
      expect(group.color).toBeDefined();
    });

    it('should not allow grouping less than 2 tables', () => {
      expect(() => {
        tableGroupAPI.createVirtualGroup(['table-1']);
      }).toThrow('Virtual group requires at least 2 tables');
    });
  });

  describe('Dissolve Group', () => {
    it('should dissolve a group', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      tableGroupAPI.dissolveGroup(group.id);

      expect(tableGroupAPI.getGroup(group.id)).toBeNull();
      expect(tableGroupAPI.getGroupForTable('table-1')).toBeNull();
      expect(tableGroupAPI.getGroupForTable('table-2')).toBeNull();
    });

    it('should throw if group not found', () => {
      expect(() => {
        tableGroupAPI.dissolveGroup('non-existent');
      }).toThrow('Group non-existent not found');
    });
  });

  describe('Queries', () => {
    it('should get group by ID', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      const found = tableGroupAPI.getGroup(group.id);
      expect(found).toEqual(group);
    });

    it('should get group for table', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      const found1 = tableGroupAPI.getGroupForTable('table-1');
      const found2 = tableGroupAPI.getGroupForTable('table-2');

      expect(found1).toEqual(group);
      expect(found2).toEqual(group);
    });

    it('should return null for ungrouped table', () => {
      const found = tableGroupAPI.getGroupForTable('table-1');
      expect(found).toBeNull();
    });

    it('should get all active groups', () => {
      const group1 = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);
      const group2 = tableGroupAPI.createVirtualGroup(['table-3', 'table-4']);

      const allGroups = tableGroupAPI.getAllActiveGroups();

      expect(allGroups).toHaveLength(2);
      expect(allGroups).toContainEqual(group1);
      expect(allGroups).toContainEqual(group2);
    });
  });

  describe('Membership', () => {
    it('should add table to group', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      tableGroupAPI.addTableToGroup(group.id, 'table-3');

      const updated = tableGroupAPI.getGroup(group.id);
      expect(updated?.tableIds).toEqual(['table-1', 'table-2', 'table-3']);
    });

    it('should remove table from group', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2', 'table-3']);

      tableGroupAPI.removeTableFromGroup(group.id, 'table-3');

      const updated = tableGroupAPI.getGroup(group.id);
      expect(updated?.tableIds).toEqual(['table-1', 'table-2']);
    });

    it('should dissolve group when only 1 table remains', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      tableGroupAPI.removeTableFromGroup(group.id, 'table-2');

      // Group should be dissolved
      expect(tableGroupAPI.getGroup(group.id)).toBeNull();
    });
  });

  describe('Properties', () => {
    it('should set group identifier', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      tableGroupAPI.setGroupIdentifier(group.id, 'Smith-8PM');

      const updated = tableGroupAPI.getGroup(group.id);
      expect(updated?.identifier).toBe('Smith-8PM');
    });

    it('should set group color', () => {
      const group = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      tableGroupAPI.setGroupColor(group.id, '#FF0000');

      const updated = tableGroupAPI.getGroup(group.id);
      expect(updated?.color).toBe('#FF0000');
    });
  });

  describe('Color Cycling', () => {
    it('should assign different colors to groups', () => {
      const group1 = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);
      const group2 = tableGroupAPI.createPhysicalMerge(['table-3', 'table-4']);

      expect(group1.color).not.toBe(group2.color);
    });

    it('should release color on dissolve', () => {
      const group1 = tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);
      const color1 = group1.color;

      tableGroupAPI.dissolveGroup(group1.id);

      const group2 = tableGroupAPI.createPhysicalMerge(['table-3', 'table-4']);

      // Should reuse the released color
      expect(group2.color).toBe(color1);
    });
  });

  describe('Initialization', () => {
    it('should initialize groups from array', () => {
      const mockGroups = [
        {
          id: 'group-1',
          locationId: 'loc-1',
          tableIds: ['table-1', 'table-2'],
          primaryTableId: 'table-1',
          isVirtual: false,
          color: '#E74C3C',
          identifier: 'Group 1',
          combinedCapacity: 8,
          isActive: true,
          createdAt: new Date(),
          createdBy: 'staff-1',
        },
      ];

      tableGroupAPI.initializeGroups(mockGroups);

      const loaded = tableGroupAPI.getGroup('group-1');
      expect(loaded).toEqual(mockGroups[0]);
      expect(tableGroupAPI.getGroupForTable('table-1')).toEqual(mockGroups[0]);
    });

    it('should clear all on initialization', () => {
      tableGroupAPI.createPhysicalMerge(['table-1', 'table-2']);

      tableGroupAPI.initializeGroups([]);

      expect(tableGroupAPI.getAllActiveGroups()).toHaveLength(0);
    });
  });
});



################################################################################
# FILE: src/domains/floor-plan/groups/__tests__/virtualGroup.test.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - Virtual Group Selection Tests
 */

import {
  startVirtualSelection,
  addToVirtualSelection,
  removeFromVirtualSelection,
  toggleVirtualSelection,
  isInSelectionMode,
  isTableSelected,
  getSelectedTableIds,
  getSelectedCount,
  cancelVirtualSelection,
  confirmVirtualGroup,
  onSelectionChange,
} from '../virtualGroup';

describe('Virtual Group Selection', () => {
  beforeEach(() => {
    // Cancel any active selection before each test
    cancelVirtualSelection();
  });

  describe('Selection Mode', () => {
    it('should start selection mode', () => {
      startVirtualSelection('table-1');

      expect(isInSelectionMode()).toBe(true);
      expect(isTableSelected('table-1')).toBe(true);
      expect(getSelectedTableIds()).toEqual(['table-1']);
    });

    it('should add tables to selection', () => {
      startVirtualSelection('table-1');
      addToVirtualSelection('table-2');
      addToVirtualSelection('table-3');

      expect(getSelectedCount()).toBe(3);
      expect(getSelectedTableIds()).toEqual(['table-1', 'table-2', 'table-3']);
    });

    it('should not add duplicate tables', () => {
      startVirtualSelection('table-1');
      addToVirtualSelection('table-2');
      addToVirtualSelection('table-2'); // Duplicate

      expect(getSelectedCount()).toBe(2);
      expect(getSelectedTableIds()).toEqual(['table-1', 'table-2']);
    });

    it('should remove tables from selection', () => {
      startVirtualSelection('table-1');
      addToVirtualSelection('table-2');
      addToVirtualSelection('table-3');

      removeFromVirtualSelection('table-2');

      expect(getSelectedCount()).toBe(2);
      expect(getSelectedTableIds()).toEqual(['table-1', 'table-3']);
    });

    it('should toggle table selection', () => {
      startVirtualSelection('table-1');

      toggleVirtualSelection('table-2');
      expect(isTableSelected('table-2')).toBe(true);

      toggleVirtualSelection('table-2');
      expect(isTableSelected('table-2')).toBe(false);
    });
  });

  describe('Cancel Selection', () => {
    it('should cancel selection and clear state', () => {
      startVirtualSelection('table-1');
      addToVirtualSelection('table-2');

      cancelVirtualSelection();

      expect(isInSelectionMode()).toBe(false);
      expect(getSelectedCount()).toBe(0);
      expect(getSelectedTableIds()).toEqual([]);
    });
  });

  describe('Confirm Group', () => {
    it('should return selected IDs and clear state', () => {
      startVirtualSelection('table-1');
      addToVirtualSelection('table-2');
      addToVirtualSelection('table-3');

      const selectedIds = confirmVirtualGroup();

      expect(selectedIds).toEqual(['table-1', 'table-2', 'table-3']);
      expect(isInSelectionMode()).toBe(false);
      expect(getSelectedCount()).toBe(0);
    });
  });

  describe('Selection Change Callbacks', () => {
    it('should notify callbacks on selection changes', () => {
      const callback = jest.fn();
      const unsubscribe = onSelectionChange(callback);

      startVirtualSelection('table-1');
      expect(callback).toHaveBeenCalledWith({
        isSelecting: true,
        selectedTableIds: ['table-1'],
        startedAt: expect.any(Date),
      });

      addToVirtualSelection('table-2');
      expect(callback).toHaveBeenCalledWith({
        isSelecting: true,
        selectedTableIds: ['table-1', 'table-2'],
        startedAt: expect.any(Date),
      });

      unsubscribe();
      callback.mockClear();

      // Should not be called after unsubscribe
      addToVirtualSelection('table-3');
      expect(callback).not.toHaveBeenCalled();
    });

    it('should support multiple callbacks', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();

      onSelectionChange(callback1);
      onSelectionChange(callback2);

      startVirtualSelection('table-1');

      expect(callback1).toHaveBeenCalled();
      expect(callback2).toHaveBeenCalled();
    });
  });

  describe('Query Functions', () => {
    it('should check if table is selected', () => {
      startVirtualSelection('table-1');
      addToVirtualSelection('table-2');

      expect(isTableSelected('table-1')).toBe(true);
      expect(isTableSelected('table-2')).toBe(true);
      expect(isTableSelected('table-3')).toBe(false);
    });

    it('should return selected count', () => {
      expect(getSelectedCount()).toBe(0);

      startVirtualSelection('table-1');
      expect(getSelectedCount()).toBe(1);

      addToVirtualSelection('table-2');
      expect(getSelectedCount()).toBe(2);
    });

    it('should return empty when not selecting', () => {
      expect(isInSelectionMode()).toBe(false);
      expect(getSelectedTableIds()).toEqual([]);
      expect(getSelectedCount()).toBe(0);
    });
  });

  describe('Edge Cases', () => {
    it('should handle adding when not in selection mode', () => {
      addToVirtualSelection('table-1');

      expect(isInSelectionMode()).toBe(false);
      expect(getSelectedCount()).toBe(0);
    });

    it('should handle removing when not in selection mode', () => {
      removeFromVirtualSelection('table-1');

      expect(isInSelectionMode()).toBe(false);
      expect(getSelectedCount()).toBe(0);
    });

    it('should handle removing non-existent table', () => {
      startVirtualSelection('table-1');

      removeFromVirtualSelection('table-99');

      expect(getSelectedCount()).toBe(1);
      expect(getSelectedTableIds()).toEqual(['table-1']);
    });
  });
});



################################################################################
# FILE: src/domains/floor-plan/groups/colorPalette.ts
################################################################################

/**
 * Color Palette for Virtual Table Groups
 *
 * Provides color families with multiple shades so each table in a combined
 * group can have a distinct but related color. Seats are slightly lighter
 * than their parent table.
 */

export type ColorFamilyName = 'blue' | 'green' | 'purple' | 'amber' | 'teal' | 'rose';

export interface ColorFamily {
  name: ColorFamilyName;
  displayName: string;
  // Shades from darkest to lightest (for tables)
  tableShades: string[];
  // Corresponding seat shades (lighter than table)
  seatShades: string[];
  // Base color for the family (used for group outline)
  base: string;
}

/**
 * Color families optimized for visual distinction on floor plan
 * Each family has 6 shades to support up to 6 tables per group
 */
export const COLOR_FAMILIES: Record<ColorFamilyName, ColorFamily> = {
  blue: {
    name: 'blue',
    displayName: 'Blue',
    base: '#3B82F6',
    tableShades: ['#1E40AF', '#1D4ED8', '#2563EB', '#3B82F6', '#60A5FA', '#93C5FD'],
    seatShades: ['#3B82F6', '#60A5FA', '#93C5FD', '#BFDBFE', '#DBEAFE', '#EFF6FF'],
  },
  green: {
    name: 'green',
    displayName: 'Green',
    base: '#22C55E',
    tableShades: ['#14532D', '#15803D', '#16A34A', '#22C55E', '#4ADE80', '#86EFAC'],
    seatShades: ['#22C55E', '#4ADE80', '#86EFAC', '#BBF7D0', '#DCFCE7', '#F0FDF4'],
  },
  purple: {
    name: 'purple',
    displayName: 'Purple',
    base: '#A855F7',
    tableShades: ['#581C87', '#7E22CE', '#9333EA', '#A855F7', '#C084FC', '#D8B4FE'],
    seatShades: ['#A855F7', '#C084FC', '#D8B4FE', '#E9D5FF', '#F3E8FF', '#FAF5FF'],
  },
  amber: {
    name: 'amber',
    displayName: 'Amber',
    base: '#F59E0B',
    tableShades: ['#78350F', '#92400E', '#B45309', '#D97706', '#F59E0B', '#FBBF24'],
    seatShades: ['#F59E0B', '#FBBF24', '#FCD34D', '#FDE68A', '#FEF3C7', '#FFFBEB'],
  },
  teal: {
    name: 'teal',
    displayName: 'Teal',
    base: '#14B8A6',
    tableShades: ['#134E4A', '#115E59', '#0F766E', '#0D9488', '#14B8A6', '#2DD4BF'],
    seatShades: ['#14B8A6', '#2DD4BF', '#5EEAD4', '#99F6E4', '#CCFBF1', '#F0FDFA'],
  },
  rose: {
    name: 'rose',
    displayName: 'Rose',
    base: '#F43F5E',
    tableShades: ['#881337', '#9F1239', '#BE123C', '#E11D48', '#F43F5E', '#FB7185'],
    seatShades: ['#F43F5E', '#FB7185', '#FDA4AF', '#FECDD3', '#FFE4E6', '#FFF1F2'],
  },
};

/**
 * Get all available color family names
 */
export function getColorFamilyNames(): ColorFamilyName[] {
  return Object.keys(COLOR_FAMILIES) as ColorFamilyName[];
}

/**
 * Get a color family by name
 */
export function getColorFamily(name: ColorFamilyName): ColorFamily {
  return COLOR_FAMILIES[name];
}

/**
 * Get a color family for a group based on group index
 * Cycles through families if more groups than families
 */
export function getColorFamilyForGroup(groupIndex: number): ColorFamily {
  const families = getColorFamilyNames();
  const familyName = families[groupIndex % families.length];
  return COLOR_FAMILIES[familyName];
}

/**
 * Get table color within a family based on table index in group
 * @param family - The color family
 * @param tableIndex - 0-based index of table within the group
 */
export function getTableColor(family: ColorFamily, tableIndex: number): string {
  const shades = family.tableShades;
  return shades[tableIndex % shades.length];
}

/**
 * Get seat color for a table (lighter than the table color)
 * @param family - The color family
 * @param tableIndex - 0-based index of table within the group
 */
export function getSeatColor(family: ColorFamily, tableIndex: number): string {
  const shades = family.seatShades;
  return shades[tableIndex % shades.length];
}

/**
 * Get the group outline/glow color (base color of family)
 */
export function getGroupOutlineColor(family: ColorFamily): string {
  return family.base;
}

/**
 * Generate color assignments for all tables in a group
 * Returns a map of tableId  { tableColor, seatColor }
 */
export interface TableColorAssignment {
  tableId: string;
  tableColor: string;
  seatColor: string;
  familyName: ColorFamilyName;
}

export function assignColorsToGroup(
  tableIds: string[],
  groupIndex: number = 0
): TableColorAssignment[] {
  const family = getColorFamilyForGroup(groupIndex);

  return tableIds.map((tableId, index) => ({
    tableId,
    tableColor: getTableColor(family, index),
    seatColor: getSeatColor(family, index),
    familyName: family.name,
  }));
}

/**
 * Create a lookup map from tableId to colors
 */
export function createColorLookup(
  assignments: TableColorAssignment[]
): Map<string, { tableColor: string; seatColor: string }> {
  return new Map(
    assignments.map((a) => [a.tableId, { tableColor: a.tableColor, seatColor: a.seatColor }])
  );
}

/**
 * Get a semi-transparent version of a color for overlays/glows
 * @param hexColor - Hex color string (e.g., '#3B82F6')
 * @param opacity - Opacity value 0-1 (default 0.3)
 */
export function getColorWithOpacity(hexColor: string, opacity: number = 0.3): string {
  // Convert opacity to hex (0-255)
  const alphaHex = Math.round(opacity * 255).toString(16).padStart(2, '0');
  return `${hexColor}${alphaHex}`;
}

/**
 * Get CSS box-shadow for group glow effect
 */
export function getGroupGlowStyle(family: ColorFamily): string {
  const color = family.base;
  return `0 0 20px ${getColorWithOpacity(color, 0.4)}, 0 0 40px ${getColorWithOpacity(color, 0.2)}`;
}

/**
 * Get CSS border style for a table in a group
 */
export function getTableBorderStyle(tableColor: string): string {
  return `3px solid ${tableColor}`;
}

// =============================================================================
// LEGACY COMPATIBILITY FUNCTIONS
// These functions support the older tableGroupAPI.ts which uses a different
// color assignment approach (single color per group vs per-table shades)
// =============================================================================

// Track which colors are in use (for legacy API)
const colorsInUse = new Set<string>();

// Simple color list for legacy API (one color per group)
const LEGACY_GROUP_COLORS = [
  '#3B82F6', // blue
  '#22C55E', // green
  '#A855F7', // purple
  '#F59E0B', // amber
  '#14B8A6', // teal
  '#F43F5E', // rose
  '#6366F1', // indigo
  '#EC4899', // pink
];

/**
 * Get the next available color for a group (legacy API)
 */
export function getNextAvailableColor(): string {
  for (const color of LEGACY_GROUP_COLORS) {
    if (!colorsInUse.has(color)) {
      return color;
    }
  }
  // If all colors in use, return a random one
  return LEGACY_GROUP_COLORS[Math.floor(Math.random() * LEGACY_GROUP_COLORS.length)];
}

/**
 * Mark a color as in use (legacy API)
 */
export function markColorInUse(color: string): void {
  colorsInUse.add(color);
}

/**
 * Release a color back to the pool (legacy API)
 */
export function releaseColor(color: string): void {
  colorsInUse.delete(color);
}

/**
 * Clear all color assignments (legacy API)
 */
export function clearColorAssignments(): void {
  colorsInUse.clear();
}



################################################################################
# FILE: src/domains/floor-plan/groups/CrossRoomBadge.tsx
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - CrossRoomBadge Component
 *
 * Small badge shown on tables that are part of a cross-room virtual group
 */

'use client';

import React from 'react';
import { TableGroup } from '../shared/types';

interface CrossRoomBadgeProps {
  group: TableGroup;
  roomCount: number; // Number of different rooms in the group
  onClick?: () => void; // Click to highlight all tables in group
}

/**
 * CrossRoomBadge Component
 *
 * Shows:
 * - Group color
 * - Number of other rooms (e.g., "+2 rooms")
 * - Clickable to highlight all tables in group
 */
export function CrossRoomBadge({
  group,
  roomCount,
  onClick,
}: CrossRoomBadgeProps) {
  if (!group.isVirtual || roomCount <= 1) {
    return null;
  }

  const otherRoomCount = roomCount - 1;

  return (
    <div
      className="absolute top-1 right-1 px-2 py-1 rounded-full text-xs font-semibold text-white shadow-lg cursor-pointer hover:scale-110 transition-transform z-10"
      style={{
        backgroundColor: group.color,
      }}
      onClick={(e) => {
        e.stopPropagation();
        onClick?.();
      }}
      title={`This table is part of a virtual group spanning ${roomCount} rooms. Click to highlight all tables.`}
    >
      <div className="flex items-center gap-1">
        {/* Multi-room icon */}
        <svg
          className="w-3 h-3"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"
          />
        </svg>

        {/* Room count */}
        <span>+{otherRoomCount}</span>
      </div>
    </div>
  );
}

/**
 * Compact version for smaller tables
 */
export function CrossRoomBadgeCompact({
  group,
  roomCount,
}: {
  group: TableGroup;
  roomCount: number;
}) {
  if (!group.isVirtual || roomCount <= 1) {
    return null;
  }

  return (
    <div
      className="absolute top-0 right-0 w-3 h-3 rounded-full border-2 border-white shadow-md"
      style={{
        backgroundColor: group.color,
      }}
      title={`Part of group spanning ${roomCount} rooms`}
    />
  );
}



################################################################################
# FILE: src/domains/floor-plan/groups/dragCombine.ts
################################################################################

/**
 * Drag-to-Combine Utilities
 *
 * Handles gesture detection and target finding for drag-to-combine.
 */

export interface DragState {
  isDragging: boolean;
  draggedTableId: string | null;
  startX: number;
  startY: number;
  currentX: number;
  currentY: number;
  offsetX: number; // Offset from table center to pointer
  offsetY: number;
}

export interface DropTarget {
  tableId: string;
  tableName: string;
  distance: number; // Distance from dragged table center to target center
  edge: 'top' | 'bottom' | 'left' | 'right'; // Closest edge
}

export interface TableBounds {
  id: string;
  name: string;
  x: number; // posX
  y: number; // posY
  width: number;
  height: number;
  centerX: number;
  centerY: number;
}

/**
 * Convert table data to bounds for hit testing
 */
export function getTableBounds(table: {
  id: string;
  name: string;
  posX: number;
  posY: number;
  width: number;
  height: number;
}): TableBounds {
  return {
    id: table.id,
    name: table.name,
    x: table.posX,
    y: table.posY,
    width: table.width,
    height: table.height,
    centerX: table.posX + table.width / 2,
    centerY: table.posY + table.height / 2,
  };
}

/**
 * Find the closest edge of target table to the dragged table
 */
function findClosestEdge(
  draggedCenter: { x: number; y: number },
  target: TableBounds
): 'top' | 'bottom' | 'left' | 'right' {
  const dx = draggedCenter.x - target.centerX;
  const dy = draggedCenter.y - target.centerY;

  // Determine which edge is closest based on angle
  if (Math.abs(dx) > Math.abs(dy)) {
    return dx > 0 ? 'right' : 'left';
  } else {
    return dy > 0 ? 'bottom' : 'top';
  }
}

/**
 * Calculate distance between two points
 */
function distance(x1: number, y1: number, x2: number, y2: number): number {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

/**
 * Check if a point is within a table's bounds (with padding)
 */
export function isPointInTable(
  x: number,
  y: number,
  table: TableBounds,
  padding: number = 0
): boolean {
  return (
    x >= table.x - padding &&
    x <= table.x + table.width + padding &&
    y >= table.y - padding &&
    y <= table.y + table.height + padding
  );
}

/**
 * Find potential drop target for a dragged table
 *
 * @param draggedTableId - ID of the table being dragged
 * @param dragX - Current X position of dragged table center
 * @param dragY - Current Y position of dragged table center
 * @param allTables - All tables to check against
 * @param snapDistance - Max distance to consider a valid drop target (pixels)
 * @returns DropTarget if found, null otherwise
 */
export function findDropTarget(
  draggedTableId: string,
  dragX: number,
  dragY: number,
  allTables: Array<{
    id: string;
    name: string;
    posX: number;
    posY: number;
    width: number;
    height: number;
    virtualGroupId?: string | null;
    combinedWithId?: string | null;
  }>,
  snapDistance: number = 60 // pixels
): DropTarget | null {
  let closest: DropTarget | null = null;
  let minDist = Infinity;

  for (const table of allTables) {
    // Skip the dragged table itself
    if (table.id === draggedTableId) continue;

    // NOTE: We DO allow dropping onto tables in virtual groups
    // This enables adding more tables to an existing group

    // Skip tables that are physically combined (database-level combining)
    if (table.combinedWithId) continue;

    const bounds = getTableBounds(table);

    // Calculate distance from drag position to table edge (not center)
    // This makes it easier to "connect" tables
    const edgeDistX = Math.max(0, Math.abs(dragX - bounds.centerX) - bounds.width / 2);
    const edgeDistY = Math.max(0, Math.abs(dragY - bounds.centerY) - bounds.height / 2);
    const edgeDist = Math.sqrt(edgeDistX ** 2 + edgeDistY ** 2);

    if (edgeDist < snapDistance && edgeDist < minDist) {
      minDist = edgeDist;
      closest = {
        tableId: table.id,
        tableName: table.name,
        distance: edgeDist,
        edge: findClosestEdge({ x: dragX, y: dragY }, bounds),
      };
    }
  }

  return closest;
}

/**
 * Create initial drag state
 */
export function createDragState(
  tableId: string,
  tableCenterX: number,
  tableCenterY: number,
  pointerX: number,
  pointerY: number
): DragState {
  return {
    isDragging: true,
    draggedTableId: tableId,
    startX: pointerX,
    startY: pointerY,
    currentX: pointerX,
    currentY: pointerY,
    offsetX: pointerX - tableCenterX,
    offsetY: pointerY - tableCenterY,
  };
}

/**
 * Update drag state with new pointer position
 */
export function updateDragState(
  state: DragState,
  pointerX: number,
  pointerY: number
): DragState {
  return {
    ...state,
    currentX: pointerX,
    currentY: pointerY,
  };
}

/**
 * Get the visual position for the dragged table
 */
export function getDraggedTablePosition(state: DragState): { x: number; y: number } {
  return {
    x: state.currentX - state.offsetX,
    y: state.currentY - state.offsetY,
  };
}

/**
 * Reset drag state
 */
export function resetDragState(): DragState {
  return {
    isDragging: false,
    draggedTableId: null,
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    offsetX: 0,
    offsetY: 0,
  };
}



################################################################################
# FILE: src/domains/floor-plan/groups/index.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - Public API
 */

// API Service
export { tableGroupAPI, type TableGroupAPI } from './tableGroupAPI';

// Types
export type {
  MergeDetection,
  VirtualGroupSelection,
  CreateGroupParams,
  MergeResult,
  ColorFamilyName,
  TableColorAssignment,
  SnapEdge,
  SnapPreview,
  SnapConfig,
  TableForPerimeter,
  PerimeterSeatResult,
} from './types';
export { MERGE_CONSTANTS } from './types';

// Merge Logic
export {
  detectMergeOpportunity,
  calculateSnapPosition,
  areTablesAdjacent,
} from './mergeLogic';

// Virtual Group Selection
export {
  startLongHold,
  cancelLongHold,
  startVirtualSelection,
  addToVirtualSelection,
  removeFromVirtualSelection,
  toggleVirtualSelection,
  getVirtualSelectionState,
  isInSelectionMode,
  isTableSelected,
  getSelectedTableIds,
  getSelectedCount,
  cancelVirtualSelection,
  confirmVirtualGroup,
  onSelectionChange,
} from './virtualGroup';

// Color Palette
export {
  COLOR_FAMILIES,
  getColorFamilyNames,
  getColorFamily,
  getColorFamilyForGroup,
  getTableColor,
  getSeatColor,
  getGroupOutlineColor,
  assignColorsToGroup,
  createColorLookup,
  getColorWithOpacity,
  getGroupGlowStyle,
  getTableBorderStyle,
  type ColorFamily,
} from './colorPalette';

// React Components
export { TableGroup } from './TableGroup';
export { CrossRoomBadge, CrossRoomBadgeCompact } from './CrossRoomBadge';

// Perimeter Seat Renumbering
export * from './perimeterSeats';

// Drag-to-Combine
export * from './dragCombine';

// Snap-to-Edge
export * from './snapEngine';



################################################################################
# FILE: src/domains/floor-plan/groups/mergeLogic.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - Merge Logic
 *
 * Handles snap/magnet calculations for physical table merging
 */

import { Point, Table } from '../shared/types';
import { MergeDetection, MERGE_CONSTANTS } from './types';

/**
 * Detect if dragging table can merge with target table
 */
export function detectMergeOpportunity(
  draggingTable: Table,
  targetTable: Table,
  dragPosition: Point
): MergeDetection {
  // Can't merge with self
  if (draggingTable.id === targetTable.id) {
    return {
      canMerge: false,
      snapPosition: null,
      snapEdge: null,
      snapDistance: Infinity,
    };
  }

  // Can't merge if tables are in different rooms
  if (draggingTable.floorPlanId !== targetTable.floorPlanId) {
    return {
      canMerge: false,
      snapPosition: null,
      snapEdge: null,
      snapDistance: Infinity,
    };
  }

  // Check each edge for snap opportunity
  const edges: Array<'top' | 'bottom' | 'left' | 'right'> = [
    'top',
    'bottom',
    'left',
    'right',
  ];

  let closestEdge: typeof edges[number] | null = null;
  let closestDistance = Infinity;
  let closestSnapPosition: Point | null = null;

  for (const edge of edges) {
    const snapPos = calculateSnapPosition(draggingTable, targetTable, edge, dragPosition);
    if (!snapPos) continue;

    const distance = getDistance(dragPosition, snapPos);

    if (distance < closestDistance && distance <= MERGE_CONSTANTS.SNAP_DISTANCE_FEET) {
      closestDistance = distance;
      closestEdge = edge;
      closestSnapPosition = snapPos;
    }
  }

  return {
    canMerge: closestEdge !== null,
    snapPosition: closestSnapPosition,
    snapEdge: closestEdge,
    snapDistance: closestDistance,
  };
}

/**
 * Calculate snap position for a specific edge alignment
 */
export function calculateSnapPosition(
  draggingTable: Table,
  targetTable: Table,
  edge: 'top' | 'bottom' | 'left' | 'right',
  currentPosition?: Point
): Point | null {
  const target = {
    x: targetTable.positionX,
    y: targetTable.positionY,
    width: targetTable.width,
    height: targetTable.height,
  };

  const dragging = {
    width: draggingTable.width,
    height: draggingTable.height,
  };

  let snapX: number;
  let snapY: number;

  switch (edge) {
    case 'top':
      // Dragging table snaps to top edge of target (above it)
      snapX = target.x;
      snapY = target.y - dragging.height;
      break;

    case 'bottom':
      // Dragging table snaps to bottom edge of target (below it)
      snapX = target.x;
      snapY = target.y + target.height;
      break;

    case 'left':
      // Dragging table snaps to left edge of target (left of it)
      snapX = target.x - dragging.width;
      snapY = target.y;
      break;

    case 'right':
      // Dragging table snaps to right edge of target (right of it)
      snapX = target.x + target.width;
      snapY = target.y;
      break;
  }

  // Check alignment tolerance (tables should be roughly aligned)
  if (currentPosition) {
    const alignmentOk = checkAlignment(
      { x: snapX, y: snapY },
      currentPosition,
      edge
    );
    if (!alignmentOk) {
      return null;
    }
  }

  return { x: snapX, y: snapY };
}

/**
 * Check if tables are aligned enough to snap
 */
function checkAlignment(
  snapPos: Point,
  currentPos: Point,
  edge: 'top' | 'bottom' | 'left' | 'right'
): boolean {
  const tolerance = MERGE_CONSTANTS.SNAP_ALIGN_TOLERANCE;

  if (edge === 'top' || edge === 'bottom') {
    // For vertical edges, check horizontal alignment
    return Math.abs(snapPos.x - currentPos.x) <= tolerance;
  } else {
    // For horizontal edges, check vertical alignment
    return Math.abs(snapPos.y - currentPos.y) <= tolerance;
  }
}

/**
 * Calculate distance between two points
 */
function getDistance(p1: Point, p2: Point): number {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Check if two tables are adjacent (touching edges)
 */
export function areTablesAdjacent(table1: Table, table2: Table): boolean {
  const t1 = {
    left: table1.positionX,
    right: table1.positionX + table1.width,
    top: table1.positionY,
    bottom: table1.positionY + table1.height,
  };

  const t2 = {
    left: table2.positionX,
    right: table2.positionX + table2.width,
    top: table2.positionY,
    bottom: table2.positionY + table2.height,
  };

  const tolerance = 0.1; // Small tolerance for floating point

  // Check if touching on any edge
  const touchingTop = Math.abs(t1.bottom - t2.top) < tolerance;
  const touchingBottom = Math.abs(t1.top - t2.bottom) < tolerance;
  const touchingLeft = Math.abs(t1.right - t2.left) < tolerance;
  const touchingRight = Math.abs(t1.left - t2.right) < tolerance;

  // Check if there's overlap on the perpendicular axis
  const horizontalOverlap =
    (t1.left <= t2.right && t1.right >= t2.left) ||
    (t2.left <= t1.right && t2.right >= t1.left);
  const verticalOverlap =
    (t1.top <= t2.bottom && t1.bottom >= t2.top) ||
    (t2.top <= t1.bottom && t2.bottom >= t1.top);

  return (
    ((touchingTop || touchingBottom) && horizontalOverlap) ||
    ((touchingLeft || touchingRight) && verticalOverlap)
  );
}



################################################################################
# FILE: src/domains/floor-plan/groups/perimeterSeats.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Perimeter Seat Renumbering for Virtual Table Groups
 *
 * PROPER PERIMETER WALK for L-shapes and complex arrangements:
 * 1. Find the topmost point (12 o'clock starting position)
 * 2. Walk clockwise around actual table edges, not bounding box
 * 3. Assign seat numbers sequentially along the walk
 */

export interface SeatWithPosition {
  id: string;
  tableId: string;
  seatNumber: number;
  label: string;
  absoluteX: number;
  absoluteY: number;
}

export interface TableForPerimeter {
  id: string;
  name: string;
  posX: number;
  posY: number;
  width: number;
  height: number;
  rotation?: number;
  seats: Array<{
    id: string;
    seatNumber: number;
    label: string;
    relativeX: number;
    relativeY: number;
  }>;
}

export interface PerimeterSeatResult {
  seatId: string;
  tableId: string;
  tableName: string;
  originalNumber: number;
  perimeterNumber: number;
  originalLabel: string;
  perimeterLabel: string;
}

export interface VirtualSeatPosition {
  id: string;
  perimeterNumber: number;
  absoluteX: number;
  absoluteY: number;
  originalSeatId: string;
  originalTableId: string;
  originalSeatNumber: number;
}

function getCombinedBounds(tables: TableForPerimeter[]) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const table of tables) {
    minX = Math.min(minX, table.posX);
    minY = Math.min(minY, table.posY);
    maxX = Math.max(maxX, table.posX + table.width);
    maxY = Math.max(maxY, table.posY + table.height);
  }
  return { minX, minY, maxX, maxY, centerX: (minX + maxX) / 2, centerY: (minY + maxY) / 2 };
}

function getAbsoluteSeats(tables: TableForPerimeter[]): SeatWithPosition[] {
  const seats: SeatWithPosition[] = [];
  for (const table of tables) {
    const cx = table.posX + table.width / 2;
    const cy = table.posY + table.height / 2;
    const rad = ((table.rotation || 0) * Math.PI) / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    for (const seat of table.seats) {
      const rx = seat.relativeX * cos - seat.relativeY * sin;
      const ry = seat.relativeX * sin + seat.relativeY * cos;
      seats.push({
        id: seat.id,
        tableId: table.id,
        seatNumber: seat.seatNumber,
        label: seat.label,
        absoluteX: cx + rx,
        absoluteY: cy + ry,
      });
    }
  }
  return seats;
}

/**
 * Calculate angle from center to seat, normalized to start at 12 o'clock (top)
 * Returns value 0-360 where 0 = top, 90 = right, 180 = bottom, 270 = left
 */
function getClockwiseAngle(seatX: number, seatY: number, centerX: number, centerY: number): number {
  // atan2 returns -PI to PI, with 0 pointing right
  // We want 0 to be at top (12 o'clock), going clockwise
  const angle = Math.atan2(seatX - centerX, centerY - seatY); // Note: swapped and negated for clockwise from top
  // Convert to 0-360 range
  return ((angle * 180 / Math.PI) + 360) % 360;
}

/**
 * Calculate perimeter seat numbers using simple radial sorting from the combined center.
 * Start at 12 o'clock (top-center) and go clockwise.
 */
export function calculatePerimeterSeats(tables: TableForPerimeter[]): PerimeterSeatResult[] {
  if (tables.length === 0) return [];

  const absoluteSeats = getAbsoluteSeats(tables);
  if (absoluteSeats.length === 0) return [];

  // Calculate the center of ALL tables combined
  const bounds = getCombinedBounds(tables);
  const { centerX, centerY } = bounds;

  // Sort seats by their clockwise angle from center, starting at 12 o'clock
  const seatsWithAngles = absoluteSeats.map(seat => ({
    ...seat,
    angle: getClockwiseAngle(seat.absoluteX, seat.absoluteY, centerX, centerY),
  }));

  // Sort by angle (0 = top, going clockwise)
  seatsWithAngles.sort((a, b) => a.angle - b.angle);

  const tableNameMap = new Map(tables.map((t) => [t.id, t.name]));

  return seatsWithAngles.map((seat, index) => ({
    seatId: seat.id,
    tableId: seat.tableId,
    tableName: tableNameMap.get(seat.tableId) || 'Unknown',
    originalNumber: seat.seatNumber,
    perimeterNumber: index + 1,
    originalLabel: seat.label,
    perimeterLabel: String(index + 1),
  }));
}

export function getPerimeterSeatCount(tables: TableForPerimeter[]): number {
  return tables.reduce((sum, t) => sum + t.seats.length, 0);
}

export function getGroupDisplayName(tables: TableForPerimeter[]): string {
  const names = tables.map(t => t.name);
  const count = getPerimeterSeatCount(tables);
  if (names.length === 0) return '';
  if (names.length === 1) return `${names[0]}  ${count} seats`;
  if (names.length === 2) return `${names[0]} & ${names[1]}  Party of ${count}`;
  return `${names.slice(0, -1).join(', ')} & ${names[names.length - 1]}  Party of ${count}`;
}

export function createPerimeterLookup(results: PerimeterSeatResult[]): Map<string, number> {
  return new Map(results.map(r => [r.seatId, r.perimeterNumber]));
}

export function getInnerSeats(tables: TableForPerimeter[]): Set<string> {
  if (tables.length < 2) return new Set();
  const innerSeatIds = new Set<string>();
  const OVERLAP_ZONE = 44;

  for (const table of tables) {
    const tL = table.posX, tR = table.posX + table.width;
    const tT = table.posY, tB = table.posY + table.height;

    for (const seat of table.seats) {
      const isOnRight = seat.relativeX > table.width / 4;
      const isOnLeft = seat.relativeX < -table.width / 4;
      const isOnBottom = seat.relativeY > table.height / 4;
      const isOnTop = seat.relativeY < -table.height / 4;

      for (const other of tables) {
        if (other.id === table.id) continue;
        const oL = other.posX, oR = other.posX + other.width;
        const oT = other.posY, oB = other.posY + other.height;
        const hasV = tT < oB + OVERLAP_ZONE && tB > oT - OVERLAP_ZONE;
        const hasH = tL < oR + OVERLAP_ZONE && tR > oL - OVERLAP_ZONE;

        if (isOnRight && hasV && oL - tR >= -5 && oL - tR <= OVERLAP_ZONE) { innerSeatIds.add(seat.id); break; }
        if (isOnLeft && hasV && tL - oR >= -5 && tL - oR <= OVERLAP_ZONE) { innerSeatIds.add(seat.id); break; }
        if (isOnBottom && hasH && oT - tB >= -5 && oT - tB <= OVERLAP_ZONE) { innerSeatIds.add(seat.id); break; }
        if (isOnTop && hasH && tT - oB >= -5 && tT - oB <= OVERLAP_ZONE) { innerSeatIds.add(seat.id); break; }
      }
    }
  }
  return innerSeatIds;
}

export function createEnhancedPerimeterLookup(tables: TableForPerimeter[]): Map<string, { perimeterNumber: number; isVisible: boolean }> {
  const results = calculatePerimeterSeats(tables);
  const inner = getInnerSeats(tables);
  const lookup = new Map<string, { perimeterNumber: number; isVisible: boolean }>();
  for (const r of results) {
    lookup.set(r.seatId, { perimeterNumber: r.perimeterNumber, isVisible: !inner.has(r.seatId) });
  }
  return lookup;
}

// ============================================================================
// VIRTUAL SEAT POSITION GENERATION
// Generate evenly-spaced seat positions around the combined table perimeter
// Seats hug the actual table edges, following L-shapes and complex arrangements
// ============================================================================

interface OuterEdge {
  tableId: string;
  edge: 'top' | 'right' | 'bottom' | 'left';
  x1: number; y1: number;
  x2: number; y2: number;
  length: number;
  angle: number; // Clockwise angle from 12 o'clock for sorting
}

/**
 * Find the starting point for seat numbering:
 * - Find the leftmost table
 * - Use the top-left corner of that table as the starting point
 */
function findStartingPoint(tables: TableForPerimeter[]): { x: number; y: number } {
  if (tables.length === 0) return { x: 0, y: 0 };

  // Find the leftmost table (smallest posX)
  // If tied, pick the one with smallest posY (highest on screen)
  let leftmostTable = tables[0];
  for (const table of tables) {
    if (table.posX < leftmostTable.posX ||
        (table.posX === leftmostTable.posX && table.posY < leftmostTable.posY)) {
      leftmostTable = table;
    }
  }

  // Return the top-left corner of the leftmost table
  return { x: leftmostTable.posX, y: leftmostTable.posY };
}

/**
 * Get all outer edges of the combined tables (edges not touching another table)
 */
function getOuterEdges(tables: TableForPerimeter[]): OuterEdge[] {
  // Tables snap at ~44px, so use 50px threshold to detect "touching"
  const TOUCH_THRESHOLD = 50;
  const edges: OuterEdge[] = [];
  const bounds = getCombinedBounds(tables);
  const { centerX, centerY } = bounds;

  for (const table of tables) {
    const l = table.posX;
    const r = table.posX + table.width;
    const t = table.posY;
    const b = table.posY + table.height;

    // Define edges in clockwise order for each table
    const tableEdges: Array<{ edge: 'top' | 'right' | 'bottom' | 'left'; x1: number; y1: number; x2: number; y2: number }> = [
      { edge: 'top', x1: l, y1: t, x2: r, y2: t },
      { edge: 'right', x1: r, y1: t, x2: r, y2: b },
      { edge: 'bottom', x1: r, y1: b, x2: l, y2: b },
      { edge: 'left', x1: l, y1: b, x2: l, y2: t },
    ];

    for (const e of tableEdges) {
      let isCovered = false;

      for (const other of tables) {
        if (other.id === table.id) continue;
        const oL = other.posX;
        const oR = other.posX + other.width;
        const oT = other.posY;
        const oB = other.posY + other.height;

        if (e.edge === 'top' && Math.abs(oB - t) <= TOUCH_THRESHOLD && oL < r && oR > l) { isCovered = true; break; }
        if (e.edge === 'bottom' && Math.abs(oT - b) <= TOUCH_THRESHOLD && oL < r && oR > l) { isCovered = true; break; }
        if (e.edge === 'left' && Math.abs(oR - l) <= TOUCH_THRESHOLD && oT < b && oB > t) { isCovered = true; break; }
        if (e.edge === 'right' && Math.abs(oL - r) <= TOUCH_THRESHOLD && oT < b && oB > t) { isCovered = true; break; }
      }

      if (!isCovered) {
        const length = Math.sqrt(Math.pow(e.x2 - e.x1, 2) + Math.pow(e.y2 - e.y1, 2));
        if (length > 0) {
          // Calculate angle of edge midpoint for sorting
          const midX = (e.x1 + e.x2) / 2;
          const midY = (e.y1 + e.y2) / 2;
          const angle = getClockwiseAngle(midX, midY, centerX, centerY);
          edges.push({ tableId: table.id, edge: e.edge, x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2, length, angle });
        }
      }
    }
  }

  // Sort edges clockwise by their midpoint angle
  edges.sort((a, b) => a.angle - b.angle);

  // Find the starting point (top-left of leftmost table)
  const startPoint = findStartingPoint(tables);

  // Find the edge that starts closest to the starting point
  let bestEdgeIdx = 0;
  let bestDist = Infinity;
  for (let i = 0; i < edges.length; i++) {
    const edge = edges[i];
    const dx = edge.x1 - startPoint.x;
    const dy = edge.y1 - startPoint.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < bestDist) {
      bestDist = dist;
      bestEdgeIdx = i;
    }
  }

  // Rotate the array so the best edge comes first
  if (bestEdgeIdx > 0) {
    const rotated = [...edges.slice(bestEdgeIdx), ...edges.slice(0, bestEdgeIdx)];
    return rotated;
  }

  return edges;
}

/**
 * A point along the perimeter path with its offset direction for seat placement
 */
interface PerimeterPoint {
  x: number;
  y: number;
  // Offset direction (normalized) - points outward from table
  offsetX: number;
  offsetY: number;
  distFromStart: number; // Cumulative distance from start of perimeter
}

/**
 * Build a continuous perimeter path including corners.
 * Corners get diagonal offsets so seats at corners point outward at 45 degrees.
 */
function buildPerimeterPath(edges: OuterEdge[]): PerimeterPoint[] {
  if (edges.length === 0) return [];

  const points: PerimeterPoint[] = [];
  let cumDist = 0;

  for (let i = 0; i < edges.length; i++) {
    const edge = edges[i];
    const nextEdge = edges[(i + 1) % edges.length];

    // Get offset direction for this edge (perpendicular, pointing outward)
    const edgeOffset = getEdgeOffset(edge.edge);

    // Add start point of edge (this is also the corner from previous edge)
    // For corners, we blend the offset directions
    if (i === 0) {
      // First point - use this edge's offset
      points.push({
        x: edge.x1,
        y: edge.y1,
        offsetX: edgeOffset.x,
        offsetY: edgeOffset.y,
        distFromStart: cumDist,
      });
    }

    // Add the end point of this edge
    cumDist += edge.length;

    // Calculate corner offset (blend this edge and next edge directions)
    const nextOffset = getEdgeOffset(nextEdge.edge);
    // Average and normalize for diagonal corners
    let cornerOffsetX = (edgeOffset.x + nextOffset.x);
    let cornerOffsetY = (edgeOffset.y + nextOffset.y);
    const cornerLen = Math.sqrt(cornerOffsetX * cornerOffsetX + cornerOffsetY * cornerOffsetY);
    if (cornerLen > 0) {
      cornerOffsetX /= cornerLen;
      cornerOffsetY /= cornerLen;
    }

    points.push({
      x: edge.x2,
      y: edge.y2,
      offsetX: cornerOffsetX,
      offsetY: cornerOffsetY,
      distFromStart: cumDist,
    });
  }

  return points;
}

/**
 * Get the outward offset direction for an edge type
 */
function getEdgeOffset(edge: 'top' | 'right' | 'bottom' | 'left'): { x: number; y: number } {
  switch (edge) {
    case 'top': return { x: 0, y: -1 };
    case 'bottom': return { x: 0, y: 1 };
    case 'left': return { x: -1, y: 0 };
    case 'right': return { x: 1, y: 0 };
  }
}

/**
 * Interpolate position and offset along the perimeter path at a given distance
 */
function interpolatePerimeter(points: PerimeterPoint[], dist: number, totalPerimeter: number): { x: number; y: number; offsetX: number; offsetY: number } {
  // Handle wrapping
  const normalizedDist = ((dist % totalPerimeter) + totalPerimeter) % totalPerimeter;

  // Find the two points we're between
  for (let i = 0; i < points.length - 1; i++) {
    const p1 = points[i];
    const p2 = points[i + 1];

    if (normalizedDist >= p1.distFromStart && normalizedDist <= p2.distFromStart) {
      const segmentLength = p2.distFromStart - p1.distFromStart;
      if (segmentLength === 0) {
        return { x: p1.x, y: p1.y, offsetX: p1.offsetX, offsetY: p1.offsetY };
      }

      const t = (normalizedDist - p1.distFromStart) / segmentLength;

      // Lerp position
      const x = p1.x + (p2.x - p1.x) * t;
      const y = p1.y + (p2.y - p1.y) * t;

      // Lerp and normalize offset
      let offsetX = p1.offsetX + (p2.offsetX - p1.offsetX) * t;
      let offsetY = p1.offsetY + (p2.offsetY - p1.offsetY) * t;
      const len = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      if (len > 0) {
        offsetX /= len;
        offsetY /= len;
      }

      return { x, y, offsetX, offsetY };
    }
  }

  // Fallback to last point
  const last = points[points.length - 1];
  return { x: last.x, y: last.y, offsetX: last.offsetX, offsetY: last.offsetY };
}

// Collision detection constants
const SEAT_RADIUS = 12; // Half of 24px seat diameter
const MIN_GAP = 3; // Minimum 3px gap between any objects
const SEAT_TO_TABLE_CLEARANCE = SEAT_RADIUS + MIN_GAP; // 15px - Seat center must be this far from table edge
const SEAT_TO_SEAT_MIN_DIST = SEAT_RADIUS * 2 + MIN_GAP; // 27px minimum between seat centers

/**
 * Check if a seat position collides with any table.
 * A collision occurs if the seat center is closer than SEAT_TO_TABLE_CLEARANCE to any table edge.
 * Returns true if collision detected.
 */
function collidesWithTable(seatX: number, seatY: number, tables: TableForPerimeter[]): boolean {
  for (const table of tables) {
    // Check if seat center is within the "forbidden zone" (table + clearance)
    const left = table.posX - SEAT_TO_TABLE_CLEARANCE;
    const right = table.posX + table.width + SEAT_TO_TABLE_CLEARANCE;
    const top = table.posY - SEAT_TO_TABLE_CLEARANCE;
    const bottom = table.posY + table.height + SEAT_TO_TABLE_CLEARANCE;

    if (seatX > left && seatX < right && seatY > top && seatY < bottom) {
      return true;
    }
  }
  return false;
}

/**
 * Check if a seat collides with already-placed seats
 * Returns true if collision detected
 */
function collidesWithSeats(
  seatX: number,
  seatY: number,
  placedSeats: Array<{ x: number; y: number }>
): boolean {
  for (const placed of placedSeats) {
    const dx = seatX - placed.x;
    const dy = seatY - placed.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < SEAT_TO_SEAT_MIN_DIST) {
      return true;
    }
  }
  return false;
}

/**
 * Generate virtual seat positions evenly spaced around the perimeter.
 * Seats follow the actual table edges (hugging L-shapes), with minimum spacing enforced.
 * Corners are utilized - seats at corners get diagonal offsets.
 *
 * COLLISION RULES:
 * - Seats must have 3px minimum gap from table edges
 * - Seats must have 3px minimum gap from other seats (27px center-to-center)
 * - If perimeter is too small for all seats, we cap at what fits
 */
export function generateVirtualSeatPositions(tables: TableForPerimeter[], seatDistance = 22): VirtualSeatPosition[] {
  if (tables.length === 0) return [];

  const totalSeats = tables.reduce((sum, t) => sum + t.seats.length, 0);
  if (totalSeats === 0) return [];

  const outerEdges = getOuterEdges(tables);
  if (outerEdges.length === 0) return [];

  // Build continuous perimeter path with corner support
  const perimeterPath = buildPerimeterPath(outerEdges);
  if (perimeterPath.length < 2) return [];

  // Calculate total perimeter
  const totalPerimeter = perimeterPath[perimeterPath.length - 1].distFromStart;
  if (totalPerimeter === 0) return [];

  // STANDARD SEAT SPACING - seats must not overlap (27px = 24px diameter + 3px gap)
  const MIN_SPACING = SEAT_TO_SEAT_MIN_DIST;

  // Calculate how many seats can actually fit at minimum spacing
  const maxSeatsAtMinSpacing = Math.floor(totalPerimeter / MIN_SPACING);

  // Use the minimum of requested seats and what physically fits
  const seatsToPlace = Math.min(totalSeats, maxSeatsAtMinSpacing);
  if (seatsToPlace === 0) return [];

  // Calculate actual spacing (evenly distributed)
  const effectiveSpacing = totalPerimeter / seatsToPlace;

  const perimeterSeats = calculatePerimeterSeats(tables);
  const virtualSeats: VirtualSeatPosition[] = [];
  const placedPositions: Array<{ x: number; y: number }> = [];

  // Place seats evenly around the perimeter
  for (let seatIdx = 0; seatIdx < seatsToPlace; seatIdx++) {
    // Calculate distance along perimeter for this seat
    const dist = (seatIdx + 0.5) * effectiveSpacing; // +0.5 to center within segment

    // Get position and offset at this distance
    const { x, y, offsetX, offsetY } = interpolatePerimeter(perimeterPath, dist, totalPerimeter);

    // Start with base offset distance
    let currentDistance = seatDistance;

    // Calculate initial seat position
    let seatX = x + offsetX * currentDistance;
    let seatY = y + offsetY * currentDistance;

    // Push outward until clear of all tables (max 20 attempts, 3px each)
    let tableAttempts = 0;
    while (collidesWithTable(seatX, seatY, tables) && tableAttempts < 20) {
      currentDistance += 3; // Push outward in 3px increments
      seatX = x + offsetX * currentDistance;
      seatY = y + offsetY * currentDistance;
      tableAttempts++;
    }

    // Push outward until clear of already-placed seats (max 10 attempts, 3px each)
    let seatAttempts = 0;
    while (collidesWithSeats(seatX, seatY, placedPositions) && seatAttempts < 10) {
      currentDistance += 3; // Push outward in 3px increments
      seatX = x + offsetX * currentDistance;
      seatY = y + offsetY * currentDistance;
      seatAttempts++;
    }

    // Record this seat's position for future collision checks
    placedPositions.push({ x: seatX, y: seatY });

    const orig = perimeterSeats[seatIdx % perimeterSeats.length];
    virtualSeats.push({
      id: `virtual-seat-${seatIdx + 1}`,
      perimeterNumber: seatIdx + 1,
      absoluteX: seatX,
      absoluteY: seatY,
      originalSeatId: orig?.seatId || `seat-${seatIdx}`,
      originalTableId: orig?.tableId || tables[0].id,
      originalSeatNumber: orig?.originalNumber || seatIdx + 1,
    });
  }

  return virtualSeats;
}

/**
 * Get total distance along perimeter before a given edge index
 */
function getTotalDistBefore(edges: OuterEdge[], edgeIndex: number): number {
  let total = 0;
  for (let i = 0; i < edgeIndex; i++) {
    total += edges[i].length;
  }
  return total;
}



################################################################################
# FILE: src/domains/floor-plan/groups/snapEngine.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Snap Engine for Table Combining
 *
 * Calculates snap positions when dragging tables near each other.
 * Tables snap to edges with configurable offset tolerance.
 */

import type { SnapEdge, SnapPreview, SnapConfig } from './types';

export interface TableRect {
  id: string;
  x: number; // posX (top-left corner)
  y: number; // posY (top-left corner)
  width: number;
  height: number;
}

const DEFAULT_CONFIG: SnapConfig = {
  snapTriggerDistance: 30,
  maxOffsetPercent: 0.5,
  minOverlap: 20,
};

/**
 * Get the center point of a table
 */
function getCenter(table: TableRect): { x: number; y: number } {
  return {
    x: table.x + table.width / 2,
    y: table.y + table.height / 2,
  };
}

/**
 * Get the edges of a table as line segments
 */
function getEdges(table: TableRect): Record<SnapEdge, { start: number; end: number; position: number }> {
  return {
    top: { start: table.x, end: table.x + table.width, position: table.y },
    bottom: { start: table.x, end: table.x + table.width, position: table.y + table.height },
    left: { start: table.y, end: table.y + table.height, position: table.x },
    right: { start: table.y, end: table.y + table.height, position: table.x + table.width },
  };
}

/**
 * Calculate overlap between two ranges
 */
function getRangeOverlap(
  start1: number,
  end1: number,
  start2: number,
  end2: number
): { overlap: number; offset: number } {
  const overlapStart = Math.max(start1, start2);
  const overlapEnd = Math.min(end1, end2);
  const overlap = Math.max(0, overlapEnd - overlapStart);

  // Offset is how far the centers are apart along this axis
  const center1 = (start1 + end1) / 2;
  const center2 = (start2 + end2) / 2;
  const offset = center1 - center2;

  return { overlap, offset };
}

/**
 * Calculate snap position for dragging table to target's edge
 */
function calculateSnapToEdge(
  dragged: TableRect,
  target: TableRect,
  edge: SnapEdge,
  config: SnapConfig
): SnapPreview | null {
  const targetEdges = getEdges(target);
  const draggedCenter = getCenter(dragged);

  let snapX: number;
  let snapY: number;
  let edgeOffset: number;
  let overlap: number;

  switch (edge) {
    case 'right': {
      // Snap dragged table to the RIGHT of target
      snapX = target.x + target.width; // Dragged table's left edge touches target's right edge

      // Calculate vertical alignment - try to center, but respect current position
      const vertOverlap = getRangeOverlap(
        dragged.y, dragged.y + dragged.height,
        target.y, target.y + target.height
      );
      overlap = vertOverlap.overlap;
      edgeOffset = vertOverlap.offset;

      // Keep vertical position unless it would cause no overlap
      snapY = dragged.y;
      if (overlap < config.minOverlap) {
        // Adjust to ensure minimum overlap
        if (dragged.y > target.y + target.height - config.minOverlap) {
          snapY = target.y + target.height - config.minOverlap - dragged.height;
        } else if (dragged.y + dragged.height < target.y + config.minOverlap) {
          snapY = target.y + config.minOverlap;
        }
      }
      break;
    }

    case 'left': {
      // Snap dragged table to the LEFT of target
      snapX = target.x - dragged.width;

      const vertOverlap = getRangeOverlap(
        dragged.y, dragged.y + dragged.height,
        target.y, target.y + target.height
      );
      overlap = vertOverlap.overlap;
      edgeOffset = vertOverlap.offset;
      snapY = dragged.y;

      if (overlap < config.minOverlap) {
        if (dragged.y > target.y + target.height - config.minOverlap) {
          snapY = target.y + target.height - config.minOverlap - dragged.height;
        } else if (dragged.y + dragged.height < target.y + config.minOverlap) {
          snapY = target.y + config.minOverlap;
        }
      }
      break;
    }

    case 'bottom': {
      // Snap dragged table to the BOTTOM of target
      snapY = target.y + target.height;

      const horizOverlap = getRangeOverlap(
        dragged.x, dragged.x + dragged.width,
        target.x, target.x + target.width
      );
      overlap = horizOverlap.overlap;
      edgeOffset = horizOverlap.offset;
      snapX = dragged.x;

      if (overlap < config.minOverlap) {
        if (dragged.x > target.x + target.width - config.minOverlap) {
          snapX = target.x + target.width - config.minOverlap - dragged.width;
        } else if (dragged.x + dragged.width < target.x + config.minOverlap) {
          snapX = target.x + config.minOverlap;
        }
      }
      break;
    }

    case 'top': {
      // Snap dragged table to the TOP of target
      snapY = target.y - dragged.height;

      const horizOverlap = getRangeOverlap(
        dragged.x, dragged.x + dragged.width,
        target.x, target.x + target.width
      );
      overlap = horizOverlap.overlap;
      edgeOffset = horizOverlap.offset;
      snapX = dragged.x;

      if (overlap < config.minOverlap) {
        if (dragged.x > target.x + target.width - config.minOverlap) {
          snapX = target.x + target.width - config.minOverlap - dragged.width;
        } else if (dragged.x + dragged.width < target.x + config.minOverlap) {
          snapX = target.x + config.minOverlap;
        }
      }
      break;
    }
  }

  // Check if offset is within tolerance
  const smallerDimension = Math.min(
    edge === 'left' || edge === 'right' ? dragged.height : dragged.width,
    edge === 'left' || edge === 'right' ? target.height : target.width
  );
  const maxOffset = smallerDimension * config.maxOffsetPercent;
  const isValidOffset = Math.abs(edgeOffset) <= maxOffset;

  // Calculate distance from current position to snap position
  const snapDistance = Math.sqrt(
    (snapX - dragged.x) ** 2 + (snapY - dragged.y) ** 2
  );

  // Calculate actual edge-to-edge distance (how far apart the tables are)
  let edgeToEdgeDistance: number;
  switch (edge) {
    case 'right':
      // Dragged table's left edge to target's right edge
      edgeToEdgeDistance = dragged.x - (target.x + target.width);
      break;
    case 'left':
      // Dragged table's right edge to target's left edge
      edgeToEdgeDistance = target.x - (dragged.x + dragged.width);
      break;
    case 'bottom':
      // Dragged table's top edge to target's bottom edge
      edgeToEdgeDistance = dragged.y - (target.y + target.height);
      break;
    case 'top':
      // Dragged table's bottom edge to target's top edge
      edgeToEdgeDistance = target.y - (dragged.y + dragged.height);
      break;
  }

  // Tables must be close (within snap trigger distance) AND have valid offset/overlap
  // edgeToEdgeDistance can be negative (overlapping) or positive (gap)
  // We allow snapping when the gap is small OR tables are slightly overlapping
  const isCloseEnough = edgeToEdgeDistance < config.snapTriggerDistance && edgeToEdgeDistance > -config.snapTriggerDistance;

  return {
    targetTableId: target.id,
    targetEdge: edge,
    snapPosition: { x: snapX, y: snapY },
    edgeOffset,
    snapDistance,
    isValid: isValidOffset && overlap >= config.minOverlap && isCloseEnough,
  };
}

/**
 * Find the best snap position for a dragged table
 *
 * @param draggedTable - The table being dragged (with current drag position)
 * @param targetTables - All potential target tables
 * @param config - Snap configuration
 * @returns Best snap preview, or null if no valid snap
 */
export function findBestSnap(
  draggedTable: TableRect,
  targetTables: TableRect[],
  config: Partial<SnapConfig> = {}
): SnapPreview | null {
  const fullConfig = { ...DEFAULT_CONFIG, ...config };
  const draggedCenter = getCenter(draggedTable);

  let bestSnap: SnapPreview | null = null;
  let bestDistance = Infinity;

  for (const target of targetTables) {
    // Skip self
    if (target.id === draggedTable.id) continue;

    // Quick distance check - skip if too far
    const targetCenter = getCenter(target);
    const roughDistance = Math.sqrt(
      (draggedCenter.x - targetCenter.x) ** 2 +
      (draggedCenter.y - targetCenter.y) ** 2
    );

    // If centers are too far apart, skip detailed calculation
    const maxReach = Math.max(draggedTable.width, draggedTable.height, target.width, target.height);
    if (roughDistance > maxReach + fullConfig.snapTriggerDistance * 2) {
      continue;
    }

    // Check all four edges
    const edges: SnapEdge[] = ['top', 'bottom', 'left', 'right'];

    for (const edge of edges) {
      const snap = calculateSnapToEdge(draggedTable, target, edge, fullConfig);

      if (snap && snap.isValid && snap.snapDistance < fullConfig.snapTriggerDistance) {
        if (snap.snapDistance < bestDistance) {
          bestDistance = snap.snapDistance;
          bestSnap = snap;
        }
      }
    }
  }

  return bestSnap;
}

/**
 * Get CSS transform for snap preview animation
 */
export function getSnapPreviewStyle(
  originalPosition: { x: number; y: number },
  snapPosition: { x: number; y: number }
): React.CSSProperties {
  const dx = snapPosition.x - originalPosition.x;
  const dy = snapPosition.y - originalPosition.y;

  return {
    transform: `translate(${dx}px, ${dy}px)`,
    transition: 'transform 0.15s ease-out',
  };
}

/**
 * Check if two tables would be validly connected at a snap position
 */
export function validateConnection(
  table1: TableRect,
  table2: TableRect,
  config: Partial<SnapConfig> = {}
): { isValid: boolean; edge: SnapEdge | null; overlap: number } {
  const fullConfig = { ...DEFAULT_CONFIG, ...config };

  // Check each possible connection
  const edges: SnapEdge[] = ['top', 'bottom', 'left', 'right'];

  for (const edge of edges) {
    const snap = calculateSnapToEdge(table1, table2, edge, fullConfig);
    if (snap && snap.isValid && snap.snapDistance < 5) {
      // Tables are touching
      return {
        isValid: true,
        edge,
        overlap: Math.abs(snap.edgeOffset),
      };
    }
  }

  return { isValid: false, edge: null, overlap: 0 };
}



################################################################################
# FILE: src/domains/floor-plan/groups/TableGroup.tsx
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - TableGroup Component
 *
 * Renders visual indicators for grouped tables
 */

'use client';

import React from 'react';
import { TableGroup as TableGroupType, Table } from '../shared/types';

interface TableGroupProps {
  group: TableGroupType;
  tables: Table[];
  scale?: number; // Pixels per foot
}

/**
 * TableGroup Component
 *
 * Renders:
 * - Colored border around grouped tables
 * - Group identifier badge
 * - Dashed border for virtual groups
 */
export function TableGroup({ group, tables, scale = 20 }: TableGroupProps) {
  // Filter tables that belong to this group
  const groupTables = tables.filter((t) => group.tableIds.includes(t.id));

  if (groupTables.length === 0) {
    return null;
  }

  // Calculate bounding box for all tables in group
  const bounds = calculateBoundingBox(groupTables);

  // Convert feet to pixels
  const x = bounds.minX * scale;
  const y = bounds.minY * scale;
  const width = (bounds.maxX - bounds.minX) * scale;
  const height = (bounds.maxY - bounds.minY) * scale;

  // Border style
  const borderStyle = group.isVirtual ? 'dashed' : 'solid';
  const borderWidth = 3;

  return (
    <div
      className="pointer-events-none absolute"
      style={{
        left: `${x - borderWidth * 2}px`,
        top: `${y - borderWidth * 2}px`,
        width: `${width + borderWidth * 4}px`,
        height: `${height + borderWidth * 4}px`,
        border: `${borderWidth}px ${borderStyle} ${group.color}`,
        borderRadius: '8px',
        zIndex: 5,
      }}
    >
      {/* Group Identifier Badge */}
      {group.identifier && (
        <div
          className="absolute -top-8 left-0 px-3 py-1 rounded-full text-xs font-semibold text-white shadow-md"
          style={{
            backgroundColor: group.color,
          }}
        >
          {group.identifier}
        </div>
      )}

      {/* Seat Count Badge */}
      <div
        className="absolute -top-8 right-0 px-2 py-1 rounded-full text-xs font-semibold text-white shadow-md"
        style={{
          backgroundColor: group.color,
        }}
      >
        {group.combinedCapacity} seats
      </div>

      {/* Virtual Group Indicator */}
      {group.isVirtual && (
        <div
          className="absolute -bottom-8 left-0 px-2 py-1 rounded text-xs font-medium text-white shadow-md"
          style={{
            backgroundColor: group.color,
          }}
        >
          Virtual Group
        </div>
      )}
    </div>
  );
}

/**
 * Calculate bounding box containing all tables in group
 */
function calculateBoundingBox(tables: Table[]): {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
} {
  if (tables.length === 0) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  }

  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  for (const table of tables) {
    const tableMinX = table.positionX;
    const tableMinY = table.positionY;
    const tableMaxX = table.positionX + table.width;
    const tableMaxY = table.positionY + table.height;

    minX = Math.min(minX, tableMinX);
    minY = Math.min(minY, tableMinY);
    maxX = Math.max(maxX, tableMaxX);
    maxY = Math.max(maxY, tableMaxY);
  }

  return { minX, minY, maxX, maxY };
}



################################################################################
# FILE: src/domains/floor-plan/groups/tableGroupAPI.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - API Service
 *
 * Central service for managing table groups (physical merge + virtual groups)
 */

import { TableGroup, Seat } from '../shared/types';
import {
  getNextAvailableColor,
  markColorInUse,
  releaseColor,
  clearColorAssignments,
} from './colorPalette';

// In-memory storage for groups (would be replaced with database)
const groups = new Map<string, TableGroup>();

// Track which tables are in groups
const tableToGroupMap = new Map<string, string>();

// Counter for generating group IDs
let groupIdCounter = 1;

/**
 * Table Group API Interface
 */
export interface TableGroupAPI {
  // Create/dissolve
  createPhysicalMerge(tableIds: string[]): TableGroup;
  createVirtualGroup(tableIds: string[]): TableGroup;
  dissolveGroup(groupId: string): void;

  // Queries
  getGroup(groupId: string): TableGroup | null;
  getGroupForTable(tableId: string): TableGroup | null;
  getAllActiveGroups(): TableGroup[];
  getGroupsInRoom(roomId: string): TableGroup[];

  // Membership
  addTableToGroup(groupId: string, tableId: string): void;
  removeTableFromGroup(groupId: string, tableId: string): void;

  // Properties
  setGroupColor(groupId: string, color: string): void;
  setGroupIdentifier(groupId: string, identifier: string): void;

  // Seats
  getGroupSeats(groupId: string): Seat[];
  getGroupSeatCount(groupId: string): number;

  // Cross-room
  getGroupRooms(groupId: string): string[];
  isCrossRoomGroup(groupId: string): boolean;

  // Initialization
  initializeGroups(groups: TableGroup[]): void;
  clearAll(): void;
}

/**
 * Create a physical merge group
 * Tables snap together, share color, seats renumber sequentially
 */
function createPhysicalMerge(tableIds: string[]): TableGroup {
  if (tableIds.length < 2) {
    throw new Error('Physical merge requires at least 2 tables');
  }

  // Check if any tables are already grouped
  for (const tableId of tableIds) {
    if (tableToGroupMap.has(tableId)) {
      throw new Error(`Table ${tableId} is already in a group`);
    }
  }

  // TODO: Get tables from TableAPI to validate they're in same room
  // TODO: Calculate snap positions using mergeLogic
  // TODO: Update table positions via TableAPI

  const groupId = `group-${groupIdCounter++}`;
  const color = getNextAvailableColor();

  const group: TableGroup = {
    id: groupId,
    locationId: '', // TODO: Get from tables
    tableIds: [...tableIds],
    primaryTableId: tableIds[0],
    isVirtual: false,
    color,
    identifier: '',
    combinedCapacity: 0, // TODO: Calculate from seats
    isActive: true,
    createdAt: new Date(),
    createdBy: '', // TODO: Get from context
  };

  groups.set(groupId, group);

  // Update table-to-group mapping
  for (const tableId of tableIds) {
    tableToGroupMap.set(tableId, groupId);
  }

  // TODO: Call SeatAPI.renumberSeatsForMerge(tableIds)
  // TODO: Call TableAPI.setTableColor(tableId, color) for each table
  // TODO: Call TableAPI.updateTable to set groupId

  return group;
}

/**
 * Create a virtual group
 * Tables stay in place but are linked for ordering
 */
function createVirtualGroup(tableIds: string[]): TableGroup {
  if (tableIds.length < 2) {
    throw new Error('Virtual group requires at least 2 tables');
  }

  // Check if any tables are already grouped
  for (const tableId of tableIds) {
    if (tableToGroupMap.has(tableId)) {
      throw new Error(`Table ${tableId} is already in a group`);
    }
  }

  const groupId = `group-${groupIdCounter++}`;
  const color = getNextAvailableColor();

  const group: TableGroup = {
    id: groupId,
    locationId: '', // TODO: Get from tables
    tableIds: [...tableIds],
    primaryTableId: tableIds[0],
    isVirtual: true,
    color,
    identifier: '',
    combinedCapacity: 0, // TODO: Calculate from seats
    isActive: true,
    createdAt: new Date(),
    createdBy: '', // TODO: Get from context
  };

  groups.set(groupId, group);

  // Update table-to-group mapping
  for (const tableId of tableIds) {
    tableToGroupMap.set(tableId, groupId);
  }

  // TODO: Call TableAPI.setTableColor(tableId, color) for each table
  // TODO: Call TableAPI.updateTable to set groupId
  // NOTE: Tables do NOT move for virtual groups

  return group;
}

/**
 * Dissolve a group and restore tables to ungrouped state
 */
function dissolveGroup(groupId: string): void {
  const group = groups.get(groupId);
  if (!group) {
    throw new Error(`Group ${groupId} not found`);
  }

  // Release color back to pool
  releaseColor(group.color);

  // Remove table mappings
  for (const tableId of group.tableIds) {
    tableToGroupMap.delete(tableId);
  }

  // TODO: For physical merges, restore original table positions
  // TODO: Call TableAPI.setTableColor(tableId, null) to clear color
  // TODO: Call TableAPI.updateTable to clear groupId
  // TODO: Call SeatAPI to restore original seat numbering

  // Mark group as inactive
  group.isActive = false;
  groups.delete(groupId);
}

/**
 * Get a specific group by ID
 */
function getGroup(groupId: string): TableGroup | null {
  return groups.get(groupId) || null;
}

/**
 * Get the group that a table belongs to
 */
function getGroupForTable(tableId: string): TableGroup | null {
  const groupId = tableToGroupMap.get(tableId);
  if (!groupId) return null;
  return groups.get(groupId) || null;
}

/**
 * Get all active groups
 */
function getAllActiveGroups(): TableGroup[] {
  return Array.from(groups.values()).filter((g) => g.isActive);
}

/**
 * Get all groups in a specific room
 */
function getGroupsInRoom(_roomId: string): TableGroup[] {
  // TODO: Filter by room using TableAPI to check table locations
  return getAllActiveGroups();
}

/**
 * Add a table to an existing group
 */
function addTableToGroup(groupId: string, tableId: string): void {
  const group = groups.get(groupId);
  if (!group) {
    throw new Error(`Group ${groupId} not found`);
  }

  if (tableToGroupMap.has(tableId)) {
    throw new Error(`Table ${tableId} is already in a group`);
  }

  group.tableIds.push(tableId);
  tableToGroupMap.set(tableId, groupId);

  // TODO: Update table position if physical merge
  // TODO: Call TableAPI.setTableColor(tableId, group.color)
  // TODO: Call SeatAPI.renumberSeatsForMerge if needed
}

/**
 * Remove a table from a group
 */
function removeTableFromGroup(groupId: string, tableId: string): void {
  const group = groups.get(groupId);
  if (!group) {
    throw new Error(`Group ${groupId} not found`);
  }

  const index = group.tableIds.indexOf(tableId);
  if (index === -1) {
    throw new Error(`Table ${tableId} not in group ${groupId}`);
  }

  group.tableIds.splice(index, 1);
  tableToGroupMap.delete(tableId);

  // TODO: Restore table to original position if physical merge
  // TODO: Call TableAPI.setTableColor(tableId, null)

  // If only one table left, dissolve the group
  if (group.tableIds.length < 2) {
    dissolveGroup(groupId);
  }
}

/**
 * Set the color for a group
 */
function setGroupColor(groupId: string, color: string): void {
  const group = groups.get(groupId);
  if (!group) {
    throw new Error(`Group ${groupId} not found`);
  }

  // Release old color
  releaseColor(group.color);

  // Set new color
  group.color = color;
  markColorInUse(color);

  // TODO: Update all table colors via TableAPI
}

/**
 * Set the identifier for a group
 */
function setGroupIdentifier(groupId: string, identifier: string): void {
  const group = groups.get(groupId);
  if (!group) {
    throw new Error(`Group ${groupId} not found`);
  }

  group.identifier = identifier;
}

/**
 * Get all seats for a group (across all tables)
 */
function getGroupSeats(groupId: string): Seat[] {
  const group = groups.get(groupId);
  if (!group) {
    return [];
  }

  // TODO: Call SeatAPI.getSeatsForTable for each table and combine
  return [];
}

/**
 * Get total seat count for a group
 */
function getGroupSeatCount(groupId: string): number {
  const group = groups.get(groupId);
  if (!group) {
    return 0;
  }

  // TODO: Sum seat counts from all tables
  return group.combinedCapacity;
}

/**
 * Get all unique room IDs that tables in this group belong to
 */
function getGroupRooms(groupId: string): string[] {
  const group = groups.get(groupId);
  if (!group) {
    return [];
  }

  // TODO: Get room IDs from tables via TableAPI
  // For now, return empty array
  return [];
}

/**
 * Check if a group spans multiple rooms
 */
function isCrossRoomGroup(groupId: string): boolean {
  const rooms = getGroupRooms(groupId);
  return rooms.length > 1;
}

/**
 * Initialize groups from database
 */
function initializeGroups(loadedGroups: TableGroup[]): void {
  clearAll();

  for (const group of loadedGroups) {
    groups.set(group.id, group);

    // Mark color as in use
    markColorInUse(group.color);

    // Update table-to-group mapping
    for (const tableId of group.tableIds) {
      tableToGroupMap.set(tableId, group.id);
    }
  }
}

/**
 * Clear all groups and reset state
 */
function clearAll(): void {
  groups.clear();
  tableToGroupMap.clear();
  clearColorAssignments();
  groupIdCounter = 1;
}

/**
 * Export API instance
 */
export const tableGroupAPI: TableGroupAPI = {
  createPhysicalMerge,
  createVirtualGroup,
  dissolveGroup,
  getGroup,
  getGroupForTable,
  getAllActiveGroups,
  getGroupsInRoom,
  addTableToGroup,
  removeTableFromGroup,
  setGroupColor,
  setGroupIdentifier,
  getGroupSeats,
  getGroupSeatCount,
  getGroupRooms,
  isCrossRoomGroup,
  initializeGroups,
  clearAll,
};



################################################################################
# FILE: src/domains/floor-plan/groups/types.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - Types
 */

import { Point } from '../shared/types';

/**
 * Detection result for physical merge snap opportunity
 */
export interface MergeDetection {
  canMerge: boolean;
  snapPosition: Point | null;
  snapEdge: 'top' | 'bottom' | 'left' | 'right' | null;
  snapDistance: number; // Distance in feet
}

/**
 * Virtual group selection state for long-hold flow
 */
export interface VirtualGroupSelection {
  isSelecting: boolean;
  selectedTableIds: string[];
  startedAt: Date | null;
}

/**
 * Group creation parameters
 */
export interface CreateGroupParams {
  tableIds: string[];
  isVirtual: boolean;
  identifier?: string;
  createdBy: string; // Staff ID
  locationId: string;
}

/**
 * Merge result with updated positions
 */
export interface MergeResult {
  groupId: string;
  tablePositions: Map<string, Point>; // tableId  new position
  seatRenumbering: Map<string, number>; // seatId  new seat number
}

/**
 * Constants for merge detection
 */
export const MERGE_CONSTANTS = {
  SNAP_DISTANCE_FEET: 1.0, // Tables within 1 foot can snap
  SNAP_ALIGN_TOLERANCE: 0.25, // Alignment tolerance in feet
  LONG_HOLD_DURATION_MS: 750, // Duration for long-hold gesture (FOH view)
} as const;

/**
 * Table data for perimeter seat calculation
 */
export interface TableForPerimeter {
  id: string;
  name: string;
  posX: number;
  posY: number;
  width: number;
  height: number;
  seats: Array<{
    id: string;
    seatNumber: number;
    label: string;
    relativeX: number;
    relativeY: number;
  }>;
}

/**
 * Perimeter seat calculation result
 */
export interface PerimeterSeatResult {
  seatId: string;
  tableId: string;
  tableName: string;
  originalNumber: number;
  perimeterNumber: number;
  originalLabel: string;
  perimeterLabel: string;
}

/**
 * Color family name for virtual groups
 */
export type ColorFamilyName = 'blue' | 'green' | 'purple' | 'amber' | 'teal' | 'rose';

/**
 * Color assignment for a table in a virtual group
 */
export interface TableColorAssignment {
  tableId: string;
  tableColor: string;
  seatColor: string;
  familyName: ColorFamilyName;
}

/**
 * Edge direction for snap calculations
 */
export type SnapEdge = 'top' | 'bottom' | 'left' | 'right';

/**
 * Snap preview result
 */
export interface SnapPreview {
  targetTableId: string;
  targetEdge: SnapEdge;
  snapPosition: { x: number; y: number };
  edgeOffset: number;
  snapDistance: number;
  isValid: boolean;
}

/**
 * Configuration for snap behavior
 */
export interface SnapConfig {
  snapTriggerDistance: number;
  maxOffsetPercent: number;
  minOverlap: number;
}



################################################################################
# FILE: src/domains/floor-plan/groups/virtualGroup.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 4: Table Groups - Virtual Group Selection
 *
 * Handles long-hold selection flow for creating virtual groups
 */

import { VirtualGroupSelection, MERGE_CONSTANTS } from './types';

// Global selection state
let selectionState: VirtualGroupSelection = {
  isSelecting: false,
  selectedTableIds: [],
  startedAt: null,
};

// Long-hold timer reference
let longHoldTimer: NodeJS.Timeout | null = null;

// Callbacks for selection changes
type SelectionChangeCallback = (state: VirtualGroupSelection) => void;
const selectionChangeCallbacks: Set<SelectionChangeCallback> = new Set();

/**
 * Register a callback for selection state changes
 */
export function onSelectionChange(callback: SelectionChangeCallback): () => void {
  selectionChangeCallbacks.add(callback);
  // Return unsubscribe function
  return () => {
    selectionChangeCallbacks.delete(callback);
  };
}

/**
 * Notify all callbacks of state change
 */
function notifySelectionChange(): void {
  selectionChangeCallbacks.forEach((cb) => cb({ ...selectionState }));
}

/**
 * Start long-hold gesture on a table
 */
export function startLongHold(
  tableId: string,
  onLongHoldComplete: () => void
): void {
  // Clear any existing timer
  if (longHoldTimer) {
    clearTimeout(longHoldTimer);
  }

  // Start new timer
  longHoldTimer = setTimeout(() => {
    startVirtualSelection(tableId);
    onLongHoldComplete();
  }, MERGE_CONSTANTS.LONG_HOLD_DURATION_MS);
}

/**
 * Cancel long-hold gesture (e.g., on pointer up or move)
 */
export function cancelLongHold(): void {
  if (longHoldTimer) {
    clearTimeout(longHoldTimer);
    longHoldTimer = null;
  }
}

/**
 * Start virtual group selection mode
 */
export function startVirtualSelection(tableId: string): void {
  selectionState = {
    isSelecting: true,
    selectedTableIds: [tableId],
    startedAt: new Date(),
  };
  notifySelectionChange();
}

/**
 * Add table to current virtual selection
 */
export function addToVirtualSelection(tableId: string): void {
  if (!selectionState.isSelecting) {
    return;
  }

  if (!selectionState.selectedTableIds.includes(tableId)) {
    selectionState.selectedTableIds.push(tableId);
    notifySelectionChange();
  }
}

/**
 * Remove table from current virtual selection
 */
export function removeFromVirtualSelection(tableId: string): void {
  if (!selectionState.isSelecting) {
    return;
  }

  const index = selectionState.selectedTableIds.indexOf(tableId);
  if (index > -1) {
    selectionState.selectedTableIds.splice(index, 1);
    notifySelectionChange();
  }
}

/**
 * Toggle table in virtual selection
 */
export function toggleVirtualSelection(tableId: string): void {
  if (selectionState.selectedTableIds.includes(tableId)) {
    removeFromVirtualSelection(tableId);
  } else {
    addToVirtualSelection(tableId);
  }
}

/**
 * Get current virtual selection state
 */
export function getVirtualSelectionState(): VirtualGroupSelection {
  return { ...selectionState };
}

/**
 * Check if currently in selection mode
 */
export function isInSelectionMode(): boolean {
  return selectionState.isSelecting;
}

/**
 * Check if a table is selected
 */
export function isTableSelected(tableId: string): boolean {
  return selectionState.selectedTableIds.includes(tableId);
}

/**
 * Get selected table IDs
 */
export function getSelectedTableIds(): string[] {
  return [...selectionState.selectedTableIds];
}

/**
 * Get count of selected tables
 */
export function getSelectedCount(): number {
  return selectionState.selectedTableIds.length;
}

/**
 * Clear selection and exit selection mode
 */
export function cancelVirtualSelection(): void {
  selectionState = {
    isSelecting: false,
    selectedTableIds: [],
    startedAt: null,
  };
  notifySelectionChange();
}

/**
 * Confirm virtual group creation (returns selected IDs and clears state)
 */
export function confirmVirtualGroup(): string[] {
  const selectedIds = [...selectionState.selectedTableIds];

  // Clear selection state
  cancelVirtualSelection();

  return selectedIds;
}



################################################################################
# FILE: src/domains/floor-plan/hooks/index.ts
################################################################################

/**
 * Floor Plan Hooks Index
 */

export { useFloorPlan } from './useFloorPlan'
export { useSeating } from './useSeating'
export { useTableGroups } from './useTableGroups'



################################################################################
# FILE: src/domains/floor-plan/hooks/useFloorPlan.ts
################################################################################

'use client'

/**
 * useFloorPlan Hook
 *
 * Main hook for floor plan state management.
 * Wraps the existing Zustand store and adds domain-specific functionality.
 */

import { useCallback, useEffect } from 'react'
import { create } from 'zustand'
import type { Table, TableStatus, Section } from '../types'
import * as TableService from '../services/table-service'
import * as StatusEngine from '../services/status-engine'

// =============================================================================
// STORE TYPES
// =============================================================================

interface FloorPlanState {
  // Data
  tables: Table[]
  sections: Section[]
  isLoading: boolean
  error: string | null

  // Selection
  selectedTableId: string | null
  selectedSectionId: string | null

  // View
  zoom: number
  panX: number
  panY: number

  // Actions
  setTables: (tables: Table[]) => void
  setSections: (sections: Section[]) => void
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  selectTable: (tableId: string | null) => void
  selectSection: (sectionId: string | null) => void
  setZoom: (zoom: number) => void
  setPan: (x: number, y: number) => void
  updateTableStatus: (tableId: string, status: TableStatus) => void
  updateTablePosition: (tableId: string, x: number, y: number) => void
}

// =============================================================================
// STORE
// =============================================================================

const useFloorPlanStore = create<FloorPlanState>((set) => ({
  // Initial state
  tables: [],
  sections: [],
  isLoading: false,
  error: null,
  selectedTableId: null,
  selectedSectionId: null,
  zoom: 1,
  panX: 0,
  panY: 0,

  // Actions
  setTables: (tables) => set({ tables }),
  setSections: (sections) => set({ sections }),
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error }),
  selectTable: (selectedTableId) => set({ selectedTableId }),
  selectSection: (selectedSectionId) => set({ selectedSectionId }),
  setZoom: (zoom) => set({ zoom: Math.max(0.5, Math.min(2, zoom)) }),
  setPan: (panX, panY) => set({ panX, panY }),

  updateTableStatus: (tableId, status) =>
    set((state) => ({
      tables: state.tables.map((t) =>
        t.id === tableId ? { ...t, status } : t
      ),
    })),

  updateTablePosition: (tableId, x, y) =>
    set((state) => ({
      tables: state.tables.map((t) =>
        t.id === tableId ? { ...t, x, y } : t
      ),
    })),
}))

// =============================================================================
// HOOK
// =============================================================================

export function useFloorPlan(locationId?: string) {
  const store = useFloorPlanStore()

  // Load tables on mount
  useEffect(() => {
    if (!locationId) return

    const loadTables = async () => {
      store.setLoading(true)
      store.setError(null)

      try {
        const tables = await TableService.getTablesForLocation(locationId)
        store.setTables(tables)
      } catch (error) {
        store.setError(error instanceof Error ? error.message : 'Failed to load tables')
      } finally {
        store.setLoading(false)
      }
    }

    loadTables()
  }, [locationId])

  // Get selected table
  const selectedTable = store.selectedTableId
    ? store.tables.find((t) => t.id === store.selectedTableId) || null
    : null

  // Get tables for current section
  const tablesInSection = store.selectedSectionId
    ? store.tables.filter((t) => t.sectionId === store.selectedSectionId)
    : store.tables

  // Update table status (with validation)
  const changeTableStatus = useCallback(
    async (tableId: string, newStatus: TableStatus) => {
      const table = store.tables.find((t) => t.id === tableId)
      if (!table) return false

      // Validate transition
      if (!StatusEngine.isValidTransition(table.status, newStatus)) {
        console.warn(`Invalid status transition: ${table.status} -> ${newStatus}`)
        return false
      }

      // Optimistic update
      store.updateTableStatus(tableId, newStatus)

      try {
        await TableService.updateTableStatus(tableId, newStatus)
        return true
      } catch (error) {
        // Revert on failure
        store.updateTableStatus(tableId, table.status)
        return false
      }
    },
    [store.tables]
  )

  // Move table position
  const moveTable = useCallback(
    async (tableId: string, x: number, y: number) => {
      const table = store.tables.find((t) => t.id === tableId)
      if (!table) return false

      // Optimistic update
      store.updateTablePosition(tableId, x, y)

      try {
        await TableService.updateTablePosition(tableId, x, y)
        return true
      } catch (error) {
        // Revert on failure
        store.updateTablePosition(tableId, table.x, table.y)
        return false
      }
    },
    [store.tables]
  )

  // Zoom controls
  const zoomIn = useCallback(() => {
    store.setZoom(store.zoom + 0.1)
  }, [store.zoom])

  const zoomOut = useCallback(() => {
    store.setZoom(store.zoom - 0.1)
  }, [store.zoom])

  const resetZoom = useCallback(() => {
    store.setZoom(1)
    store.setPan(0, 0)
  }, [])

  // Get status info
  const getTableStatusInfo = useCallback((tableId: string) => {
    const table = store.tables.find((t) => t.id === tableId)
    if (!table) return null

    return {
      ...StatusEngine.getStatusDisplay(table.status),
      validNextStatuses: StatusEngine.getValidNextStatuses(table.status),
      isDining: StatusEngine.isDiningState(table.status),
      canSeat: StatusEngine.canSeatGuests(table.status),
      needsAttention: StatusEngine.needsAttention(table.status),
    }
  }, [store.tables])

  return {
    // State
    tables: store.tables,
    sections: store.sections,
    isLoading: store.isLoading,
    error: store.error,
    selectedTable,
    selectedTableId: store.selectedTableId,
    selectedSectionId: store.selectedSectionId,
    tablesInSection,
    zoom: store.zoom,
    panX: store.panX,
    panY: store.panY,

    // Actions
    selectTable: store.selectTable,
    selectSection: store.selectSection,
    changeTableStatus,
    moveTable,
    zoomIn,
    zoomOut,
    resetZoom,
    setPan: store.setPan,

    // Utilities
    getTableStatusInfo,
  }
}

export default useFloorPlan



################################################################################
# FILE: src/domains/floor-plan/hooks/useSeating.ts
################################################################################

'use client'

/**
 * useSeating Hook
 *
 * Manages seat assignment and status for tables.
 */

import { useState, useCallback, useEffect } from 'react'
import type { Seat } from '../types'
import * as SeatService from '../services/seat-service'

interface UseSeatingOptions {
  tableId: string
  autoLoad?: boolean
}

export function useSeating({ tableId, autoLoad = true }: UseSeatingOptions) {
  const [seats, setSeats] = useState<Seat[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [selectedSeatId, setSelectedSeatId] = useState<string | null>(null)

  // Load seats
  const loadSeats = useCallback(async () => {
    if (!tableId) return

    setIsLoading(true)
    setError(null)

    try {
      const loadedSeats = await SeatService.getSeatsForTable(tableId)
      setSeats(loadedSeats)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load seats')
    } finally {
      setIsLoading(false)
    }
  }, [tableId])

  // Auto-load on mount
  useEffect(() => {
    if (autoLoad) {
      loadSeats()
    }
  }, [autoLoad, loadSeats])

  // Get selected seat
  const selectedSeat = selectedSeatId
    ? seats.find((s) => s.id === selectedSeatId) || null
    : null

  // Select a seat
  const selectSeat = useCallback((seatId: string | null) => {
    setSelectedSeatId(seatId)
  }, [])

  // Select seat by number
  const selectSeatByNumber = useCallback(
    (seatNumber: number) => {
      const seat = seats.find((s) => s.number === seatNumber)
      setSelectedSeatId(seat?.id || null)
    },
    [seats]
  )

  // Auto-generate seats
  const regenerateSeats = useCallback(
    async (capacity: number, shape: string) => {
      setIsLoading(true)
      setError(null)

      try {
        const newSeats = await SeatService.autoGenerateSeats(tableId, capacity, shape)
        setSeats(newSeats)
        return true
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to generate seats')
        return false
      } finally {
        setIsLoading(false)
      }
    },
    [tableId]
  )

  // Add virtual seat
  const addVirtualSeat = useCallback(
    async (position: { x: number; y: number; angle: number }) => {
      setIsLoading(true)
      setError(null)

      try {
        const newSeat = await SeatService.addVirtualSeat(tableId, {
          x: position.x,
          y: position.y,
          angle: position.angle,
          distance: 0.5,
        })
        setSeats((prev) => [...prev, newSeat])
        return newSeat
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to add seat')
        return null
      } finally {
        setIsLoading(false)
      }
    },
    [tableId]
  )

  // Get seat count
  const seatCount = seats.length
  const occupiedCount = seats.filter((s) => s.isOccupied).length
  const availableCount = seatCount - occupiedCount

  return {
    // State
    seats,
    isLoading,
    error,
    selectedSeat,
    selectedSeatId,
    seatCount,
    occupiedCount,
    availableCount,

    // Actions
    loadSeats,
    selectSeat,
    selectSeatByNumber,
    regenerateSeats,
    addVirtualSeat,
  }
}

export default useSeating



################################################################################
# FILE: src/domains/floor-plan/hooks/useTableGroups.ts
################################################################################

'use client'

/**
 * useTableGroups Hook
 *
 * Manages physical and virtual table groups.
 * Uses API routes instead of direct Prisma calls to work in the browser.
 */

import { useState, useCallback, useEffect } from 'react'
import type { TableGroup, GroupColor } from '../types'

interface UseTableGroupsOptions {
  locationId: string
  autoLoad?: boolean
}

interface VirtualGroupAPIResponse {
  data?: {
    virtualGroupId: string
    groupColor: string
    primaryTableId: string
    memberTableIds: string[]
    tables: Array<{
      id: string
      name: string
      virtualGroupId: string
      virtualGroupPrimary: boolean
      virtualGroupColor: string
    }>
    message?: string
  }
  error?: string
  requiresAction?: boolean
  existingOrders?: Array<{
    tableId: string
    tableName: string
    orderId: string
    orderNumber: number
    itemCount: number
    total: number
  }>
}

interface VirtualGroupListItem {
  virtualGroupId: string
  primaryTableId: string
  groupColor: string
  createdAt: string
  tables: Array<{
    id: string
    name: string
    isPrimary: boolean
  }>
}

export function useTableGroups({ locationId, autoLoad = true }: UseTableGroupsOptions) {
  const [groups, setGroups] = useState<TableGroup[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Load groups via API
  const loadGroups = useCallback(async () => {
    if (!locationId) return

    setIsLoading(true)
    setError(null)

    try {
      const res = await fetch(`/api/tables/virtual-combine?locationId=${locationId}`)
      if (!res.ok) {
        throw new Error('Failed to load virtual groups')
      }

      const data = await res.json()
      const virtualGroups: VirtualGroupListItem[] = data.data || []

      // Convert API response to TableGroup format
      const loadedGroups: TableGroup[] = virtualGroups.map((vg) => ({
        id: vg.virtualGroupId,
        locationId,
        name: vg.tables.map((t) => t.name).join('+'),
        color: (vg.groupColor || 'blue') as GroupColor,
        isVirtual: true,
        tableIds: vg.tables.map((t) => t.id),
        primaryTableId: vg.primaryTableId,
        createdAt: new Date(vg.createdAt),
        createdBy: '',
      }))

      setGroups(loadedGroups)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load groups')
    } finally {
      setIsLoading(false)
    }
  }, [locationId])

  // Auto-load on mount
  useEffect(() => {
    if (autoLoad) {
      loadGroups()
    }
  }, [autoLoad, loadGroups])

  // Get group for a table
  const getGroupForTable = useCallback(
    (tableId: string) => {
      return groups.find((g) => g.tableIds.includes(tableId)) || null
    },
    [groups]
  )

  // Check if table is in a group
  const isTableInGroup = useCallback(
    (tableId: string) => {
      return groups.some((g) => g.tableIds.includes(tableId))
    },
    [groups]
  )

  // Create virtual group via API
  const createVirtualGroup = useCallback(
    async (
      tableIds: string[],
      employeeId: string,
      _color?: GroupColor,
      visualOffsets?: Array<{ tableId: string; offsetX: number; offsetY: number }>
    ) => {
      if (tableIds.length < 2) {
        setError('Need at least 2 tables to create a group')
        return null
      }

      setIsLoading(true)
      setError(null)

      try {
        // First table is primary
        const primaryTableId = tableIds[0]

        const res = await fetch('/api/tables/virtual-combine', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tableIds,
            primaryTableId,
            locationId,
            employeeId,
            visualOffsets, // Pass visual offsets to persist in DB
          }),
        })

        const data: VirtualGroupAPIResponse = await res.json()

        if (!res.ok) {
          throw new Error(data.error || 'Failed to create virtual group')
        }

        // Handle case where orders need to be dealt with first
        if (data.requiresAction) {
          setError(`Some tables have open orders: ${data.existingOrders?.map((o) => o.tableName).join(', ')}`)
          return null
        }

        if (!data.data) {
          throw new Error('No data returned from API')
        }

        // Create TableGroup from response
        const group: TableGroup = {
          id: data.data.virtualGroupId,
          locationId,
          name: data.data.tables.map((t) => t.name).join('+'),
          color: (data.data.groupColor || 'blue') as GroupColor,
          isVirtual: true,
          tableIds: data.data.memberTableIds,
          primaryTableId: data.data.primaryTableId,
          createdAt: new Date(),
          createdBy: employeeId,
        }

        setGroups((prev) => [...prev, group])
        return group
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to create group'
        setError(message)
        console.error('[useTableGroups] createVirtualGroup error:', err)
        return null
      } finally {
        setIsLoading(false)
      }
    },
    [locationId]
  )

  // Dissolve group via API
  const dissolveGroup = useCallback(
    async (groupId: string, employeeId: string = 'emp-1') => {
      setIsLoading(true)
      setError(null)

      try {
        const res = await fetch(`/api/tables/virtual-combine/${groupId}/dissolve`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            locationId,
            employeeId,
          }),
        })

        if (!res.ok) {
          const data = await res.json()
          throw new Error(data.error || 'Failed to dissolve group')
        }

        setGroups((prev) => prev.filter((g) => g.id !== groupId))
        return true
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to dissolve group')
        console.error('[useTableGroups] dissolveGroup error:', err)
        return false
      } finally {
        setIsLoading(false)
      }
    },
    [locationId]
  )

  // Add table to existing group via API
  const addToGroup = useCallback(
    async (
      groupId: string,
      tableId: string,
      employeeId: string = 'emp-1',
      offsetX: number = 0,
      offsetY: number = 0
    ) => {
      setIsLoading(true)
      setError(null)

      try {
        const res = await fetch(`/api/tables/virtual-combine/${groupId}/add`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tableId,
            locationId,
            employeeId,
            offsetX, // Pass visual offset to persist in DB
            offsetY,
          }),
        })

        if (!res.ok) {
          const data = await res.json()
          throw new Error(data.error || 'Failed to add table to group')
        }

        // Reload groups to get updated state
        await loadGroups()
        return true
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to add table to group')
        return false
      } finally {
        setIsLoading(false)
      }
    },
    [locationId, loadGroups]
  )

  // Remove table from group via API
  const removeFromGroup = useCallback(
    async (groupId: string, tableId: string, employeeId: string = 'emp-1') => {
      setIsLoading(true)
      setError(null)

      try {
        const res = await fetch(`/api/tables/virtual-combine/${groupId}/remove`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tableId,
            locationId,
            employeeId,
          }),
        })

        const data = await res.json()

        if (!res.ok) {
          throw new Error(data.error || 'Failed to remove table from group')
        }

        // Check if group was dissolved
        if (data.data?.dissolved) {
          setGroups((prev) => prev.filter((g) => g.id !== groupId))
        } else {
          // Reload groups to get updated state
          await loadGroups()
        }

        return true
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to remove table from group')
        return false
      } finally {
        setIsLoading(false)
      }
    },
    [locationId, loadGroups]
  )

  // Get virtual groups only
  const virtualGroups = groups.filter((g) => g.isVirtual)

  // Get physical groups only
  const physicalGroups = groups.filter((g) => !g.isVirtual)

  return {
    // State
    groups,
    virtualGroups,
    physicalGroups,
    isLoading,
    error,

    // Queries
    getGroupForTable,
    isTableInGroup,

    // Actions
    loadGroups,
    createVirtualGroup,
    dissolveGroup,
    addToGroup,
    removeFromGroup,
  }
}

export default useTableGroups



################################################################################
# FILE: src/domains/floor-plan/index.ts
################################################################################

/**
 * Floor Plan Domain
 *
 * Manages WHERE everything is and WHO sits where.
 *
 * Layers:
 * - L1: Floor Canvas (rooms, grid, fixtures)
 * - L2: Tables & Smart Objects (tables, entertainment)
 * - L3: Seats (auto-positioned around objects)
 * - L4: Table Groups (physical merge, virtual combine)
 * - L5: Admin & Persistence (blueprint vs live state)
 * - L6: Staff Roles (sections, assignments)
 * - L7: Status Engine (15-status state machine)
 * - L8: Entertainment (timed rentals, sessions)
 * - L9: Waitlist (queue management)
 *
 * This domain NEVER handles order logic directly.
 * It communicates with Order Management through the floor-to-order bridge.
 */

// =============================================================================
// PUBLIC TYPES
// =============================================================================

export type {
  Table,
  TableShape,
  TableStatus,
  Seat,
  SeatPosition,
  Room,
  FloorPlan,
  Fixture,
  FixtureType,
  TableGroup,
  GroupColor,
  Section,
  SectionAssignment,
  StatusTransition,
  StatusTrigger,
  TimedRental,
  EntertainmentType,
  RentalStatus,
  WaitlistEntry,
  WaitlistStatus,
  WaitlistPreferences,
} from './types'

// =============================================================================
// PUBLIC HOOKS
// =============================================================================

export { useFloorPlan } from './hooks/useFloorPlan'
export { useSeating } from './hooks/useSeating'
export { useTableGroups } from './hooks/useTableGroups'

// =============================================================================
// PUBLIC SERVICES
// =============================================================================

// Table Service (L2)
export {
  getTablesForLocation,
  getTableById,
  getTablesForSection,
  updateTablePosition,
  updateTableStatus,
  toTableRect,
  toTableRectArray,
  getPrimaryTableId,
  getPrimaryTable,
  isPhysicalGroup,
  isVirtualGroup,
  isPrimaryTable,
} from './services/table-service'

// Seat Service (L3)
export {
  getSeatsForTable,
  getSeatById,
  autoGenerateSeats,
  addVirtualSeat,
  updateSeatOccupancy,
  calculateSeatBalance,
  determineSeatStatus,
  SEAT_STATUS_COLORS,
  SEAT_STATUS_BG_COLORS,
  SEAT_STATUS_GLOW,
} from './services/seat-service'

export type { SeatStatus, SeatInfo, OrderItemForSeat, PaymentForSeat } from './services/seat-service'

// Group Service (L4)
export {
  getGroupsForLocation,
  getGroupById,
  createVirtualGroup,
  createPhysicalGroup,
  dissolveGroup,
  addTableToGroup,
  removeTableFromGroup,
} from './services/group-service'

// Status Engine (L7)
export {
  isValidTransition,
  getValidNextStatuses,
  getNextStatusForTrigger,
  isAutomaticTransition,
  getTransitionTimeout,
  getStatusDisplay,
  isDiningState,
  canSeatGuests,
  needsAttention,
} from './services/status-engine'

// =============================================================================
// PUBLIC COMPONENTS (to be migrated)
// =============================================================================

// Components will be migrated incrementally
// export { FloorPlanCanvas } from './components/FloorPlanCanvas'
// export { TableNode } from './components/TableNode'
// export { SeatNode } from './components/SeatNode'

// =============================================================================
// CONSTANTS
// =============================================================================

export const TABLE_STATUSES = [
  'available',
  'seating',
  'occupied',
  'ordering',
  'food_pending',
  'food_served',
  'dessert',
  'check_requested',
  'check_dropped',
  'paid',
  'dirty',
  'bussing',
  'reserved',
  'blocked',
  'combined',
] as const

export const ENTERTAINMENT_TYPES = [
  'pool',
  'darts',
  'karaoke',
  'arcade',
  'bowling',
  'shuffleboard',
] as const

export const GROUP_COLORS = [
  'blue',
  'green',
  'orange',
  'purple',
  'pink',
  'yellow',
  'cyan',
  'red',
] as const

export const TABLE_SHAPES = [
  'square',
  'round',
  'rectangle',
  'oval',
  'booth',
  'bar_seat',
  'high_top',
  'custom',
] as const



################################################################################
# FILE: src/domains/floor-plan/seats/index.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 3: Seats - Public Exports
 */

// API
export { SeatAPI, default as seatAPI } from './seatAPI';
export type {
  createSeat,
  getSeat,
  updateSeat,
  deleteSeat,
  getSeatsForTable,
  getOccupiedSeats,
  getAvailableSeats,
  generateSeatsForTable,
  repositionSeats,
  addVirtualSeat,
  removeVirtualSeat,
  clearVirtualSeats,
  setSeatOccupied,
  renumberSeatsForMerge,
  handleSeamEdgeDisplacement,
  initializeSeats,
  clearAll,
} from './seatAPI';

// Layout engine
export {
  generateSeatPositions,
  generateBoothSeats,
  type SeatPosition,
} from './seatLayout';

// Component
export { Seat, default as SeatComponent } from './Seat';



################################################################################
# FILE: src/domains/floor-plan/seats/Seat.tsx
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 3: Seat Component
 *
 * Renders a seat as a small circle around a table.
 * Shows occupied state, guest info, and virtual seat indicators.
 */

'use client';

import React from 'react';
import type { Seat as SeatType } from '../shared/types';

interface SeatProps {
  seat: SeatType;
  tableX: number; // Table center X position in feet
  tableY: number; // Table center Y position in feet
  pixelsPerFoot: number;
  isSelected?: boolean;
  onSelect?: (seatId: string) => void;
}

/**
 * Seat Component
 * Renders a seat as a circle relative to the table center
 */
export function Seat({
  seat,
  tableX,
  tableY,
  pixelsPerFoot,
  isSelected,
  onSelect,
}: SeatProps) {
  // Calculate absolute position (table center + offset)
  const absoluteX = (tableX + seat.offsetX) * pixelsPerFoot;
  const absoluteY = (tableY + seat.offsetY) * pixelsPerFoot;

  // Seat circle radius
  const radius = 12; // pixels

  // Determine colors based on state
  let fillColor = '#FFFFFF'; // Default: empty white
  let strokeColor = '#9CA3AF'; // Default: gray border
  let strokeWidth = 2;
  let textColor = '#374151';

  if (seat.isOccupied) {
    fillColor = '#3B82F6'; // Blue for occupied
    strokeColor = '#2563EB';
    textColor = '#FFFFFF';
  }

  if (isSelected) {
    strokeColor = '#2563EB'; // Blue glow for selected
    strokeWidth = 3;
  }

  // Virtual seat gets dashed border
  const strokeDasharray = seat.isVirtual ? '4,2' : undefined;

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (onSelect) {
      onSelect(seat.id);
    }
  };

  // Get display text (guest initial or seat number)
  let displayText = seat.seatNumber.toString();
  if (seat.isOccupied && seat.guestName) {
    // Show first letter of guest name
    displayText = seat.guestName.charAt(0).toUpperCase();
  }

  return (
    <g
      style={{
        cursor: 'pointer',
      }}
      onClick={handleClick}
    >
      {/* Selected glow effect */}
      {isSelected && (
        <circle
          cx={absoluteX}
          cy={absoluteY}
          r={radius + 4}
          fill="none"
          stroke="rgba(59, 130, 246, 0.5)"
          strokeWidth="4"
          style={{ pointerEvents: 'none' }}
        />
      )}

      {/* Seat circle */}
      <circle
        cx={absoluteX}
        cy={absoluteY}
        r={radius}
        fill={fillColor}
        stroke={strokeColor}
        strokeWidth={strokeWidth}
        strokeDasharray={strokeDasharray}
      />

      {/* Seat number or guest initial */}
      <text
        x={absoluteX}
        y={absoluteY}
        textAnchor="middle"
        dominantBaseline="middle"
        fill={textColor}
        fontSize="11"
        fontWeight={seat.isOccupied ? 'bold' : 'normal'}
        style={{ pointerEvents: 'none', userSelect: 'none' }}
      >
        {displayText}
      </text>

      {/* Virtual seat indicator (small "V" badge) */}
      {seat.isVirtual && (
        <text
          x={absoluteX + radius - 2}
          y={absoluteY - radius + 6}
          textAnchor="middle"
          dominantBaseline="middle"
          fill="#F59E0B"
          fontSize="8"
          fontWeight="bold"
          style={{ pointerEvents: 'none', userSelect: 'none' }}
        >
          V
        </text>
      )}
    </g>
  );
}

export default Seat;



################################################################################
# FILE: src/domains/floor-plan/seats/seatAPI.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 3: Seats API
 *
 * Manages seats around tables. Auto-positions seats based on table shape,
 * handles virtual seats (added during service), and seat renumbering when tables merge.
 */

import type { Seat, TableShape } from '../shared/types';
import { TableAPI } from '../tables';
import { generateSeatPositions, generateBoothSeats } from './seatLayout';

// =============================================================================
// STATE (In production, this would come from the database)
// =============================================================================

let seats: Map<string, Seat> = new Map();

// =============================================================================
// CRUD OPERATIONS
// =============================================================================

/**
 * Create a new seat
 */
export function createSeat(data: Omit<Seat, 'id'>): Seat {
  const id = `seat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const seat: Seat = {
    id,
    ...data,
  };
  seats.set(id, seat);
  return seat;
}

/**
 * Get a seat by ID
 */
export function getSeat(seatId: string): Seat | null {
  return seats.get(seatId) ?? null;
}

/**
 * Update a seat
 */
export function updateSeat(seatId: string, updates: Partial<Seat>): void {
  const seat = seats.get(seatId);
  if (seat) {
    seats.set(seatId, { ...seat, ...updates });
  }
}

/**
 * Delete a seat
 */
export function deleteSeat(seatId: string): void {
  seats.delete(seatId);
}

// =============================================================================
// QUERY METHODS
// =============================================================================

/**
 * Get all seats for a table
 */
export function getSeatsForTable(tableId: string): Seat[] {
  return Array.from(seats.values())
    .filter((s) => s.tableId === tableId && s.isActive)
    .sort((a, b) => a.seatNumber - b.seatNumber);
}

/**
 * Get occupied seats for a table
 */
export function getOccupiedSeats(tableId: string): Seat[] {
  return getSeatsForTable(tableId).filter((s) => s.isOccupied);
}

/**
 * Get available (unoccupied) seats for a table
 */
export function getAvailableSeats(tableId: string): Seat[] {
  return getSeatsForTable(tableId).filter((s) => !s.isOccupied);
}

// =============================================================================
// AUTO-LAYOUT
// =============================================================================

/**
 * Generate seats for a table with auto-positioning
 */
export function generateSeatsForTable(
  tableId: string,
  count: number,
  shape: TableShape
): Seat[] {
  // Get table info for dimensions
  const table = TableAPI.getTable(tableId);
  if (!table) {
    throw new Error(`Table not found: ${tableId}`);
  }

  // Generate positions based on shape
  let positions;
  if (table.objectType === 'booth') {
    positions = generateBoothSeats(count, table.width, table.height);
  } else {
    positions = generateSeatPositions(shape, count, table.width, table.height);
  }

  // Create seat objects
  const newSeats: Seat[] = [];
  for (let i = 0; i < count; i++) {
    const pos = positions[i];
    const seat = createSeat({
      tableId,
      locationId: table.locationId,
      seatNumber: i + 1,
      positionIndex: i,
      offsetX: pos.offsetX,
      offsetY: pos.offsetY,
      angle: pos.angle,
      isOccupied: false,
      isVirtual: false,
      orderId: null,
      guestName: null,
      isActive: true,
    });
    newSeats.push(seat);
  }

  return newSeats;
}

/**
 * Reposition seats for a table (recalculate based on current table dimensions)
 */
export function repositionSeats(tableId: string): void {
  const table = TableAPI.getTable(tableId);
  if (!table) return;

  const existingSeats = getSeatsForTable(tableId);
  const count = existingSeats.length;

  if (count === 0) return;

  // Generate new positions
  let positions;
  if (table.objectType === 'booth') {
    positions = generateBoothSeats(count, table.width, table.height);
  } else {
    positions = generateSeatPositions(table.shape, count, table.width, table.height);
  }

  // Update each seat with new position
  for (let i = 0; i < count; i++) {
    const seat = existingSeats[i];
    const pos = positions[i];
    updateSeat(seat.id, {
      offsetX: pos.offsetX,
      offsetY: pos.offsetY,
      angle: pos.angle,
      positionIndex: i,
    });
  }
}

// =============================================================================
// VIRTUAL SEATS
// =============================================================================

/**
 * Add a virtual seat to a table (added during service, removed on close)
 */
export function addVirtualSeat(tableId: string): Seat {
  const table = TableAPI.getTable(tableId);
  if (!table) {
    throw new Error(`Table not found: ${tableId}`);
  }

  const existingSeats = getSeatsForTable(tableId);
  const nextSeatNumber = existingSeats.length + 1;

  // Position virtual seat at a reasonable location
  // For now, place it at the end of the current seat arrangement
  const lastSeat = existingSeats[existingSeats.length - 1];
  let offsetX = 0;
  let offsetY = 0;
  let angle = 0;

  if (lastSeat) {
    // Place near last seat with slight offset
    offsetX = lastSeat.offsetX + 1;
    offsetY = lastSeat.offsetY + 1;
    angle = lastSeat.angle;
  } else {
    // First seat, place at default position
    offsetX = 0;
    offsetY = table.height / 2 + 1.5;
    angle = 0;
  }

  const seat = createSeat({
    tableId,
    locationId: table.locationId,
    seatNumber: nextSeatNumber,
    positionIndex: nextSeatNumber - 1,
    offsetX,
    offsetY,
    angle,
    isOccupied: false,
    isVirtual: true,
    orderId: null,
    guestName: null,
    isActive: true,
  });

  return seat;
}

/**
 * Remove a virtual seat
 */
export function removeVirtualSeat(seatId: string): void {
  const seat = seats.get(seatId);
  if (!seat || !seat.isVirtual) {
    throw new Error('Can only remove virtual seats');
  }
  deleteSeat(seatId);
}

/**
 * Clear all virtual seats for a table
 */
export function clearVirtualSeats(tableId: string): void {
  const tableSeats = getSeatsForTable(tableId);
  for (const seat of tableSeats) {
    if (seat.isVirtual) {
      deleteSeat(seat.id);
    }
  }
}

// =============================================================================
// OCCUPANCY
// =============================================================================

/**
 * Set a seat's occupied state
 */
export function setSeatOccupied(
  seatId: string,
  occupied: boolean,
  guestName?: string
): void {
  updateSeat(seatId, {
    isOccupied: occupied,
    guestName: guestName ?? null,
  });
}

// =============================================================================
// MERGE HANDLING
// =============================================================================

/**
 * Renumber seats for merged tables (sequential across all tables)
 * Returns a map of seatId -> new seat number
 */
export function renumberSeatsForMerge(tableIds: string[]): Map<string, number> {
  const renumberMap = new Map<string, number>();
  let currentNumber = 1;

  // Collect all seats from all tables
  for (const tableId of tableIds) {
    const tableSeats = getSeatsForTable(tableId);

    // Sort by current position index to maintain order
    tableSeats.sort((a, b) => a.positionIndex - b.positionIndex);

    // Renumber sequentially
    for (const seat of tableSeats) {
      renumberMap.set(seat.id, currentNumber);
      updateSeat(seat.id, { seatNumber: currentNumber });
      currentNumber++;
    }
  }

  return renumberMap;
}

/**
 * Handle seat displacement when tables are merged at seam edge
 * (Future implementation - for now just reposition seats)
 */
export function handleSeamEdgeDisplacement(
  table1Id: string,
  table2Id: string
): void {
  // For now, just reposition seats for both tables
  repositionSeats(table1Id);
  repositionSeats(table2Id);
}

// =============================================================================
// INITIALIZATION
// =============================================================================

/**
 * Initialize seats from the database
 */
export function initializeSeats(seatList: Seat[]): void {
  seats.clear();
  for (const seat of seatList) {
    seats.set(seat.id, seat);
  }
}

/**
 * Clear all seats (for testing)
 */
export function clearAll(): void {
  seats.clear();
}

// =============================================================================
// EXPORT THE API
// =============================================================================

export const SeatAPI = {
  // CRUD
  createSeat,
  getSeat,
  updateSeat,
  deleteSeat,

  // Queries
  getSeatsForTable,
  getOccupiedSeats,
  getAvailableSeats,

  // Auto-layout
  generateSeatsForTable,
  repositionSeats,

  // Virtual seats
  addVirtualSeat,
  removeVirtualSeat,
  clearVirtualSeats,

  // Occupancy
  setSeatOccupied,

  // Merge handling
  renumberSeatsForMerge,
  handleSeamEdgeDisplacement,

  // Initialization
  initializeSeats,
  clearAll,
};

export default SeatAPI;



################################################################################
# FILE: src/domains/floor-plan/seats/seatLayout.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 3: Seat Layout Engine
 *
 * Auto-positions seats around tables based on shape.
 * All positions are in feet relative to table center.
 */

import type { TableShape } from '../shared/types';

export interface SeatPosition {
  offsetX: number; // feet from table center
  offsetY: number; // feet from table center
  angle: number; // degrees, facing toward center
}

/**
 * Generate seat positions for a table based on shape and count
 */
export function generateSeatPositions(
  shape: TableShape,
  count: number,
  tableWidth: number,
  tableHeight: number
): SeatPosition[] {
  switch (shape) {
    case 'round':
    case 'oval':
      return generateCircularSeats(count, tableWidth, tableHeight);

    case 'square':
    case 'rectangle':
      return generateRectangularSeats(count, tableWidth, tableHeight);

    case 'hexagon':
      return generateHexagonSeats(count, tableWidth, tableHeight);

    case 'custom':
    default:
      // Default to circular distribution
      return generateCircularSeats(count, tableWidth, tableHeight);
  }
}

/**
 * Generate seats in a circle around the table (for round/oval tables)
 *
 * Example (8 seats):
 *      1
 *   8     2
 *  7      3
 *   6     4
 *      5
 */
function generateCircularSeats(
  count: number,
  tableWidth: number,
  tableHeight: number
): SeatPosition[] {
  const seats: SeatPosition[] = [];
  const radiusX = tableWidth / 2 + 1.5; // 1.5 feet clearance
  const radiusY = tableHeight / 2 + 1.5;

  // Start at top (270 degrees / -90 degrees from right)
  const startAngle = -Math.PI / 2;

  for (let i = 0; i < count; i++) {
    const angle = startAngle + (i * 2 * Math.PI) / count;

    const offsetX = radiusX * Math.cos(angle);
    const offsetY = radiusY * Math.sin(angle);

    // Calculate angle facing toward center (in degrees)
    const facingAngle = ((angle + Math.PI) * 180) / Math.PI;

    seats.push({
      offsetX: Number(offsetX.toFixed(2)),
      offsetY: Number(offsetY.toFixed(2)),
      angle: Number(facingAngle.toFixed(1)),
    });
  }

  return seats;
}

/**
 * Generate seats distributed along edges of rectangle
 *
 * Example (6 seats):
 *     1   2
 *   6    3
 *     5   4
 */
function generateRectangularSeats(
  count: number,
  tableWidth: number,
  tableHeight: number
): SeatPosition[] {
  const seats: SeatPosition[] = [];
  const clearance = 1.5; // feet

  // Calculate perimeter and distribute seats
  const perimeter = 2 * (tableWidth + tableHeight);
  const spacing = perimeter / count;

  // Determine how many seats per side based on side length
  const topCount = Math.round((tableWidth / perimeter) * count);
  const rightCount = Math.round((tableHeight / perimeter) * count);
  const bottomCount = Math.round((tableWidth / perimeter) * count);
  const leftCount = count - topCount - rightCount - bottomCount;

  // Top edge (left to right)
  for (let i = 0; i < topCount; i++) {
    const x = -tableWidth / 2 + (tableWidth / (topCount + 1)) * (i + 1);
    const y = -tableHeight / 2 - clearance;
    seats.push({
      offsetX: Number(x.toFixed(2)),
      offsetY: Number(y.toFixed(2)),
      angle: 180, // facing down (toward center)
    });
  }

  // Right edge (top to bottom)
  for (let i = 0; i < rightCount; i++) {
    const x = tableWidth / 2 + clearance;
    const y = -tableHeight / 2 + (tableHeight / (rightCount + 1)) * (i + 1);
    seats.push({
      offsetX: Number(x.toFixed(2)),
      offsetY: Number(y.toFixed(2)),
      angle: 270, // facing left (toward center)
    });
  }

  // Bottom edge (right to left)
  for (let i = 0; i < bottomCount; i++) {
    const x = tableWidth / 2 - (tableWidth / (bottomCount + 1)) * (i + 1);
    const y = tableHeight / 2 + clearance;
    seats.push({
      offsetX: Number(x.toFixed(2)),
      offsetY: Number(y.toFixed(2)),
      angle: 0, // facing up (toward center)
    });
  }

  // Left edge (bottom to top)
  for (let i = 0; i < leftCount; i++) {
    const x = -tableWidth / 2 - clearance;
    const y = tableHeight / 2 - (tableHeight / (leftCount + 1)) * (i + 1);
    seats.push({
      offsetX: Number(x.toFixed(2)),
      offsetY: Number(y.toFixed(2)),
      angle: 90, // facing right (toward center)
    });
  }

  return seats;
}

/**
 * Generate seats around hexagon table
 */
function generateHexagonSeats(
  count: number,
  tableWidth: number,
  tableHeight: number
): SeatPosition[] {
  // For hexagons, use circular distribution with slight adjustment
  return generateCircularSeats(count, tableWidth, tableHeight);
}

/**
 * Generate booth seating (seats on 3 sides, back against wall)
 *
 * Example (4 seats):
 *   
 *   1  2  3  4
 *   (open side only)
 */
export function generateBoothSeats(
  count: number,
  tableWidth: number,
  tableHeight: number
): SeatPosition[] {
  const seats: SeatPosition[] = [];
  const clearance = 1.5;

  // All seats on the open (front) side
  const y = tableHeight / 2 + clearance;

  for (let i = 0; i < count; i++) {
    const x = -tableWidth / 2 + (tableWidth / (count + 1)) * (i + 1);
    seats.push({
      offsetX: Number(x.toFixed(2)),
      offsetY: Number(y.toFixed(2)),
      angle: 0, // facing up (toward table)
    });
  }

  return seats;
}



################################################################################
# FILE: src/domains/floor-plan/seats/test-seats.ts
################################################################################

/**
 * Simple test/demo of Seats Layer functionality
 * Run with: npx ts-node --project tsconfig.json src/domains/floor-plan/seats/test-seats.ts
 */

import { SeatAPI } from './seatAPI';
import { TableAPI } from '../tables';

// Initialize with empty data
TableAPI.initializeTables([]);
SeatAPI.initializeSeats([]);

console.log('=== Layer 3: Seats Test ===\n');

// Create a test table
const table = TableAPI.createTable({
  locationId: 'loc_1',
  floorPlanId: 'room_1',
  sectionId: null,
  label: 'T1',
  objectType: 'dining_table',
  category: 'seatable',
  shape: 'round',
  positionX: 10,
  positionY: 10,
  width: 4,
  height: 4,
  rotation: 0,
  minCapacity: 2,
  maxCapacity: 8,
  defaultCapacity: 4,
  isActive: true,
  isReservable: true,
  sortOrder: 1,
  groupId: null,
  combinedTableIds: [],
  color: null,
  entertainmentConfig: null,
});

console.log(` Created table: ${table.label} (${table.shape}, ${table.width}ft x ${table.height}ft)`);

// Generate seats for the table
console.log('\n--- Generating 8 seats for round table ---');
const seats = SeatAPI.generateSeatsForTable(table.id, 8, 'round');

console.log(` Generated ${seats.length} seats:`);
seats.forEach((seat, i) => {
  console.log(
    `   Seat ${seat.seatNumber}: offset=(${seat.offsetX}, ${seat.offsetY}), angle=${seat.angle}`
  );
});

// Test queries
console.log('\n--- Query Tests ---');
const allSeats = SeatAPI.getSeatsForTable(table.id);
console.log(` getSeatsForTable: ${allSeats.length} seats`);

const available = SeatAPI.getAvailableSeats(table.id);
console.log(` getAvailableSeats: ${available.length} seats (all initially available)`);

// Test occupancy
console.log('\n--- Occupancy Tests ---');
SeatAPI.setSeatOccupied(seats[0].id, true, 'Alice');
SeatAPI.setSeatOccupied(seats[1].id, true, 'Bob');

const occupied = SeatAPI.getOccupiedSeats(table.id);
console.log(` After seating 2 guests: ${occupied.length} occupied seats`);

const nowAvailable = SeatAPI.getAvailableSeats(table.id);
console.log(` Available seats: ${nowAvailable.length} seats`);

// Test virtual seats
console.log('\n--- Virtual Seat Tests ---');
const virtualSeat = SeatAPI.addVirtualSeat(table.id);
console.log(` Added virtual seat: Seat ${virtualSeat.seatNumber} (isVirtual=${virtualSeat.isVirtual})`);

const allSeatsWithVirtual = SeatAPI.getSeatsForTable(table.id);
console.log(` Total seats with virtual: ${allSeatsWithVirtual.length}`);

SeatAPI.clearVirtualSeats(table.id);
const afterClear = SeatAPI.getSeatsForTable(table.id);
console.log(` After clearing virtual seats: ${afterClear.length} seats`);

// Test merge renumbering
console.log('\n--- Merge Renumbering Test ---');
const table2 = TableAPI.createTable({
  locationId: 'loc_1',
  floorPlanId: 'room_1',
  sectionId: null,
  label: 'T2',
  objectType: 'dining_table',
  category: 'seatable',
  shape: 'square',
  positionX: 15,
  positionY: 10,
  width: 3,
  height: 3,
  rotation: 0,
  minCapacity: 2,
  maxCapacity: 4,
  defaultCapacity: 4,
  isActive: true,
  isReservable: true,
  sortOrder: 2,
  groupId: null,
  combinedTableIds: [],
  color: null,
  entertainmentConfig: null,
});

const seats2 = SeatAPI.generateSeatsForTable(table2.id, 4, 'square');
console.log(` Created table T2 with ${seats2.length} seats`);

console.log('\nBefore merge:');
console.log(`   Table 1 seats: ${SeatAPI.getSeatsForTable(table.id).map(s => s.seatNumber).join(', ')}`);
console.log(`   Table 2 seats: ${SeatAPI.getSeatsForTable(table2.id).map(s => s.seatNumber).join(', ')}`);

const renumberMap = SeatAPI.renumberSeatsForMerge([table.id, table2.id]);
console.log(`\n Renumbered ${renumberMap.size} seats after merge`);

console.log('After merge:');
console.log(`   Table 1 seats: ${SeatAPI.getSeatsForTable(table.id).map(s => s.seatNumber).join(', ')}`);
console.log(`   Table 2 seats: ${SeatAPI.getSeatsForTable(table2.id).map(s => s.seatNumber).join(', ')}`);

// Test repositioning
console.log('\n--- Reposition Test ---');
console.log('Original position of seat 1:', seats[0].offsetX, seats[0].offsetY);
SeatAPI.repositionSeats(table.id);
const repositioned = SeatAPI.getSeat(seats[0].id);
console.log('After reposition:', repositioned?.offsetX, repositioned?.offsetY);
console.log(' Seats repositioned successfully');

console.log('\n=== All Tests Passed! ===');



################################################################################
# FILE: src/domains/floor-plan/services/group-service.ts
################################################################################

/**
 * Group Service - L4 Table Groups
 *
 * Manages physical merges and virtual combines.
 *
 * Note: The schema uses:
 * - VirtualGroup model for virtual groups
 * - Table.virtualGroupId, virtualGroupPrimary, virtualGroupColor for membership
 * - Table.combinedWithId, combinedTableIds for physical combines (no separate model)
 */

import { db } from '@/shared'
import type { TableGroup, GroupColor } from '../types'
import { GROUP_COLORS } from '../index'

/**
 * Get all virtual groups for a location
 */
export async function getGroupsForLocation(locationId: string): Promise<TableGroup[]> {
  // Get virtual groups from VirtualGroup model
  const virtualGroups = await db.virtualGroup.findMany({
    where: {
      locationId,
      deletedAt: null,
    },
  })

  // For each group, get the tables
  const groups: TableGroup[] = []

  for (const vg of virtualGroups) {
    const tables = await db.table.findMany({
      where: {
        virtualGroupId: vg.id,
        deletedAt: null,
      },
      select: { id: true, virtualGroupPrimary: true, virtualGroupColor: true },
    })

    groups.push({
      id: vg.id,
      locationId: vg.locationId,
      name: vg.name,
      color: (tables[0]?.virtualGroupColor || 'blue') as GroupColor,
      isVirtual: true,
      tableIds: tables.map(t => t.id),
      primaryTableId: tables.find(t => t.virtualGroupPrimary)?.id || vg.primaryTableId,
      createdAt: vg.createdAt,
      createdBy: '', // Not stored in schema
    })
  }

  // Also get physical combines (tables with combinedTableIds)
  // Note: combinedTableIds is a JSON field, so we filter in code
  const allTables = await db.table.findMany({
    where: {
      locationId,
      deletedAt: null,
    },
  })

  const primaryTables = allTables.filter(t => {
    const ids = t.combinedTableIds as string[] | null
    return ids && ids.length > 0
  })

  for (const pt of primaryTables) {
    const combinedIds = (pt.combinedTableIds as string[]) || []
    groups.push({
      id: `physical-${pt.id}`,
      locationId,
      name: pt.name,
      color: 'blue' as GroupColor,
      isVirtual: false,
      tableIds: [pt.id, ...combinedIds],
      primaryTableId: pt.id,
      createdAt: pt.createdAt,
      createdBy: '',
    })
  }

  return groups
}

/**
 * Get a group by ID
 */
export async function getGroupById(groupId: string): Promise<TableGroup | null> {
  // Check if it's a physical group ID
  if (groupId.startsWith('physical-')) {
    const tableId = groupId.replace('physical-', '')
    const table = await db.table.findUnique({
      where: { id: tableId },
    })
    if (!table || !table.combinedTableIds) return null

    const combinedIds = (table.combinedTableIds as string[]) || []
    return {
      id: groupId,
      locationId: table.locationId,
      name: table.name,
      color: 'blue' as GroupColor,
      isVirtual: false,
      tableIds: [table.id, ...combinedIds],
      primaryTableId: table.id,
      createdAt: table.createdAt,
      createdBy: '',
    }
  }

  // Virtual group
  const group = await db.virtualGroup.findUnique({
    where: { id: groupId },
  })

  if (!group) return null

  const tables = await db.table.findMany({
    where: {
      virtualGroupId: group.id,
      deletedAt: null,
    },
    select: { id: true, virtualGroupPrimary: true, virtualGroupColor: true },
  })

  return {
    id: group.id,
    locationId: group.locationId,
    name: group.name,
    color: (tables[0]?.virtualGroupColor || 'blue') as GroupColor,
    isVirtual: true,
    tableIds: tables.map(t => t.id),
    primaryTableId: tables.find(t => t.virtualGroupPrimary)?.id || group.primaryTableId,
    createdAt: group.createdAt,
    createdBy: '',
  }
}

/**
 * Create a virtual group (order-linked, no geometry change)
 */
export async function createVirtualGroup(
  locationId: string,
  tableIds: string[],
  _createdBy: string,
  color?: GroupColor
): Promise<TableGroup> {
  if (tableIds.length < 2) {
    throw new Error('Need at least 2 tables to create a group')
  }

  const selectedColor = color || (await getNextAvailableColor(locationId))
  const primaryTableId = tableIds[0]

  // Get table names for group name
  const tables = await db.table.findMany({
    where: { id: { in: tableIds } },
    select: { name: true },
  })
  const groupName = tables.map(t => t.name).join('+')

  // Create the virtual group
  const group = await db.virtualGroup.create({
    data: {
      locationId,
      name: groupName,
      primaryTableId,
    },
  })

  // Update all tables with virtual group info
  await Promise.all(
    tableIds.map((tableId, index) =>
      db.table.update({
        where: { id: tableId },
        data: {
          virtualGroupId: group.id,
          virtualGroupColor: selectedColor,
          virtualGroupPrimary: index === 0,
          virtualGroupCreatedAt: new Date(),
        },
      })
    )
  )

  return {
    id: group.id,
    locationId,
    name: groupName,
    color: selectedColor,
    isVirtual: true,
    tableIds,
    primaryTableId,
    createdAt: group.createdAt,
    createdBy: _createdBy,
  }
}

/**
 * Create a physical group (magnetic snap, geometry merges)
 * Physical groups don't use a separate model - just table fields
 */
export async function createPhysicalGroup(
  locationId: string,
  primaryTableId: string,
  secondaryTableIds: string[],
  _createdBy: string
): Promise<TableGroup> {
  // Update primary table with combined IDs
  const primaryTable = await db.table.update({
    where: { id: primaryTableId },
    data: {
      combinedTableIds: secondaryTableIds,
    },
  })

  // Update secondary tables to point to primary
  await db.table.updateMany({
    where: { id: { in: secondaryTableIds } },
    data: {
      combinedWithId: primaryTableId,
    },
  })

  return {
    id: `physical-${primaryTableId}`,
    locationId,
    name: primaryTable.name,
    color: 'blue' as GroupColor,
    isVirtual: false,
    tableIds: [primaryTableId, ...secondaryTableIds],
    primaryTableId,
    createdAt: new Date(),
    createdBy: _createdBy,
  }
}

/**
 * Dissolve a group
 */
export async function dissolveGroup(groupId: string): Promise<void> {
  if (groupId.startsWith('physical-')) {
    // Physical group - clear combine fields
    const tableId = groupId.replace('physical-', '')
    const table = await db.table.findUnique({
      where: { id: tableId },
    })

    if (!table) return

    const combinedIds = (table.combinedTableIds as string[]) || []

    // Clear secondary tables
    await db.table.updateMany({
      where: { id: { in: combinedIds } },
      data: {
        combinedWithId: null,
      },
    })

    // Clear primary table
    await db.table.update({
      where: { id: tableId },
      data: {
        combinedTableIds: [],
      },
    })
  } else {
    // Virtual group
    const tables = await db.table.findMany({
      where: { virtualGroupId: groupId },
      select: { id: true },
    })

    // Clear virtual group fields from tables
    await db.table.updateMany({
      where: { id: { in: tables.map(t => t.id) } },
      data: {
        virtualGroupId: null,
        virtualGroupColor: null,
        virtualGroupPrimary: false,
        virtualGroupCreatedAt: null,
      },
    })

    // Soft delete the group
    await db.virtualGroup.update({
      where: { id: groupId },
      data: { deletedAt: new Date() },
    })
  }
}

/**
 * Add a table to an existing virtual group
 */
export async function addTableToGroup(
  groupId: string,
  tableId: string
): Promise<TableGroup> {
  if (groupId.startsWith('physical-')) {
    throw new Error('Cannot add tables to physical groups')
  }

  const group = await db.virtualGroup.findUnique({
    where: { id: groupId },
  })

  if (!group) {
    throw new Error('Group not found')
  }

  // Get existing color from other tables
  const existingTable = await db.table.findFirst({
    where: { virtualGroupId: groupId },
    select: { virtualGroupColor: true },
  })

  await db.table.update({
    where: { id: tableId },
    data: {
      virtualGroupId: groupId,
      virtualGroupColor: existingTable?.virtualGroupColor || 'blue',
      virtualGroupPrimary: false,
    },
  })

  // Update group name
  const tables = await db.table.findMany({
    where: { virtualGroupId: groupId },
    select: { name: true },
  })

  await db.virtualGroup.update({
    where: { id: groupId },
    data: {
      name: tables.map(t => t.name).join('+'),
    },
  })

  return getGroupById(groupId) as Promise<TableGroup>
}

/**
 * Remove a table from a virtual group
 */
export async function removeTableFromGroup(
  groupId: string,
  tableId: string
): Promise<TableGroup | null> {
  if (groupId.startsWith('physical-')) {
    throw new Error('Use dissolveGroup for physical groups')
  }

  const tables = await db.table.findMany({
    where: { virtualGroupId: groupId },
    select: { id: true },
  })

  // If only 2 tables, dissolve the group
  if (tables.length <= 2) {
    await dissolveGroup(groupId)
    return null
  }

  // Clear the table's group fields
  await db.table.update({
    where: { id: tableId },
    data: {
      virtualGroupId: null,
      virtualGroupColor: null,
      virtualGroupPrimary: false,
    },
  })

  // Update group name
  const remainingTables = await db.table.findMany({
    where: { virtualGroupId: groupId },
    select: { name: true },
  })

  await db.virtualGroup.update({
    where: { id: groupId },
    data: {
      name: remainingTables.map(t => t.name).join('+'),
    },
  })

  return getGroupById(groupId)
}

/**
 * Get the next available color for a new group
 */
async function getNextAvailableColor(locationId: string): Promise<GroupColor> {
  const tables = await db.table.findMany({
    where: {
      locationId,
      virtualGroupId: { not: null },
      virtualGroupColor: { not: null },
      deletedAt: null,
    },
    select: { virtualGroupColor: true },
    distinct: ['virtualGroupColor'],
  })

  const usedColors = new Set(tables.map(t => t.virtualGroupColor))

  for (const color of GROUP_COLORS) {
    if (!usedColors.has(color)) {
      return color
    }
  }

  // If all colors used, cycle back to first
  return GROUP_COLORS[0]
}



################################################################################
# FILE: src/domains/floor-plan/services/index.ts
################################################################################

/**
 * Floor Plan Services Index
 *
 * Export all services from the Floor Plan domain.
 */

// L2: Tables & Smart Objects
export * from './table-service'

// L3: Seats
export * from './seat-service'

// L4: Table Groups
export * from './group-service'

// L7: Status Engine
export * from './status-engine'

// L8: Entertainment (will be added)
// export * from './entertainment-service'

// L9: Waitlist (will be added)
// export * from './waitlist-service'



################################################################################
# FILE: src/domains/floor-plan/services/seat-service.ts
################################################################################

/**
 * Seat Service - L3 Seats
 *
 * Provides seat management operations for the Floor Plan domain.
 * Handles auto-positioning, status tracking, and seat assignment.
 */

import { db } from '@/shared'
import type { Seat, SeatPosition } from '../types'

// Re-export existing seat utilities
export {
  calculateSeatBalance,
  determineSeatStatus,
  SEAT_STATUS_COLORS,
  SEAT_STATUS_BG_COLORS,
  SEAT_STATUS_GLOW,
} from '@/lib/seat-utils'

export type { SeatStatus, SeatInfo, OrderItemForSeat, PaymentForSeat } from '@/lib/seat-utils'

/**
 * Get all seats for a table
 */
export async function getSeatsForTable(tableId: string): Promise<Seat[]> {
  const seats = await db.seat.findMany({
    where: {
      tableId,
      deletedAt: null,
    },
    orderBy: { seatNumber: 'asc' },
  })

  return seats.map(mapPrismaSeatToDomain)
}

/**
 * Get a single seat by ID
 */
export async function getSeatById(seatId: string): Promise<Seat | null> {
  const seat = await db.seat.findUnique({
    where: { id: seatId },
  })

  if (!seat) return null
  return mapPrismaSeatToDomain(seat)
}

/**
 * Auto-generate seats for a table based on shape and capacity
 */
export async function autoGenerateSeats(
  tableId: string,
  capacity: number,
  shape: string
): Promise<Seat[]> {
  // Get table to find locationId
  const table = await db.table.findUnique({
    where: { id: tableId },
    select: { locationId: true },
  })

  if (!table) {
    throw new Error('Table not found')
  }

  // Delete existing seats
  await db.seat.updateMany({
    where: { tableId },
    data: { deletedAt: new Date() },
  })

  // Generate new seats based on shape
  const positions = calculateSeatPositions(capacity, shape)

  const seats = await Promise.all(
    positions.map((pos, index) =>
      db.seat.create({
        data: {
          locationId: table.locationId,
          tableId,
          seatNumber: index + 1,
          label: `${index + 1}`,
          relativeX: Math.round(pos.x * 100), // Convert to int pixels
          relativeY: Math.round(pos.y * 100),
          angle: Math.round(pos.angle),
          seatType: 'standard',
        },
      })
    )
  )

  return seats.map(mapPrismaSeatToDomain)
}

/**
 * Add a virtual seat (server-added during service)
 */
export async function addVirtualSeat(
  tableId: string,
  position: SeatPosition
): Promise<Seat> {
  // Get table to find locationId
  const table = await db.table.findUnique({
    where: { id: tableId },
    select: { locationId: true },
  })

  if (!table) {
    throw new Error('Table not found')
  }

  // Get next seat number
  const maxSeat = await db.seat.findFirst({
    where: { tableId, deletedAt: null },
    orderBy: { seatNumber: 'desc' },
  })

  const nextNumber = (maxSeat?.seatNumber || 0) + 1

  const seat = await db.seat.create({
    data: {
      locationId: table.locationId,
      tableId,
      seatNumber: nextNumber,
      label: `V${nextNumber}`,
      relativeX: Math.round(position.x * 100), // Convert to int pixels
      relativeY: Math.round(position.y * 100),
      angle: Math.round(position.angle),
      seatType: 'virtual',
    },
  })

  return mapPrismaSeatToDomain(seat)
}

/**
 * Update seat occupancy
 */
export async function updateSeatOccupancy(
  seatId: string,
  isOccupied: boolean,
  guestId?: string
): Promise<Seat> {
  const seat = await db.seat.update({
    where: { id: seatId },
    data: {
      // Note: These fields may need to be added to the schema
      // isOccupied,
      // guestId,
    },
  })

  return mapPrismaSeatToDomain(seat)
}

/**
 * Calculate seat positions based on shape
 */
function calculateSeatPositions(
  capacity: number,
  shape: string
): Array<{ x: number; y: number; angle: number }> {
  const positions: Array<{ x: number; y: number; angle: number }> = []

  switch (shape) {
    case 'circle':
    case 'round':
      // Distribute evenly around circle
      for (let i = 0; i < capacity; i++) {
        const angle = (i / capacity) * 360
        const radians = (angle * Math.PI) / 180
        positions.push({
          x: Math.cos(radians) * 0.6, // 60% from center
          y: Math.sin(radians) * 0.6,
          angle,
        })
      }
      break

    case 'booth':
      // Seats only on interior
      for (let i = 0; i < capacity; i++) {
        positions.push({
          x: 0.2 + (i / Math.max(1, capacity - 1)) * 0.6,
          y: 0.3,
          angle: 180,
        })
      }
      break

    case 'bar':
    case 'bar_seat':
      // Seats on one side only
      for (let i = 0; i < capacity; i++) {
        positions.push({
          x: 0.1 + (i / Math.max(1, capacity - 1)) * 0.8,
          y: -0.3,
          angle: 0,
        })
      }
      break

    default:
      // Rectangle/square - distribute around perimeter
      const sides = {
        top: Math.ceil(capacity / 4),
        right: Math.ceil(capacity / 4),
        bottom: Math.ceil(capacity / 4),
        left: capacity - Math.ceil(capacity / 4) * 3,
      }

      let seatIndex = 0

      // Top side
      for (let i = 0; i < sides.top && seatIndex < capacity; i++) {
        positions.push({
          x: 0.1 + (i / Math.max(1, sides.top - 1)) * 0.8,
          y: -0.4,
          angle: 0,
        })
        seatIndex++
      }

      // Right side
      for (let i = 0; i < sides.right && seatIndex < capacity; i++) {
        positions.push({
          x: 1.1,
          y: 0.1 + (i / Math.max(1, sides.right - 1)) * 0.8,
          angle: 90,
        })
        seatIndex++
      }

      // Bottom side
      for (let i = 0; i < sides.bottom && seatIndex < capacity; i++) {
        positions.push({
          x: 0.9 - (i / Math.max(1, sides.bottom - 1)) * 0.8,
          y: 1.1,
          angle: 180,
        })
        seatIndex++
      }

      // Left side
      for (let i = 0; i < sides.left && seatIndex < capacity; i++) {
        positions.push({
          x: -0.1,
          y: 0.9 - (i / Math.max(1, sides.left - 1)) * 0.8,
          angle: 270,
        })
        seatIndex++
      }
      break
  }

  return positions
}

/**
 * Map Prisma seat to domain Seat type
 */
function mapPrismaSeatToDomain(prismaSeat: any): Seat {
  return {
    id: prismaSeat.id,
    tableId: prismaSeat.tableId,
    number: prismaSeat.seatNumber,
    position: {
      angle: prismaSeat.angle || 0,
      distance: 0.5, // Default distance
      x: prismaSeat.relativeX || 0,
      y: prismaSeat.relativeY || 0,
    },
    isVirtual: prismaSeat.seatType === 'virtual',
    isOccupied: false, // Would come from order data via bridge
    guestId: undefined,
    orderId: undefined,
  }
}



################################################################################
# FILE: src/domains/floor-plan/services/status-engine.ts
################################################################################

/**
 * Status Engine - L7 Status State Machine
 *
 * Manages the 15-status state machine for tables.
 * Handles automatic transitions based on events.
 */

import type { TableStatus, StatusTransition, StatusTrigger } from '../types'
import { TABLE_STATUSES } from '../index'

/**
 * Valid status transitions
 */
const STATUS_TRANSITIONS: StatusTransition[] = [
  // Available -> Seating (guest arrival)
  { from: 'available', to: 'seating', trigger: 'guest_seated', automatic: false },
  { from: 'available', to: 'reserved', trigger: 'manual', automatic: false },

  // Seating -> Occupied (seated)
  { from: 'seating', to: 'occupied', trigger: 'guest_seated', automatic: true, timeoutMinutes: 2 },

  // Occupied -> Ordering
  { from: 'occupied', to: 'ordering', trigger: 'order_created', automatic: true },

  // Ordering -> Food Pending (order sent)
  { from: 'ordering', to: 'food_pending', trigger: 'order_sent', automatic: true },

  // Food Pending -> Food Served
  { from: 'food_pending', to: 'food_served', trigger: 'food_delivered', automatic: true },

  // Food Served -> Dessert (optional)
  { from: 'food_served', to: 'dessert', trigger: 'manual', automatic: false },

  // Any dining state -> Check Requested
  { from: 'occupied', to: 'check_requested', trigger: 'check_requested', automatic: false },
  { from: 'ordering', to: 'check_requested', trigger: 'check_requested', automatic: false },
  { from: 'food_pending', to: 'check_requested', trigger: 'check_requested', automatic: false },
  { from: 'food_served', to: 'check_requested', trigger: 'check_requested', automatic: false },
  { from: 'dessert', to: 'check_requested', trigger: 'check_requested', automatic: false },

  // Check Requested -> Check Dropped
  { from: 'check_requested', to: 'check_dropped', trigger: 'check_printed', automatic: true },

  // Check Dropped -> Paid
  { from: 'check_dropped', to: 'paid', trigger: 'payment_complete', automatic: true },

  // Paid -> Dirty
  { from: 'paid', to: 'dirty', trigger: 'manual', automatic: false, timeoutMinutes: 5 },

  // Dirty -> Bussing
  { from: 'dirty', to: 'bussing', trigger: 'manual', automatic: false },

  // Bussing -> Available
  { from: 'bussing', to: 'available', trigger: 'table_cleared', automatic: true },
  { from: 'dirty', to: 'available', trigger: 'table_cleared', automatic: true },

  // Reserved -> Seating (party arrives)
  { from: 'reserved', to: 'seating', trigger: 'guest_seated', automatic: false },

  // Blocked can go to available
  { from: 'blocked', to: 'available', trigger: 'manual', automatic: false },
]

/**
 * Check if a status transition is valid
 */
export function isValidTransition(from: TableStatus, to: TableStatus): boolean {
  return STATUS_TRANSITIONS.some(t => t.from === from && t.to === to)
}

/**
 * Get all valid next statuses from current status
 */
export function getValidNextStatuses(current: TableStatus): TableStatus[] {
  const transitions = STATUS_TRANSITIONS.filter(t => t.from === current)
  return [...new Set(transitions.map(t => t.to))]
}

/**
 * Get the expected next status for a trigger
 */
export function getNextStatusForTrigger(
  current: TableStatus,
  trigger: StatusTrigger
): TableStatus | null {
  const transition = STATUS_TRANSITIONS.find(
    t => t.from === current && t.trigger === trigger
  )
  return transition?.to || null
}

/**
 * Check if a transition should happen automatically
 */
export function isAutomaticTransition(from: TableStatus, to: TableStatus): boolean {
  const transition = STATUS_TRANSITIONS.find(t => t.from === from && t.to === to)
  return transition?.automatic || false
}

/**
 * Get timeout for automatic transition (if any)
 */
export function getTransitionTimeout(from: TableStatus, to: TableStatus): number | null {
  const transition = STATUS_TRANSITIONS.find(t => t.from === from && t.to === to)
  return transition?.timeoutMinutes || null
}

/**
 * Get status display info (color, label)
 */
export function getStatusDisplay(status: TableStatus): {
  label: string
  color: string
  bgColor: string
  textColor: string
} {
  const statusDisplays: Record<TableStatus, {
    label: string
    color: string
    bgColor: string
    textColor: string
  }> = {
    available: {
      label: 'Available',
      color: '#22c55e',
      bgColor: 'bg-green-500',
      textColor: 'text-white',
    },
    seating: {
      label: 'Seating',
      color: '#eab308',
      bgColor: 'bg-yellow-500',
      textColor: 'text-black',
    },
    occupied: {
      label: 'Occupied',
      color: '#3b82f6',
      bgColor: 'bg-blue-500',
      textColor: 'text-white',
    },
    ordering: {
      label: 'Ordering',
      color: '#8b5cf6',
      bgColor: 'bg-violet-500',
      textColor: 'text-white',
    },
    food_pending: {
      label: 'Food Pending',
      color: '#f97316',
      bgColor: 'bg-orange-500',
      textColor: 'text-white',
    },
    food_served: {
      label: 'Food Served',
      color: '#06b6d4',
      bgColor: 'bg-cyan-500',
      textColor: 'text-white',
    },
    dessert: {
      label: 'Dessert',
      color: '#ec4899',
      bgColor: 'bg-pink-500',
      textColor: 'text-white',
    },
    check_requested: {
      label: 'Check Requested',
      color: '#f59e0b',
      bgColor: 'bg-amber-500',
      textColor: 'text-black',
    },
    check_dropped: {
      label: 'Check Dropped',
      color: '#84cc16',
      bgColor: 'bg-lime-500',
      textColor: 'text-black',
    },
    paid: {
      label: 'Paid',
      color: '#10b981',
      bgColor: 'bg-emerald-500',
      textColor: 'text-white',
    },
    dirty: {
      label: 'Dirty',
      color: '#ef4444',
      bgColor: 'bg-red-500',
      textColor: 'text-white',
    },
    bussing: {
      label: 'Bussing',
      color: '#f97316',
      bgColor: 'bg-orange-500',
      textColor: 'text-white',
    },
    reserved: {
      label: 'Reserved',
      color: '#a855f7',
      bgColor: 'bg-purple-500',
      textColor: 'text-white',
    },
    blocked: {
      label: 'Blocked',
      color: '#6b7280',
      bgColor: 'bg-gray-500',
      textColor: 'text-white',
    },
    combined: {
      label: 'Combined',
      color: '#14b8a6',
      bgColor: 'bg-teal-500',
      textColor: 'text-white',
    },
  }

  return statusDisplays[status] || statusDisplays.available
}

/**
 * Check if a table is in a "dining" state (occupied with guests)
 */
export function isDiningState(status: TableStatus): boolean {
  const diningStates: TableStatus[] = [
    'occupied',
    'ordering',
    'food_pending',
    'food_served',
    'dessert',
    'check_requested',
    'check_dropped',
  ]
  return diningStates.includes(status)
}

/**
 * Check if a table can accept new guests
 */
export function canSeatGuests(status: TableStatus): boolean {
  return status === 'available' || status === 'reserved'
}

/**
 * Check if a table needs attention (for alerts)
 */
export function needsAttention(status: TableStatus): boolean {
  return status === 'check_requested' || status === 'dirty'
}



################################################################################
# FILE: src/domains/floor-plan/services/table-service.ts
################################################################################

/**
 * Table Service - L2 Tables & Smart Objects
 *
 * Provides table management operations for the Floor Plan domain.
 * Wraps existing utilities and provides a clean domain API.
 */

import { db } from '@/shared'
import type { Table, TableShape, TableStatus } from '../types'

// Re-export existing utilities for internal use
export {
  toTableRect,
  toTableRectArray,
  getPrimaryTableId,
  getPrimaryTable,
  isPhysicalGroup,
  isVirtualGroup,
  isPrimaryTable,
} from '@/lib/table-utils'

/**
 * Get all tables for a location
 */
export async function getTablesForLocation(locationId: string): Promise<Table[]> {
  const tables = await db.table.findMany({
    where: {
      locationId,
      deletedAt: null,
    },
    include: {
      section: true,
      seats: {
        where: { deletedAt: null },
      },
    },
    orderBy: [
      { name: 'asc' },
    ],
  })

  return tables.map(mapPrismaTableToDomain)
}

/**
 * Get a single table by ID
 */
export async function getTableById(tableId: string): Promise<Table | null> {
  const table = await db.table.findUnique({
    where: { id: tableId },
    include: {
      section: true,
      seats: {
        where: { deletedAt: null },
      },
    },
  })

  if (!table) return null
  return mapPrismaTableToDomain(table)
}

/**
 * Get tables for a specific section
 */
export async function getTablesForSection(sectionId: string): Promise<Table[]> {
  const tables = await db.table.findMany({
    where: {
      sectionId,
      deletedAt: null,
    },
    include: {
      section: true,
      seats: {
        where: { deletedAt: null },
      },
    },
    orderBy: { name: 'asc' },
  })

  return tables.map(mapPrismaTableToDomain)
}

/**
 * Update table position
 */
export async function updateTablePosition(
  tableId: string,
  posX: number,
  posY: number
): Promise<Table> {
  const table = await db.table.update({
    where: { id: tableId },
    data: { posX, posY },
    include: {
      section: true,
      seats: {
        where: { deletedAt: null },
      },
    },
  })

  return mapPrismaTableToDomain(table)
}

/**
 * Update table status
 */
export async function updateTableStatus(
  tableId: string,
  status: TableStatus
): Promise<Table> {
  const table = await db.table.update({
    where: { id: tableId },
    data: { status },
    include: {
      section: true,
      seats: {
        where: { deletedAt: null },
      },
    },
  })

  return mapPrismaTableToDomain(table)
}

/**
 * Map Prisma table to domain Table type
 */
function mapPrismaTableToDomain(prismaTable: any): Table {
  return {
    id: prismaTable.id,
    sectionId: prismaTable.sectionId,
    name: prismaTable.name,
    number: parseInt(prismaTable.name?.replace(/\D/g, '') || '0', 10),
    shape: mapShape(prismaTable.shape),
    x: prismaTable.posX,
    y: prismaTable.posY,
    width: prismaTable.width,
    height: prismaTable.height,
    rotation: prismaTable.rotation || 0,
    capacity: prismaTable.capacity,
    minCapacity: 1,
    status: prismaTable.status as TableStatus,
    isActive: prismaTable.isActive ?? true,
    isEntertainment: prismaTable.isTimedRental ?? false,
    entertainmentType: prismaTable.timedItemId ? 'timed' : undefined,
  }
}

/**
 * Map database shape to domain TableShape
 */
function mapShape(dbShape: string): TableShape {
  const shapeMap: Record<string, TableShape> = {
    'rectangle': 'rectangle',
    'circle': 'round',
    'square': 'square',
    'booth': 'booth',
    'bar': 'bar_seat',
    'oval': 'oval',
    'high_top': 'high_top',
  }
  return shapeMap[dbShape] || 'rectangle'
}



################################################################################
# FILE: src/domains/floor-plan/shared/collisionDetection.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Collision Detection Module
 *
 * Pure collision detection functions for table placement validation.
 * Prevents tables from overlapping with fixtures (walls, bar counters, etc.)
 *
 * Coordinate System: All positions are in FEET
 * Tables use center-based positioning (x, y is center point)
 * Walls use geometry with start/end points
 * Other fixtures use posX/posY with width/height
 */

import type { Point } from './types'

// =============================================================================
// TYPE DEFINITIONS
// =============================================================================

/**
 * Table bounding box
 */
export interface TableBounds {
  x: number // Center X in feet
  y: number // Center Y in feet
  width: number // Width in feet
  height: number // Height in feet
  rotation?: number // Degrees (optional, for rotated tables)
}

/**
 * Fixture bounds (from FloorPlanElement)
 */
export interface FixtureBounds {
  id: string
  type: 'wall' | 'rectangle' | 'circle'
  visualType: string
  // For rectangles
  x?: number
  y?: number
  width?: number
  height?: number
  // For circles (pillars, planters)
  centerX?: number
  centerY?: number
  radius?: number
  // For walls (lines)
  geometry?: {
    start: { x: number; y: number }
    end: { x: number; y: number }
  }
  thickness?: number
}

/**
 * Collision result
 */
export interface CollisionResult {
  collides: boolean
  collidingFixtures: string[] // IDs of fixtures that collide
  suggestedPosition?: { x: number; y: number } // Optional snap position
}

// =============================================================================
// COLLISION DETECTION ALGORITHMS
// =============================================================================

/**
 * Rectangle-Rectangle collision (AABB - Axis-Aligned Bounding Box)
 * Used for tables vs bar counters, kitchens, stages, etc.
 */
export function rectRectCollision(
  rect1: { x: number; y: number; width: number; height: number },
  rect2: { x: number; y: number; width: number; height: number }
): boolean {
  // Convert center-based coords to corner-based for easier math
  const r1Left = rect1.x - rect1.width / 2
  const r1Right = rect1.x + rect1.width / 2
  const r1Top = rect1.y - rect1.height / 2
  const r1Bottom = rect1.y + rect1.height / 2

  const r2Left = rect2.x - rect2.width / 2
  const r2Right = rect2.x + rect2.width / 2
  const r2Top = rect2.y - rect2.height / 2
  const r2Bottom = rect2.y + rect2.height / 2

  // Check if rectangles overlap
  return !(
    r1Right < r2Left ||
    r1Left > r2Right ||
    r1Bottom < r2Top ||
    r1Top > r2Bottom
  )
}

/**
 * Circle-Rectangle collision
 * Used for tables vs circular pillars, planters
 */
export function circleRectCollision(
  circle: { x: number; y: number; radius: number },
  rect: { x: number; y: number; width: number; height: number }
): boolean {
  // Find closest point on rectangle to circle center
  const rectLeft = rect.x - rect.width / 2
  const rectRight = rect.x + rect.width / 2
  const rectTop = rect.y - rect.height / 2
  const rectBottom = rect.y + rect.height / 2

  const closestX = Math.max(rectLeft, Math.min(circle.x, rectRight))
  const closestY = Math.max(rectTop, Math.min(circle.y, rectBottom))

  // Calculate distance from circle center to closest point
  const distX = circle.x - closestX
  const distY = circle.y - closestY
  const distSquared = distX * distX + distY * distY

  return distSquared < circle.radius * circle.radius
}

/**
 * Line-Rectangle collision (for walls)
 * Treats wall as a thick line (capsule shape)
 */
export function lineRectCollision(
  line: { start: Point; end: Point; thickness: number },
  rect: { x: number; y: number; width: number; height: number }
): boolean {
  const { start, end, thickness } = line
  const halfThickness = thickness / 2

  // Convert rect to corners
  const rectLeft = rect.x - rect.width / 2
  const rectRight = rect.x + rect.width / 2
  const rectTop = rect.y - rect.height / 2
  const rectBottom = rect.y + rect.height / 2

  // Check if any corner of the rectangle is within thickness of the line segment
  const corners = [
    { x: rectLeft, y: rectTop },
    { x: rectRight, y: rectTop },
    { x: rectLeft, y: rectBottom },
    { x: rectRight, y: rectBottom },
  ]

  for (const corner of corners) {
    const dist = pointToLineDistance(corner, start, end)
    if (dist < halfThickness) return true
  }

  // Also check if line segment intersects the rectangle
  // (covers case where line passes through but corners are outside)
  if (lineSegmentIntersectsRect(start, end, rectLeft, rectRight, rectTop, rectBottom)) {
    return true
  }

  return false
}

/**
 * Calculate distance from a point to a line segment
 */
function pointToLineDistance(point: Point, lineStart: Point, lineEnd: Point): number {
  const { x: px, y: py } = point
  const { x: x1, y: y1 } = lineStart
  const { x: x2, y: y2 } = lineEnd

  // Vector from line start to end
  const dx = x2 - x1
  const dy = y2 - y1

  // If line is actually a point
  if (dx === 0 && dy === 0) {
    return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1))
  }

  // Calculate projection parameter t (0 = start, 1 = end, clamped to segment)
  const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)))

  // Find closest point on line segment
  const closestX = x1 + t * dx
  const closestY = y1 + t * dy

  // Return distance
  return Math.sqrt((px - closestX) * (px - closestX) + (py - closestY) * (py - closestY))
}

/**
 * Check if a line segment intersects a rectangle
 */
function lineSegmentIntersectsRect(
  start: Point,
  end: Point,
  left: number,
  right: number,
  top: number,
  bottom: number
): boolean {
  // Check if line segment intersects any of the four rectangle edges
  const edges = [
    { p1: { x: left, y: top }, p2: { x: right, y: top } }, // Top edge
    { p1: { x: right, y: top }, p2: { x: right, y: bottom } }, // Right edge
    { p1: { x: left, y: bottom }, p2: { x: right, y: bottom } }, // Bottom edge
    { p1: { x: left, y: top }, p2: { x: left, y: bottom } }, // Left edge
  ]

  for (const edge of edges) {
    if (lineSegmentsIntersect(start, end, edge.p1, edge.p2)) {
      return true
    }
  }

  // Also check if either endpoint is inside the rectangle
  if (
    (start.x >= left && start.x <= right && start.y >= top && start.y <= bottom) ||
    (end.x >= left && end.x <= right && end.y >= top && end.y <= bottom)
  ) {
    return true
  }

  return false
}

/**
 * Check if two line segments intersect
 */
function lineSegmentsIntersect(p1: Point, p2: Point, p3: Point, p4: Point): boolean {
  const ccw = (a: Point, b: Point, c: Point) => {
    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x)
  }

  return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4)
}

// =============================================================================
// HIGH-LEVEL COLLISION CHECKING
// =============================================================================

/**
 * Check if a table collides with a single fixture
 */
export function checkTableFixtureCollision(
  table: TableBounds,
  fixture: FixtureBounds
): boolean {
  // Route to correct collision algorithm based on fixture type
  switch (fixture.type) {
    case 'rectangle':
      if (fixture.x !== undefined && fixture.y !== undefined && fixture.width && fixture.height) {
        return rectRectCollision(table, {
          x: fixture.x,
          y: fixture.y,
          width: fixture.width,
          height: fixture.height,
        })
      }
      break

    case 'circle':
      if (fixture.centerX !== undefined && fixture.centerY !== undefined && fixture.radius) {
        return circleRectCollision(
          {
            x: fixture.centerX,
            y: fixture.centerY,
            radius: fixture.radius,
          },
          table
        )
      }
      break

    case 'wall':
      if (fixture.geometry?.start && fixture.geometry?.end) {
        return lineRectCollision(
          {
            start: fixture.geometry.start,
            end: fixture.geometry.end,
            thickness: fixture.thickness || 0.5,
          },
          table
        )
      }
      break

    default:
      console.warn(`Unknown fixture type: ${fixture.type}`)
  }

  return false
}

/**
 * Check if a table collides with ANY fixture in an array
 * Returns collision result with list of colliding fixture IDs
 */
export function checkTableAllFixturesCollision(
  table: TableBounds,
  fixtures: FixtureBounds[]
): CollisionResult {
  const collidingFixtures: string[] = []

  for (const fixture of fixtures) {
    if (checkTableFixtureCollision(table, fixture)) {
      collidingFixtures.push(fixture.id)
    }
  }

  return {
    collides: collidingFixtures.length > 0,
    collidingFixtures,
  }
}

/**
 * Find nearest valid position for a table (optional snap feature)
 * This is a simplified implementation - could be enhanced with grid search
 */
export function findNearestValidPosition(
  table: TableBounds,
  fixtures: FixtureBounds[],
  maxSearchRadius: number = 5 // feet
): { x: number; y: number } | null {
  // Try positions in a spiral pattern outward from current position
  const step = 0.5 // feet
  const maxSteps = Math.floor(maxSearchRadius / step)

  for (let radius = 1; radius <= maxSteps; radius++) {
    const testPositions = [
      { x: table.x + radius * step, y: table.y }, // Right
      { x: table.x - radius * step, y: table.y }, // Left
      { x: table.x, y: table.y + radius * step }, // Down
      { x: table.x, y: table.y - radius * step }, // Up
      { x: table.x + radius * step, y: table.y + radius * step }, // Bottom-right
      { x: table.x - radius * step, y: table.y + radius * step }, // Bottom-left
      { x: table.x + radius * step, y: table.y - radius * step }, // Top-right
      { x: table.x - radius * step, y: table.y - radius * step }, // Top-left
    ]

    for (const pos of testPositions) {
      const testTable = { ...table, x: pos.x, y: pos.y }
      const result = checkTableAllFixturesCollision(testTable, fixtures)
      if (!result.collides) {
        return pos
      }
    }
  }

  return null
}

// =============================================================================
// EXPORT DEFAULT
// =============================================================================

export default {
  rectRectCollision,
  circleRectCollision,
  lineRectCollision,
  checkTableFixtureCollision,
  checkTableAllFixturesCollision,
  findNearestValidPosition,
}



################################################################################
# FILE: src/domains/floor-plan/shared/types.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Shared Types
 *
 * These types are used across all layers of the Floor Plan domain.
 * Do not modify without Domain PM approval.
 */

// Re-export collision detection types and functions
export * from './collisionDetection'

// =============================================================================
// COORDINATE SYSTEM
// =============================================================================

export interface Point {
  x: number; // feet from top-left
  y: number;
}

export interface Dimensions {
  width: number; // feet
  height: number;
}

// =============================================================================
// LAYER 1: FLOOR CANVAS
// =============================================================================

export type RoomType = 'indoor' | 'outdoor' | 'bar' | 'private' | 'patio';

export interface FloorPlan {
  id: string;
  locationId: string;
  name: string;
  type: RoomType;
  widthFeet: number;
  heightFeet: number;
  gridSizeFeet: number; // Snap grid (e.g., 0.5 = 6 inch grid)
  isActive: boolean;
  sortOrder: number;
}

export type FixtureType =
  | 'wall'
  | 'half_wall'
  | 'pillar'
  | 'bar_counter'
  | 'service_counter'
  | 'window'
  | 'door'
  | 'railing'
  | 'stairs'
  | 'stage_platform'
  | 'dance_floor'
  | 'kitchen_boundary'
  | 'restroom'
  | 'fire_exit'
  | 'ada_path'
  | 'planter_builtin'
  | 'custom_fixture';

export type FixtureCategory =
  | 'barrier' // Blocks placement AND movement (walls, pillars)
  | 'surface' // Objects can snap to it (bar counter)
  | 'zone' // Defines area, doesn't block (dance floor)
  | 'passage' // Allows movement (doors, stairs)
  | 'clearance' // Must stay clear (fire exit, ADA path)
  | 'decorative'; // Visual only

export type FixtureGeometry =
  | { type: 'line'; start: Point; end: Point }
  | {
      type: 'rectangle';
      position: Point;
      width: number;
      height: number;
      rotation: number;
    }
  | { type: 'circle'; center: Point; radius: number }
  | { type: 'polygon'; points: Point[] }
  | {
      type: 'arc';
      center: Point;
      radius: number;
      startAngle: number;
      endAngle: number;
    };

export interface Fixture {
  id: string;
  floorPlanId: string;
  roomId: string;
  type: FixtureType;
  category: FixtureCategory;
  label: string;
  geometry: FixtureGeometry;
  color: string;
  opacity: number;
  thickness: number; // Wall thickness in feet
  height: 'full' | 'half' | 'counter' | null;
  blocksPlacement: boolean;
  blocksMovement: boolean;
  snapTarget: boolean; // Can objects snap TO this?
  isActive: boolean;
}

// =============================================================================
// LAYER 2: TABLES & OBJECTS
// =============================================================================

export type ObjectType =
  // Seatable (dining)
  | 'dining_table'
  | 'booth'
  | 'bar_stool'
  | 'bar_rail'
  | 'high_top'
  | 'communal_table'
  // Entertainment
  | 'pool_table'
  | 'dart_board'
  | 'karaoke'
  | 'shuffleboard'
  | 'arcade'
  | 'bowling_lane'
  | 'cornhole'
  // Non-interactive
  | 'portable_planter'
  | 'portable_divider'
  | 'host_stand'
  | 'wait_station'
  | 'pos_terminal'
  | 'dj_booth'
  | 'coat_check'
  | 'high_chair_storage';

export type ObjectCategory = 'seatable' | 'entertainment' | 'decorative' | 'service';

export type TableShape = 'square' | 'rectangle' | 'round' | 'oval' | 'hexagon' | 'custom';

export interface EntertainmentConfig {
  hourlyRate: number;
  minimumMinutes: number;
  overtimeMultiplier: number;
  requiresDeposit: boolean;
  depositAmount: number;
}

export interface Table {
  id: string;
  locationId: string;
  floorPlanId: string;
  sectionId: string | null;

  // Identity
  label: string;
  objectType: ObjectType;
  category: ObjectCategory;
  shape: TableShape;

  // Position & size (in feet)
  positionX: number;
  positionY: number;
  width: number;
  height: number;
  rotation: number; // degrees

  // Capacity
  minCapacity: number;
  maxCapacity: number;
  defaultCapacity: number;

  // State
  isActive: boolean;
  isReservable: boolean;
  sortOrder: number;

  // Group membership
  groupId: string | null;
  combinedTableIds: string[]; // If merged

  // Visual
  color: string | null; // Override color (from groups/status)

  // Entertainment-specific
  entertainmentConfig: EntertainmentConfig | null;
}

// =============================================================================
// LAYER 3: SEATS
// =============================================================================

export interface Seat {
  id: string;
  tableId: string;
  locationId: string;

  seatNumber: number; // Display number (1, 2, 3...)
  positionIndex: number; // Position around table (0-N)

  // Position relative to table center
  offsetX: number; // feet from table center
  offsetY: number;
  angle: number; // degrees from table center

  // State
  isOccupied: boolean;
  isVirtual: boolean; // Added during service, removed on close
  orderId: string | null; // Future: per-seat ticketing
  guestName: string | null;

  isActive: boolean;
}

// =============================================================================
// LAYER 4: TABLE GROUPS
// =============================================================================

export interface TableGroup {
  id: string;
  locationId: string;

  tableIds: string[];
  primaryTableId: string; // The "anchor" table

  isVirtual: boolean; // Virtual = cross-room, no movement

  // Visual
  color: string;
  identifier: string; // "Smith-8PM", "Party of 12"

  // Capacity
  combinedCapacity: number;

  // State
  isActive: boolean;
  createdAt: Date;
  createdBy: string; // Staff ID
}

export const GROUP_COLOR_PALETTE = [
  '#E74C3C', // Red
  '#3498DB', // Blue
  '#2ECC71', // Green
  '#9B59B6', // Purple
  '#F39C12', // Orange
  '#1ABC9C', // Teal
  '#E91E63', // Pink
  '#00BCD4', // Cyan
] as const;

// =============================================================================
// LAYER 6: STAFF
// =============================================================================

export type StaffRole = 'hostess' | 'server' | 'bartender' | 'busser' | 'manager' | 'food_runner';

export interface StaffAssignment {
  id: string;
  staffId: string;
  staffName: string;
  role: StaffRole;
  sectionId: string | null;
  tableIds: string[];
  shiftStart: Date;
  shiftEnd: Date | null;
  isActive: boolean;
}

export interface Section {
  id: string;
  name: string;
  roomId: string;
  tableIds: string[];
  assignedStaffId: string | null;
  color: string;
  sortOrder: number;
  isActive: boolean;
}

// =============================================================================
// LAYER 7: TABLE STATUS
// =============================================================================

export type TableStatus =
  | 'available'
  | 'reserved'
  | 'seating'
  | 'seated'
  | 'occupied'
  | 'ordering'
  | 'food_pending'
  | 'food_served'
  | 'check_requested'
  | 'check_dropped'
  | 'paid'
  | 'dirty'
  | 'bussing'
  | 'blocked'
  | 'closed';

export const STATUS_COLORS: Record<TableStatus, string> = {
  available: '#FFFFFF',
  reserved: '#F0E6FF',
  seating: '#FFF9C4',
  seated: '#E3F2FD',
  occupied: '#E3F2FD',
  ordering: '#BBDEFB',
  food_pending: '#FFE0B2',
  food_served: '#C8E6C9',
  check_requested: '#FFCDD2',
  check_dropped: '#EF9A9A',
  paid: '#A5D6A7',
  dirty: '#D7CCC8',
  bussing: '#FFCC80',
  blocked: '#9E9E9E',
  closed: '#616161',
};

// Valid status transitions
export const STATUS_TRANSITIONS: Record<TableStatus, TableStatus[]> = {
  available: ['reserved', 'seating', 'blocked'],
  reserved: ['seating', 'available'],
  seating: ['seated', 'available'],
  seated: ['ordering', 'occupied'],
  occupied: ['ordering'],
  ordering: ['food_pending'],
  food_pending: ['food_served'],
  food_served: ['check_requested'],
  check_requested: ['check_dropped'],
  check_dropped: ['paid'],
  paid: ['dirty'],
  dirty: ['bussing'],
  bussing: ['available'],
  blocked: ['available'],
  closed: ['available'],
};

// =============================================================================
// LAYER 8: ENTERTAINMENT
// =============================================================================

export type EntertainmentStatus = 'available' | 'reserved' | 'in_use' | 'overtime' | 'maintenance' | 'closed';

export interface EntertainmentSession {
  id: string;
  objectId: string;
  guestName: string;
  guestCount: number;

  startedAt: Date;
  endedAt: Date | null;
  bookedMinutes: number;
  pausedAt: Date | null;
  totalPausedSeconds: number;

  linkedTableId: string | null;
  linkedTicketId: string | null;
  depositCollected: number;

  status: 'active' | 'paused' | 'overtime' | 'ended';
}

export interface EntertainmentPricing {
  objectId: string;
  baseRatePerHour: number;
  minimumMinutes: number;
  overtimeMultiplier: number;
  happyHourRate: number | null;
  happyHourStart: string | null;
  happyHourEnd: string | null;
}

// =============================================================================
// LAYER 9: WAITLIST
// =============================================================================

export type WaitlistStatus = 'waiting' | 'notified' | 'seated' | 'no_show' | 'cancelled' | 'expired';

export interface SeatingPreference {
  indoor: boolean;
  outdoor: boolean;
  bar: boolean;
  booth: boolean;
  highTop: boolean;
  accessible: boolean;
  quietArea: boolean;
  nearEntertainment: boolean;
  specificRoom: string | null;
  specificServer: string | null;
}

export interface WaitlistEntry {
  id: string;
  guestName: string;
  guestPhone: string | null;
  partySize: number;
  seatingPreference: SeatingPreference;

  addedAt: Date;
  estimatedWaitMinutes: number;
  quotedWaitMinutes: number;
  position: number;

  status: WaitlistStatus;

  notifiedAt: Date | null;
  seatedAt: Date | null;
  seatedTableId: string | null;

  notes: string;
  vipFlag: boolean;
  addedBy: string;
}

// =============================================================================
// ALERTS
// =============================================================================

export type AlertType =
  | 'long_wait' // Table has been in status too long
  | 'check_needed' // Guest waiting for check
  | 'busser_needed' // Table needs bussing
  | 'overtime' // Entertainment overtime
  | 'waitlist_ready' // Waitlist guest ready
  | 'reservation_arriving'; // Reservation arriving soon

export interface Alert {
  id: string;
  type: AlertType;
  tableId: string | null;
  message: string;
  createdAt: Date;
  acknowledgedAt: Date | null;
  acknowledgedBy: string | null;
}



################################################################################
# FILE: src/domains/floor-plan/tables/index.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 2: Tables & Smart Objects
 *
 * Public exports for the tables layer.
 */

export { Table } from './Table';
export { SmartObject } from './SmartObject';
export { TableAPI, default as tableAPI } from './tableAPI';

// Re-export types
export type {
  Table as TableType,
  ObjectType,
  ObjectCategory,
  TableShape,
  EntertainmentConfig,
  CreateTableInput,
  UpdateTableInput,
  TableDragState,
  TableSelectionState,
} from './types';



################################################################################
# FILE: src/domains/floor-plan/tables/SmartObject.tsx
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 2: Smart Object Component
 *
 * Renders non-dining objects like pool tables, dart boards, decorations, etc.
 */

'use client';

import React from 'react';
import type { Table as TableType, ObjectType } from '../shared/types';

interface SmartObjectProps {
  object: TableType;
  pixelsPerFoot: number;
  isSelected?: boolean;
  onSelect?: (objectId: string) => void;
  onDragStart?: (objectId: string, event: React.PointerEvent) => void;
}

/**
 * Get icon/visual representation for entertainment objects
 */
function getObjectIcon(objectType: ObjectType): string {
  switch (objectType) {
    case 'pool_table':
      return '';
    case 'dart_board':
      return '';
    case 'karaoke':
      return '';
    case 'shuffleboard':
      return '';
    case 'arcade':
      return '';
    case 'bowling_lane':
      return '';
    case 'cornhole':
      return '';
    case 'portable_planter':
      return '';
    case 'portable_divider':
      return '';
    case 'host_stand':
      return '';
    case 'wait_station':
      return '';
    case 'pos_terminal':
      return '';
    case 'dj_booth':
      return '';
    case 'coat_check':
      return '';
    case 'high_chair_storage':
      return '';
    default:
      return '';
  }
}

/**
 * Get background color based on object category
 */
function getObjectColor(category: string, customColor?: string | null): string {
  if (customColor) return customColor;

  switch (category) {
    case 'entertainment':
      return '#7C3AED'; // Purple
    case 'decorative':
      return '#10B981'; // Green
    case 'service':
      return '#F59E0B'; // Orange
    default:
      return '#6B7280'; // Gray
  }
}

/**
 * SmartObject Component
 * Renders entertainment, decorative, and service objects
 */
export function SmartObject({
  object,
  pixelsPerFoot,
  isSelected,
  onSelect,
  onDragStart,
}: SmartObjectProps) {
  const widthPx = object.width * pixelsPerFoot;
  const heightPx = object.height * pixelsPerFoot;
  const xPx = object.positionX * pixelsPerFoot;
  const yPx = object.positionY * pixelsPerFoot;

  const color = getObjectColor(object.category, object.color);
  const icon = getObjectIcon(object.objectType);

  const handlePointerDown = (e: React.PointerEvent) => {
    e.stopPropagation();
    if (onSelect) {
      onSelect(object.id);
    }
    if (onDragStart) {
      onDragStart(object.id, e);
    }
  };

  return (
    <g
      style={{
        transform: `translate(${xPx}px, ${yPx}px) rotate(${object.rotation}deg)`,
        transformOrigin: `${widthPx / 2}px ${heightPx / 2}px`,
        cursor: 'move',
      }}
      onPointerDown={handlePointerDown}
    >
      {/* Object shape (rounded rectangle) */}
      <rect
        x="0"
        y="0"
        width={widthPx}
        height={heightPx}
        rx="8"
        fill={color}
        stroke={isSelected ? '#3B82F6' : color}
        strokeWidth={isSelected ? '3' : '2'}
        opacity={isSelected ? 0.9 : 0.7}
        style={{
          filter: isSelected ? 'drop-shadow(0 0 8px rgba(59, 130, 246, 0.8))' : undefined,
        }}
      />

      {/* Icon */}
      <text
        x={widthPx / 2}
        y={heightPx / 2 - 10}
        textAnchor="middle"
        dominantBaseline="middle"
        fontSize="24"
        style={{ pointerEvents: 'none', userSelect: 'none' }}
      >
        {icon}
      </text>

      {/* Object label */}
      <text
        x={widthPx / 2}
        y={heightPx / 2 + 15}
        textAnchor="middle"
        dominantBaseline="middle"
        fill="white"
        fontSize="12"
        fontWeight="600"
        style={{ pointerEvents: 'none', userSelect: 'none' }}
      >
        {object.label}
      </text>

      {/* Entertainment config indicator (if applicable) */}
      {object.entertainmentConfig && (
        <g>
          <circle
            cx={widthPx - 12}
            cy="12"
            r="8"
            fill="rgba(255, 255, 255, 0.9)"
            stroke={color}
            strokeWidth="1.5"
          />
          <text
            x={widthPx - 12}
            y="12"
            textAnchor="middle"
            dominantBaseline="middle"
            fontSize="10"
            fontWeight="bold"
            fill={color}
            style={{ pointerEvents: 'none', userSelect: 'none' }}
          >
            $
          </text>
        </g>
      )}
    </g>
  );
}

export default SmartObject;



################################################################################
# FILE: src/domains/floor-plan/tables/Table.tsx
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 2: Table Component
 *
 * Renders a dining table object with correct shape (square, round, rectangle, etc.)
 */

'use client';

import React from 'react';
import type { Table as TableType, TableShape } from '../shared/types';

interface TableProps {
  table: TableType;
  pixelsPerFoot: number;
  isSelected?: boolean;
  onSelect?: (tableId: string) => void;
  onDragStart?: (tableId: string, event: React.PointerEvent) => void;
}

/**
 * Get the shape SVG path or element based on table shape
 */
function getShapePath(shape: TableShape, width: number, height: number): React.ReactElement {
  switch (shape) {
    case 'round':
      return (
        <ellipse
          cx={width / 2}
          cy={height / 2}
          rx={width / 2}
          ry={height / 2}
          fill="currentColor"
          stroke="currentColor"
          strokeWidth="2"
        />
      );

    case 'oval':
      return (
        <ellipse
          cx={width / 2}
          cy={height / 2}
          rx={width / 2}
          ry={height / 2}
          fill="currentColor"
          stroke="currentColor"
          strokeWidth="2"
        />
      );

    case 'hexagon': {
      const cx = width / 2;
      const cy = height / 2;
      const rx = width / 2;
      const ry = height / 2;
      const points = [
        [cx + rx * Math.cos(0), cy + ry * Math.sin(0)],
        [cx + rx * Math.cos(Math.PI / 3), cy + ry * Math.sin(Math.PI / 3)],
        [cx + rx * Math.cos((2 * Math.PI) / 3), cy + ry * Math.sin((2 * Math.PI) / 3)],
        [cx + rx * Math.cos(Math.PI), cy + ry * Math.sin(Math.PI)],
        [cx + rx * Math.cos((4 * Math.PI) / 3), cy + ry * Math.sin((4 * Math.PI) / 3)],
        [cx + rx * Math.cos((5 * Math.PI) / 3), cy + ry * Math.sin((5 * Math.PI) / 3)],
      ];
      const pathData = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p[0]},${p[1]}`).join(' ') + ' Z';
      return <path d={pathData} fill="currentColor" stroke="currentColor" strokeWidth="2" />;
    }

    case 'square':
    case 'rectangle':
    default:
      return (
        <rect
          x="0"
          y="0"
          width={width}
          height={height}
          rx="4"
          fill="currentColor"
          stroke="currentColor"
          strokeWidth="2"
        />
      );
  }
}

/**
 * Table Component
 * Renders a table with the specified shape, position, and rotation
 */
export function Table({ table, pixelsPerFoot, isSelected, onSelect, onDragStart }: TableProps) {
  const widthPx = table.width * pixelsPerFoot;
  const heightPx = table.height * pixelsPerFoot;
  const xPx = table.positionX * pixelsPerFoot;
  const yPx = table.positionY * pixelsPerFoot;

  // Determine color
  const color = table.color || '#8B7355'; // Default brown table color

  const handlePointerDown = (e: React.PointerEvent) => {
    e.stopPropagation();
    if (onSelect) {
      onSelect(table.id);
    }
    if (onDragStart) {
      onDragStart(table.id, e);
    }
  };

  return (
    <g
      style={{
        transform: `translate(${xPx}px, ${yPx}px) rotate(${table.rotation}deg)`,
        transformOrigin: `${widthPx / 2}px ${heightPx / 2}px`,
        cursor: 'move',
      }}
      onPointerDown={handlePointerDown}
    >
      {/* Table shape */}
      <g
        style={{
          color: color,
          opacity: isSelected ? 0.9 : 0.8,
          filter: isSelected ? 'drop-shadow(0 0 8px rgba(59, 130, 246, 0.8))' : undefined,
        }}
      >
        {getShapePath(table.shape, widthPx, heightPx)}
      </g>

      {/* Table label */}
      <text
        x={widthPx / 2}
        y={heightPx / 2}
        textAnchor="middle"
        dominantBaseline="middle"
        fill="white"
        fontSize="14"
        fontWeight="bold"
        style={{ pointerEvents: 'none', userSelect: 'none' }}
      >
        {table.label}
      </text>

      {/* Capacity indicator (small badge) */}
      {table.defaultCapacity > 0 && (
        <text
          x={widthPx - 8}
          y={heightPx - 8}
          textAnchor="end"
          dominantBaseline="auto"
          fill="white"
          fontSize="10"
          style={{ pointerEvents: 'none', userSelect: 'none' }}
        >
          {table.defaultCapacity}
        </text>
      )}
    </g>
  );
}

export default Table;



################################################################################
# FILE: src/domains/floor-plan/tables/tableAPI.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 2: Tables & Smart Objects API
 *
 * Manages all objects placed on the floor plan  dining tables, bar stools,
 * pool tables, decorations. Handles object creation, positioning, dragging, and properties.
 */

import type {
  Table,
  ObjectCategory,
  Point,
} from '../shared/types';
import { FloorCanvasAPI } from '../canvas';

// =============================================================================
// STATE (In production, this would come from the database)
// =============================================================================

let tables: Map<string, Table> = new Map();

// =============================================================================
// CRUD OPERATIONS
// =============================================================================

/**
 * Create a new table
 */
export function createTable(data: Omit<Table, 'id'>): Table {
  const id = `tbl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const table: Table = {
    id,
    ...data,
  };
  tables.set(id, table);
  return table;
}

/**
 * Get a table by ID
 */
export function getTable(tableId: string): Table | null {
  return tables.get(tableId) ?? null;
}

/**
 * Update a table
 */
export function updateTable(tableId: string, updates: Partial<Table>): void {
  const table = tables.get(tableId);
  if (table) {
    tables.set(tableId, { ...table, ...updates });
  }
}

/**
 * Delete a table
 */
export function deleteTable(tableId: string): void {
  tables.delete(tableId);
}

// =============================================================================
// QUERY METHODS
// =============================================================================

/**
 * Get all tables for a room
 */
export function getTablesForRoom(roomId: string): Table[] {
  return Array.from(tables.values())
    .filter((t) => t.floorPlanId === roomId && t.isActive)
    .sort((a, b) => a.sortOrder - b.sortOrder);
}

/**
 * Get all tables for a section
 */
export function getTablesForSection(sectionId: string): Table[] {
  return Array.from(tables.values())
    .filter((t) => t.sectionId === sectionId && t.isActive)
    .sort((a, b) => a.sortOrder - b.sortOrder);
}

/**
 * Get tables by category
 */
export function getTablesByCategory(category: ObjectCategory): Table[] {
  return Array.from(tables.values())
    .filter((t) => t.category === category && t.isActive)
    .sort((a, b) => a.sortOrder - b.sortOrder);
}

/**
 * Get all entertainment objects (pool tables, darts, etc.)
 */
export function getEntertainmentObjects(): Table[] {
  return getTablesByCategory('entertainment');
}

/**
 * Get all seatable tables (dining tables, booths, bar stools, etc.)
 */
export function getSeatableTables(): Table[] {
  return getTablesByCategory('seatable');
}

/**
 * Get all active tables (regardless of room)
 */
export function getAllTables(): Table[] {
  return Array.from(tables.values()).filter((t) => t.isActive);
}

// =============================================================================
// POSITION & MOVEMENT
// =============================================================================

/**
 * Move a table to a new position
 * Returns false if the position is blocked, true if successful
 */
export function moveTable(tableId: string, newPosition: Point): boolean {
  const table = tables.get(tableId);
  if (!table) return false;

  // Check collision with Layer 1's collision detection
  const isBlocked = FloorCanvasAPI.isPositionBlocked(
    table.floorPlanId,
    newPosition,
    table.width,
    table.height
  );

  if (isBlocked) {
    return false;
  }

  // Update position
  updateTable(tableId, {
    positionX: newPosition.x,
    positionY: newPosition.y,
  });

  return true;
}

/**
 * Rotate a table by degrees
 */
export function rotateTable(tableId: string, degrees: number): void {
  const table = tables.get(tableId);
  if (!table) return;

  // Normalize rotation to 0-359 degrees
  const newRotation = ((table.rotation + degrees) % 360 + 360) % 360;

  updateTable(tableId, { rotation: newRotation });
}

// =============================================================================
// CAPACITY MANAGEMENT
// =============================================================================

/**
 * Set the capacity of a table
 */
export function setTableCapacity(tableId: string, capacity: number): void {
  const table = tables.get(tableId);
  if (!table) return;

  // Ensure capacity is within min/max bounds
  const validCapacity = Math.max(
    table.minCapacity,
    Math.min(capacity, table.maxCapacity)
  );

  updateTable(tableId, { defaultCapacity: validCapacity });
}

// =============================================================================
// VISUAL PROPERTIES
// =============================================================================

/**
 * Set the color of a table
 */
export function setTableColor(tableId: string, color: string): void {
  updateTable(tableId, { color });
}

// =============================================================================
// BULK OPERATIONS
// =============================================================================

/**
 * Bulk update multiple tables
 */
export function bulkUpdateTables(
  updates: { tableId: string; changes: Partial<Table> }[]
): void {
  for (const { tableId, changes } of updates) {
    updateTable(tableId, changes);
  }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

/**
 * Initialize tables from the database
 */
export function initializeTables(tableList: Table[]): void {
  tables.clear();
  for (const table of tableList) {
    tables.set(table.id, table);
  }
}

/**
 * Clear all tables (for testing)
 */
export function clearAll(): void {
  tables.clear();
}

// =============================================================================
// EXPORT THE API
// =============================================================================

export const TableAPI = {
  // CRUD
  createTable,
  getTable,
  updateTable,
  deleteTable,

  // Queries
  getTablesForRoom,
  getTablesForSection,
  getTablesByCategory,
  getEntertainmentObjects,
  getSeatableTables,
  getAllTables,

  // Position & movement
  moveTable,
  rotateTable,

  // Capacity
  setTableCapacity,

  // Visual
  setTableColor,

  // Bulk operations
  bulkUpdateTables,

  // Initialization
  initializeTables,
  clearAll,
};

export default TableAPI;



################################################################################
# FILE: src/domains/floor-plan/tables/types.ts
################################################################################

/**
 * GWI POS - Floor Plan Domain
 * Layer 2: Tables & Smart Objects Types
 *
 * Layer-specific types for the tables layer.
 * Most types are imported from shared/types.ts
 */

import type {
  Table,
  ObjectType,
  ObjectCategory,
  TableShape,
  EntertainmentConfig,
} from '../shared/types';

// Re-export shared types for convenience
export type {
  Table,
  ObjectType,
  ObjectCategory,
  TableShape,
  EntertainmentConfig,
};

/**
 * Helper type for table creation (omits auto-generated fields)
 */
export type CreateTableInput = Omit<Table, 'id'>;

/**
 * Helper type for table updates (all fields optional)
 */
export type UpdateTableInput = Partial<Table>;

/**
 * Table drag state for UI interactions
 */
export interface TableDragState {
  tableId: string;
  startX: number;
  startY: number;
  offsetX: number;
  offsetY: number;
}

/**
 * Table selection state
 */
export interface TableSelectionState {
  selectedTableIds: string[];
  lastSelectedId: string | null;
}



################################################################################
# FILE: src/domains/floor-plan/types/index.ts
################################################################################

/**
 * Floor Plan Domain Types
 *
 * These types define the public contract for the Floor Plan domain.
 * Other domains should import types from the domain index, not directly from here.
 */

// =============================================================================
// L1: FLOOR CANVAS
// =============================================================================

export interface Room {
  id: string
  locationId: string
  name: string
  sortOrder: number
  gridWidth: number
  gridHeight: number
  cellSize: number
  isActive: boolean
}

export interface FloorPlan {
  id: string
  locationId: string
  name: string
  isDefault: boolean
  rooms: Room[]
}

export interface Fixture {
  id: string
  roomId: string
  type: FixtureType
  x: number
  y: number
  width: number
  height: number
  rotation: number
  metadata?: Record<string, unknown>
}

export type FixtureType =
  | 'wall'
  | 'bar_counter'
  | 'pillar'
  | 'railing'
  | 'door'
  | 'fire_exit'
  | 'ada_path'
  | 'window'
  | 'stage'

// =============================================================================
// L2: TABLES & SMART OBJECTS
// =============================================================================

export interface Table {
  id: string
  sectionId?: string | null
  name: string
  number: number
  shape: TableShape
  x: number
  y: number
  width: number
  height: number
  rotation: number
  capacity: number
  minCapacity: number
  status: TableStatus
  isActive: boolean
  isEntertainment: boolean
  entertainmentType?: EntertainmentType | string
}

export type TableShape =
  | 'square'
  | 'round'
  | 'rectangle'
  | 'oval'
  | 'booth'
  | 'bar_seat'
  | 'high_top'
  | 'custom'

export type TableStatus =
  | 'available'
  | 'seating'
  | 'occupied'
  | 'ordering'
  | 'food_pending'
  | 'food_served'
  | 'dessert'
  | 'check_requested'
  | 'check_dropped'
  | 'paid'
  | 'dirty'
  | 'bussing'
  | 'reserved'
  | 'blocked'
  | 'combined'

// =============================================================================
// L3: SEATS
// =============================================================================

export interface Seat {
  id: string
  tableId: string
  number: number
  position: SeatPosition
  isVirtual: boolean
  isOccupied: boolean
  guestId?: string
  orderId?: string
}

export interface SeatPosition {
  angle: number      // Degrees around table center
  distance: number   // Distance from table edge
  x: number          // Computed X position
  y: number          // Computed Y position
}

// =============================================================================
// L4: TABLE GROUPS
// =============================================================================

export interface TableGroup {
  id: string
  locationId: string
  name?: string
  color: GroupColor
  isVirtual: boolean  // true = virtual combine, false = physical merge
  tableIds: string[]
  primaryTableId: string
  createdAt: Date
  createdBy: string
}

export type GroupColor =
  | 'blue'
  | 'green'
  | 'orange'
  | 'purple'
  | 'pink'
  | 'yellow'
  | 'cyan'
  | 'red'

// =============================================================================
// L6: STAFF ROLES
// =============================================================================

export interface Section {
  id: string
  locationId: string
  name: string
  color: string
  tableIds: string[]
  isActive: boolean
}

export interface SectionAssignment {
  id: string
  sectionId: string
  employeeId: string
  shiftId?: string
  assignedAt: Date
  assignedBy: string
}

// =============================================================================
// L7: STATUS ENGINE
// =============================================================================

export interface StatusTransition {
  from: TableStatus
  to: TableStatus
  trigger: StatusTrigger
  automatic: boolean
  timeoutMinutes?: number
}

export type StatusTrigger =
  | 'manual'
  | 'guest_seated'
  | 'order_created'
  | 'order_sent'
  | 'food_ready'
  | 'food_delivered'
  | 'check_requested'
  | 'check_printed'
  | 'payment_complete'
  | 'table_cleared'
  | 'timeout'

// =============================================================================
// L8: ENTERTAINMENT
// =============================================================================

export interface TimedRental {
  id: string
  tableId: string
  locationId: string
  type: EntertainmentType
  status: RentalStatus
  startedAt?: Date
  pausedAt?: Date
  endedAt?: Date
  totalMinutes: number
  pausedMinutes: number
  rate: number
  overtimeRate?: number
  overtimeThreshold?: number
  linkedOrderId?: string
  guestName?: string
  guestPhone?: string
}

export type EntertainmentType =
  | 'pool'
  | 'darts'
  | 'karaoke'
  | 'arcade'
  | 'bowling'
  | 'shuffleboard'

export type RentalStatus =
  | 'available'
  | 'reserved'
  | 'active'
  | 'paused'
  | 'overtime'
  | 'completed'

// =============================================================================
// L9: WAITLIST
// =============================================================================

export interface WaitlistEntry {
  id: string
  locationId: string
  guestName: string
  guestPhone?: string
  partySize: number
  status: WaitlistStatus
  preferences: WaitlistPreferences
  estimatedWaitMinutes?: number
  quotedWaitMinutes?: number
  addedAt: Date
  notifiedAt?: Date
  seatedAt?: Date
  cancelledAt?: Date
  assignedTableId?: string
  notes?: string
}

export type WaitlistStatus =
  | 'waiting'
  | 'notified'
  | 'claiming'
  | 'seated'
  | 'cancelled'
  | 'no_show'

export interface WaitlistPreferences {
  preferredSection?: string
  outdoorOk: boolean
  barOk: boolean
  boothPreferred: boolean
  highChairNeeded: boolean
  wheelchairAccessible: boolean
  vip: boolean
}


================================================================================
SECTION 2: COMPONENT FILES (src/components/floor-plan)
================================================================================

################################################################################
# FILE: src/components/floor-plan/AddEntertainmentPalette.tsx
################################################################################

'use client'

import { useState, useEffect, useCallback } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import {
  EntertainmentVisual,
  ENTERTAINMENT_VISUAL_OPTIONS,
  type EntertainmentVisualType,
} from './entertainment-visuals'

interface EntertainmentMenuItem {
  id: string
  name: string
  price: number
  blockTimeMinutes?: number | null
  categoryType?: string | null
  isPlaced?: boolean // Whether already on floor plan
}

interface AddEntertainmentPaletteProps {
  isOpen: boolean
  onClose: () => void
  locationId: string
  selectedSectionId: string | null
  placedMenuItemIds: string[] // IDs of menu items already on the floor plan
  onAddElement: (element: {
    name: string
    visualType: EntertainmentVisualType
    linkedMenuItemId: string
    width: number
    height: number
  }) => void
}

// Try to auto-detect visual type from item name
function detectVisualType(name: string): EntertainmentVisualType {
  const lower = name.toLowerCase()
  if (lower.includes('pool')) return 'pool_table'
  if (lower.includes('dart')) return 'dartboard'
  if (lower.includes('arcade')) return 'arcade'
  if (lower.includes('foosball') || lower.includes('foos')) return 'foosball'
  if (lower.includes('shuffle')) return 'shuffleboard'
  if (lower.includes('ping') || lower.includes('pong')) return 'ping_pong'
  if (lower.includes('bowl')) return 'bowling_lane'
  if (lower.includes('karaoke')) return 'karaoke_stage'
  if (lower.includes('dj')) return 'dj_booth'
  if (lower.includes('photo')) return 'photo_booth'
  if (lower.includes('vr') || lower.includes('virtual')) return 'vr_station'
  return 'game_table' // Default
}

export function AddEntertainmentPalette({
  isOpen,
  onClose,
  locationId,
  selectedSectionId,
  placedMenuItemIds,
  onAddElement,
}: AddEntertainmentPaletteProps) {
  const [entertainmentItems, setEntertainmentItems] = useState<EntertainmentMenuItem[]>([])
  const [selectedMenuItem, setSelectedMenuItem] = useState<EntertainmentMenuItem | null>(null)
  const [selectedVisualType, setSelectedVisualType] = useState<EntertainmentVisualType | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  // Fetch entertainment menu items
  useEffect(() => {
    if (isOpen && locationId) {
      fetchEntertainmentItems()
    }
  }, [isOpen, locationId])

  // Reset when closing
  useEffect(() => {
    if (!isOpen) {
      setSelectedMenuItem(null)
      setSelectedVisualType(null)
    }
  }, [isOpen])

  const fetchEntertainmentItems = async () => {
    setIsLoading(true)
    try {
      // Fetch all items for the location, then filter by categoryType = 'entertainment'
      const response = await fetch(
        `/api/menu/items?locationId=${locationId}`
      )
      if (response.ok) {
        const data = await response.json()
        // Filter to only items in entertainment category
        const entertainmentOnly = (data.items || []).filter(
          (item: EntertainmentMenuItem) => item.categoryType === 'entertainment'
        )
        setEntertainmentItems(entertainmentOnly)
      }
    } catch (error) {
      console.error('Failed to fetch entertainment items:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // Filter out already placed items
  const availableItems = entertainmentItems.filter(
    (item) => !placedMenuItemIds.includes(item.id)
  )

  const handleSelectMenuItem = (item: EntertainmentMenuItem) => {
    setSelectedMenuItem(item)
    // Auto-detect visual type from name
    setSelectedVisualType(detectVisualType(item.name))
  }

  const handleAdd = useCallback(() => {
    if (!selectedMenuItem || !selectedVisualType) return

    const visualOption = ENTERTAINMENT_VISUAL_OPTIONS.find((v) => v.value === selectedVisualType)
    if (!visualOption) return

    onAddElement({
      name: selectedMenuItem.name,
      visualType: selectedVisualType,
      linkedMenuItemId: selectedMenuItem.id,
      width: visualOption.defaultWidth,
      height: visualOption.defaultHeight,
    })

    // Reset state
    setSelectedMenuItem(null)
    setSelectedVisualType(null)
    onClose()
  }, [selectedMenuItem, selectedVisualType, onAddElement, onClose])

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/50 z-40"
          />

          {/* Panel */}
          <motion.div
            initial={{ y: '100%' }}
            animate={{ y: 0 }}
            exit={{ y: '100%' }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed bottom-0 left-0 right-0 z-50 lg:ml-64"
            style={{
              background: 'linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%)',
              borderTop: '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '24px 24px 0 0',
              maxHeight: '70vh',
            }}
          >
            {/* Handle */}
            <div className="flex justify-center pt-3 pb-2">
              <div className="w-12 h-1.5 bg-slate-600 rounded-full" />
            </div>

            {/* Header */}
            <div className="flex items-center justify-between px-6 pb-4 border-b border-white/10">
              <div>
                <h2 className="text-lg font-bold text-white">Add Entertainment</h2>
                <p className="text-xs text-slate-500 mt-0.5">
                  {availableItems.length === 0
                    ? 'All entertainment items have been placed'
                    : 'Select an item from your menu to place on the floor plan'}
                </p>
              </div>
              <button
                onClick={onClose}
                className="p-2 rounded-lg hover:bg-white/5 transition-colors"
              >
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" className="text-slate-400">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            <div className="p-6 overflow-y-auto" style={{ maxHeight: 'calc(70vh - 100px)' }}>
              {isLoading ? (
                <div className="flex items-center justify-center py-12">
                  <div className="animate-spin w-8 h-8 border-2 border-indigo-500 border-t-transparent rounded-full" />
                </div>
              ) : availableItems.length === 0 ? (
                <div className="text-center py-12">
                  <p className="text-slate-400 text-sm">
                    {entertainmentItems.length === 0
                      ? 'No entertainment items in your menu.'
                      : 'All entertainment items have been placed on the floor plan.'}
                  </p>
                  <p className="text-slate-500 text-xs mt-2">
                    {entertainmentItems.length === 0
                      ? 'Add timed rental items in Menu Builder first.'
                      : 'To add more, create additional items in Menu Builder.'}
                  </p>
                </div>
              ) : (
                <>
                  {/* Step 1: Select Menu Item */}
                  <div className="mb-6">
                    <label className="text-[10px] font-black uppercase tracking-wider text-slate-500 mb-3 block">
                      1. Select Item to Place
                    </label>
                    <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3">
                      {availableItems.map((item) => (
                        <button
                          key={item.id}
                          onClick={() => handleSelectMenuItem(item)}
                          className={`relative p-4 rounded-xl text-left transition-all ${
                            selectedMenuItem?.id === item.id
                              ? 'bg-indigo-500/20 ring-2 ring-indigo-500'
                              : 'bg-slate-800/50 hover:bg-slate-700/50'
                          }`}
                        >
                          <div className="font-semibold text-white text-sm">{item.name}</div>
                          <div className="text-slate-400 text-xs mt-1">
                            ${item.price.toFixed(2)}
                            {item.blockTimeMinutes && (
                              <span className="text-slate-500 ml-1">
                                / {item.blockTimeMinutes}min
                              </span>
                            )}
                          </div>
                          {selectedMenuItem?.id === item.id && (
                            <motion.div
                              layoutId="selectedItem"
                              className="absolute inset-0 rounded-xl border-2 border-indigo-500"
                              transition={{ type: 'spring', stiffness: 400, damping: 30 }}
                            />
                          )}
                        </button>
                      ))}
                    </div>
                  </div>

                  {/* Step 2: Select Visual Style (shown after item selected) */}
                  {selectedMenuItem && (
                    <motion.div
                      initial={{ opacity: 0, y: 10 }}
                      animate={{ opacity: 1, y: 0 }}
                      className="mb-6"
                    >
                      <label className="text-[10px] font-black uppercase tracking-wider text-slate-500 mb-3 block">
                        2. Choose Visual Style for "{selectedMenuItem.name}"
                      </label>
                      <div className="grid grid-cols-4 sm:grid-cols-6 lg:grid-cols-8 gap-3">
                        {ENTERTAINMENT_VISUAL_OPTIONS.map((option) => (
                          <button
                            key={option.value}
                            onClick={() => setSelectedVisualType(option.value)}
                            className={`relative p-3 rounded-xl transition-all ${
                              selectedVisualType === option.value
                                ? 'bg-indigo-500/20 ring-2 ring-indigo-500'
                                : 'bg-slate-800/50 hover:bg-slate-700/50'
                            }`}
                          >
                            <div className="flex flex-col items-center gap-2">
                              <div
                                className="flex items-center justify-center"
                                style={{
                                  width: 60,
                                  height: 50,
                                  transform: `scale(${Math.min(60 / option.defaultWidth, 50 / option.defaultHeight) * 0.9})`,
                                }}
                              >
                                <EntertainmentVisual
                                  visualType={option.value}
                                  width={option.defaultWidth}
                                  height={option.defaultHeight}
                                  status="available"
                                />
                              </div>
                              <span className="text-[10px] text-slate-400 text-center leading-tight">
                                {option.label}
                              </span>
                            </div>
                            {selectedVisualType === option.value && (
                              <motion.div
                                layoutId="selectedVisual"
                                className="absolute inset-0 rounded-xl border-2 border-indigo-500"
                                transition={{ type: 'spring', stiffness: 400, damping: 30 }}
                              />
                            )}
                          </button>
                        ))}
                      </div>
                    </motion.div>
                  )}

                  {/* Preview & Add */}
                  {selectedMenuItem && selectedVisualType && (
                    <motion.div
                      initial={{ opacity: 0, y: 10 }}
                      animate={{ opacity: 1, y: 0 }}
                      className="flex items-center gap-4"
                    >
                      {/* Preview */}
                      <div
                        className="flex-1 flex items-center justify-center p-4 rounded-xl"
                        style={{
                          background: 'rgba(0, 0, 0, 0.3)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                        }}
                      >
                        <div className="flex items-center gap-4">
                          <EntertainmentVisual
                            visualType={selectedVisualType}
                            width={ENTERTAINMENT_VISUAL_OPTIONS.find((v) => v.value === selectedVisualType)?.defaultWidth || 100}
                            height={ENTERTAINMENT_VISUAL_OPTIONS.find((v) => v.value === selectedVisualType)?.defaultHeight || 100}
                            status="available"
                          />
                          <div>
                            <div className="text-white font-semibold">{selectedMenuItem.name}</div>
                            <div className="text-slate-400 text-sm">${selectedMenuItem.price.toFixed(2)}</div>
                          </div>
                        </div>
                      </div>

                      {/* Add Button */}
                      <button
                        onClick={handleAdd}
                        className="px-8 py-4 rounded-2xl text-sm font-bold text-white transition-all"
                        style={{
                          background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
                          boxShadow: '0 4px 14px rgba(99, 102, 241, 0.4)',
                        }}
                      >
                        Add to Floor Plan
                      </button>
                    </motion.div>
                  )}
                </>
              )}

              {/* Already Placed Items */}
              {entertainmentItems.length > 0 && placedMenuItemIds.length > 0 && (
                <div className="mt-6 pt-6 border-t border-white/10">
                  <label className="text-[10px] font-black uppercase tracking-wider text-slate-500 mb-2 block">
                    Already Placed ({placedMenuItemIds.length})
                  </label>
                  <div className="flex flex-wrap gap-2">
                    {entertainmentItems
                      .filter((item) => placedMenuItemIds.includes(item.id))
                      .map((item) => (
                        <span
                          key={item.id}
                          className="px-3 py-1.5 rounded-lg text-xs text-slate-500 bg-slate-800/30"
                        >
                          {item.name}
                        </span>
                      ))}
                  </div>
                </div>
              )}
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/AddRoomModal.tsx
################################################################################

'use client'

import { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'

interface AddRoomModalProps {
  isOpen: boolean
  onClose: () => void
  locationId: string
  onRoomCreated: (room: { id: string; name: string; color: string; sortOrder: number }) => void
}

const THEME_COLORS = [
  '#6366f1', // Indigo
  '#10b981', // Emerald
  '#f59e0b', // Amber
  '#ef4444', // Red
  '#ec4899', // Pink
  '#8b5cf6', // Violet
  '#06b6d4', // Cyan
  '#84cc16', // Lime
]

export function AddRoomModal({ isOpen, onClose, locationId, onRoomCreated }: AddRoomModalProps) {
  const [name, setName] = useState('')
  const [color, setColor] = useState('#6366f1')
  const [isCreating, setIsCreating] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleCreate = async () => {
    if (!name.trim()) {
      setError('Please enter a room name')
      return
    }

    setIsCreating(true)
    setError(null)

    try {
      const response = await fetch('/api/sections', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ locationId, name: name.trim(), color }),
      })

      if (response.ok) {
        const data = await response.json()
        onRoomCreated(data.section)
        setName('')
        setColor('#6366f1')
        onClose()
      } else {
        const data = await response.json()
        setError(data.error || 'Failed to create room')
      }
    } catch (err) {
      setError('Network error - please try again')
    } finally {
      setIsCreating(false)
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleCreate()
    }
    if (e.key === 'Escape') {
      onClose()
    }
  }

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50"
          />

          {/* Modal */}
          <motion.div
            initial={{ opacity: 0, scale: 0.95, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: 20 }}
            transition={{ type: 'spring', stiffness: 400, damping: 30 }}
            className="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-50 w-full max-w-sm"
          >
            <div
              className="rounded-3xl p-6"
              style={{
                background: 'linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
              }}
            >
              {/* Header */}
              <div className="flex items-center justify-between mb-6">
                <h2 className="text-lg font-bold text-white">Add Floor Plan Area</h2>
                <button
                  onClick={onClose}
                  className="p-2 rounded-lg hover:bg-white/5 transition-colors"
                >
                  <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" className="text-slate-400">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>

              {/* Form */}
              <div className="space-y-5">
                {/* Room Name */}
                <div className="space-y-2">
                  <label className="text-[10px] font-black uppercase tracking-wider text-slate-500">
                    Room Name
                  </label>
                  <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder="e.g. Back Patio, Bar Area, VIP Lounge..."
                    autoFocus
                    className="w-full px-4 py-3 rounded-xl text-sm text-white placeholder-slate-600"
                    style={{
                      background: 'rgba(0, 0, 0, 0.3)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                    }}
                  />
                </div>

                {/* Theme Color */}
                <div className="space-y-2">
                  <label className="text-[10px] font-black uppercase tracking-wider text-slate-500">
                    Theme Color
                  </label>
                  <div className="flex gap-2 flex-wrap">
                    {THEME_COLORS.map((c) => (
                      <button
                        key={c}
                        onClick={() => setColor(c)}
                        className="relative w-9 h-9 rounded-full transition-all"
                        style={{
                          backgroundColor: c,
                          transform: color === c ? 'scale(1.15)' : 'scale(1)',
                          boxShadow: color === c ? `0 0 20px ${c}80` : 'none',
                        }}
                      >
                        {color === c && (
                          <motion.div
                            layoutId="colorCheck"
                            className="absolute inset-0 flex items-center justify-center"
                          >
                            <svg width="16" height="16" fill="none" stroke="white" viewBox="0 0 24 24" strokeWidth={3}>
                              <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
                            </svg>
                          </motion.div>
                        )}
                      </button>
                    ))}
                  </div>
                </div>

                {/* Error */}
                {error && (
                  <p className="text-red-400 text-sm">{error}</p>
                )}

                {/* Submit Button */}
                <button
                  onClick={handleCreate}
                  disabled={isCreating || !name.trim()}
                  className="w-full py-3.5 rounded-2xl text-sm font-bold text-white transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                  style={{
                    background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
                    boxShadow: '0 4px 14px rgba(99, 102, 241, 0.4)',
                  }}
                >
                  {isCreating ? 'Creating...' : 'Create Room'}
                </button>
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/CategoriesBar.tsx
################################################################################

'use client'

import { motion } from 'framer-motion'

interface Category {
  id: string
  name: string
  color?: string
  itemCount?: number
  categoryType?: string  // food, drinks, liquor, entertainment, combos, retail
  categoryShow?: string  // 'bar' | 'food' | 'entertainment' | 'all'
}

interface CategoriesBarProps {
  categories: Category[]
  selectedCategoryId: string | null
  onCategorySelect: (categoryId: string | null) => void
  onStartTabWorkflow?: () => void
}

export function CategoriesBar({
  categories,
  selectedCategoryId,
  onCategorySelect,
  onStartTabWorkflow,
}: CategoriesBarProps) {
  // Split categories by categoryShow field (matches BartenderView logic)
  const foodCategories = categories.filter(c => {
    const show = (c.categoryShow || 'all').toLowerCase()
    return show === 'food' || show === 'all'
  })
  const barCategories = categories.filter(c => {
    const show = (c.categoryShow || 'all').toLowerCase()
    return show === 'bar'
  })

  const renderCategoryButton = (category: Category) => (
    <motion.button
      key={category.id}
      className={`category-button ${selectedCategoryId === category.id ? 'active' : ''}`}
      onClick={() => onCategorySelect(category.id)}
      whileHover={{ y: -2 }}
      whileTap={{ scale: 0.98 }}
      style={{
        padding: '10px 20px',
        background: selectedCategoryId === category.id
          ? (category.color ? `${category.color}20` : 'rgba(99, 102, 241, 0.2)')
          : 'rgba(255, 255, 255, 0.05)',
        borderWidth: '1px',
        borderStyle: 'solid',
        borderColor: selectedCategoryId === category.id && category.color
          ? category.color
          : 'rgba(255, 255, 255, 0.1)',
        borderRadius: '10px',
        color: selectedCategoryId === category.id ? '#a5b4fc' : '#94a3b8',
        fontSize: '14px',
        fontWeight: 500,
        cursor: 'pointer',
        whiteSpace: 'nowrap' as const,
      }}
    >
      {category.name}
      {category.itemCount !== undefined && (
        <span style={{ marginLeft: '6px', fontSize: '12px', opacity: 0.6 }}>({category.itemCount})</span>
      )}
    </motion.button>
  )


  return (
    <div className="categories-bar-container" style={{ minHeight: '100px', background: 'rgba(0,0,0,0.2)' }}>
      {/* Food Row */}
      <div className="categories-bar categories-row-food" style={{ display: 'flex', padding: '8px 20px', gap: '8px' }}>
        <span className="category-row-label" style={{ color: '#f97316', fontWeight: 600, fontSize: '11px', display: 'flex', alignItems: 'center', gap: '6px', textTransform: 'uppercase' as const }}>
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
          </svg>
          Food
        </span>

        {foodCategories.map(renderCategoryButton)}
      </div>

      {/* Bar Row */}
      <div className="categories-bar categories-row-bar" style={{ display: 'flex', padding: '8px 20px', gap: '8px' }}>
        <span className="category-row-label" style={{ color: '#3b82f6', fontWeight: 600, fontSize: '11px', display: 'flex', alignItems: 'center', gap: '6px' }}>
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
          </svg>
          Bar
        </span>

        {barCategories.map(renderCategoryButton)}

        {/* Start Tab Quick Action */}
        {onStartTabWorkflow && (
          <motion.button
            className="category-button new-tab-button"
            onClick={onStartTabWorkflow}
            whileHover={{ y: -2 }}
            whileTap={{ scale: 0.98 }}
          >
            <svg
              className="w-4 h-4 mr-1.5 inline-block"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 4v16m8-8H4"
              />
            </svg>
            New Tab
          </motion.button>
        )}
      </div>
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/entertainment-visuals.tsx
################################################################################

'use client'

/**
 * Entertainment Visual SVG Components
 *
 * Lightweight inline SVGs for floor plan entertainment elements.
 * All components accept width/height and optional fill colors for customization.
 * Designed to be crisp at any size and render instantly (no external files).
 */

interface VisualProps {
  width?: number
  height?: number
  fillColor?: string
  strokeColor?: string
  className?: string
  status?: 'available' | 'in_use' | 'reserved' | 'maintenance'
}

// Status-based colors
const STATUS_FILLS: Record<string, string> = {
  available: '#22c55e20',
  in_use: '#6366f140',
  reserved: '#eab30840',
  maintenance: '#ef444440',
}

const STATUS_STROKES: Record<string, string> = {
  available: '#22c55e',
  in_use: '#6366f1',
  reserved: '#eab308',
  maintenance: '#ef4444',
}

/**
 * Pool Table - Green felt with pockets and wood rail
 */
export function PoolTableVisual({
  width = 160,
  height = 90,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const fill = fillColor || STATUS_FILLS[status]
  const stroke = strokeColor || STATUS_STROKES[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 160 90"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Wood rail */}
      <rect
        x="2"
        y="2"
        width="156"
        height="86"
        rx="8"
        fill="#8B4513"
        stroke="#5D3A1A"
        strokeWidth="2"
      />
      {/* Green felt */}
      <rect
        x="10"
        y="10"
        width="140"
        height="70"
        rx="2"
        fill={fillColor || '#166534'}
        stroke={stroke}
        strokeWidth="1.5"
      />
      {/* Center line */}
      <line x1="80" y1="10" x2="80" y2="80" stroke="#15803d" strokeWidth="1" strokeDasharray="4 4" />
      {/* Pockets */}
      {[
        [12, 12], [80, 10], [148, 12], // Top
        [12, 78], [80, 80], [148, 78], // Bottom
      ].map(([cx, cy], i) => (
        <circle key={i} cx={cx} cy={cy} r="6" fill="#1a1a1a" />
      ))}
      {/* Status glow overlay */}
      <rect
        x="10"
        y="10"
        width="140"
        height="70"
        rx="2"
        fill={fill}
        style={{ pointerEvents: 'none' }}
      />
    </svg>
  )
}

/**
 * Dartboard - Circular target with wedges
 */
export function DartboardVisual({
  width = 100,
  height = 100,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 100 100"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Outer ring */}
      <circle cx="50" cy="50" r="46" fill="#1a1a1a" stroke={stroke} strokeWidth="2" />
      {/* Scoring rings */}
      <circle cx="50" cy="50" r="40" fill="none" stroke="#dc2626" strokeWidth="8" />
      <circle cx="50" cy="50" r="32" fill="none" stroke="#16a34a" strokeWidth="8" />
      <circle cx="50" cy="50" r="24" fill="none" stroke="#dc2626" strokeWidth="8" />
      <circle cx="50" cy="50" r="16" fill="none" stroke="#16a34a" strokeWidth="8" />
      {/* Double/Triple rings */}
      <circle cx="50" cy="50" r="44" fill="none" stroke="#000" strokeWidth="1" />
      <circle cx="50" cy="50" r="28" fill="none" stroke="#000" strokeWidth="1" />
      {/* Bullseye */}
      <circle cx="50" cy="50" r="6" fill="#16a34a" stroke="#000" strokeWidth="1" />
      <circle cx="50" cy="50" r="2" fill="#dc2626" stroke="#000" strokeWidth="0.5" />
      {/* Dividing lines */}
      {Array.from({ length: 20 }).map((_, i) => {
        const angle = (i * 18 - 9) * (Math.PI / 180)
        return (
          <line
            key={i}
            x1={50 + Math.cos(angle) * 8}
            y1={50 + Math.sin(angle) * 8}
            x2={50 + Math.cos(angle) * 46}
            y2={50 + Math.sin(angle) * 46}
            stroke="#000"
            strokeWidth="0.5"
          />
        )
      })}
      {/* Status overlay */}
      <circle cx="50" cy="50" r="46" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Arcade Cabinet - Retro game cabinet with screen
 */
export function ArcadeVisual({
  width = 70,
  height = 100,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 70 100"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Cabinet body */}
      <path
        d="M10 95 L10 20 Q10 10 20 10 L50 10 Q60 10 60 20 L60 95 Q60 98 55 98 L15 98 Q10 98 10 95 Z"
        fill="#1e293b"
        stroke={stroke}
        strokeWidth="2"
      />
      {/* Screen bezel */}
      <rect x="15" y="18" width="40" height="35" rx="2" fill="#0f172a" stroke="#334155" strokeWidth="1" />
      {/* Screen */}
      <rect x="18" y="21" width="34" height="29" rx="1" fill="#1e1b4b">
        {/* Screen glow effect */}
        <animate attributeName="fill" values="#1e1b4b;#312e81;#1e1b4b" dur="3s" repeatCount="indefinite" />
      </rect>
      {/* Marquee */}
      <rect x="12" y="5" width="46" height="10" rx="1" fill="#7c3aed" />
      {/* Control panel */}
      <rect x="15" y="58" width="40" height="18" rx="2" fill="#334155" />
      {/* Joystick */}
      <circle cx="28" cy="67" r="4" fill="#1a1a1a" />
      <rect x="26" y="60" width="4" height="10" rx="1" fill="#dc2626" />
      {/* Buttons */}
      <circle cx="42" cy="63" r="3" fill="#22c55e" />
      <circle cx="50" cy="65" r="3" fill="#3b82f6" />
      <circle cx="46" cy="72" r="3" fill="#eab308" />
      {/* Coin slot */}
      <rect x="28" y="80" width="14" height="3" rx="1" fill="#0a0a0a" />
      {/* Status overlay */}
      <rect x="10" y="10" width="50" height="88" rx="4" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Foosball Table - Table with rods and players
 */
export function FoosballVisual({
  width = 140,
  height = 80,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 140 80"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Table frame */}
      <rect x="5" y="5" width="130" height="70" rx="4" fill="#1e293b" stroke={stroke} strokeWidth="2" />
      {/* Playing field */}
      <rect x="12" y="12" width="116" height="56" rx="2" fill="#16a34a" />
      {/* Center circle */}
      <circle cx="70" cy="40" r="10" fill="none" stroke="#15803d" strokeWidth="1.5" />
      {/* Center line */}
      <line x1="70" y1="12" x2="70" y2="68" stroke="#15803d" strokeWidth="1.5" />
      {/* Goals */}
      <rect x="12" y="28" width="6" height="24" fill="#0f172a" rx="1" />
      <rect x="122" y="28" width="6" height="24" fill="#0f172a" rx="1" />
      {/* Rods with handles */}
      {[25, 45, 65, 85, 105].map((x, i) => (
        <g key={i}>
          {/* Rod */}
          <line x1={x} y1="0" x2={x} y2="80" stroke="#9ca3af" strokeWidth="3" />
          {/* Handles */}
          <rect x={x - 4} y="-2" width="8" height="6" rx="1" fill="#4b5563" />
          <rect x={x - 4} y="76" width="8" height="6" rx="1" fill="#4b5563" />
          {/* Players (alternating colors) */}
          {(i % 2 === 0 ? [25, 55] : [20, 40, 60]).map((py, j) => (
            <rect
              key={j}
              x={x - 3}
              y={py}
              width="6"
              height="10"
              rx="1"
              fill={i % 2 === 0 ? '#dc2626' : '#2563eb'}
            />
          ))}
        </g>
      ))}
      {/* Status overlay */}
      <rect x="12" y="12" width="116" height="56" rx="2" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Shuffleboard Table - Long narrow table with scoring zones
 */
export function ShuffleboardVisual({
  width = 200,
  height = 50,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 200 50"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Table frame */}
      <rect x="2" y="2" width="196" height="46" rx="4" fill="#8B4513" stroke="#5D3A1A" strokeWidth="2" />
      {/* Playing surface */}
      <rect x="8" y="8" width="184" height="34" rx="2" fill="#d4a574" />
      {/* Scoring zones */}
      <line x1="160" y1="8" x2="160" y2="42" stroke="#8B4513" strokeWidth="1" />
      <line x1="175" y1="8" x2="175" y2="42" stroke="#8B4513" strokeWidth="1" />
      <line x1="185" y1="8" x2="185" y2="42" stroke="#8B4513" strokeWidth="1" />
      {/* Score labels */}
      <text x="167" y="28" fontSize="8" fill="#5D3A1A" textAnchor="middle">1</text>
      <text x="180" y="28" fontSize="8" fill="#5D3A1A" textAnchor="middle">2</text>
      <text x="189" y="28" fontSize="8" fill="#5D3A1A" textAnchor="middle">3</text>
      {/* Foul line */}
      <line x1="40" y1="8" x2="40" y2="42" stroke="#dc2626" strokeWidth="1.5" strokeDasharray="4 2" />
      {/* Status overlay */}
      <rect x="8" y="8" width="184" height="34" rx="2" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Ping Pong Table - Table with net
 */
export function PingPongVisual({
  width = 140,
  height = 80,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 140 80"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Table surface */}
      <rect x="5" y="5" width="130" height="70" rx="2" fill="#1d4ed8" stroke={stroke} strokeWidth="2" />
      {/* White border lines */}
      <rect x="10" y="10" width="120" height="60" fill="none" stroke="white" strokeWidth="2" />
      {/* Center line */}
      <line x1="10" y1="40" x2="130" y2="40" stroke="white" strokeWidth="2" />
      {/* Net */}
      <rect x="68" y="5" width="4" height="70" fill="#374151" />
      <line x1="70" y1="5" x2="70" y2="75" stroke="white" strokeWidth="1" strokeDasharray="2 2" />
      {/* Net posts */}
      <circle cx="70" cy="5" r="3" fill="#6b7280" />
      <circle cx="70" cy="75" r="3" fill="#6b7280" />
      {/* Status overlay */}
      <rect x="5" y="5" width="130" height="70" rx="2" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Bowling Lane - Long lane with pins
 */
export function BowlingLaneVisual({
  width = 220,
  height = 45,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 220 45"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Lane */}
      <rect x="2" y="5" width="216" height="35" rx="2" fill="#d4a574" stroke={stroke} strokeWidth="2" />
      {/* Arrows/markers */}
      {[40, 60, 80].map((x) => (
        <polygon key={x} points={`${x},22.5 ${x - 4},28 ${x + 4},28`} fill="#8B4513" />
      ))}
      {/* Foul line */}
      <line x1="30" y1="5" x2="30" y2="40" stroke="#1a1a1a" strokeWidth="2" />
      {/* Gutters */}
      <rect x="2" y="5" width="216" height="4" fill="#374151" />
      <rect x="2" y="36" width="216" height="4" fill="#374151" />
      {/* Pin deck */}
      <rect x="195" y="5" width="23" height="35" fill="#f5f5f5" />
      {/* Pins (triangle formation) */}
      {[
        [207, 22.5], // 1
        [211, 18], [211, 27], // 2-3
        [215, 14], [215, 22.5], [215, 31], // 4-6
      ].map(([cx, cy], i) => (
        <ellipse key={i} cx={cx} cy={cy} rx="2" ry="3" fill="white" stroke="#ccc" strokeWidth="0.5" />
      ))}
      {/* Status overlay */}
      <rect x="2" y="5" width="216" height="35" rx="2" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Karaoke Stage - Small platform with mic
 */
export function KaraokeStageVisual({
  width = 100,
  height = 80,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 100 80"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Stage platform */}
      <path d="M10 70 L5 75 L95 75 L90 70 Z" fill="#4a5568" />
      <rect x="10" y="50" width="80" height="20" rx="2" fill="#1e293b" stroke={stroke} strokeWidth="2" />
      {/* Stage floor pattern */}
      <rect x="12" y="52" width="76" height="16" rx="1" fill="#374151" />
      {/* Spotlight effect */}
      <ellipse cx="50" cy="58" rx="25" ry="8" fill="#fef08a" opacity="0.3" />
      {/* Mic stand */}
      <line x1="50" y1="25" x2="50" y2="52" stroke="#6b7280" strokeWidth="2" />
      <rect x="45" y="50" width="10" height="4" rx="1" fill="#4b5563" />
      {/* Microphone */}
      <ellipse cx="50" cy="22" rx="6" ry="8" fill="#1f2937" stroke="#4b5563" strokeWidth="1" />
      <rect x="48" y="28" width="4" height="6" fill="#374151" />
      {/* Monitor speakers */}
      <rect x="15" y="42" width="12" height="8" rx="1" fill="#1f2937" stroke="#374151" strokeWidth="0.5" />
      <rect x="73" y="42" width="12" height="8" rx="1" fill="#1f2937" stroke="#374151" strokeWidth="0.5" />
      {/* Music notes decoration */}
      <text x="25" y="35" fontSize="10" fill="#a855f7" opacity="0.7"></text>
      <text x="72" y="32" fontSize="8" fill="#a855f7" opacity="0.7"></text>
      {/* Status overlay */}
      <rect x="10" y="50" width="80" height="20" rx="2" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * DJ Booth - Booth with turntables
 */
export function DJBoothVisual({
  width = 120,
  height = 70,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 120 70"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Booth base */}
      <rect x="5" y="35" width="110" height="30" rx="4" fill="#1e293b" stroke={stroke} strokeWidth="2" />
      {/* Equipment surface */}
      <rect x="10" y="25" width="100" height="15" rx="2" fill="#0f172a" stroke="#334155" strokeWidth="1" />
      {/* Left turntable */}
      <circle cx="30" cy="32" r="10" fill="#1f2937" stroke="#4b5563" strokeWidth="1" />
      <circle cx="30" cy="32" r="7" fill="#27272a" />
      <circle cx="30" cy="32" r="1.5" fill="#dc2626" />
      {/* Right turntable */}
      <circle cx="90" cy="32" r="10" fill="#1f2937" stroke="#4b5563" strokeWidth="1" />
      <circle cx="90" cy="32" r="7" fill="#27272a" />
      <circle cx="90" cy="32" r="1.5" fill="#dc2626" />
      {/* Mixer in center */}
      <rect x="48" y="27" width="24" height="10" rx="1" fill="#374151" />
      {/* Mixer faders */}
      {[52, 56, 60, 64, 68].map((x) => (
        <rect key={x} x={x} y="29" width="2" height="6" rx="0.5" fill="#22c55e" />
      ))}
      {/* Crossfader */}
      <rect x="52" y="38" width="16" height="3" rx="1" fill="#4b5563" />
      <rect x="58" y="37" width="4" height="5" rx="1" fill="#ef4444" />
      {/* LED strip */}
      <rect x="10" y="55" width="100" height="3" rx="1" fill="#7c3aed">
        <animate attributeName="fill" values="#7c3aed;#3b82f6;#22c55e;#eab308;#7c3aed" dur="2s" repeatCount="indefinite" />
      </rect>
      {/* Status overlay */}
      <rect x="5" y="25" width="110" height="40" rx="4" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Photo Booth - Curtained booth with camera
 */
export function PhotoBoothVisual({
  width = 80,
  height = 100,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 80 100"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Booth frame */}
      <rect x="5" y="5" width="70" height="90" rx="4" fill="#1e293b" stroke={stroke} strokeWidth="2" />
      {/* Curtain top bar */}
      <rect x="10" y="8" width="60" height="4" rx="1" fill="#7c2d12" />
      {/* Curtains */}
      <path d="M10 12 Q15 50 10 95 L10 12" fill="#dc2626" />
      <path d="M70 12 Q65 50 70 95 L70 12" fill="#dc2626" />
      {/* Curtain folds */}
      <path d="M10 12 Q20 40 15 95" fill="none" stroke="#b91c1c" strokeWidth="1" />
      <path d="M70 12 Q60 40 65 95" fill="none" stroke="#b91c1c" strokeWidth="1" />
      {/* Interior */}
      <rect x="18" y="12" width="44" height="80" fill="#0f172a" />
      {/* Camera/screen */}
      <rect x="28" y="20" width="24" height="18" rx="2" fill="#1f2937" stroke="#4b5563" strokeWidth="1" />
      <circle cx="40" cy="29" r="5" fill="#374151" stroke="#4b5563" strokeWidth="1" />
      <circle cx="40" cy="29" r="2" fill="#0f172a" />
      {/* Flash */}
      <rect x="35" y="42" width="10" height="4" rx="1" fill="#fef08a" opacity="0.8" />
      {/* Bench */}
      <rect x="22" y="75" width="36" height="8" rx="2" fill="#4b5563" />
      {/* "PHOTOS" sign */}
      <rect x="25" y="1" width="30" height="8" rx="2" fill="#f59e0b" />
      <text x="40" y="7" fontSize="5" fill="white" textAnchor="middle" fontWeight="bold">PHOTOS</text>
      {/* Status overlay */}
      <rect x="18" y="12" width="44" height="80" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * Generic Game Table - Flexible table for card games, board games, etc.
 */
export function GameTableVisual({
  width = 100,
  height = 100,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 100 100"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Table */}
      <circle cx="50" cy="50" r="45" fill="#1e293b" stroke={stroke} strokeWidth="2" />
      {/* Felt surface */}
      <circle cx="50" cy="50" r="38" fill="#166534" />
      {/* Card/chip spots */}
      {[0, 60, 120, 180, 240, 300].map((angle, i) => {
        const rad = (angle * Math.PI) / 180
        const x = 50 + Math.cos(rad) * 28
        const y = 50 + Math.sin(rad) * 28
        return (
          <rect
            key={i}
            x={x - 8}
            y={y - 5}
            width="16"
            height="10"
            rx="2"
            fill="#15803d"
            stroke="#14532d"
            strokeWidth="0.5"
            transform={`rotate(${angle}, ${x}, ${y})`}
          />
        )
      })}
      {/* Center logo area */}
      <circle cx="50" cy="50" r="10" fill="#14532d" />
      {/* Status overlay */}
      <circle cx="50" cy="50" r="45" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

/**
 * VR Station - Virtual reality gaming station
 */
export function VRStationVisual({
  width = 90,
  height = 90,
  fillColor,
  strokeColor,
  status = 'available',
  className,
}: VisualProps) {
  const stroke = strokeColor || STATUS_STROKES[status]
  const fill = fillColor || STATUS_FILLS[status]

  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 90 90"
      className={className}
      style={{ overflow: 'visible' }}
    >
      {/* Play area boundary */}
      <rect x="5" y="5" width="80" height="80" rx="4" fill="none" stroke={stroke} strokeWidth="2" strokeDasharray="8 4" />
      {/* Play mat */}
      <rect x="15" y="15" width="60" height="60" rx="2" fill="#1e293b" />
      {/* Grid lines */}
      {[30, 45, 60].map((pos) => (
        <g key={pos}>
          <line x1={pos} y1="15" x2={pos} y2="75" stroke="#334155" strokeWidth="0.5" />
          <line x1="15" y1={pos} x2="75" y2={pos} stroke="#334155" strokeWidth="0.5" />
        </g>
      ))}
      {/* VR headset icon in center */}
      <ellipse cx="45" cy="45" rx="15" ry="10" fill="#4b5563" stroke="#6b7280" strokeWidth="1" />
      <rect x="32" y="40" width="10" height="8" rx="2" fill="#1f2937" />
      <rect x="48" y="40" width="10" height="8" rx="2" fill="#1f2937" />
      <rect x="42" y="48" width="6" height="4" rx="1" fill="#374151" />
      {/* Sensors in corners */}
      {[[12, 12], [78, 12], [12, 78], [78, 78]].map(([cx, cy], i) => (
        <circle key={i} cx={cx} cy={cy} r="4" fill="#7c3aed">
          <animate attributeName="opacity" values="1;0.5;1" dur="1.5s" repeatCount="indefinite" begin={`${i * 0.3}s`} />
        </circle>
      ))}
      {/* Status overlay */}
      <rect x="15" y="15" width="60" height="60" rx="2" fill={fill} style={{ pointerEvents: 'none' }} />
    </svg>
  )
}

// ============================================
// VISUAL TYPE REGISTRY
// ============================================

export const ENTERTAINMENT_VISUALS = {
  pool_table: PoolTableVisual,
  dartboard: DartboardVisual,
  arcade: ArcadeVisual,
  foosball: FoosballVisual,
  shuffleboard: ShuffleboardVisual,
  ping_pong: PingPongVisual,
  bowling_lane: BowlingLaneVisual,
  karaoke_stage: KaraokeStageVisual,
  dj_booth: DJBoothVisual,
  photo_booth: PhotoBoothVisual,
  game_table: GameTableVisual,
  vr_station: VRStationVisual,
} as const

export type EntertainmentVisualType = keyof typeof ENTERTAINMENT_VISUALS

export const ENTERTAINMENT_VISUAL_OPTIONS: { value: EntertainmentVisualType; label: string; defaultWidth: number; defaultHeight: number }[] = [
  { value: 'pool_table', label: 'Pool Table', defaultWidth: 160, defaultHeight: 90 },
  { value: 'dartboard', label: 'Dartboard', defaultWidth: 80, defaultHeight: 80 },
  { value: 'arcade', label: 'Arcade Cabinet', defaultWidth: 60, defaultHeight: 90 },
  { value: 'foosball', label: 'Foosball Table', defaultWidth: 140, defaultHeight: 80 },
  { value: 'shuffleboard', label: 'Shuffleboard', defaultWidth: 200, defaultHeight: 50 },
  { value: 'ping_pong', label: 'Ping Pong Table', defaultWidth: 140, defaultHeight: 80 },
  { value: 'bowling_lane', label: 'Bowling Lane', defaultWidth: 220, defaultHeight: 45 },
  { value: 'karaoke_stage', label: 'Karaoke Stage', defaultWidth: 100, defaultHeight: 80 },
  { value: 'dj_booth', label: 'DJ Booth', defaultWidth: 120, defaultHeight: 70 },
  { value: 'photo_booth', label: 'Photo Booth', defaultWidth: 80, defaultHeight: 100 },
  { value: 'game_table', label: 'Game Table', defaultWidth: 100, defaultHeight: 100 },
  { value: 'vr_station', label: 'VR Station', defaultWidth: 90, defaultHeight: 90 },
]

/**
 * Render the appropriate visual for a given type
 */
export function EntertainmentVisual({
  visualType,
  ...props
}: VisualProps & { visualType: EntertainmentVisualType }) {
  const Component = ENTERTAINMENT_VISUALS[visualType]
  if (!Component) {
    // Fallback to game table for unknown types
    return <GameTableVisual {...props} />
  }
  return <Component {...props} />
}



################################################################################
# FILE: src/components/floor-plan/ExistingOrdersModal.tsx
################################################################################

'use client'

import { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { XMarkIcon, ArrowRightIcon, CreditCardIcon } from '@heroicons/react/24/outline'

interface ExistingOrder {
  tableId: string
  tableName: string
  orderId: string
  orderNumber: number
  itemCount: number
  total: number
}

interface OrderAction {
  orderId: string
  action: 'merge' | 'close'
}

interface ExistingOrdersModalProps {
  isOpen: boolean
  existingOrders: ExistingOrder[]
  primaryTableName: string
  onConfirm: (actions: OrderAction[]) => void
  onCancel: () => void
  onCloseOrder: (orderId: string) => void
  isProcessing?: boolean
}

export function ExistingOrdersModal({
  isOpen,
  existingOrders,
  primaryTableName,
  onConfirm,
  onCancel,
  onCloseOrder,
  isProcessing = false,
}: ExistingOrdersModalProps) {
  const [orderActions, setOrderActions] = useState<Map<string, 'merge' | 'close'>>(
    new Map(existingOrders.map(o => [o.orderId, 'merge']))
  )

  if (!isOpen) return null

  const handleActionChange = (orderId: string, action: 'merge' | 'close') => {
    const newActions = new Map(orderActions)
    newActions.set(orderId, action)
    setOrderActions(newActions)
  }

  const handleConfirm = () => {
    // Check if any orders are set to 'close'
    const ordersToClose = existingOrders.filter(
      o => orderActions.get(o.orderId) === 'close'
    )

    if (ordersToClose.length > 0) {
      // Close each order first
      ordersToClose.forEach(o => onCloseOrder(o.orderId))
    }

    // Build actions array for merge only
    const actions: OrderAction[] = []
    for (const order of existingOrders) {
      const action = orderActions.get(order.orderId)
      if (action === 'merge') {
        actions.push({ orderId: order.orderId, action: 'merge' })
      }
    }

    onConfirm(actions)
  }

  const allMerge = existingOrders.every(o => orderActions.get(o.orderId) === 'merge')
  const hasCloseActions = existingOrders.some(o => orderActions.get(o.orderId) === 'close')

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
        onClick={onCancel}
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.95, opacity: 0 }}
          transition={{ type: 'spring', damping: 25, stiffness: 300 }}
          className="w-full max-w-lg mx-4 bg-slate-900 rounded-2xl shadow-2xl border border-slate-700/50 overflow-hidden"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Header */}
          <div className="flex items-center justify-between px-6 py-4 border-b border-slate-700/50">
            <div>
              <h2 className="text-lg font-semibold text-white">
                Existing Orders Found
              </h2>
              <p className="text-sm text-slate-400">
                These tables have open orders. How should they be handled?
              </p>
            </div>
            <button
              onClick={onCancel}
              className="p-2 text-slate-400 hover:text-white hover:bg-slate-700 rounded-lg transition-colors"
            >
              <XMarkIcon className="w-5 h-5" />
            </button>
          </div>

          {/* Order list */}
          <div className="px-6 py-4 space-y-3 max-h-80 overflow-y-auto">
            {existingOrders.map((order) => {
              const currentAction = orderActions.get(order.orderId) || 'merge'

              return (
                <div
                  key={order.orderId}
                  className="p-4 bg-slate-800/50 rounded-xl border border-slate-700/50"
                >
                  <div className="flex items-center justify-between mb-3">
                    <div>
                      <span className="font-medium text-white">{order.tableName}</span>
                      <span className="ml-2 text-sm text-slate-400">
                        Order #{order.orderNumber}
                      </span>
                    </div>
                    <div className="text-right">
                      <div className="text-lg font-semibold text-white">
                        ${order.total.toFixed(2)}
                      </div>
                      <div className="text-xs text-slate-400">
                        {order.itemCount} item{order.itemCount !== 1 ? 's' : ''}
                      </div>
                    </div>
                  </div>

                  {/* Action buttons */}
                  <div className="flex gap-2">
                    <button
                      onClick={() => handleActionChange(order.orderId, 'merge')}
                      className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all ${
                        currentAction === 'merge'
                          ? 'bg-cyan-500 text-white'
                          : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                      }`}
                    >
                      <ArrowRightIcon className="w-4 h-4" />
                      Add to Group
                    </button>
                    <button
                      onClick={() => handleActionChange(order.orderId, 'close')}
                      className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all ${
                        currentAction === 'close'
                          ? 'bg-amber-500 text-white'
                          : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                      }`}
                    >
                      <CreditCardIcon className="w-4 h-4" />
                      Close Out
                    </button>
                  </div>
                </div>
              )
            })}
          </div>

          {/* Footer */}
          <div className="px-6 py-4 border-t border-slate-700/50 bg-slate-800/30">
            <div className="flex items-center justify-between">
              <div className="text-sm text-slate-400">
                {allMerge ? (
                  <>All items will merge into <span className="text-cyan-400">{primaryTableName}</span></>
                ) : hasCloseActions ? (
                  <>Some orders will be closed out first</>
                ) : (
                  <>Configure how to handle each order</>
                )}
              </div>
              <div className="flex gap-3">
                <button
                  onClick={onCancel}
                  className="px-4 py-2 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleConfirm}
                  disabled={isProcessing}
                  className={`px-4 py-2 rounded-lg font-medium transition-all ${
                    isProcessing
                      ? 'bg-slate-700 text-slate-400 cursor-wait'
                      : 'bg-cyan-500 text-white hover:bg-cyan-400'
                  }`}
                >
                  {isProcessing ? 'Processing...' : 'Continue'}
                </button>
              </div>
            </div>
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/FloorPlanEntertainment.tsx
################################################################################

'use client'

import { useRef, useState, useCallback } from 'react'
import { motion } from 'framer-motion'
import { EntertainmentVisual } from './entertainment-visuals'
import type { FloorPlanElement, ElementStatus } from './use-floor-plan'

interface FloorPlanEntertainmentProps {
  element: FloorPlanElement
  isSelected: boolean
  mode: 'admin' | 'service'
  onSelect: () => void
  onPositionChange?: (posX: number, posY: number) => void
  onSizeChange?: (width: number, height: number) => void
  onRotationChange?: (rotation: number) => void
  onDelete?: () => void
}

// Status colors for the glow effect
const STATUS_COLORS: Record<ElementStatus, string> = {
  available: '#22c55e', // green
  in_use: '#f59e0b', // amber
  reserved: '#6366f1', // indigo
  maintenance: '#ef4444', // red
}

export function FloorPlanEntertainment({
  element,
  isSelected,
  mode,
  onSelect,
  onPositionChange,
  onSizeChange,
  onRotationChange,
  onDelete,
}: FloorPlanEntertainmentProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const [isResizing, setIsResizing] = useState(false)
  const [isRotating, setIsRotating] = useState(false)
  const [resizeStart, setResizeStart] = useState({ x: 0, y: 0, width: 0, height: 0 })

  // Calculate time remaining for sessions
  const getTimeRemaining = useCallback(() => {
    if (!element.sessionExpiresAt) return null
    const expiresAt = new Date(element.sessionExpiresAt).getTime()
    const now = Date.now()
    const remaining = expiresAt - now
    if (remaining <= 0) return 'EXPIRED'
    const minutes = Math.floor(remaining / 60000)
    const seconds = Math.floor((remaining % 60000) / 1000)
    return `${minutes}:${seconds.toString().padStart(2, '0')}`
  }, [element.sessionExpiresAt])

  // Handle resize start
  const handleResizeStart = useCallback(
    (e: React.MouseEvent, corner: string) => {
      if (mode !== 'admin') return
      e.stopPropagation()
      e.preventDefault()
      setIsResizing(true)
      setResizeStart({
        x: e.clientX,
        y: e.clientY,
        width: element.width,
        height: element.height,
      })

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const deltaX = moveEvent.clientX - e.clientX
        const deltaY = moveEvent.clientY - e.clientY

        let newWidth = resizeStart.width
        let newHeight = resizeStart.height

        if (corner.includes('e')) newWidth = Math.max(60, element.width + deltaX)
        if (corner.includes('w')) newWidth = Math.max(60, element.width - deltaX)
        if (corner.includes('s')) newHeight = Math.max(60, element.height + deltaY)
        if (corner.includes('n')) newHeight = Math.max(60, element.height - deltaY)

        onSizeChange?.(newWidth, newHeight)
      }

      const handleMouseUp = () => {
        setIsResizing(false)
        window.removeEventListener('mousemove', handleMouseMove)
        window.removeEventListener('mouseup', handleMouseUp)
      }

      window.addEventListener('mousemove', handleMouseMove)
      window.addEventListener('mouseup', handleMouseUp)
    },
    [mode, element.width, element.height, onSizeChange, resizeStart.width, resizeStart.height]
  )

  // Handle rotation start
  const handleRotateStart = useCallback(
    (e: React.MouseEvent) => {
      if (mode !== 'admin' || !containerRef.current) return
      e.stopPropagation()
      e.preventDefault()
      setIsRotating(true)

      // Get center of element
      const rect = containerRef.current.getBoundingClientRect()
      const centerX = rect.left + rect.width / 2
      const centerY = rect.top + rect.height / 2

      // Track last valid angle to prevent jumps
      let lastValidAngle = element.rotation || 0

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const dx = moveEvent.clientX - centerX
        const dy = moveEvent.clientY - centerY
        const distance = Math.sqrt(dx * dx + dy * dy)

        // Only rotate if mouse is at least 30px from center
        // This prevents hyper-sensitive rotation when close to center
        const minRadius = 30
        if (distance < minRadius) return

        // Calculate angle from center to mouse position
        const angle = Math.atan2(dy, dx)
        // Convert to degrees and adjust (handle is at top, so offset by +90)
        let degrees = (angle * 180) / Math.PI + 90
        // Normalize to 0-360
        if (degrees < 0) degrees += 360

        // Snap to 15-degree increments for easier alignment
        const snappedDegrees = Math.round(degrees / 15) * 15
        lastValidAngle = snappedDegrees % 360
        onRotationChange?.(lastValidAngle)
      }

      const handleMouseUp = () => {
        setIsRotating(false)
        window.removeEventListener('mousemove', handleMouseMove)
        window.removeEventListener('mouseup', handleMouseUp)
      }

      window.addEventListener('mousemove', handleMouseMove)
      window.addEventListener('mouseup', handleMouseUp)
    },
    [mode, onRotationChange, element.rotation]
  )

  const status = element.status as ElementStatus
  const statusColor = STATUS_COLORS[status] || STATUS_COLORS.available
  const timeRemaining = getTimeRemaining()

  return (
    <div
      ref={containerRef}
      onClick={(e) => {
        e.stopPropagation()
        onSelect()
      }}
      style={{
        width: element.width,
        height: element.height,
        position: 'relative',
        cursor: mode === 'admin' ? 'grab' : 'pointer',
      }}
    >
      {/* Glow effect based on status */}
      <div
        style={{
          position: 'absolute',
          inset: -4,
          borderRadius: 12,
          opacity: isSelected ? 0.6 : 0.3,
          background: `radial-gradient(ellipse at center, ${statusColor}40 0%, transparent 70%)`,
          transition: 'opacity 0.2s',
          pointerEvents: 'none',
        }}
      />

      {/* Selection ring */}
      {isSelected && (
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          style={{
            position: 'absolute',
            inset: -3,
            borderRadius: 10,
            border: '2px solid rgba(99, 102, 241, 0.8)',
            boxShadow: '0 0 12px rgba(99, 102, 241, 0.4)',
            pointerEvents: 'none',
          }}
        />
      )}

      {/* Main visual container */}
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          borderRadius: 8,
          background: 'rgba(15, 23, 42, 0.8)',
          border: `1px solid ${isSelected ? 'rgba(99, 102, 241, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
          overflow: 'hidden',
          transition: 'border-color 0.2s',
        }}
      >
        {/* SVG Visual - rotates independently */}
        <div
          style={{
            flex: 1,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: 8,
            transform: `rotate(${element.rotation || 0}deg)`,
            transition: 'transform 0.15s ease-out',
          }}
        >
          <EntertainmentVisual
            visualType={element.visualType as any}
            width={element.width - 16}
            height={element.height - 40}
            status={status}
          />
        </div>

        {/* Label - stays fixed at bottom */}
        <div
          style={{
            width: '100%',
            padding: '4px 8px',
            background: 'rgba(0, 0, 0, 0.4)',
            textAlign: 'center',
          }}
        >
          <span
            style={{
              fontSize: 10,
              fontWeight: 600,
              color: '#e2e8f0',
              textTransform: 'uppercase',
              letterSpacing: '0.05em',
            }}
          >
            {element.abbreviation || element.name}
          </span>
        </div>
      </div>

      {/* Status badge */}
      <div
        style={{
          position: 'absolute',
          top: -8,
          right: -8,
          width: 16,
          height: 16,
          borderRadius: '50%',
          background: statusColor,
          border: '2px solid rgba(15, 23, 42, 0.9)',
          boxShadow: `0 0 8px ${statusColor}60`,
        }}
      />

      {/* Time remaining badge (for in_use status) */}
      {status === 'in_use' && timeRemaining && (
        <div
          style={{
            position: 'absolute',
            top: -6,
            left: '50%',
            transform: 'translateX(-50%)',
            padding: '2px 8px',
            borderRadius: 8,
            background: timeRemaining === 'EXPIRED' ? '#ef4444' : '#f59e0b',
            fontSize: 10,
            fontWeight: 700,
            color: '#fff',
            whiteSpace: 'nowrap',
            boxShadow: '0 2px 8px rgba(0, 0, 0, 0.3)',
          }}
        >
          {timeRemaining}
        </div>
      )}

      {/* Waitlist badge */}
      {element.waitlistCount > 0 && (
        <div
          style={{
            position: 'absolute',
            bottom: -6,
            right: -6,
            minWidth: 20,
            height: 20,
            borderRadius: 10,
            background: '#6366f1',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: 10,
            fontWeight: 700,
            color: '#fff',
            padding: '0 6px',
            boxShadow: '0 2px 8px rgba(99, 102, 241, 0.4)',
          }}
        >
          {element.waitlistCount}
        </div>
      )}

      {/* Resize handles (admin mode only) */}
      {mode === 'admin' && isSelected && (
        <>
          {/* Corner handles */}
          {['nw', 'ne', 'sw', 'se'].map((corner) => (
            <div
              key={corner}
              onMouseDown={(e) => handleResizeStart(e, corner)}
              style={{
                position: 'absolute',
                width: 10,
                height: 10,
                background: '#6366f1',
                border: '2px solid #fff',
                borderRadius: 2,
                cursor: `${corner}-resize`,
                ...(corner.includes('n') ? { top: -5 } : { bottom: -5 }),
                ...(corner.includes('w') ? { left: -5 } : { right: -5 }),
              }}
            />
          ))}

          {/* Rotation handle */}
          {onRotationChange && (
            <>
              {/* Line from center-top to rotation handle - extended for easier grabbing */}
              <div
                style={{
                  position: 'absolute',
                  top: -48,
                  left: '50%',
                  transform: 'translateX(-50%)',
                  width: 2,
                  height: 40,
                  background: 'rgba(99, 102, 241, 0.6)',
                  pointerEvents: 'none',
                }}
              />
              {/* Rotation handle circle - larger and further out */}
              <div
                onMouseDown={handleRotateStart}
                style={{
                  position: 'absolute',
                  top: -62,
                  left: '50%',
                  transform: 'translateX(-50%)',
                  width: 24,
                  height: 24,
                  borderRadius: '50%',
                  background: isRotating ? '#818cf8' : '#6366f1',
                  border: '2px solid #fff',
                  cursor: 'grab',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  boxShadow: '0 2px 8px rgba(99, 102, 241, 0.4)',
                  transition: 'background 0.15s',
                }}
              >
                {/* Rotation icon */}
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2.5">
                  <path d="M23 4v6h-6M1 20v-6h6" strokeLinecap="round" strokeLinejoin="round" />
                  <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15" strokeLinecap="round" strokeLinejoin="round" />
                </svg>
              </div>
            </>
          )}

          {/* Delete button */}
          {onDelete && (
            <button
              onClick={(e) => {
                e.stopPropagation()
                if (confirm('Delete this element?')) {
                  onDelete()
                }
              }}
              style={{
                position: 'absolute',
                top: -12,
                left: -12,
                width: 24,
                height: 24,
                borderRadius: '50%',
                background: '#ef4444',
                border: '2px solid #fff',
                color: '#fff',
                fontSize: 14,
                fontWeight: 700,
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                boxShadow: '0 2px 8px rgba(239, 68, 68, 0.4)',
              }}
            >
              
            </button>
          )}
        </>
      )}
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/FloorPlanHome.tsx
################################################################################

'use client'

import { useEffect, useState, useCallback, useRef, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { useFloorPlanStore, FloorPlanTable, FloorPlanElement } from './use-floor-plan'
import { FloorPlanEntertainment } from './FloorPlanEntertainment'
import { TableNode, getCombinedGroupColor } from './TableNode'
import { TableInfoPanel } from './TableInfoPanel'
import { CategoriesBar } from './CategoriesBar'
import { VirtualCombineBar } from './VirtualCombineBar'
import { ExistingOrdersModal } from './ExistingOrdersModal'
import { VirtualGroupManagerModal } from './VirtualGroupManagerModal'
import { RoomTabs } from './RoomTabs'
import { RoomReorderModal } from './RoomReorderModal'
import { useFloorPlanAutoScale, useFloorPlanDrag } from './hooks'
import { calculateAttachSide, calculateAttachPosition } from './table-positioning'
import { getCombinedGroupTables, calculatePerimeterCapacity } from '@/lib/table-geometry'
import { toTableRect, toTableRectArray } from '@/lib/table-utils'
import {
  generateVirtualSeatPositions,
  type TableForPerimeter,
  type VirtualSeatPosition,
} from '@/domains/floor-plan/groups'
import { usePOSLayout } from '@/hooks/usePOSLayout'
import { QuickAccessBar } from '@/components/pos/QuickAccessBar'
import { MenuItemContextMenu } from '@/components/pos/MenuItemContextMenu'
import { StockBadge } from '@/components/menu/StockBadge'
import { CompVoidModal } from '@/components/orders/CompVoidModal'
import { SplitTicketManager } from '@/components/orders/SplitTicketManager'
import { OrderPanel, type OrderPanelItemData } from '@/components/orders/OrderPanel'
import type { PizzaOrderConfig } from '@/types'
import { toast } from '@/stores/toast-store'
import { useOrderStore } from '@/stores/order-store'
import { useEvents } from '@/lib/events'
import { useMenuSearch } from '@/hooks/useMenuSearch'
import { MenuSearchInput, MenuSearchResults } from '@/components/search'
import './styles/floor-plan.css'

interface Category {
  id: string
  name: string
  color?: string
  itemCount?: number
  categoryType?: string
}

interface MenuItem {
  id: string
  name: string
  price: number
  description?: string
  categoryId: string
  categoryType?: string // 'food' | 'pizza' | 'entertainment' | etc.
  hasModifiers?: boolean
  isPizza?: boolean
  itemType?: string // 'standard' | 'combo' | 'timed_rental' | 'pizza'
  entertainmentStatus?: 'available' | 'in_use' | 'maintenance'
  blockTimeMinutes?: number
  modifierGroupCount?: number
  timedPricing?: {
    per15Min?: number
    per30Min?: number
    perHour?: number
    minimum?: number
  }
  // Prep stock status (from API)
  stockStatus?: 'ok' | 'low' | 'critical' | 'out'
  stockCount?: number | null
  stockIngredientName?: string | null
  // 86 status (ingredient out of stock)
  is86d?: boolean
  reasons86d?: string[]
}

interface InlineOrderItem {
  id: string
  menuItemId: string
  name: string
  price: number
  quantity: number
  modifiers?: { id: string; name: string; price: number }[]
  specialNotes?: string
  seatNumber?: number
  sourceTableId?: string // For virtual groups - tracks which table this item was ordered from
  courseNumber?: number
  courseStatus?: 'pending' | 'fired' | 'ready' | 'served'
  isHeld?: boolean
  sentToKitchen?: boolean
  isCompleted?: boolean
  status?: 'active' | 'voided' | 'comped'
  // Timed rental / entertainment items
  isTimedRental?: boolean
  blockTimeMinutes?: number
  blockTimeStartedAt?: string
  blockTimeExpiresAt?: string
  // Item lifecycle status
  kitchenStatus?: 'pending' | 'cooking' | 'ready' | 'delivered'
  completedAt?: string
  resendCount?: number
  resendNote?: string
  createdAt?: string
}

interface OpenOrder {
  id: string
  orderNumber: number
  tableId?: string
  tableName?: string
  tabName?: string
  orderType: string
  total: number
  itemCount: number
  openedAt: string
  employeeName?: string
}

// View mode: tables (floor plan) or menu (category items)
type ViewMode = 'tables' | 'menu'

// Order type for quick order buttons
type QuickOrderType = 'takeout' | 'delivery' | 'bar_tab'

interface FloorPlanHomeProps {
  locationId: string
  employeeId: string
  employeeName: string
  employeeRole?: string
  onLogout: () => void
  onSwitchUser?: () => void
  onOpenSettings?: () => void
  onOpenAdminNav?: () => void
  isManager?: boolean
  // Payment and modifier callbacks
  onOpenPayment?: (orderId: string) => void
  onOpenModifiers?: (item: MenuItem, onComplete: (modifiers: { id: string; name: string; price: number }[]) => void, existingModifiers?: { id: string; name: string; price: number }[]) => void
  // Open Orders panel
  onOpenOrdersPanel?: () => void
  // Tabs page (for bartenders)
  onOpenTabs?: () => void
  // Switch to bartender view (speed-optimized for bar tabs)
  onSwitchToBartenderView?: () => void
  // Guest count for seat assignment (from table or default)
  defaultGuestCount?: number
  // Timed rental/entertainment modal callback
  onOpenTimedRental?: (item: MenuItem, onComplete: (price: number, blockMinutes: number) => void) => void
  // Pizza builder modal callback
  onOpenPizzaBuilder?: (item: MenuItem, onComplete: (config: PizzaOrderConfig) => void) => void
  // Order to load (from Open Orders panel) - set this to load an existing order
  orderToLoad?: { id: string; orderNumber: number; tableId?: string; tabName?: string; orderType: string } | null
  // Callback when order is loaded (to clear the orderToLoad prop)
  onOrderLoaded?: () => void
  // Order ID that was just paid - triggers clearing of order panel
  paidOrderId?: string | null
  // Callback when paid order is cleared (to reset paidOrderId prop)
  onPaidOrderCleared?: () => void
}

// Pizza order configuration (matches what pizza builder produces)
export function FloorPlanHome({
  locationId,
  employeeId,
  employeeName,
  employeeRole,
  onLogout,
  onSwitchUser,
  onOpenSettings,
  onOpenAdminNav,
  isManager = false,
  onOpenPayment,
  onOpenModifiers,
  onOpenOrdersPanel,
  onOpenTabs,
  onSwitchToBartenderView,
  defaultGuestCount = 4,
  onOpenTimedRental,
  onOpenPizzaBuilder,
  orderToLoad,
  onOrderLoaded,
  paidOrderId,
  onPaidOrderCleared,
}: FloorPlanHomeProps) {
  const containerRef = useRef<HTMLDivElement>(null)

  // View mode: tables (floor plan) or menu (category items)
  const [viewMode, setViewMode] = useState<ViewMode>('tables')

  // Categories and menu items
  const [categories, setCategories] = useState<Category[]>([])
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(null)
  const [menuItems, setMenuItems] = useState<MenuItem[]>([])
  const [loadingMenuItems, setLoadingMenuItems] = useState(false)

  // Open orders count
  const [openOrdersCount, setOpenOrdersCount] = useState(0)

  // Employee dropdown
  const [showEmployeeDropdown, setShowEmployeeDropdown] = useState(false)

  // Settings dropdown
  const [showSettingsDropdown, setShowSettingsDropdown] = useState(false)

  // Active order state (for selected table or quick order)
  const [activeTableId, setActiveTableId] = useState<string | null>(null)
  const [activeOrderId, setActiveOrderId] = useState<string | null>(null)
  const [activeOrderNumber, setActiveOrderNumber] = useState<string | null>(null)
  const [activeOrderType, setActiveOrderType] = useState<string | null>(null)
  const [inlineOrderItems, setInlineOrderItems] = useState<InlineOrderItem[]>([])
  const [showOrderPanel, setShowOrderPanel] = useState(false)
  const [isSendingOrder, setIsSendingOrder] = useState(false)
  const [pendingPayAfterSave, setPendingPayAfterSave] = useState(false)
  const [guestCount, setGuestCount] = useState(defaultGuestCount)

  // Notes editing state
  const [editingNotesItemId, setEditingNotesItemId] = useState<string | null>(null)
  const [editingNotesText, setEditingNotesText] = useState('')

  // Modifiers editing state
  const [editingModifiersItemId, setEditingModifiersItemId] = useState<string | null>(null)

  // Comp/Void modal state
  const [compVoidItem, setCompVoidItem] = useState<{
    id: string
    name: string
    price: number
    quantity: number
    modifiers: { name: string; price: number }[]
    status?: string
  } | null>(null)

  // Split ticket manager state
  const [showSplitTicketManager, setShowSplitTicketManager] = useState(false)
  const [splitItemId, setSplitItemId] = useState<string | null>(null)

  // Item controls expansion state
  const [expandedItemId, setExpandedItemId] = useState<string | null>(null)

  // Active seat for auto-assignment (null = "Shared")
  const [activeSeatNumber, setActiveSeatNumber] = useState<number | null>(null)
  // Source table for seat (for virtual groups - tracks which table the seat belongs to)
  const [activeSourceTableId, setActiveSourceTableId] = useState<string | null>(null)

  // Context menu state for menu items (right-click)
  const [contextMenu, setContextMenu] = useState<{
    x: number
    y: number
    item: MenuItem
  } | null>(null)

  // Note: Drag state (lastDropPosition) is now managed by useFloorPlanDrag hook

  // Room/section selection state
  const [selectedSectionId, setSelectedSectionId] = useState<string | null>(null)
  const [showRoomReorderModal, setShowRoomReorderModal] = useState(false)
  const [preferredRoomOrder, setPreferredRoomOrder] = useState<string[]>([])

  // Virtual group manager modal state
  const [virtualGroupManagerTableId, setVirtualGroupManagerTableId] = useState<string | null>(null)

  // Dismissed virtual group banners (auto-dismiss after 5 seconds)
  const [dismissedBanners, setDismissedBanners] = useState<Set<string>>(new Set())

  // Resend to kitchen state
  const [resendModal, setResendModal] = useState<{ itemId: string; itemName: string } | null>(null)
  const [resendNote, setResendNote] = useState('')
  const [resendLoading, setResendLoading] = useState(false)

  // TODO: May be redundant now that OrderPanel manages its own sort/highlight state
  const [itemSortDirection, setItemSortDirection] = useState<'newest-bottom' | 'newest-top'>('newest-bottom')
  // TODO: May be redundant now that OrderPanel manages its own sort/highlight state
  const [newestItemId, setNewestItemId] = useState<string | null>(null)
  // TODO: May be redundant now that OrderPanel manages its own sort/highlight state
  const prevItemCountRef2 = useRef(0)
  // TODO: May be redundant now that OrderPanel manages its own scroll ref
  const orderScrollRef = useRef<HTMLDivElement>(null)
  const newestTimerRef2 = useRef<ReturnType<typeof setTimeout> | null>(null)

  const {
    tables,
    sections,
    elements,
    selectedTableId,
    draggedTableId,
    dropTargetTableId,
    infoPanelTableId,
    undoStack,
    isLoading,
    showSeats,
    selectedSeat,
    flashingTables,
    setTables,
    setSections,
    setElements,
    selectTable,
    startDrag,
    updateDragTarget,
    endDrag,
    openInfoPanel,
    closeInfoPanel,
    addUndoAction,
    popUndoAction,
    clearExpiredUndos,
    toggleShowSeats,
    selectSeat,
    clearSelectedSeat,
    flashTableMessage,
    clearExpiredFlashes,
    setLoading,
    // Virtual combine mode
    virtualCombineMode,
    virtualCombineSelectedIds,
    virtualCombinePrimaryId,
    startVirtualCombineMode,
    toggleVirtualCombineSelection,
    cancelVirtualCombineMode,
    clearVirtualCombineMode,
    updateTablesWithVirtualGroup,
  } = useFloorPlanStore()

  // Virtual group perimeter seats data - calculated from tables in virtual groups
  // This enables seats to be distributed around the combined perimeter of grouped tables
  // Two modes:
  // - Static (long-hold): Tables stay in place, keep their own seats, just get colored glow
  // - Snapped (drag-drop): Tables visually snap together, seats redistribute around perimeter
  interface VirtualGroupSeatData {
    groupId: string
    virtualSeats: VirtualSeatPosition[] // Empty for static groups
    displayName: string
    tableIds: string[]
    groupColor: string
    isStatic?: boolean // True for long-hold groups (tables keep their own seats)
  }

  // Helper to sync order data to Zustand store for cross-route persistence
  const syncOrderToStore = useCallback((data: any) => {
    useOrderStore.getState().loadOrder({
      id: data.id,
      orderNumber: data.orderNumber,
      orderType: data.orderType || 'dine_in',
      tableId: data.tableId || undefined,
      tableName: data.tableName || undefined,
      tabName: data.tabName || undefined,
      guestCount: data.guestCount || 1,
      status: data.status,
      items: (data.items || []).map((item: any) => ({
        id: item.id,
        menuItemId: item.menuItemId,
        name: item.name,
        price: Number(item.unitPrice || item.price),
        quantity: item.quantity,
        itemTotal: Number(item.itemTotal || (item.unitPrice || item.price) * item.quantity),
        specialNotes: item.specialNotes || null,
        seatNumber: item.seatNumber || null,
        courseNumber: item.courseNumber || null,
        courseStatus: item.courseStatus || null,
        isHeld: item.isHeld || false,
        holdUntil: item.holdUntil || null,
        firedAt: item.firedAt || null,
        isCompleted: item.isCompleted || false,
        completedAt: item.completedAt || null,
        resendCount: item.resendCount || 0,
        blockTimeMinutes: item.blockTimeMinutes || null,
        blockTimeStartedAt: item.blockTimeStartedAt || null,
        blockTimeExpiresAt: item.blockTimeExpiresAt || null,
        modifiers: (item.modifiers || []).map((mod: any) => ({
          id: mod.id,
          modifierId: mod.modifierId || mod.id,
          name: mod.name,
          price: Number(mod.price),
          preModifier: mod.preModifier || null,
          depth: mod.depth || 0,
        })),
      })),
      subtotal: Number(data.subtotal || 0),
      discountTotal: Number(data.discountTotal || 0),
      taxTotal: Number(data.taxTotal || data.tax || 0),
      tipTotal: Number(data.tipTotal || 0),
      total: Number(data.total || 0),
      notes: data.notes || undefined,
    })
  }, [])

  // Helper function to calculate snap position for a secondary table relative to a primary table
  // Used when tables don't have stored visual offsets
  const calculateSnapPositionForTable = useCallback((
    secondary: FloorPlanTable,
    primary: FloorPlanTable
  ): { x: number; y: number } => {
    // Calculate centers
    const primaryCenterX = primary.posX + primary.width / 2
    const primaryCenterY = primary.posY + primary.height / 2
    const secondaryCenterX = secondary.posX + secondary.width / 2
    const secondaryCenterY = secondary.posY + secondary.height / 2

    // Determine which edge to snap to based on relative position
    const dx = secondaryCenterX - primaryCenterX
    const dy = secondaryCenterY - primaryCenterY

    // Determine primary direction (horizontal or vertical)
    const isHorizontal = Math.abs(dx) > Math.abs(dy)

    let snapX: number
    let snapY: number

    if (isHorizontal) {
      if (dx > 0) {
        // Secondary is to the RIGHT of primary - snap to primary's right edge
        snapX = primary.posX + primary.width  // Left edge of secondary touches right edge of primary
      } else {
        // Secondary is to the LEFT of primary - snap to primary's left edge
        snapX = primary.posX - secondary.width  // Right edge of secondary touches left edge of primary
      }
      // Align centers vertically (with small offset to preserve original offset)
      const verticalOffset = Math.min(Math.abs(dy), Math.min(primary.height, secondary.height) * 0.3)
      snapY = primary.posY + (primary.height - secondary.height) / 2 + (dy > 0 ? verticalOffset : -verticalOffset) * 0.5
    } else {
      if (dy > 0) {
        // Secondary is BELOW primary - snap to primary's bottom edge
        snapY = primary.posY + primary.height  // Top edge of secondary touches bottom edge of primary
      } else {
        // Secondary is ABOVE primary - snap to primary's top edge
        snapY = primary.posY - secondary.height  // Bottom edge of secondary touches top edge of primary
      }
      // Align centers horizontally (with small offset to preserve original offset)
      const horizontalOffset = Math.min(Math.abs(dx), Math.min(primary.width, secondary.width) * 0.3)
      snapX = primary.posX + (primary.width - secondary.width) / 2 + (dx > 0 ? horizontalOffset : -horizontalOffset) * 0.5
    }

    return { x: snapX, y: snapY }
  }, [])

  // Helper function to calculate snap position for a table joining an existing group with multiple tables
  // Finds the nearest already-positioned table and snaps to it
  const calculateSnapPositionForTableInGroup = useCallback((
    newTable: FloorPlanTable,
    primaryTable: FloorPlanTable,
    allGroupTables: FloorPlanTable[],
    currentOffsets: Map<string, { offsetX: number; offsetY: number }>
  ): { x: number; y: number } => {
    // Get all tables that already have positions calculated (including primary)
    const positionedTables = allGroupTables.filter(t =>
      t.id === primaryTable.id || currentOffsets.has(t.id)
    )

    if (positionedTables.length === 0) {
      // Fallback to primary
      return calculateSnapPositionForTable(newTable, primaryTable)
    }

    // Find the nearest positioned table to snap to
    let nearestTable = primaryTable
    let nearestDistance = Infinity

    for (const table of positionedTables) {
      const offset = currentOffsets.get(table.id) || { offsetX: 0, offsetY: 0 }
      const visualX = table.posX + offset.offsetX
      const visualY = table.posY + offset.offsetY

      // Calculate distance from new table's original position to this positioned table
      const dx = newTable.posX - visualX
      const dy = newTable.posY - visualY
      const distance = Math.sqrt(dx * dx + dy * dy)

      if (distance < nearestDistance) {
        nearestDistance = distance
        nearestTable = table
      }
    }

    // Create a virtual table with the visual position for snapping
    const nearestOffset = currentOffsets.get(nearestTable.id) || { offsetX: 0, offsetY: 0 }
    const virtualNearestTable: FloorPlanTable = {
      ...nearestTable,
      posX: nearestTable.posX + nearestOffset.offsetX,
      posY: nearestTable.posY + nearestOffset.offsetY,
    }

    return calculateSnapPositionForTable(newTable, virtualNearestTable)
  }, [calculateSnapPositionForTable])

  // Determine which virtual groups are "snapped" (drag-drop) vs "static" (long-hold)
  // Snapped groups have non-zero offsets and redistribute seats around perimeter
  // Static groups keep tables in place with their original seats
  const snappedGroupIds = useMemo(() => {
    const snapped = new Set<string>()
    tables.forEach(t => {
      if (t.virtualGroupId) {
        // If any table in the group has non-zero offsets, it's a snapped group
        if (t.virtualGroupOffsetX != null && t.virtualGroupOffsetY != null &&
            (t.virtualGroupOffsetX !== 0 || t.virtualGroupOffsetY !== 0)) {
          snapped.add(t.virtualGroupId)
        }
      }
    })
    return snapped
  }, [tables])

  const virtualGroupSeats = useMemo<Map<string, VirtualGroupSeatData>>(() => {
    const groups = new Map<string, VirtualGroupSeatData>()

    // Find all unique virtual group IDs
    const groupIds = new Set<string>()
    tables.forEach(t => {
      if (t.virtualGroupId) groupIds.add(t.virtualGroupId)
    })

    // Calculate virtual seats for each group
    groupIds.forEach(groupId => {
      const groupTables = tables.filter(t => t.virtualGroupId === groupId)
      if (groupTables.length < 2) return // Need at least 2 tables for virtual group

      // Find primary table
      const primaryTable = groupTables.find(t => t.virtualGroupPrimary) || groupTables[0]
      const groupColor = primaryTable.virtualGroupColor || '#06b6d4'

      // Check if this is a snapped (drag-drop) group or static (long-hold) group
      const isSnappedGroup = snappedGroupIds.has(groupId)

      // For STATIC groups (long-hold): tables stay in place, no perimeter seat redistribution
      // Just store group info for coloring/display purposes
      if (!isSnappedGroup) {
        // Count total seats across all tables in the group
        const totalSeats = groupTables.reduce((sum, t) => sum + (t.seats?.length || 0), 0)
        const names = groupTables.map(t => t.name)
        const displayName = names.length === 2
          ? `${names[0]} & ${names[1]}  Party of ${totalSeats}`
          : `${names.slice(0, -1).join(', ')} & ${names[names.length - 1]}  Party of ${totalSeats}`

        groups.set(groupId, {
          groupId,
          virtualSeats: [], // No perimeter seats for static groups
          displayName,
          tableIds: groupTables.map(t => t.id),
          groupColor,
          isStatic: true, // Flag to indicate tables keep their own seats
        })
        return
      }

      // For SNAPPED groups (drag-drop): calculate perimeter seat redistribution
      const visualOffsets = new Map<string, { offsetX: number; offsetY: number }>()

      // Primary table stays at its position (no offset)
      visualOffsets.set(primaryTable.id, { offsetX: 0, offsetY: 0 })

      // Sort secondary tables by distance from primary (closest first)
      const secondaryTables = groupTables.filter(t => t.id !== primaryTable.id)
      secondaryTables.sort((a, b) => {
        const distA = Math.sqrt(
          Math.pow(a.posX - primaryTable.posX, 2) +
          Math.pow(a.posY - primaryTable.posY, 2)
        )
        const distB = Math.sqrt(
          Math.pow(b.posX - primaryTable.posX, 2) +
          Math.pow(b.posY - primaryTable.posY, 2)
        )
        return distA - distB
      })

      // Calculate offset for each secondary table
      secondaryTables.forEach(table => {
        // Use DB-stored offsets
        if (table.virtualGroupOffsetX != null && table.virtualGroupOffsetY != null) {
          visualOffsets.set(table.id, {
            offsetX: table.virtualGroupOffsetX,
            offsetY: table.virtualGroupOffsetY,
          })
          return
        }

        // Fallback: Auto-calculate snap position
        const snapPos = calculateSnapPositionForTableInGroup(
          table,
          primaryTable,
          groupTables,
          visualOffsets
        )
        visualOffsets.set(table.id, {
          offsetX: snapPos.x - table.posX,
          offsetY: snapPos.y - table.posY,
        })
      })

      // Build tables for perimeter calculation using visual (snapped) positions
      const tablesForPerimeter: TableForPerimeter[] = groupTables.map(t => {
        const offset = visualOffsets.get(t.id) || { offsetX: 0, offsetY: 0 }
        return {
          id: t.id,
          name: t.name,
          posX: t.posX + offset.offsetX,
          posY: t.posY + offset.offsetY,
          width: t.width,
          height: t.height,
          rotation: t.rotation,
          seats: (t.seats || []).map(s => ({
            id: s.id,
            seatNumber: s.seatNumber,
            label: s.label,
            relativeX: s.relativeX,
            relativeY: s.relativeY,
          })),
        }
      })

      // Generate perimeter seats around the combined shape
      const virtualSeats = generateVirtualSeatPositions(tablesForPerimeter, 22)

      // Build display name
      const names = groupTables.map(t => t.name)
      const totalSeats = virtualSeats.length
      const displayName = names.length === 2
        ? `${names[0]} & ${names[1]}  Party of ${totalSeats}`
        : `${names.slice(0, -1).join(', ')} & ${names[names.length - 1]}  Party of ${totalSeats}`

      groups.set(groupId, {
        groupId,
        virtualSeats,
        displayName,
        tableIds: groupTables.map(t => t.id),
        groupColor,
        isStatic: false,
      })
    })

    return groups
  }, [tables, snappedGroupIds, calculateSnapPositionForTableInGroup])

  // Auto-scaling hook (fits floor plan to container)
  const {
    containerSize,
    tableBounds,
    autoScale,
    autoScaleOffset,
  } = useFloorPlanAutoScale({
    containerRef,
    tables,
    elements,
    selectedSectionId,
  })

  // POS Layout personalization hook (quick bar, colors, etc.)
  const {
    quickBar,
    quickBarEnabled,
    toggleQuickBar,
    addToQuickBar,
    removeFromQuickBar,
    isInQuickBar,
    menuItemColors,
    categoryColors,
    canCustomize,
    resetAllCategoryColors,
    resetAllMenuItemStyles,
  } = usePOSLayout({
    employeeId,
    locationId,
    permissions: { posLayout: ['customize_personal'] }, // Servers can customize their own layout
  })

  // Editing modes (for settings dropdown options)
  const [isEditingFavorites, setIsEditingFavorites] = useState(false)
  const [isEditingCategories, setIsEditingCategories] = useState(false)
  const [isEditingMenuItems, setIsEditingMenuItems] = useState(false)

  // Menu search
  const searchContainerRef = useRef<HTMLDivElement>(null)
  const {
    query: searchQuery,
    setQuery: setSearchQuery,
    isSearching,
    results: searchResults,
    clearSearch
  } = useMenuSearch({
    locationId,
    menuItems: menuItems.map(item => ({
      id: item.id,
      name: item.name,
      price: Number(item.price),
      categoryId: item.categoryId,
    })),
    enabled: true  // Panel is always visible, search always enabled
  })

  // Sort sections based on employee's preferred room order
  const sortedSections = useMemo(() => {
    if (preferredRoomOrder.length === 0) return sections

    return [...sections].sort((a, b) => {
      const aIndex = preferredRoomOrder.indexOf(a.id)
      const bIndex = preferredRoomOrder.indexOf(b.id)

      // Rooms in preferred order come first, in that order
      // Rooms not in preferred order come after, in original order
      if (aIndex >= 0 && bIndex >= 0) return aIndex - bIndex
      if (aIndex >= 0) return -1
      if (bIndex >= 0) return 1
      return 0
    })
  }, [sections, preferredRoomOrder])

  // Load employee's room order preferences on mount
  useEffect(() => {
    const loadPreferences = async () => {
      if (!employeeId) return
      try {
        const res = await fetch(`/api/employees/${employeeId}/preferences`)
        if (res.ok) {
          const data = await res.json()
          if (data.preferences?.preferredRoomOrder) {
            setPreferredRoomOrder(data.preferences.preferredRoomOrder)
          }
        }
      } catch (error) {
        console.error('Failed to load room preferences:', error)
      }
    }
    loadPreferences()
  }, [employeeId])

  // Initialize to first room when sections load
  useEffect(() => {
    if (sortedSections.length > 0 && selectedSectionId === null) {
      setSelectedSectionId(sortedSections[0].id)
    }
  }, [sortedSections, selectedSectionId])

  // Save room order preferences
  const handleSaveRoomOrder = useCallback(async (orderedRoomIds: string[]) => {
    if (!employeeId) return
    try {
      const res = await fetch(`/api/employees/${employeeId}/preferences`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ preferredRoomOrder: orderedRoomIds }),
      })
      if (res.ok) {
        setPreferredRoomOrder(orderedRoomIds)
        toast.success('Room order saved')
      } else {
        toast.error('Failed to save room order')
      }
    } catch (error) {
      console.error('Failed to save room order:', error)
      toast.error('Failed to save room order')
    }
  }, [employeeId])

  // Virtual combine state
  const [isCreatingVirtualGroup, setIsCreatingVirtualGroup] = useState(false)
  const [showExistingOrdersModal, setShowExistingOrdersModal] = useState(false)
  const [pendingExistingOrders, setPendingExistingOrders] = useState<Array<{
    tableId: string
    tableName: string
    orderId: string
    orderNumber: number
    itemCount: number
    total: number
  }>>([])

  // Seat management refresh trigger (Skill 121)
  const [refreshKey, setRefreshKey] = useState(0)

  // Extra virtual seats per table (for walk-up guests before order exists)
  const [extraSeats, setExtraSeats] = useState<Map<string, number>>(new Map())

  // FIX: Ref to always access latest tables data (avoids stale closure issues)
  const tablesRef = useRef(tables)
  tablesRef.current = tables

  // Ref for fixtures/elements data (for collision detection)
  const fixturesRef = useRef(elements)
  fixturesRef.current = elements

  // Auto-dismiss virtual group banners after 5 seconds
  useEffect(() => {
    const virtualGroupIds = new Set(
      tables
        .filter(t => t.virtualGroupId && t.virtualGroupPrimary)
        .map(t => t.virtualGroupId!)
    )

    if (virtualGroupIds.size === 0) return

    const timers: NodeJS.Timeout[] = []

    virtualGroupIds.forEach(groupId => {
      if (!dismissedBanners.has(groupId)) {
        const timer = setTimeout(() => {
          setDismissedBanners(prev => new Set([...prev, groupId]))
        }, 5000)
        timers.push(timer)
      }
    })

    return () => {
      timers.forEach(timer => clearTimeout(timer))
    }
  }, [tables, dismissedBanners])

  // FIX: Refs for auto-scale values (needed in handlePointerMove for coordinate transformation)
  const autoScaleRef = useRef(autoScale)
  autoScaleRef.current = autoScale
  const autoScaleOffsetRef = useRef(autoScaleOffset)
  autoScaleOffsetRef.current = autoScaleOffset

  // Helper to get best seat count - use MAX of capacity and actual seats, plus any extra virtual seats
  const getTableSeatCount = useCallback((t: FloorPlanTable): number => {
    const seatsLen = t.seats?.length || 0
    const cap = t.capacity || 0
    const extra = extraSeats.get(t.id) || 0
    return Math.max(seatsLen, cap) + extra
  }, [extraSeats])

  // Get all tables in a virtual group (returns array with primary table first)
  // FIX: Uses tablesRef.current to always access latest tables data
  const getVirtualGroupTables = useCallback((table: FloorPlanTable | null): FloorPlanTable[] => {
    if (!table) return []
    if (!table.virtualGroupId) return [table]

    // Find all tables in the same virtual group - use ref for latest data
    const groupTables = tablesRef.current.filter(t => t.virtualGroupId === table.virtualGroupId)

    // Sort so primary table is first
    return groupTables.sort((a, b) => {
      if (a.virtualGroupPrimary) return -1
      if (b.virtualGroupPrimary) return 1
      return 0
    })
  }, [])

  // Calculate total seats for a table (including combined tables or virtual group)
  // Uses perimeter-based capacity for combined groups to avoid the "8-seat" problem
  // FIX: Uses tablesRef.current to always access latest tables data (avoids stale closure)
  const getTotalSeats = useCallback((table: FloorPlanTable | null): number => {
    if (!table) return 0

    // Always use the ref to get the latest tables data
    const currentTables = tablesRef.current

    // If this is a virtual group, sum all tables in the group (including extra seats)
    if (table.virtualGroupId) {
      const groupTables = getVirtualGroupTables(table)
      const total = groupTables.reduce((sum, t) => {
        const tableSeats = getTableSeatCount(t)
        const tableExtra = extraSeats.get(t.id) || 0
        return sum + tableSeats + tableExtra
      }, 0)
      console.log(`[getTotalSeats] Virtual group ${table.name}: tables=${groupTables.length}, total=${total}`)
      return total
    }

    // FIX: If this is a CHILD of a combined group, redirect to the PRIMARY
    // This handles the case where user taps on a child table or if activeTableId is stale
    if (table.combinedWithId) {
      const primaryTable = currentTables.find(t => t.id === table.combinedWithId)
      if (primaryTable) {
        console.log(`[getTotalSeats] Redirecting from child ${table.name} to primary ${primaryTable.name}`)
        // Calculate seats from the primary's perspective
        const combinedIds = primaryTable.combinedTableIds as string[] | null
        if (combinedIds && Array.isArray(combinedIds) && combinedIds.length > 0) {
          const primarySeats = primaryTable.seats?.length || 0
          const primaryExtra = extraSeats.get(primaryTable.id) || 0
          let totalSeats = primarySeats + primaryExtra

          for (const childId of combinedIds) {
            const childTable = currentTables.find(t => t.id === childId)
            if (childTable) {
              const childSeats = childTable.seats?.length || 0
              const childExtra = extraSeats.get(childId) || 0
              totalSeats += childSeats + childExtra
            }
          }

          if (totalSeats === 0) {
            totalSeats = primaryTable.capacity || 0
          }

          console.log(`[getTotalSeats] Child ${table.name} -> Primary ${primaryTable.name}: TOTAL=${totalSeats}`)
          return totalSeats
        }
        // Primary doesn't have combinedTableIds - fall back to primary's seat count
        return getTableSeatCount(primaryTable)
      }
      // Primary not found - just return this table's count
      console.warn(`[getTotalSeats] Primary table ${table.combinedWithId} not found for child ${table.name}`)
    }

    // If this is a combined table (primary), sum seats from primary + all children
    // Use combinedTableIds directly instead of getCombinedGroupTables for reliability
    const combinedIds = table.combinedTableIds as string[] | null
    if (combinedIds && Array.isArray(combinedIds) && combinedIds.length > 0) {
      // Start with primary table's seats
      const primarySeats = table.seats?.length || 0
      const primaryExtra = extraSeats.get(table.id) || 0
      let totalSeats = primarySeats + primaryExtra

      console.log(`[getTotalSeats] Combined primary ${table.name}: seats.length=${primarySeats}, extra=${primaryExtra}, combinedIds=${combinedIds.length}`)

      // Add seats from each child table listed in combinedTableIds
      for (const childId of combinedIds) {
        const childTable = currentTables.find(t => t.id === childId)
        if (childTable) {
          const childSeats = childTable.seats?.length || 0
          const childExtra = extraSeats.get(childId) || 0
          console.log(`[getTotalSeats] + Child ${childTable.name}: seats.length=${childSeats}, extra=${childExtra}`)
          totalSeats += childSeats + childExtra
        } else {
          console.warn(`[getTotalSeats] Child table ${childId} not found in tables array! (tables count: ${currentTables.length})`)
        }
      }

      // If no actual seat records exist, fall back to primary's combined capacity
      if (totalSeats === 0) {
        totalSeats = table.capacity || 0
        console.log(`[getTotalSeats] No seats found, using capacity=${totalSeats}`)
      }

      console.log(`[getTotalSeats] Combined table ${table.name}: TOTAL=${totalSeats}`)
      return totalSeats
    }

    // Single table - use MAX of capacity and seats array length
    const seatCount = getTableSeatCount(table)
    console.log(`[getTotalSeats] Table ${table.name}: capacity=${table.capacity}, seats.length=${table.seats?.length}, returning=${seatCount}`)
    return seatCount
  }, [getTableSeatCount, getVirtualGroupTables, extraSeats])

  // Get combined table count (includes virtual groups)
  const getCombinedTableCount = useCallback((table: FloorPlanTable | null): number => {
    if (!table) return 0

    // Check virtual group first
    if (table.virtualGroupId) {
      const groupTables = getVirtualGroupTables(table)
      return groupTables.length
    }

    // Physical combine
    if (table.combinedTableIds && table.combinedTableIds.length > 0) {
      return table.combinedTableIds.length + 1 // +1 for the primary table
    }
    return 1
  }, [getVirtualGroupTables])

  // Get the active table object
  const activeTable = activeTableId ? tables.find(t => t.id === activeTableId) || null : null

  // FIX 3: Group order items by seat for display - use useMemo instead of useCallback
  // useCallback returns a function that runs on every render; useMemo caches the result
  const groupedOrderItems = useMemo(() => {
    if (!activeTable || getTotalSeats(activeTable) === 0) {
      // No seats - just return all items in one "group"
      return [{ seatNumber: null, sourceTableId: null, label: 'All Items', items: inlineOrderItems }]
    }

    const groups: { seatNumber: number | null; sourceTableId: string | null; label: string; items: InlineOrderItem[] }[] = []

    // For virtual groups, use T-S notation (e.g., T4-S1)
    const isVirtualGroup = activeTable.virtualGroupId !== null

    if (isVirtualGroup) {
      // Group by sourceTableId + seatNumber
      const seatKeys = new Map<string, InlineOrderItem[]>()

      inlineOrderItems.forEach(item => {
        if (item.seatNumber && item.sourceTableId) {
          const key = `${item.sourceTableId}-${item.seatNumber}`
          if (!seatKeys.has(key)) {
            seatKeys.set(key, [])
          }
          seatKeys.get(key)!.push(item)
        }
      })

      // Sort by table name, then seat number
      const sortedKeys = Array.from(seatKeys.keys()).sort((a, b) => {
        const [tableIdA, seatA] = a.split('-')
        const [tableIdB, seatB] = b.split('-')
        const tableA = tables.find(t => t.id === tableIdA)
        const tableB = tables.find(t => t.id === tableIdB)
        const nameCompare = (tableA?.name || '').localeCompare(tableB?.name || '')
        if (nameCompare !== 0) return nameCompare
        return parseInt(seatA) - parseInt(seatB)
      })

      sortedKeys.forEach(key => {
        const [tableId, seatNumStr] = key.split('-')
        const seatNum = parseInt(seatNumStr)
        const table = tables.find(t => t.id === tableId)
        const tableLabel = table?.abbreviation || table?.name || 'Table'
        groups.push({
          seatNumber: seatNum,
          sourceTableId: tableId,
          label: `${tableLabel}-S${seatNum}`,
          items: seatKeys.get(key)!,
        })
      })
    } else {
      // Non-virtual group - simple seat grouping
      const seatsWithItems = new Set<number>()
      inlineOrderItems.forEach(item => {
        if (item.seatNumber) {
          seatsWithItems.add(item.seatNumber)
        }
      })

      Array.from(seatsWithItems).sort((a, b) => a - b).forEach(seatNum => {
        groups.push({
          seatNumber: seatNum,
          sourceTableId: null,
          label: `Seat ${seatNum}`,
          items: inlineOrderItems.filter(item => item.seatNumber === seatNum),
        })
      })
    }

    // Add shared items (no seat) at the end
    const sharedItems = inlineOrderItems.filter(item => !item.seatNumber)
    if (sharedItems.length > 0) {
      groups.push({
        seatNumber: null,
        sourceTableId: null,
        label: 'Shared',
        items: sharedItems,
      })
    }

    return groups
  }, [activeTable, getTotalSeats, inlineOrderItems, tables])

  // Convert grouped order items to OrderPanel seatGroups format
  const seatGroupsForPanel = useMemo(() => {
    if (!activeTableId || inlineOrderItems.length === 0) return undefined

    const groups = groupedOrderItems

    // If only one group with no seat number (e.g., "All Items"), don't use seat grouping
    if (groups.length === 1 && groups[0].seatNumber === null) {
      return undefined
    }

    // Convert to OrderPanel's SeatGroup format
    return groups.map(group => ({
      seatNumber: group.seatNumber,
      sourceTableId: group.sourceTableId,
      label: group.label,
      items: group.items.map(i => ({
        id: i.id,
        name: i.name,
        quantity: i.quantity,
        price: i.price,
        modifiers: i.modifiers?.map(m => ({ name: m.name, price: m.price })),
        specialNotes: i.specialNotes,
        kitchenStatus: i.kitchenStatus as OrderPanelItemData['kitchenStatus'],
        isHeld: i.isHeld,
        isCompleted: i.isCompleted,
        isTimedRental: i.isTimedRental,
        menuItemId: i.menuItemId,
        blockTimeMinutes: i.blockTimeMinutes,
        blockTimeStartedAt: i.blockTimeStartedAt,
        blockTimeExpiresAt: i.blockTimeExpiresAt,
        seatNumber: i.seatNumber,
        courseNumber: i.courseNumber,
        courseStatus: i.courseStatus,
        sentToKitchen: i.sentToKitchen,
        resendCount: i.resendCount,
        completedAt: i.completedAt,
        createdAt: i.createdAt,
      })),
    }))
  }, [activeTableId, inlineOrderItems, groupedOrderItems])

  // Quick bar items with full data
  const [quickBarItems, setQuickBarItems] = useState<{
    id: string
    name: string
    price: number
    bgColor?: string | null
    textColor?: string | null
  }[]>([])

  // Load quick bar items when quickBar changes
  useEffect(() => {
    if (quickBar.length === 0) {
      setQuickBarItems([])
      return
    }

    const loadQuickBarItems = async () => {
      try {
        // Fetch item details for each quick bar item
        const itemPromises = quickBar.map(async (itemId) => {
          const res = await fetch(`/api/menu/items/${itemId}`)
          if (res.ok) {
            const data = await res.json()
            const customStyle = menuItemColors[itemId]
            return {
              id: data.item.id,
              name: data.item.name,
              price: Number(data.item.price),
              bgColor: customStyle?.bgColor || null,
              textColor: customStyle?.textColor || null,
            }
          }
          return null
        })

        const items = await Promise.all(itemPromises)
        setQuickBarItems(items.filter(Boolean) as typeof quickBarItems)
      } catch (error) {
        console.error('[FloorPlanHome] Quick bar items load error:', error)
      }
    }

    loadQuickBarItems()
  }, [quickBar, menuItemColors])

  // Load data on mount
  useEffect(() => {
    loadFloorPlanData()
    loadCategories()
    loadOpenOrdersCount()
    // Clear any leftover virtual combine state from previous sessions
    cancelVirtualCombineMode()
  }, [locationId, cancelVirtualCombineMode])

  // Consolidated heartbeat - single interval for all periodic tasks
  // FIX 4: Uses refs for callbacks to prevent interval restart on re-render
  // This prevents multiple setIntervals from causing frame drops during animations
  useEffect(() => {
    let tickCount = 0
    const heartbeat = setInterval(() => {
      tickCount++

      // Every tick (1s): Clear expired undos and flashes
      callbacksRef.current.clearExpiredUndos()
      callbacksRef.current.clearExpiredFlashes()

      // Every 30 ticks (30s): Refresh floor plan data for live preview
      // This allows admin changes to tables/entertainment to appear on POS
      if (tickCount % 30 === 0 && tickCount > 0) {
        callbacksRef.current.loadFloorPlanData?.()
      }

      // Every 60 ticks (60s): Refresh open orders count
      if (tickCount >= 60) {
        tickCount = 0
        callbacksRef.current.loadOpenOrdersCount?.()
      }
    }, 1000)

    return () => clearInterval(heartbeat)
  }, []) // Empty deps - refs keep callbacks fresh

  // Socket.io: Listen for floor plan updates from admin
  const { subscribe, isConnected } = useEvents({ locationId, autoConnect: true })

  useEffect(() => {
    if (!isConnected) return

    // Subscribe to floor-plan:updated event for live preview
    // Pass false to skip loading state during background refresh
    const unsubscribe = subscribe('floor-plan:updated', () => {
      console.log('[FloorPlanHome] Received floor-plan:updated event, refreshing...')
      loadFloorPlanData(false)
    })

    return unsubscribe
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isConnected, subscribe])

  // Load order when orderToLoad prop is set (from Open Orders panel)
  useEffect(() => {
    if (!orderToLoad) return

    const loadOrder = async () => {
      try {
        const res = await fetch(`/api/orders/${orderToLoad.id}`)
        if (!res.ok) {
          console.error('[FloorPlanHome] Failed to load order:', orderToLoad.id)
          toast.error('Failed to load order. Please try again.')
          return
        }

        const data = await res.json()

        // Set order state
        setActiveOrderId(orderToLoad.id)
        setActiveOrderNumber(String(orderToLoad.orderNumber))
        setActiveTableId(orderToLoad.tableId || null)
        setActiveOrderType(orderToLoad.orderType || 'bar_tab')
        setShowOrderPanel(true)

        // Load items
        const items = (data.items || []).map((item: { id: string; menuItemId: string; name: string; price: number; quantity: number; modifiers?: { id: string; name: string; price: number }[]; specialNotes?: string; seatNumber?: number; courseNumber?: number; courseStatus?: string; isHeld?: boolean; isCompleted?: boolean; kitchenStatus?: string; status?: string; blockTimeMinutes?: number; completedAt?: string; resendCount?: number; resendNote?: string; createdAt?: string }) => ({
          id: item.id,
          menuItemId: item.menuItemId,
          name: item.name || 'Unknown',
          price: Number(item.price) || 0,
          quantity: item.quantity,
          modifiers: (item.modifiers || []).map((m: { id: string; name: string; price: number }) => ({
            id: m.id,
            name: m.name || '',
            price: Number(m.price) || 0,
          })),
          specialNotes: item.specialNotes,
          seatNumber: item.seatNumber,
          courseNumber: item.courseNumber,
          courseStatus: item.courseStatus as 'pending' | 'fired' | 'ready' | 'served' | undefined,
          isHeld: item.isHeld,
          isCompleted: item.isCompleted,
          sentToKitchen: item.kitchenStatus !== 'pending' && item.kitchenStatus !== undefined,
          status: item.status as 'active' | 'voided' | 'comped' | undefined,
          blockTimeMinutes: item.blockTimeMinutes,
          // Item lifecycle status
          kitchenStatus: item.kitchenStatus as 'pending' | 'cooking' | 'ready' | 'delivered' | undefined,
          completedAt: item.completedAt,
          resendCount: item.resendCount,
          resendNote: item.resendNote,
          createdAt: item.createdAt,
        }))
        setInlineOrderItems(items)

        // Sync to Zustand store for cross-route persistence
        syncOrderToStore(data)

        // Notify parent that order is loaded
        onOrderLoaded?.()
      } catch (error) {
        console.error('[FloorPlanHome] Failed to load order:', error)
        toast.error('Failed to load order. Please try again.')
      }
    }

    loadOrder()
  }, [orderToLoad, onOrderLoaded])

  // Clear order when it's been paid (paidOrderId matches activeOrderId)
  useEffect(() => {
    if (!paidOrderId) return
    if (paidOrderId !== activeOrderId) return

    // Clear extra seats for the table that was just paid
    // (extra seats are temporary and should reset when ticket is closed)
    if (activeTableId) {
      const activeTable = tables.find(t => t.id === activeTableId)
      if (activeTable?.virtualGroupId) {
        // Clear extra seats for all tables in the virtual group
        const groupTables = tables.filter(t => t.virtualGroupId === activeTable.virtualGroupId)
        setExtraSeats(prev => {
          const next = new Map(prev)
          groupTables.forEach(t => next.delete(t.id))
          return next
        })
      } else {
        // Clear extra seats for just this table
        setExtraSeats(prev => {
          const next = new Map(prev)
          next.delete(activeTableId)
          return next
        })
      }
    }

    // Clear the order panel state
    setActiveOrderId(null)
    setActiveOrderNumber(null)
    setActiveTableId(null)
    setActiveOrderType(null)
    setInlineOrderItems([])
    setShowOrderPanel(false)
    setSelectedCategoryId(null)
    setViewMode('tables')

    // Clear Zustand store for cross-route persistence
    useOrderStore.getState().clearOrder()

    // Refresh floor plan to show updated table status
    loadFloorPlanData()
    loadOpenOrdersCount()

    // Notify parent that we've cleared the paid order
    onPaidOrderCleared?.()
  }, [paidOrderId, activeOrderId, activeTableId, tables, onPaidOrderCleared])

  // Refs to track previous data for change detection (prevents flashing during polling)
  const prevTablesJsonRef = useRef<string>('')
  const prevSectionsJsonRef = useRef<string>('')
  const prevElementsJsonRef = useRef<string>('')

  // Ref to prevent double-tap race condition on Send button
  const isProcessingSendRef = useRef(false)

  // FIX 4: Refs for heartbeat callbacks - prevents interval restart on re-render
  const callbacksRef = useRef({
    clearExpiredUndos,
    clearExpiredFlashes,
    loadFloorPlanData: null as (() => Promise<void>) | null,
    loadOpenOrdersCount: null as (() => Promise<void>) | null,
  })

  const loadFloorPlanData = async (showLoading = true) => {
    // Only show loading state on initial load, not during background polling
    if (showLoading) setLoading(true)
    try {
      const [tablesRes, sectionsRes, elementsRes] = await Promise.all([
        fetch(`/api/tables?locationId=${locationId}&includeSeats=true&includeOrders=true&includeOrderItems=true`),
        fetch(`/api/sections?locationId=${locationId}`),
        fetch(`/api/floor-plan-elements?locationId=${locationId}`),
      ])

      if (tablesRes.ok) {
        const data = await tablesRes.json()
        const newTables = data.tables || []
        // Only update if data actually changed to prevent flashing during polling
        const newJson = JSON.stringify(newTables)
        if (newJson !== prevTablesJsonRef.current) {
          prevTablesJsonRef.current = newJson
          setTables(newTables)
        }
      }
      if (sectionsRes.ok) {
        const data = await sectionsRes.json()
        const newSections = data.sections || []
        const newJson = JSON.stringify(newSections)
        if (newJson !== prevSectionsJsonRef.current) {
          prevSectionsJsonRef.current = newJson
          setSections(newSections)
        }
      }
      if (elementsRes.ok) {
        const data = await elementsRes.json()
        const newElements = data.elements || []
        const newJson = JSON.stringify(newElements)
        if (newJson !== prevElementsJsonRef.current) {
          prevElementsJsonRef.current = newJson
          setElements(newElements)
        }
      }
    } catch (error) {
      console.error('[FloorPlanHome] Load error:', error)
    } finally {
      if (showLoading) setLoading(false)
    }
  }

  const loadCategories = async () => {
    try {
      // Use same /api/menu endpoint as orders page for consistency
      const timestamp = Date.now()
      const params = new URLSearchParams({ locationId, _t: timestamp.toString() })
      const res = await fetch(`/api/menu?${params}`, {
        cache: 'no-store',
        headers: { 'Cache-Control': 'no-cache' },
      })
      if (res.ok) {
        const data = await res.json()
        setCategories(data.categories || [])
      }
    } catch (error) {
      console.error('[FloorPlanHome] Categories load error:', error)
    }
  }

  const loadOpenOrdersCount = async () => {
    try {
      const res = await fetch(`/api/orders?locationId=${locationId}&status=open&count=true`)
      if (res.ok) {
        const data = await res.json()
        setOpenOrdersCount(data.count || 0)
      }
    } catch (error) {
      console.error('[FloorPlanHome] Open orders count error:', error)
    }
  }

  // FIX 4: Keep refs updated with latest callbacks
  useEffect(() => {
    callbacksRef.current = {
      clearExpiredUndos,
      clearExpiredFlashes,
      loadFloorPlanData: () => loadFloorPlanData(false),
      loadOpenOrdersCount,
    }
  })

  const loadMenuItems = async (categoryId: string) => {
    setLoadingMenuItems(true)
    try {
      // Include stock status for prep item tracking
      const res = await fetch(`/api/menu/items?categoryId=${categoryId}&locationId=${locationId}&includeStock=true`)
      if (res.ok) {
        const data = await res.json()
        setMenuItems(data.items || [])
      }
    } catch (error) {
      console.error('[FloorPlanHome] Menu items load error:', error)
    } finally {
      setLoadingMenuItems(false)
    }
  }

  // Handle category click - toggle between tables and menu view
  const handleCategoryClick = useCallback((categoryId: string | null) => {
    if (!categoryId) {
      // "All" was clicked - show tables
      setSelectedCategoryId(null)
      setViewMode('tables')
      setMenuItems([])
      return
    }

    // Toggle behavior: clicking same category deselects it
    if (categoryId === selectedCategoryId) {
      setSelectedCategoryId(null)
      setViewMode('tables')
      setMenuItems([])
      return
    }

    // Select new category
    setSelectedCategoryId(categoryId)
    setViewMode('menu')
    loadMenuItems(categoryId)
  }, [selectedCategoryId])


  // Handle confirming virtual combine
  const handleConfirmVirtualCombine = useCallback(async (existingOrderActions?: Array<{ orderId: string; action: 'merge' | 'close' }>) => {
    if (virtualCombineSelectedIds.size < 2) return

    // FIX: Use tablesRef.current to get latest table data (avoids stale closure)
    const currentTables = tablesRef.current
    const selectedTableIds = Array.from(virtualCombineSelectedIds)
    const primaryId = virtualCombinePrimaryId || selectedTableIds[0]
    const primaryTable = currentTables.find(t => t.id === primaryId)

    setIsCreatingVirtualGroup(true)

    try {
      // Check if primary table is already in a virtual group (ADD mode vs CREATE mode)
      if (primaryTable?.virtualGroupId) {
        // ADD mode: Add new tables to existing group
        const existingGroupId = primaryTable.virtualGroupId
        const tablesToAdd = selectedTableIds.filter(id => {
          const table = currentTables.find(t => t.id === id)
          return !table?.virtualGroupId // Only add tables not already in the group
        })

        if (tablesToAdd.length === 0) {
          toast.info('All selected tables are already in this group')
          clearVirtualCombineMode()
          return
        }

        // Add each new table to the group
        const addedTables: Array<{ id: string; virtualGroupId: string; virtualGroupPrimary: boolean; virtualGroupColor: string }> = []

        for (const tableId of tablesToAdd) {
          const res = await fetch(`/api/tables/virtual-combine/${existingGroupId}/add`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              tableId,
              locationId,
              employeeId,
              mergeExistingOrder: existingOrderActions?.find(a =>
                currentTables.find(t => t.id === tableId)?.currentOrder?.id === a.orderId
              )?.action === 'merge',
            }),
          })

          const data = await res.json()

          if (data.requiresAction) {
            // Show modal to handle this table's existing order
            setPendingExistingOrders([data.existingOrder])
            setShowExistingOrdersModal(true)
            setIsCreatingVirtualGroup(false)
            return
          }

          if (!res.ok) {
            throw new Error(data.error || `Failed to add table to group`)
          }

          if (data.data?.table) {
            addedTables.push({
              id: data.data.table.id,
              virtualGroupId: data.data.table.virtualGroupId,
              virtualGroupPrimary: false,
              virtualGroupColor: data.data.table.virtualGroupColor,
            })
          }
        }

        // Update local state with added tables
        if (addedTables.length > 0) {
          updateTablesWithVirtualGroup(addedTables)
        }

        toast.success(`Added ${tablesToAdd.length} table${tablesToAdd.length > 1 ? 's' : ''} to virtual group`)
      } else {
        // CREATE mode: Create a new STATIC virtual group (long-hold)
        // Tables stay in their original positions - NO visual offsets
        // This creates a color-linked group where each table keeps its own seats
        // (Contrast with drag-drop mode which snaps tables together and redistributes seats)

        const res = await fetch('/api/tables/virtual-combine', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tableIds: selectedTableIds,
            primaryTableId: primaryId,
            locationId,
            employeeId,
            existingOrderActions,
            // NO visualOffsets - this creates a STATIC group where tables stay in place
          }),
        })

        const data = await res.json()

        if (data.requiresAction) {
          // Show modal to handle existing orders
          setPendingExistingOrders(data.existingOrders)
          setShowExistingOrdersModal(true)
          setIsCreatingVirtualGroup(false)
          return
        }

        if (!res.ok) {
          throw new Error(data.error || 'Failed to create virtual group')
        }

        // Update local state with new virtual group info
        if (data.data?.tables) {
          updateTablesWithVirtualGroup(
            data.data.tables.map((t: { id: string; virtualGroupId: string; virtualGroupPrimary: boolean; virtualGroupColor: string }) => ({
              id: t.id,
              virtualGroupId: t.virtualGroupId,
              virtualGroupPrimary: t.virtualGroupPrimary,
              virtualGroupColor: t.virtualGroupColor,
            }))
          )
        }

        toast.success(`Virtual group created with ${selectedTableIds.length} tables`)
      }

      clearVirtualCombineMode()
      setShowExistingOrdersModal(false)
      setPendingExistingOrders([])
    } catch (error) {
      console.error('Failed to create/add to virtual group:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to create virtual group')
    } finally {
      setIsCreatingVirtualGroup(false)
    }
  }, [virtualCombineSelectedIds, virtualCombinePrimaryId, locationId, employeeId, updateTablesWithVirtualGroup, clearVirtualCombineMode, calculateSnapPositionForTableInGroup])
  // Note: Using tablesRef.current instead of tables in dependency array

  // Handle table tap - open order panel
  // If tapped table is part of a combined group, redirect to the PRIMARY table
  // If in virtual combine mode, toggle selection instead
  // FIX: Uses tablesRef.current to always access latest tables data
  const handleTableTap = useCallback(async (table: FloorPlanTable) => {
    console.log('[VirtualCombine] handleTableTap called:', { tableId: table.id, virtualCombineMode, selectedIds: Array.from(virtualCombineSelectedIds) })

    // Always use the ref to get the latest tables data
    const currentTables = tablesRef.current

    // In virtual combine mode, toggle selection
    if (virtualCombineMode) {
      const primaryTable = currentTables.find(t => t.id === virtualCombinePrimaryId)
      const primaryGroupId = primaryTable?.virtualGroupId

      // Prevent selecting tables that are in a DIFFERENT virtual group
      if (table.virtualGroupId && table.virtualGroupId !== primaryGroupId && !virtualCombineSelectedIds.has(table.id)) {
        toast.error(`${table.name} is already in another group. Dissolve that group first.`)
        return
      }
      // Prevent selecting tables that are physically combined
      if (table.combinedWithId || (table.combinedTableIds && table.combinedTableIds.length > 0)) {
        toast.error(`${table.name} is physically combined. Split it first.`)
        return
      }
      console.log('[VirtualCombine] Toggling selection for table:', table.id)
      toggleVirtualCombineSelection(table.id)
      return
    }

    if (selectedSeat) {
      clearSelectedSeat()
    }

    // If this table is in a VIRTUAL group, redirect to the PRIMARY virtual table
    if (table.virtualGroupId && !table.virtualGroupPrimary) {
      const virtualPrimary = currentTables.find(t => t.virtualGroupId === table.virtualGroupId && t.virtualGroupPrimary)
      if (virtualPrimary) {
        table = virtualPrimary
      }
    }

    // If this table is combined INTO another (physical), find and use the primary instead
    // FIX: Also check if the table passed in has stale data - look up fresh from ref
    let primaryTable = table
    const freshTable = currentTables.find(t => t.id === table.id)
    if (freshTable?.combinedWithId) {
      const foundPrimary = currentTables.find(t => t.id === freshTable.combinedWithId)
      if (foundPrimary) {
        primaryTable = foundPrimary
        console.log(`[handleTableTap] Redirecting from child ${table.name} to primary ${foundPrimary.name}`)
      }
    } else if (table.combinedWithId) {
      const foundPrimary = currentTables.find(t => t.id === table.combinedWithId)
      if (foundPrimary) {
        primaryTable = foundPrimary
      }
    }

    const totalSeats = getTotalSeats(primaryTable)
    console.log(`[handleTableTap] Setting guest count to ${totalSeats} for table ${primaryTable.name} (capacity=${primaryTable.capacity})`)

    setActiveTableId(primaryTable.id)
    setActiveOrderType('dine_in')
    setShowOrderPanel(true)
    setActiveSeatNumber(null) // Reset active seat when switching tables
    setActiveSourceTableId(null) // Reset source table too
    setGuestCount(totalSeats) // Set guest count based on table capacity

    if (primaryTable.currentOrder) {
      // Load existing order items from PRIMARY table (combined tables share one order)
      setActiveOrderId(primaryTable.currentOrder.id)
      setActiveOrderNumber(String(primaryTable.currentOrder.orderNumber))
      try {
        const res = await fetch(`/api/orders/${primaryTable.currentOrder.id}`)
        if (res.ok) {
          const data = await res.json()
          const items = (data.items || []).map((item: { id: string; menuItemId: string; name: string; price: number; quantity: number; modifiers?: { id: string; name: string; price: number }[]; specialNotes?: string; seatNumber?: number; courseNumber?: number; courseStatus?: string; isHeld?: boolean; isCompleted?: boolean; kitchenStatus?: string; status?: string; blockTimeMinutes?: number; completedAt?: string; resendCount?: number; resendNote?: string; createdAt?: string }) => ({
            id: item.id,
            menuItemId: item.menuItemId,
            name: item.name || 'Unknown',
            price: Number(item.price) || 0,
            quantity: item.quantity,
            modifiers: (item.modifiers || []).map((m: { id: string; name: string; price: number }) => ({
              id: m.id,
              name: m.name || '',
              price: Number(m.price) || 0,
            })),
            specialNotes: item.specialNotes,
            seatNumber: item.seatNumber,
            courseNumber: item.courseNumber,
            courseStatus: item.courseStatus as 'pending' | 'fired' | 'ready' | 'served' | undefined,
            isHeld: item.isHeld,
            isCompleted: item.isCompleted,
            sentToKitchen: item.kitchenStatus !== 'pending' && item.kitchenStatus !== undefined,
            status: item.status as 'active' | 'voided' | 'comped' | undefined,
            blockTimeMinutes: item.blockTimeMinutes,
            // Item lifecycle status
            kitchenStatus: item.kitchenStatus as 'pending' | 'cooking' | 'ready' | 'delivered' | undefined,
            completedAt: item.completedAt,
            resendCount: item.resendCount,
            resendNote: item.resendNote,
            createdAt: item.createdAt,
          }))
          setInlineOrderItems(items)

          // Sync to Zustand store for cross-route persistence
          syncOrderToStore(data)
        }
      } catch (error) {
        console.error('[FloorPlanHome] Failed to load order:', error)
      }
    } else {
      // FIX: Only clear items if we're switching to a DIFFERENT table
      // If tapping the same table we already have selected, preserve unsaved items
      const isSameTable = activeTableId === primaryTable.id
      if (!isSameTable) {
        setActiveOrderId(null)
        setActiveOrderNumber(null)
        setInlineOrderItems([])
        useOrderStore.getState().clearOrder()
      }
      // If same table, keep existing items (user may have added items but not sent yet)
    }
  }, [selectedSeat, clearSelectedSeat, getTotalSeats, virtualCombineMode, toggleVirtualCombineSelection, virtualCombineSelectedIds.size, virtualCombinePrimaryId, activeTableId])

  // Handle quick order type (Takeout, Delivery, Bar Tab)
  const handleQuickOrderType = useCallback((orderType: QuickOrderType) => {
    setActiveTableId(null)
    setActiveOrderType(orderType)
    setActiveOrderId(null)
    setActiveOrderNumber(null)
    setInlineOrderItems([])
    useOrderStore.getState().clearOrder()
    setShowOrderPanel(true)
  }, [])

  // Handle menu item tap - add to order
  const handleMenuItemTap = useCallback(async (item: MenuItem) => {
    // Check for timed rental (entertainment) items - show rate selection modal
    if (item.itemType === 'timed_rental' && onOpenTimedRental) {
      onOpenTimedRental(item, (price: number, blockMinutes: number) => {
        const newItem: InlineOrderItem = {
          id: `temp-${crypto.randomUUID()}`,
          menuItemId: item.id,
          name: item.name,
          price: price, // Use selected rate price
          quantity: 1,
          modifiers: [],
          seatNumber: activeSeatNumber || undefined,
          sourceTableId: activeSourceTableId || undefined,
          sentToKitchen: false,
          // Store block time info for timed session
          blockTimeMinutes: blockMinutes,
        }
        setInlineOrderItems(prev => [...prev, newItem])
      })
      return
    }

    // Check for pizza items - show pizza builder modal
    if (item.isPizza && onOpenPizzaBuilder) {
      onOpenPizzaBuilder(item, (config: PizzaOrderConfig) => {
        // Build pizza item with selections as modifiers
        // Use priceBreakdown since the global PizzaOrderConfig structure has that
        const pizzaModifiers: { id: string; name: string; price: number }[] = []

        // Add size and crust
        pizzaModifiers.push({ id: config.sizeId, name: `Size`, price: config.priceBreakdown.sizePrice })
        pizzaModifiers.push({ id: config.crustId, name: `Crust`, price: config.priceBreakdown.crustPrice })

        // Add sauces if present
        if (config.sauces && config.sauces.length > 0) {
          config.sauces.forEach(s => {
            pizzaModifiers.push({ id: s.sauceId, name: `${s.name} (${s.amount})`, price: s.price || 0 })
          })
        } else if (config.sauceId) {
          pizzaModifiers.push({ id: config.sauceId, name: `Sauce (${config.sauceAmount})`, price: config.priceBreakdown.saucePrice })
        }

        // Add cheeses if present
        if (config.cheeses && config.cheeses.length > 0) {
          config.cheeses.forEach(c => {
            pizzaModifiers.push({ id: c.cheeseId, name: `${c.name} (${c.amount})`, price: c.price || 0 })
          })
        } else if (config.cheeseId) {
          pizzaModifiers.push({ id: config.cheeseId, name: `Cheese (${config.cheeseAmount})`, price: config.priceBreakdown.cheesePrice })
        }

        // Add toppings
        config.toppings.forEach(t => {
          const sectionStr = t.sections ? `sections: ${t.sections.length}` : ''
          pizzaModifiers.push({ id: t.toppingId, name: `${t.name}${sectionStr ? ` (${sectionStr})` : ''}`, price: t.price })
        })

        const newItem: InlineOrderItem = {
          id: `temp-${crypto.randomUUID()}`,
          menuItemId: item.id,
          name: item.name,
          price: config.totalPrice, // Use calculated pizza price
          quantity: 1,
          modifiers: pizzaModifiers,
          seatNumber: activeSeatNumber || undefined,
          sourceTableId: activeSourceTableId || undefined,
          sentToKitchen: false,
        }
        setInlineOrderItems(prev => [...prev, newItem])
      })
      return
    }

    // If item has modifiers, check if defaults can auto-fill all required groups
    if (item.hasModifiers && onOpenModifiers) {
      // Try to auto-add with defaults (no modal needed if defaults satisfy requirements)
      try {
        const res = await fetch(`/api/menu/items/${item.id}/modifier-groups`)
        if (res.ok) {
          const { data: groups } = await res.json()
          if (groups && groups.length > 0) {
            // Collect all default modifiers and check if required groups are satisfied
            const defaultMods: { id: string; name: string; price: number }[] = []
            let allRequiredSatisfied = true

            for (const group of groups) {
              const defaults = (group.modifiers || []).filter((m: any) => m.isDefault)
              defaults.forEach((m: any) => {
                defaultMods.push({ id: m.id, name: m.name, price: Number(m.price || 0) })
              })
              // Check if required group has enough defaults
              if (group.isRequired && group.minSelections > 0 && defaults.length < group.minSelections) {
                allRequiredSatisfied = false
              }
            }

            // If defaults satisfy all requirements, add directly  skip modal
            if (allRequiredSatisfied && defaultMods.length > 0) {
              const modPrice = defaultMods.reduce((sum, m) => sum + m.price, 0)
              const newItem: InlineOrderItem = {
                id: `temp-${crypto.randomUUID()}`,
                menuItemId: item.id,
                name: item.name,
                price: item.price,
                quantity: 1,
                modifiers: defaultMods,
                seatNumber: activeSeatNumber || undefined,
                sourceTableId: activeSourceTableId || undefined,
                sentToKitchen: false,
              }
              setInlineOrderItems(prev => [...prev, newItem])
              if (navigator.vibrate) navigator.vibrate(10)
              return
            }
          }
        }
      } catch (e) {
        // If fetch fails, fall through to open modal
        console.error('Failed to check defaults:', e)
      }

      // Defaults don't cover requirements  open modifier modal as usual
      onOpenModifiers(item, (modifiers) => {
        const newItem: InlineOrderItem = {
          id: `temp-${crypto.randomUUID()}`,
          menuItemId: item.id,
          name: item.name,
          price: item.price,
          quantity: 1,
          modifiers,
          seatNumber: activeSeatNumber || undefined,
          sourceTableId: activeSourceTableId || undefined,
          sentToKitchen: false,
        }
        setInlineOrderItems(prev => [...prev, newItem])
      })
      return
    }

    // Add item directly
    const newItem: InlineOrderItem = {
      id: `temp-${crypto.randomUUID()}`,
      menuItemId: item.id,
      name: item.name,
      price: item.price,
      quantity: 1,
      modifiers: [],
      seatNumber: activeSeatNumber || undefined, // Assign active seat
      sourceTableId: activeSourceTableId || undefined,
      sentToKitchen: false,
    }
    setInlineOrderItems(prev => [...prev, newItem])

    // Haptic feedback
    if (navigator.vibrate) {
      navigator.vibrate(10)
    }
  }, [onOpenModifiers, onOpenTimedRental, onOpenPizzaBuilder, activeSeatNumber, activeSourceTableId])

  // Handle search result selection
  const handleSearchSelect = useCallback((item: { id: string; name: string; price: number; categoryId: string }) => {
    // Find full menu item data
    const fullItem = menuItems.find(m => m.id === item.id)
    if (fullItem) {
      handleMenuItemTap(fullItem)
    }
    clearSearch()
  }, [menuItems, clearSearch, handleMenuItemTap])

  // Handle quick bar item click - add to order
  const handleQuickBarItemClick = useCallback(async (itemId: string) => {
    // Find the item in quickBarItems to get full info
    const qbItem = quickBarItems.find(i => i.id === itemId)
    if (!qbItem) return

    // Fetch full item details (including hasModifiers)
    try {
      const res = await fetch(`/api/menu/items/${itemId}`)
      if (!res.ok) return

      const { item } = await res.json()
      handleMenuItemTap({
        id: item.id,
        name: item.name,
        price: Number(item.price),
        categoryId: item.categoryId,
        categoryType: item.categoryType,
        hasModifiers: item.modifierGroups?.length > 0,
        itemType: item.itemType,
        isPizza: item.isPizza,
        entertainmentStatus: item.entertainmentStatus,
        blockTimeMinutes: item.blockTimeMinutes,
        timedPricing: item.timedPricing,
      })
    } catch (error) {
      console.error('[FloorPlanHome] Quick bar item load error:', error)
    }
  }, [quickBarItems, handleMenuItemTap])

  // Handle right-click on menu item (context menu)
  const handleMenuItemContextMenu = useCallback((e: React.MouseEvent, item: MenuItem) => {
    e.preventDefault()
    e.stopPropagation()
    setContextMenu({
      x: e.clientX,
      y: e.clientY,
      item,
    })
  }, [])

  // Close context menu
  const closeContextMenu = useCallback(() => {
    setContextMenu(null)
  }, [])

  // Update item quantity
  const handleUpdateQuantity = useCallback((itemId: string, quantity: number) => {
    if (quantity <= 0) {
      setInlineOrderItems(prev => prev.filter(item => item.id !== itemId))
    } else {
      setInlineOrderItems(prev =>
        prev.map(item =>
          item.id === itemId ? { ...item, quantity } : item
        )
      )
    }
  }, [])

  // Remove item
  const handleRemoveItem = useCallback((itemId: string) => {
    setInlineOrderItems(prev => prev.filter(item => item.id !== itemId))
  }, [])

  // Toggle hold on item
  const handleToggleHold = useCallback((itemId: string) => {
    setInlineOrderItems(prev =>
      prev.map(item =>
        item.id === itemId ? { ...item, isHeld: !item.isHeld } : item
      )
    )
  }, [])

  // Open notes editor
  const handleOpenNotesEditor = useCallback((itemId: string, currentNotes?: string) => {
    setEditingNotesItemId(itemId)
    setEditingNotesText(currentNotes || '')
  }, [])

  // Handle tapping an existing order item to edit modifiers
  const handleOrderItemTap = useCallback((item: InlineOrderItem) => {
    // Don't allow editing sent items
    if (item.sentToKitchen) {
      return
    }

    // Find the menu item to get modifier groups
    const menuItem = menuItems.find(m => m.id === item.menuItemId)
    if (!menuItem) return

    // Open modifier modal in "edit" mode with current modifiers
    if (onOpenModifiers) {
      onOpenModifiers(menuItem, (newModifiers) => {
        // Update the item's modifiers
        setInlineOrderItems(prev => prev.map(i =>
          i.id === item.id
            ? {
                ...i,
                modifiers: newModifiers,
              }
            : i
        ))
      }, item.modifiers) // Pass existing modifiers for pre-selection
    }
  }, [menuItems, onOpenModifiers])

  // Save notes
  const handleSaveNotes = useCallback(() => {
    if (editingNotesItemId) {
      setInlineOrderItems(prev =>
        prev.map(item =>
          item.id === editingNotesItemId
            ? { ...item, specialNotes: editingNotesText.trim() || undefined }
            : item
        )
      )
    }
    setEditingNotesItemId(null)
    setEditingNotesText('')
  }, [editingNotesItemId, editingNotesText])

  // Update seat number
  const handleUpdateSeat = useCallback((itemId: string, seatNumber: number | null) => {
    setInlineOrderItems(prev =>
      prev.map(item =>
        item.id === itemId
          ? { ...item, seatNumber: seatNumber || undefined }
          : item
      )
    )
  }, [])

  // Add a new seat to the table (Skill 121 - Atomic Seat Management)
  // Works with or without an active order
  const handleAddSeat = useCallback(async (tableId?: string) => {
    const targetTableId = tableId || activeTable?.id
    if (!targetTableId) {
      toast.error('No table selected')
      return
    }

    // If there's an active order, add seat via API
    if (activeOrderId) {
      try {
        const response = await fetch(`/api/orders/${activeOrderId}/seating`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'INSERT',
            position: getTotalSeats(activeTable) + 1, // Add at the end
          }),
        })

        if (!response.ok) {
          const data = await response.json()
          throw new Error(data.error || 'Failed to add seat')
        }

        const result = await response.json()
        toast.success(`Seat ${result.position} added`)

        // Refresh the order to get updated seat count
        const orderResponse = await fetch(`/api/orders/${activeOrderId}`)
        if (orderResponse.ok) {
          // Force a refresh by updating the state
          setRefreshKey(prev => prev + 1)
        }
      } catch (err) {
        console.error('[FloorPlanHome] Failed to add seat:', err)
        toast.error(err instanceof Error ? err.message : 'Failed to add seat')
      }
    } else {
      // No active order - add a virtual seat locally
      setExtraSeats(prev => {
        const next = new Map(prev)
        const current = next.get(targetTableId) || 0
        next.set(targetTableId, current + 1)
        return next
      })
      // Use getTotalSeats for combined tables (8+5=13, so new seat is 14)
      const newSeatNum = getTotalSeats(activeTable!) + 1
      toast.success(`Seat ${newSeatNum} added`)
    }
  }, [activeOrderId, activeTable, getTotalSeats])

  // Update course number
  const handleUpdateCourse = useCallback((itemId: string, courseNumber: number | null) => {
    setInlineOrderItems(prev =>
      prev.map(item =>
        item.id === itemId
          ? { ...item, courseNumber: courseNumber || undefined }
          : item
      )
    )
  }, [])

  // Toggle item controls expansion
  const handleToggleItemControls = useCallback((itemId: string) => {
    setExpandedItemId(prev => prev === itemId ? null : itemId)
  }, [])

  // Edit item (reopen modifiers)
  const handleEditItem = useCallback((item: InlineOrderItem) => {
    // Find the menu item to get its data
    const menuItem = menuItems.find(mi => mi.id === item.menuItemId)
    if (!menuItem) return

    if (onOpenModifiers) {
      onOpenModifiers(menuItem, (newModifiers) => {
        setInlineOrderItems(prev =>
          prev.map(i =>
            i.id === item.id
              ? { ...i, modifiers: newModifiers }
              : i
          )
        )
      }, item.modifiers)
    }
  }, [menuItems, onOpenModifiers])

  // Save modifier changes to API and update local state
  const handleSaveModifierChanges = useCallback(async (
    itemId: string,
    newModifiers: { id: string; name: string; price: number }[]
  ) => {
    if (!activeOrderId) return

    try {
      const response = await fetch(`/api/orders/${activeOrderId}/items/${itemId}/modifiers`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ modifiers: newModifiers })
      })

      if (!response.ok) {
        const data = await response.json()
        toast.error(data.error || 'Failed to update modifiers')
        return
      }

      // Update local state
      setInlineOrderItems(prev => prev.map(item =>
        item.id === itemId
          ? { ...item, modifiers: newModifiers, resendCount: (item.resendCount || 0) + 1 }
          : item
      ))

      setEditingModifiersItemId(null)
      toast.success('Modifiers updated')
    } catch (error) {
      console.error('Failed to update modifiers:', error)
      toast.error('Connection error. Please try again.')
    }
  }, [activeOrderId])

  // Edit modifiers on a sent item
  const handleEditSentItemModifiers = useCallback((item: InlineOrderItem) => {
    const menuItem = menuItems.find(mi => mi.id === item.menuItemId)
    if (!menuItem) return

    setEditingModifiersItemId(item.id)

    if (onOpenModifiers) {
      onOpenModifiers(menuItem, (newModifiers) => {
        handleSaveModifierChanges(item.id, newModifiers)
      }, item.modifiers)
    }
  }, [menuItems, onOpenModifiers, handleSaveModifierChanges])

  // Handle resend item to kitchen
  const handleResendItem = useCallback((itemId: string, itemName: string) => {
    setResendNote('')
    setResendModal({ itemId, itemName })
  }, [])

  // Confirm resend item to kitchen
  const confirmResendItem = useCallback(async () => {
    if (!resendModal) return

    setResendLoading(true)
    try {
      const response = await fetch('/api/kds', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          itemIds: [resendModal.itemId],
          action: 'resend',
          resendNote: resendNote.trim() || undefined,
        }),
      })

      if (response.ok) {
        // Update local state to increment resend count
        setInlineOrderItems(prev => prev.map(item =>
          item.id === resendModal.itemId
            ? { ...item, resendCount: (item.resendCount || 0) + 1 }
            : item
        ))

        setResendModal(null)
        setResendNote('')
        toast.success('Item resent to kitchen')
      } else {
        const data = await response.json()
        toast.error(data.error || 'Failed to resend item')
      }
    } catch (error) {
      console.error('Failed to resend item:', error)
      toast.error('Failed to resend item')
    } finally {
      setResendLoading(false)
    }
  }, [resendModal, resendNote])

  // Open comp/void modal for a sent item
  const handleOpenCompVoid = useCallback((item: InlineOrderItem) => {
    setCompVoidItem({
      id: item.id,
      name: item.name,
      price: item.price,
      quantity: item.quantity,
      modifiers: (item.modifiers || []).map(m => ({ name: m.name, price: m.price })),
      status: item.status,
    })
  }, [])

  // Send order to kitchen
  const handleSendToKitchen = useCallback(async () => {
    // FIX 2: Race condition prevention - immediate gate catches double-taps
    if (isProcessingSendRef.current || inlineOrderItems.length === 0) return

    // Filter out held items and already-sent items
    const unsavedItems = inlineOrderItems.filter(item => !item.sentToKitchen && !item.isHeld)
    if (unsavedItems.length === 0) return

    isProcessingSendRef.current = true  // Set BEFORE any async work
    setIsSendingOrder(true)

    try {
      let orderId = activeOrderId

      // FIX 1: Use correlationId pattern to properly match items back
      // The temp item.id serves as a unique correlationId for each item
      const itemsPayload = unsavedItems.map(item => ({
        menuItemId: item.menuItemId,
        correlationId: item.id, // Use temp ID as unique anchor for matching
        name: item.name,
        price: item.price,
        quantity: item.quantity,
        modifiers: item.modifiers?.map(m => ({
          modifierId: m.id,
          name: m.name,
          price: m.price,
        })) || [],
        seatNumber: item.seatNumber,
        courseNumber: item.courseNumber,
        specialNotes: item.specialNotes,
        blockTimeMinutes: item.blockTimeMinutes, // For timed rental items
      }))

      if (!orderId) {
        // Create new order
        const createRes = await fetch('/api/orders', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            locationId,
            employeeId,
            tableId: activeTableId || undefined,
            orderType: activeOrderType || 'dine_in',
            items: itemsPayload,
          }),
        })

        if (createRes.ok) {
          const data = await createRes.json()
          orderId = data.id
          setActiveOrderId(orderId)
          setActiveOrderNumber(String(data.orderNumber))

          // Clear extra virtual seats for this table since they're now part of the order
          if (activeTableId) {
            setExtraSeats(prev => {
              const next = new Map(prev)
              next.delete(activeTableId)
              return next
            })
          }

          // Match using correlationId - prevents ghost ID issues with identical items
          if (data.items && data.items.length > 0) {
            const serverItems = data.items as { id: string; correlationId?: string; menuItemId: string; name: string }[]
            setInlineOrderItems(prev => prev.map(localItem => {
              // First try matching by correlationId (reliable)
              const matchByCorrelation = serverItems.find(s => s.correlationId === localItem.id)
              if (matchByCorrelation) {
                return { ...localItem, id: matchByCorrelation.id }
              }
              // Fallback for older API: match by temp prefix + menuItemId + name
              if (localItem.id.startsWith('temp-')) {
                const matchByLegacy = serverItems.find(
                  s => s.menuItemId === localItem.menuItemId && s.name === localItem.name
                )
                if (matchByLegacy) {
                  return { ...localItem, id: matchByLegacy.id }
                }
              }
              return localItem
            }))
          }
        } else {
          const errorData = await createRes.json().catch(() => ({}))
          console.error('[FloorPlanHome] Create order failed:', errorData)
          toast.error('Failed to create order. Please try again.')
          throw new Error('Failed to create order')
        }
      } else {
        // Add items to existing order - use POST to append atomically
        const appendRes = await fetch(`/api/orders/${orderId}/items`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ items: itemsPayload }),
        })

        const appendData = await appendRes.json().catch(() => ({}))

        if (!appendRes.ok) {
          console.error('[FloorPlanHome] Append items failed:', appendData)
          toast.error('Failed to add items to order. Please try again.')
          throw new Error('Failed to add items to order')
        }

        // Match using correlationId - prevents ghost ID issues with identical items
        if (appendData?.addedItems && appendData.addedItems.length > 0) {
          const addedItems = appendData.addedItems as { id: string; correlationId?: string; name: string }[]
          setInlineOrderItems(prev => prev.map(localItem => {
            // First try matching by correlationId (reliable)
            const matchByCorrelation = addedItems.find(s => s.correlationId === localItem.id)
            if (matchByCorrelation) {
              return { ...localItem, id: matchByCorrelation.id }
            }
            // Fallback for older API: match by temp prefix + name
            if (localItem.id.startsWith('temp-')) {
              const matchByLegacy = addedItems.find(s => s.name === localItem.name)
              if (matchByLegacy) {
                return { ...localItem, id: matchByLegacy.id }
              }
            }
            return localItem
          }))
        }
      }

      // Send to kitchen
      if (orderId) {
        const sendRes = await fetch(`/api/orders/${orderId}/send`, { method: 'POST' })
        if (!sendRes.ok) {
          const errorData = await sendRes.json().catch(() => ({}))
          console.error('[FloorPlanHome] Send to kitchen failed:', errorData)
          // Don't throw - order is saved, just printing/kitchen send failed
          toast.warning('Order saved but failed to send to kitchen. Check printer connection.')
        } else {
          toast.success('Order sent to kitchen')
        }
      }

      // Mark non-held items as sent
      setInlineOrderItems(prev =>
        prev.map(item =>
          item.isHeld ? item : { ...item, sentToKitchen: true }
        )
      )

      // Refresh floor plan data (without showing loading indicator)
      // This updates the table to show it has an active order
      await loadFloorPlanData(false)
      loadOpenOrdersCount()

      // Sync saved order to store for cross-route persistence
      if (orderId) {
        try {
          const orderRes = await fetch(`/api/orders/${orderId}`)
          if (orderRes.ok) {
            const orderData = await orderRes.json()
            syncOrderToStore(orderData)
          }
        } catch (err) {
          console.error('[FloorPlanHome] Failed to sync order to store:', err)
        }
      }

      // Panel stays open after send  order items already marked as sent above

    } catch (error) {
      console.error('[FloorPlanHome] Failed to send order:', error)
      toast.error('Failed to send order. Please try again.')
    } finally {
      isProcessingSendRef.current = false
      setIsSendingOrder(false)
    }
  }, [activeTableId, activeOrderId, activeOrderType, inlineOrderItems, locationId, employeeId])

  // Save order to DB without sending to kitchen (for Pay before Send flow)
  const handleSaveOrderForPayment = useCallback(async () => {
    if (inlineOrderItems.length === 0) return

    const unsavedItems = inlineOrderItems.filter(item => !item.sentToKitchen)
    if (unsavedItems.length === 0 && activeOrderId) {
      // All items already saved, just open payment
      setPendingPayAfterSave(true)
      return
    }

    setIsSendingOrder(true)
    try {
      let orderId = activeOrderId
      const itemsPayload = unsavedItems.map(item => ({
        menuItemId: item.menuItemId,
        correlationId: item.id,
        name: item.name,
        price: item.price,
        quantity: item.quantity,
        modifiers: item.modifiers?.map(m => ({
          modifierId: m.id,
          name: m.name,
          price: m.price,
        })) || [],
        seatNumber: item.seatNumber,
        courseNumber: item.courseNumber,
        specialNotes: item.specialNotes,
        blockTimeMinutes: item.blockTimeMinutes,
      }))

      if (!orderId) {
        // Create new order (without sending to kitchen)
        const createRes = await fetch('/api/orders', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            locationId,
            employeeId,
            tableId: activeTableId || undefined,
            orderType: activeOrderType || 'dine_in',
            items: itemsPayload,
          }),
        })

        if (createRes.ok) {
          const data = await createRes.json()
          orderId = data.id
          setActiveOrderId(orderId)
          setActiveOrderNumber(String(data.orderNumber))

          // Match correlationIds
          if (data.items && data.items.length > 0) {
            const serverItems = data.items as { id: string; correlationId?: string; menuItemId: string; name: string }[]
            setInlineOrderItems(prev => prev.map(localItem => {
              const match = serverItems.find(s => s.correlationId === localItem.id)
              if (match) return { ...localItem, id: match.id }
              return localItem
            }))
          }
        } else {
          toast.error('Failed to create order')
          return
        }
      } else if (unsavedItems.length > 0) {
        // Append items to existing order
        const appendRes = await fetch(`/api/orders/${orderId}/items`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ items: itemsPayload }),
        })

        if (!appendRes.ok) {
          toast.error('Failed to save items')
          return
        }

        const appendData = await appendRes.json().catch(() => ({}))
        if (appendData?.addedItems) {
          const addedItems = appendData.addedItems as { id: string; correlationId?: string; name: string }[]
          setInlineOrderItems(prev => prev.map(localItem => {
            const match = addedItems.find(s => s.correlationId === localItem.id)
            if (match) return { ...localItem, id: match.id }
            return localItem
          }))
        }
      }

      // Flag that payment should open after orderId is set
      setPendingPayAfterSave(true)
    } catch (error) {
      console.error('[FloorPlanHome] Failed to save order for payment:', error)
      toast.error('Failed to save order')
    } finally {
      setIsSendingOrder(false)
    }
  }, [activeTableId, activeOrderId, activeOrderType, inlineOrderItems, locationId, employeeId])

  // Open payment
  const handleOpenPayment = useCallback(() => {
    if (activeOrderId && onOpenPayment) {
      onOpenPayment(activeOrderId)
    }
  }, [activeOrderId, onOpenPayment])

  // Close order panel
  const handleCloseOrderPanel = useCallback(() => {
    // If no items were added and no order exists, clear extra seats (reset to original)
    // This handles the case where user opens a table, maybe adds an extra seat, but then
    // clicks away without ordering anything
    if (inlineOrderItems.length === 0 && !activeOrderId && activeTableId) {
      const currentTable = tablesRef.current.find(t => t.id === activeTableId)
      if (currentTable?.virtualGroupId) {
        // Clear extra seats for all tables in the virtual group
        const groupTables = tablesRef.current.filter(t => t.virtualGroupId === currentTable.virtualGroupId)
        setExtraSeats(prev => {
          const next = new Map(prev)
          groupTables.forEach(t => next.delete(t.id))
          return next
        })
      } else {
        // Clear extra seats for just this table
        setExtraSeats(prev => {
          const next = new Map(prev)
          next.delete(activeTableId)
          return next
        })
      }
    }

    // Clear dependent state FIRST
    setInlineOrderItems([])
    setActiveOrderId(null)
    setActiveOrderNumber(null)
    setActiveOrderType(null)
    setExpandedItemId(null)
    setEditingNotesItemId(null)
    setEditingNotesText('')
    setGuestCount(defaultGuestCount)
    setActiveSeatNumber(null)
    setActiveSourceTableId(null)

    // Clear Zustand store for cross-route persistence
    useOrderStore.getState().clearOrder()

    // Clear primary state LAST
    setActiveTableId(null)
    setShowOrderPanel(false)
  }, [defaultGuestCount, inlineOrderItems.length, activeOrderId, activeTableId])

  // Detect new items added  highlight + auto-scroll
  useEffect(() => {
    const prevCount = prevItemCountRef2.current
    prevItemCountRef2.current = inlineOrderItems.length

    if (inlineOrderItems.length > prevCount) {
      const pendingItems = inlineOrderItems.filter(item =>
        !item.sentToKitchen && (!item.kitchenStatus || item.kitchenStatus === 'pending')
      )
      if (pendingItems.length > 0) {
        const newest = itemSortDirection === 'newest-top' ? pendingItems[0] : pendingItems[pendingItems.length - 1]
        if (newest) {
          setNewestItemId(newest.id)

          requestAnimationFrame(() => {
            const container = orderScrollRef.current
            if (!container) return
            const el = container.querySelector(`[data-item-id="${newest.id}"]`)
            if (el) {
              el.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
            }
          })

          if (newestTimerRef2.current) clearTimeout(newestTimerRef2.current)
          newestTimerRef2.current = setTimeout(() => setNewestItemId(null), 2000)
        }
      }
    }
  }, [inlineOrderItems, itemSortDirection])

  // Payment mode state (cash or card)
  const [paymentMode, setPaymentMode] = useState<'cash' | 'card'>('cash')
  const [showTotalDetails, setShowTotalDetails] = useState(false)

  // Calculate order subtotal
  const orderSubtotal = inlineOrderItems.reduce((sum, item) => {
    const itemTotal = item.price * item.quantity
    const modifiersTotal = (item.modifiers || []).reduce((mSum, m) => mSum + m.price, 0) * item.quantity
    return sum + itemTotal + modifiersTotal
  }, 0)

  // Tax rate (TODO: make this configurable per location)
  const TAX_RATE = 0.08
  const CASH_DISCOUNT_RATE = 0.04

  // Calculate totals
  const cashDiscount = paymentMode === 'cash' ? orderSubtotal * CASH_DISCOUNT_RATE : 0
  const taxableAmount = orderSubtotal - cashDiscount
  const tax = taxableAmount * TAX_RATE
  const orderTotal = taxableAmount + tax
  const cardTotal = (orderSubtotal * (1 + TAX_RATE))

  // Handle payment success (extracted from inline for OrderPanel)
  const handlePaymentSuccess = useCallback(async (result: { cardLast4?: string; cardBrand?: string; tipAmount: number }) => {
    toast.success(`Payment approved! Card: ****${result.cardLast4 || '****'}`)

    // Record the payment in the database and mark order as paid/closed
    if (activeOrderId) {
      try {
        await fetch(`/api/orders/${activeOrderId}/pay`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            payments: [{
              method: 'credit',
              amount: orderTotal,
              tipAmount: result.tipAmount || 0,
              cardBrand: result.cardBrand,
              cardLast4: result.cardLast4,
            }],
            employeeId,
          }),
        })
      } catch (err) {
        console.error('[FloorPlanHome] Failed to record payment:', err)
      }
    }

    // Clear the order panel (same as handleCloseOrderPanel)
    setInlineOrderItems([])
    setActiveOrderId(null)
    setActiveOrderNumber(null)
    setActiveOrderType(null)
    setExpandedItemId(null)
    setEditingNotesItemId(null)
    setEditingNotesText('')
    setGuestCount(defaultGuestCount)
    setActiveSeatNumber(null)
    setActiveSourceTableId(null)
    useOrderStore.getState().clearOrder()
    setActiveTableId(null)
    setShowOrderPanel(false)
    setSelectedCategoryId(null)
    setViewMode('tables')

    // Refresh floor plan to show updated table status
    loadFloorPlanData()
    loadOpenOrdersCount()
  }, [activeOrderId, orderTotal, employeeId, defaultGuestCount, loadFloorPlanData, loadOpenOrdersCount])

  // Get primary tables for combined groups
  const primaryTables = tables.filter(
    t => t.combinedTableIds && t.combinedTableIds.length > 0
  )

  // Build connection lines between combined tables
  const connectionLines = primaryTables.flatMap(primary => {
    const connectedIds = primary.combinedTableIds || []
    const groupColor = getCombinedGroupColor(primary.id)

    return connectedIds.map(connectedId => {
      const connected = tables.find(t => t.id === connectedId)
      if (!connected) return null

      const primaryCenterX = primary.posX + primary.width / 2
      const primaryCenterY = primary.posY + primary.height / 2
      const connectedCenterX = connected.posX + connected.width / 2
      const connectedCenterY = connected.posY + connected.height / 2

      const dx = connectedCenterX - primaryCenterX
      const dy = connectedCenterY - primaryCenterY

      let x1: number, y1: number, x2: number, y2: number

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0) {
          x1 = primary.posX + primary.width
          y1 = primary.posY + primary.height / 2
          x2 = connected.posX
          y2 = connected.posY + connected.height / 2
        } else {
          x1 = primary.posX
          y1 = primary.posY + primary.height / 2
          x2 = connected.posX + connected.width
          y2 = connected.posY + connected.height / 2
        }
      } else {
        if (dy > 0) {
          x1 = primary.posX + primary.width / 2
          y1 = primary.posY + primary.height
          x2 = connected.posX + connected.width / 2
          y2 = connected.posY
        } else {
          x1 = primary.posX + primary.width / 2
          y1 = primary.posY
          x2 = connected.posX + connected.width / 2
          y2 = connected.posY + connected.height
        }
      }

      return { id: `${primary.id}-${connectedId}`, x1, y1, x2, y2, color: groupColor }
    }).filter(Boolean)
  }) as { id: string; x1: number; y1: number; x2: number; y2: number; color: string }[]

  // Build combined group colors map
  const combinedGroupColors = new Map<string, string>()
  for (const primary of primaryTables) {
    const color = getCombinedGroupColor(primary.id)
    combinedGroupColors.set(primary.id, color)
    const childIds = primary.combinedTableIds || []
    for (const childId of childIds) {
      combinedGroupColors.set(childId, color)
    }
  }

  // Note: Ghost preview calculation is now handled by useFloorPlanDrag hook

  // Handle table combine - NOW USES VIRTUAL COMBINE (no permanent DB changes)
  // Dragging tables together in FOH view creates a temporary visual group only
  // The backend database positions are NOT modified
  const handleTableCombine = useCallback(async (
    sourceId: string,
    targetId: string,
    dropPosition?: { x: number; y: number }
  ) => {
    try {
      const currentTables = tablesRef.current
      const sourceTable = currentTables.find(t => t.id === sourceId)
      const targetTable = currentTables.find(t => t.id === targetId)

      if (!sourceTable || !targetTable) {
        toast.error('Could not find tables to combine')
        return false
      }

      // Check if either table is already in a virtual group
      if (sourceTable.virtualGroupId || targetTable.virtualGroupId) {
        toast.info('One or more tables is already in a virtual group')
        return false
      }

      // Use target as primary (the table being dropped onto)
      const primaryId = targetId
      const tableIds = [targetId, sourceId]

      // Calculate visual offsets for snap positioning
      const visualOffsets: Array<{ tableId: string; offsetX: number; offsetY: number }> = []
      const offsetsMap = new Map<string, { offsetX: number; offsetY: number }>()

      // Primary table stays at its position
      visualOffsets.push({ tableId: primaryId, offsetX: 0, offsetY: 0 })
      offsetsMap.set(primaryId, { offsetX: 0, offsetY: 0 })

      // Calculate snap position for source table relative to target
      const snapPos = calculateSnapPositionForTable(sourceTable, targetTable)
      const offset = {
        offsetX: snapPos.x - sourceTable.posX,
        offsetY: snapPos.y - sourceTable.posY,
      }
      visualOffsets.push({ tableId: sourceId, ...offset })

      console.log('[FloorPlanHome] Virtual combine request:', {
        sourceId,
        targetId,
        primaryId,
        visualOffsets,
      })

      const res = await fetch('/api/tables/virtual-combine', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tableIds,
          primaryTableId: primaryId,
          locationId,
          employeeId,
          visualOffsets,
        }),
      })

      const data = await res.json()

      if (data.requiresAction) {
        // Tables have open orders - show modal to handle them
        setPendingExistingOrders(data.existingOrders)
        setShowExistingOrdersModal(true)
        return false
      }

      if (res.ok) {
        // Update local state with new virtual group info
        if (data.data?.tables) {
          updateTablesWithVirtualGroup(
            data.data.tables.map((t: { id: string; virtualGroupId: string; virtualGroupPrimary: boolean; virtualGroupColor: string }) => ({
              id: t.id,
              virtualGroupId: t.virtualGroupId,
              virtualGroupPrimary: t.virtualGroupPrimary,
              virtualGroupColor: t.virtualGroupColor,
            }))
          )
        }
        toast.success('Tables grouped together')
        await loadFloorPlanData()
        return true
      } else {
        console.error('[FloorPlanHome] Virtual combine failed:', data.error)
        toast.error(`Failed to group tables: ${data.error || 'Unknown error'}`)
      }
      return false
    } catch (error) {
      console.error('[FloorPlanHome] Virtual combine error:', error)
      toast.error('Failed to group tables. Please try again.')
      return false
    }
  }, [locationId, employeeId, updateTablesWithVirtualGroup, calculateSnapPositionForTable])
  // Note: Using tablesRef.current instead of tables in dependency array

  // Handle reset to default
  const handleResetToDefault = useCallback(async (tableIds: string[]) => {
    try {
      const res = await fetch('/api/tables/reset-to-default', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tableIds,
          locationId,
          employeeId,
        }),
      })

      if (res.ok) {
        const result = await res.json()
        if (result.data?.skippedTableIds?.length > 0) {
          for (const tableId of result.data.skippedTableIds) {
            flashTableMessage(tableId, 'OPEN ORDER', 3000)
          }
        }
        // FIX: Await data refresh to ensure positions are loaded before continuing
        await loadFloorPlanData()
        closeInfoPanel()
        return true
      }
      return false
    } catch (error) {
      console.error('[FloorPlanHome] Reset error:', error)
      return false
    }
  }, [locationId, employeeId, closeInfoPanel, flashTableMessage])

  // Handle status update
  const handleUpdateStatus = useCallback(async (tableId: string, status: string) => {
    try {
      await fetch(`/api/tables/${tableId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status }),
      })
      loadFloorPlanData()
    } catch (error) {
      console.error('Failed to update status:', error)
    }
  }, [])

  // Handle undo - removes the last table added to a combined group
  const handleUndo = useCallback(async () => {
    const action = popUndoAction()
    if (!action) return

    if (action.type === 'combine') {
      // Remove just the source table (the one that was added) from the group
      // This is different from split which breaks apart ALL tables
      const res = await fetch(`/api/tables/${action.sourceTableId}/remove-from-group`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          employeeId,
        }),
      })

      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        console.error('[Undo] Failed to remove table from group:', error)
      }

      // Await data refresh to prevent stale table data
      await loadFloorPlanData()
    }
  }, [popUndoAction, locationId, employeeId, loadFloorPlanData])

  // Handle seat tap - sync both visual selection and order panel seat
  // FIX: Uses tablesRef.current to always access latest tables data (avoids stale closure)
  const handleSeatTap = useCallback((tableId: string, seatNumber: number) => {
    // For combined tables, always use the primary table ID for consistency
    // This ensures order panel and table visual stay in sync
    const table = tablesRef.current.find(t => t.id === tableId)
    const effectiveTableId = table?.combinedWithId || tableId
    const isCombinedGroup = Boolean(table?.combinedWithId || table?.combinedTableIds?.length)
    const isVirtualGroup = Boolean(table?.virtualGroupId)

    // For combined groups, just check seatNumber since seats are sequential across tables
    // For single tables, check both tableId and seatNumber
    const isAlreadySelected = isCombinedGroup
      ? selectedSeat?.seatNumber === seatNumber
      : selectedSeat?.tableId === effectiveTableId && selectedSeat?.seatNumber === seatNumber

    if (isAlreadySelected) {
      // Deselecting - clear both
      clearSelectedSeat()
      setActiveSeatNumber(null)
      setActiveSourceTableId(null)
    } else {
      // Selecting - update both
      selectSeat(effectiveTableId, seatNumber)
      setActiveSeatNumber(seatNumber)
      // For virtual groups, track which table the seat belongs to
      setActiveSourceTableId(isVirtualGroup ? tableId : effectiveTableId)
    }
  }, [selectedSeat, selectSeat, clearSelectedSeat])
  // Note: Using tablesRef.current instead of tables in dependency array

  // Drag handlers hook (handles pointer move/up and ghost preview)
  const {
    handlePointerMove,
    handlePointerUp,
    ghostPreview,
    isColliding,
  } = useFloorPlanDrag({
    containerRef,
    tablesRef,
    fixturesRef,
    autoScaleRef,
    autoScaleOffsetRef,
    draggedTableId,
    dropTargetTableId,
    updateDragTarget,
    endDrag,
    onCombine: handleTableCombine,
  })

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (searchQuery) {
          // Escape clears search if active
          clearSearch()
        } else if (viewMode === 'menu') {
          // Escape in menu mode goes back to tables
          setSelectedCategoryId(null)
          setViewMode('tables')
          setMenuItems([])
        } else {
          closeInfoPanel()
          selectTable(null)
          handleCloseOrderPanel()
        }
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
        e.preventDefault()
        handleUndo()
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault()
        const searchInput = searchContainerRef.current?.querySelector('input')
        searchInput?.focus()
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [viewMode, closeInfoPanel, selectTable, handleUndo, handleCloseOrderPanel, searchQuery, clearSearch])

  // Close search results on click outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (searchContainerRef.current && !searchContainerRef.current.contains(e.target as Node)) {
        if (searchQuery) clearSearch()
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [searchQuery, clearSearch])

  // Close employee dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setShowEmployeeDropdown(false)
    if (showEmployeeDropdown) {
      document.addEventListener('click', handleClickOutside)
      return () => document.removeEventListener('click', handleClickOutside)
    }
  }, [showEmployeeDropdown])

  // Close settings dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setShowSettingsDropdown(false)
    if (showSettingsDropdown) {
      document.addEventListener('click', handleClickOutside)
      return () => document.removeEventListener('click', handleClickOutside)
    }
  }, [showSettingsDropdown])

  const selectedCategory = categories.find(c => c.id === selectedCategoryId)

  return (
    <div
      className={`floor-plan-container floor-plan-home ${virtualCombineMode ? 'virtual-combine-mode' : ''}`}
      style={{ height: '100vh', maxHeight: '100vh', overflow: 'hidden', display: 'flex', flexDirection: 'column' }}
    >
      {/* Header */}
      <header className="floor-plan-header">
        <div className="floor-plan-header-left">
          {/* Employee Menu Dropdown */}
          <div style={{ position: 'relative', zIndex: 100 }}>
            <button
              className="employee-dropdown-trigger"
              onClick={(e) => {
                e.stopPropagation()
                setShowEmployeeDropdown(!showEmployeeDropdown)
              }}
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px',
                padding: '8px 12px',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '10px',
                color: '#f1f5f9',
                cursor: 'pointer',
                fontSize: '14px',
                fontWeight: 500,
              }}
            >
              <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
              </svg>
              <span>{employeeName}</span>
              <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ opacity: 0.6 }}>
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
              </svg>
            </button>

            {/* Dropdown Menu */}
            <AnimatePresence>
              {showEmployeeDropdown && (
                <motion.div
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -10 }}
                  style={{
                    position: 'absolute',
                    top: '100%',
                    left: 0,
                    marginTop: '4px',
                    minWidth: '200px',
                    background: 'rgba(15, 23, 42, 0.98)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    borderRadius: '12px',
                    padding: '8px 0',
                    boxShadow: '0 10px 40px rgba(0, 0, 0, 0.5)',
                    zIndex: 1000,
                  }}
                  onClick={(e) => e.stopPropagation()}
                >
                  {/* Employee Info */}
                  <div style={{ padding: '12px 16px', borderBottom: '1px solid rgba(255, 255, 255, 0.1)' }}>
                    <div style={{ fontSize: '14px', fontWeight: 600, color: '#f1f5f9' }}>{employeeName}</div>
                    {employeeRole && (
                      <div style={{ fontSize: '12px', color: '#64748b', marginTop: '2px' }}>{employeeRole}</div>
                    )}
                  </div>

                  {/* Menu Items */}
                  <div style={{ padding: '4px 0' }}>
                    {onSwitchUser && (
                      <button
                        onClick={() => {
                          setShowEmployeeDropdown(false)
                          onSwitchUser()
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: '10px',
                          width: '100%',
                          padding: '10px 16px',
                          background: 'transparent',
                          border: 'none',
                          color: '#e2e8f0',
                          fontSize: '13px',
                          cursor: 'pointer',
                          textAlign: 'left',
                        }}
                        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
                        onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                      >
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                        </svg>
                        Switch User
                      </button>
                    )}

                    {onOpenSettings && (
                      <button
                        onClick={() => {
                          setShowEmployeeDropdown(false)
                          onOpenSettings()
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: '10px',
                          width: '100%',
                          padding: '10px 16px',
                          background: 'transparent',
                          border: 'none',
                          color: '#e2e8f0',
                          fontSize: '13px',
                          cursor: 'pointer',
                          textAlign: 'left',
                        }}
                        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
                        onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                      >
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                        Settings
                      </button>
                    )}

                    {onSwitchToBartenderView && (
                      <button
                        onClick={() => {
                          setShowEmployeeDropdown(false)
                          onSwitchToBartenderView()
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: '10px',
                          width: '100%',
                          padding: '10px 16px',
                          background: 'transparent',
                          border: 'none',
                          color: '#818cf8',
                          fontSize: '13px',
                          cursor: 'pointer',
                          textAlign: 'left',
                        }}
                        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
                        onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                      >
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                        </svg>
                        Bar Mode
                      </button>
                    )}

                    <div style={{ height: '1px', background: 'rgba(255, 255, 255, 0.1)', margin: '4px 0' }} />

                    <button
                      onClick={() => {
                        setShowEmployeeDropdown(false)
                        onLogout()
                      }}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '10px',
                        width: '100%',
                        padding: '10px 16px',
                        background: 'transparent',
                        border: 'none',
                        color: '#f87171',
                        fontSize: '13px',
                        cursor: 'pointer',
                        textAlign: 'left',
                      }}
                      onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
                      onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                    >
                      <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                      </svg>
                      Clock Out
                    </button>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>

          {/* Quick Order Type Buttons */}
          <div style={{ display: 'flex', gap: '8px', marginLeft: '16px' }}>
            {/* Tables Button - Returns to floor plan view */}
            <button
              onClick={() => {
                setViewMode('tables')
                setSelectedCategoryId(null)
              }}
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                padding: '8px 14px',
                background: viewMode === 'tables' && !activeOrderType ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
                border: `1px solid ${viewMode === 'tables' && !activeOrderType ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
                borderRadius: '8px',
                color: viewMode === 'tables' && !activeOrderType ? '#a5b4fc' : '#94a3b8',
                fontSize: '13px',
                fontWeight: 500,
                cursor: 'pointer',
              }}
            >
              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
              </svg>
              Tables
            </button>

            <button
              onClick={() => handleQuickOrderType('takeout')}
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                padding: '8px 14px',
                background: activeOrderType === 'takeout' ? 'rgba(34, 197, 94, 0.2)' : 'rgba(255, 255, 255, 0.03)',
                border: `1px solid ${activeOrderType === 'takeout' ? 'rgba(34, 197, 94, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
                borderRadius: '8px',
                color: activeOrderType === 'takeout' ? '#86efac' : '#94a3b8',
                fontSize: '13px',
                fontWeight: 500,
                cursor: 'pointer',
              }}
            >
              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8" />
              </svg>
              Takeout
            </button>

            <button
              onClick={() => handleQuickOrderType('delivery')}
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                padding: '8px 14px',
                background: activeOrderType === 'delivery' ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
                border: `1px solid ${activeOrderType === 'delivery' ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
                borderRadius: '8px',
                color: activeOrderType === 'delivery' ? '#a5b4fc' : '#94a3b8',
                fontSize: '13px',
                fontWeight: 500,
                cursor: 'pointer',
              }}
            >
              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16V6a1 1 0 00-1-1H4a1 1 0 00-1 1v10a1 1 0 001 1h1m8-1a1 1 0 01-1 1H9m4-1V8a1 1 0 011-1h2.586a1 1 0 01.707.293l3.414 3.414a1 1 0 01.293.707V16a1 1 0 01-1 1h-1m-6-1a1 1 0 001 1h1M5 17a2 2 0 104 0m-4 0a2 2 0 114 0m6 0a2 2 0 104 0m-4 0a2 2 0 114 0" />
              </svg>
              Delivery
            </button>

            {onSwitchToBartenderView && (
              <button
                onClick={() => onSwitchToBartenderView()}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '6px',
                  padding: '8px 14px',
                  background: 'rgba(255, 255, 255, 0.03)',
                  border: '1px solid rgba(255, 255, 255, 0.08)',
                  borderRadius: '8px',
                  color: '#94a3b8',
                  fontSize: '13px',
                  fontWeight: 500,
                  cursor: 'pointer',
                }}
              >
                <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                </svg>
                Bar Mode
              </button>
            )}

            {/* Gear Settings Button */}
            <div style={{ position: 'relative', marginLeft: '8px' }}>
              <button
                onClick={(e) => {
                  e.stopPropagation()
                  setShowSettingsDropdown(!showSettingsDropdown)
                }}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  padding: '8px',
                  background: showSettingsDropdown ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.03)',
                  border: `1px solid ${showSettingsDropdown ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.08)'}`,
                  borderRadius: '8px',
                  color: showSettingsDropdown ? '#a5b4fc' : '#94a3b8',
                  cursor: 'pointer',
                }}
                title="Layout Settings"
              >
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
              </button>

              {/* Settings Dropdown */}
              <AnimatePresence>
                {showSettingsDropdown && (
                  <motion.div
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -10 }}
                    style={{
                      position: 'absolute',
                      top: '100%',
                      left: 0,
                      marginTop: '4px',
                      minWidth: '220px',
                      background: 'rgba(15, 23, 42, 0.98)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                      borderRadius: '12px',
                      padding: '8px 0',
                      boxShadow: '0 10px 40px rgba(0, 0, 0, 0.5)',
                      zIndex: 1000,
                    }}
                    onClick={(e) => e.stopPropagation()}
                  >
                    {canCustomize && (
                      <>
                        {/* Show/Hide Quick Bar Toggle */}
                        <button
                          onClick={() => {
                            toggleQuickBar()
                            setShowSettingsDropdown(false)
                          }}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '10px',
                            width: '100%',
                            padding: '10px 16px',
                            background: 'transparent',
                            border: 'none',
                            color: '#e2e8f0',
                            fontSize: '13px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                          onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
                          onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                        >
                          <svg width="16" height="16" fill="none" stroke={quickBarEnabled ? '#22c55e' : '#94a3b8'} viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                          </svg>
                          {quickBarEnabled ? ' Quick Bar Enabled' : 'Enable Quick Bar'}
                        </button>

                        <div style={{ height: '1px', background: 'rgba(255, 255, 255, 0.1)', margin: '4px 0' }} />

                        {/* Edit Favorites */}
                        <button
                          onClick={() => {
                            setIsEditingFavorites(!isEditingFavorites)
                            setIsEditingCategories(false)
                            setIsEditingMenuItems(false)
                            setShowSettingsDropdown(false)
                          }}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '10px',
                            width: '100%',
                            padding: '10px 16px',
                            background: isEditingFavorites ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
                            border: 'none',
                            color: isEditingFavorites ? '#a5b4fc' : '#e2e8f0',
                            fontSize: '13px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                          onMouseEnter={(e) => { if (!isEditingFavorites) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)' }}
                          onMouseLeave={(e) => { if (!isEditingFavorites) e.currentTarget.style.background = 'transparent' }}
                        >
                          <svg width="16" height="16" fill={isEditingFavorites ? '#a5b4fc' : '#94a3b8'} viewBox="0 0 20 20">
                            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                          </svg>
                          {isEditingFavorites ? ' Done Editing Favorites' : 'Edit Favorites'}
                        </button>

                        {/* Reorder Categories */}
                        <button
                          onClick={() => {
                            setIsEditingCategories(!isEditingCategories)
                            setIsEditingFavorites(false)
                            setIsEditingMenuItems(false)
                            setShowSettingsDropdown(false)
                          }}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '10px',
                            width: '100%',
                            padding: '10px 16px',
                            background: isEditingCategories ? 'rgba(99, 102, 241, 0.15)' : 'transparent',
                            border: 'none',
                            color: isEditingCategories ? '#a5b4fc' : '#e2e8f0',
                            fontSize: '13px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                          onMouseEnter={(e) => { if (!isEditingCategories) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)' }}
                          onMouseLeave={(e) => { if (!isEditingCategories) e.currentTarget.style.background = 'transparent' }}
                        >
                          <svg width="16" height="16" fill="none" stroke={isEditingCategories ? '#a5b4fc' : '#94a3b8'} viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" />
                          </svg>
                          {isEditingCategories ? ' Done Reordering' : 'Reorder Categories'}
                        </button>

                        {/* Customize Item Colors */}
                        <button
                          onClick={() => {
                            setIsEditingMenuItems(!isEditingMenuItems)
                            setIsEditingFavorites(false)
                            setIsEditingCategories(false)
                            setShowSettingsDropdown(false)
                          }}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '10px',
                            width: '100%',
                            padding: '10px 16px',
                            background: isEditingMenuItems ? 'rgba(168, 85, 247, 0.15)' : 'transparent',
                            border: 'none',
                            color: isEditingMenuItems ? '#c4b5fd' : '#e2e8f0',
                            fontSize: '13px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                          onMouseEnter={(e) => { if (!isEditingMenuItems) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)' }}
                          onMouseLeave={(e) => { if (!isEditingMenuItems) e.currentTarget.style.background = 'transparent' }}
                        >
                          <svg width="16" height="16" fill="none" stroke={isEditingMenuItems ? '#c4b5fd' : '#94a3b8'} viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
                          </svg>
                          {isEditingMenuItems ? ' Done Customizing Items' : 'Customize Item Colors'}
                        </button>

                        <div style={{ height: '1px', background: 'rgba(255, 255, 255, 0.1)', margin: '4px 0' }} />

                        {/* Reset All Category Colors */}
                        <button
                          onClick={() => {
                            resetAllCategoryColors()
                            setShowSettingsDropdown(false)
                          }}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '10px',
                            width: '100%',
                            padding: '10px 16px',
                            background: 'transparent',
                            border: 'none',
                            color: '#f87171',
                            fontSize: '13px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                          onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(248, 113, 113, 0.1)'}
                          onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                        >
                          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                          </svg>
                          Reset All Category Colors
                        </button>

                        {/* Reset All Item Styles */}
                        <button
                          onClick={() => {
                            resetAllMenuItemStyles()
                            setShowSettingsDropdown(false)
                          }}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '10px',
                            width: '100%',
                            padding: '10px 16px',
                            background: 'transparent',
                            border: 'none',
                            color: '#f87171',
                            fontSize: '13px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                          onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(248, 113, 113, 0.1)'}
                          onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                        >
                          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                          </svg>
                          Reset All Item Styles
                        </button>
                      </>
                    )}
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>

        <div className="floor-plan-header-right">
          {/* Open Orders Button */}
          <button
            onClick={onOpenOrdersPanel}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              padding: '8px 16px',
              background: openOrdersCount > 0 ? 'rgba(99, 102, 241, 0.15)' : 'rgba(255, 255, 255, 0.03)',
              border: `1px solid ${openOrdersCount > 0 ? 'rgba(99, 102, 241, 0.3)' : 'rgba(255, 255, 255, 0.08)'}`,
              borderRadius: '10px',
              color: openOrdersCount > 0 ? '#a5b4fc' : '#94a3b8',
              fontSize: '13px',
              fontWeight: 600,
              cursor: 'pointer',
            }}
          >
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
            Open Orders
            {openOrdersCount > 0 && (
              <span
                style={{
                  background: 'rgba(99, 102, 241, 0.3)',
                  padding: '2px 8px',
                  borderRadius: '12px',
                  fontSize: '12px',
                  fontWeight: 700,
                }}
              >
                {openOrdersCount}
              </span>
            )}
          </button>

          {/* Show Seats Toggle */}
          <button
            className={`icon-btn ${showSeats ? 'active' : ''}`}
            onClick={toggleShowSeats}
            title={showSeats ? 'Hide Seats' : 'Show Seats'}
            style={showSeats ? { background: 'rgba(99, 102, 241, 0.2)', borderColor: 'rgba(99, 102, 241, 0.4)' } : undefined}
          >
            <svg width="18" height="18" fill="none" stroke={showSeats ? '#a5b4fc' : 'currentColor'} viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="3" strokeWidth={2} />
              <circle cx="12" cy="4" r="2" strokeWidth={2} />
              <circle cx="12" cy="20" r="2" strokeWidth={2} />
              <circle cx="4" cy="12" r="2" strokeWidth={2} />
              <circle cx="20" cy="12" r="2" strokeWidth={2} />
            </svg>
          </button>

          {/* Reset Layout (if combined tables exist) */}
          {primaryTables.length > 0 && (
            <button
              className="reset-to-default-btn"
              onClick={() => handleResetToDefault(primaryTables.map(t => t.id))}
              title="Reset all combined tables"
            >
              <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              Reset
            </button>
          )}

          {/* Undo Button */}
          <AnimatePresence>
            {undoStack.length > 0 && (
              <motion.button
                className="icon-btn"
                onClick={handleUndo}
                title="Undo"
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                exit={{ scale: 0 }}
                style={{ background: 'rgba(251, 191, 36, 0.15)', borderColor: 'rgba(251, 191, 36, 0.3)' }}
              >
                <svg width="18" height="18" fill="none" stroke="#fbbf24" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
                </svg>
              </motion.button>
            )}
          </AnimatePresence>

          {/* Admin Menu - Always show if callback provided, permissions control nav content */}
          {onOpenAdminNav && (
            <button
              className="icon-btn"
              onClick={onOpenAdminNav}
              title="Menu"
              style={{
                background: 'rgba(59, 130, 246, 0.2)',
                border: '1px solid rgba(59, 130, 246, 0.4)',
                borderRadius: '8px',
                padding: '8px',
              }}
            >
              <svg width="22" height="22" fill="none" stroke="#3b82f6" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
          )}
        </div>
      </header>

      {/* Content below header: Left column (bars + main) + Right order panel */}
      <div style={{ display: 'flex', flex: 1, minHeight: 0, overflow: 'hidden' }}>
        {/* Left Column - Bars + Main Content */}
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', minHeight: 0, overflow: 'hidden' }}>

          {/* Quick Access Bar - Personal favorites */}
          {(quickBarEnabled || isEditingFavorites) && (
            <QuickAccessBar
              items={quickBarItems}
              onItemClick={handleQuickBarItemClick}
              onRemoveItem={removeFromQuickBar}
              isEditMode={isEditingFavorites}
            />
          )}

          {/* Menu Search Bar - always visible */}
          <div className="px-4 py-2 bg-gray-900/50 border-b border-gray-800/50" ref={searchContainerRef}>
            <div className="relative max-w-xl">
              <MenuSearchInput
                value={searchQuery}
                onChange={setSearchQuery}
                onClear={clearSearch}
                placeholder="Search menu items or ingredients... (K)"
                isSearching={isSearching}
              />
              <MenuSearchResults
                results={searchResults}
                query={searchQuery}
                isSearching={isSearching}
                onSelectItem={handleSearchSelect}
                onClose={clearSearch}
              />
            </div>
          </div>

          {/* Categories Bar */}
          <CategoriesBar
            categories={categories}
            selectedCategoryId={selectedCategoryId}
            onCategorySelect={handleCategoryClick}
          />

          {/* Main Content Area - Tables OR Menu Items */}
          <div className="floor-plan-main" style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
            {/* Left Panel - Tables or Menu Items */}
            <div style={{ flex: 1, overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>
          {viewMode === 'tables' ? (
            <>
              {/* Room/Section Tabs */}
              {sortedSections.length > 0 && (
                <RoomTabs
                  rooms={sortedSections.map(s => ({ id: s.id, name: s.name, color: s.color }))}
                  selectedRoomId={selectedSectionId}
                  onRoomSelect={setSelectedSectionId}
                  showAllTab={false}
                  showSettingsButton={true}
                  onOpenSettings={() => setShowRoomReorderModal(true)}
                />
              )}

              {/* Floor Plan Canvas */}
              <div
                ref={containerRef}
                className="floor-plan-canvas"
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
                onClick={() => selectTable(null)}
                style={{ flex: 1 }}
              >
              {isLoading ? (
                <div className="flex items-center justify-center h-full text-slate-400">
                  <motion.div
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
                  >
                    <svg width="32" height="32" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                  </motion.div>
                </div>
              ) : tables.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-full text-slate-400">
                  <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24" className="opacity-50 mb-4">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                  </svg>
                  <p className="text-lg font-medium">No tables configured</p>
                  <p className="text-sm opacity-60 mt-1">Add tables in the admin settings</p>
                </div>
              ) : (
                <>
                  {/* Scale indicator - show when auto-scaled */}
                  {autoScale < 1 && (
                    <div
                      style={{
                        position: 'absolute',
                        top: '8px',
                        right: '8px',
                        padding: '4px 8px',
                        borderRadius: '6px',
                        background: 'rgba(99, 102, 241, 0.2)',
                        border: '1px solid rgba(99, 102, 241, 0.3)',
                        color: '#a5b4fc',
                        fontSize: '11px',
                        fontWeight: 500,
                        zIndex: 10,
                      }}
                    >
                      {Math.round(autoScale * 100)}% zoom
                    </div>
                  )}

                  {/* Auto-scaled content wrapper */}
                  <div
                    style={{
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      width: '100%',
                      height: '100%',
                      transform: autoScale < 1
                        ? `translate(${autoScaleOffset.x}px, ${autoScaleOffset.y}px) scale(${autoScale})`
                        : undefined,
                      transformOrigin: 'top left',
                      pointerEvents: 'auto',
                    }}
                  >
                  {/* Connection Lines */}
                  {connectionLines.length > 0 && (
                    <svg className="connection-lines-layer">
                      <defs>
                        <filter id="connectionGlow" x="-50%" y="-50%" width="200%" height="200%">
                          <feGaussianBlur stdDeviation="3" result="blur" />
                          <feMerge>
                            <feMergeNode in="blur" />
                            <feMergeNode in="SourceGraphic" />
                          </feMerge>
                        </filter>
                      </defs>
                      {connectionLines.map(line => (
                        <g key={line.id}>
                          <line
                            x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
                            stroke={`${line.color}66`} strokeWidth="8" strokeLinecap="round"
                            filter="url(#connectionGlow)"
                          />
                          <line
                            x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
                            stroke={line.color} strokeWidth="3" strokeLinecap="round"
                            strokeDasharray="8 4" className="connection-line-animated"
                          />
                        </g>
                      ))}
                    </svg>
                  )}

                  {/* Section Labels - filtered by selected section */}
                  {sections
                    .filter(section => {
                      // Show all section labels when "All" is selected
                      if (selectedSectionId === null) return true
                      // Only show the selected section's label
                      return section.id === selectedSectionId
                    })
                    .map(section => (
                      <div
                        key={section.id}
                        className="section-label"
                        style={{ left: section.posX + 10, top: section.posY + 10, color: section.color }}
                      >
                        {section.name}
                      </div>
                    ))}

                  {/* Tables - filtered by selected section */}
                  <AnimatePresence>
                    {tables
                      .filter(table => {
                        // Show all tables when "All" is selected (selectedSectionId is null)
                        if (selectedSectionId === null) return true
                        // Show tables in the selected section
                        return table.section?.id === selectedSectionId
                      })
                      .map(table => {
                      const flash = flashingTables.get(table.id)
                      const flashMessage = flash && flash.expiresAt > Date.now() ? flash.message : null

                      // Check if this table is part of the active combined group
                      // A table is selected if:
                      // 1. It's directly selected (selectedTableId or activeTableId)
                      // 2. It's a child and its primary is active
                      // 3. It's a primary and one of its children is somehow active (shouldn't happen with redirect)
                      const isInActiveGroup = (() => {
                        if (!activeTableId) return false
                        // Direct match
                        if (table.id === activeTableId) return true
                        // This table is a child of the active table
                        if (table.combinedWithId === activeTableId) return true
                        // This table is a primary and has the active table as a child
                        if (table.combinedTableIds?.includes(activeTableId)) return true
                        return false
                      })()

                      // Calculate combinedSeatOffset for sequential seat numbering across combined tables
                      // Primary table: offset = 0 (but still part of combined group)
                      // Child tables: offset = primary's seats + preceding siblings' seats
                      let combinedSeatOffset = 0
                      let isPartOfCombinedGroup = false

                      if (table.combinedWithId) {
                        // This is a child table - find the primary and calculate offset
                        isPartOfCombinedGroup = true
                        const primaryTable = tables.find(t => t.id === table.combinedWithId)
                        if (primaryTable && primaryTable.combinedTableIds) {
                          // Start with primary table's seat count
                          combinedSeatOffset = primaryTable.seats?.length || primaryTable.capacity || 0
                          // Add seats from all preceding siblings in the combinedTableIds array
                          const myIndex = primaryTable.combinedTableIds.indexOf(table.id)
                          for (let i = 0; i < myIndex; i++) {
                            const siblingTable = tables.find(t => t.id === primaryTable.combinedTableIds![i])
                            if (siblingTable) {
                              combinedSeatOffset += siblingTable.seats?.length || siblingTable.capacity || 0
                            }
                          }
                        }
                      } else if (table.combinedTableIds && table.combinedTableIds.length > 0) {
                        // This is the primary table of a combined group
                        // Offset is 0 but we still mark it as part of a combined group
                        isPartOfCombinedGroup = true
                      }

                      // Calculate total seats for the combined group (for selection validation)
                      const combinedTotalSeats = isPartOfCombinedGroup ? getTotalSeats(table) : undefined

                      // For SNAPPED virtual groups (drag-drop), apply visual offset to table position
                      // Static groups (long-hold) keep original positions
                      const isSnappedVirtualGroup = table.virtualGroupId && !virtualGroupSeats.get(table.virtualGroupId)?.isStatic
                      const visualTable = isSnappedVirtualGroup && (table.virtualGroupOffsetX || table.virtualGroupOffsetY)
                        ? {
                            ...table,
                            posX: table.posX + (table.virtualGroupOffsetX || 0),
                            posY: table.posY + (table.virtualGroupOffsetY || 0),
                          }
                        : table

                      return (
                        <TableNode
                          key={table.id}
                          table={visualTable}
                          isSelected={selectedTableId === table.id || isInActiveGroup}
                          isDragging={draggedTableId === table.id}
                          isDropTarget={dropTargetTableId === table.id}
                          isColliding={draggedTableId === table.id && isColliding}
                          combinedGroupColor={combinedGroupColors.get(table.id)}
                          showSeats={showSeats && (!table.virtualGroupId || Boolean(table.virtualGroupId && virtualGroupSeats.get(table.virtualGroupId)?.isStatic))} // Show seats for: non-grouped tables OR static virtual groups (long-hold). Hide for snapped groups (drag-drop) where we render perimeter seats
                          selectedSeat={selectedSeat}
                          flashMessage={flashMessage}
                          combinedSeatOffset={combinedSeatOffset}
                          combinedTotalSeats={combinedTotalSeats}
                          isVirtualCombineMode={virtualCombineMode}
                          isVirtualCombineSelected={virtualCombineSelectedIds.has(table.id)}
                          isVirtualCombineUnavailable={virtualCombineMode && !virtualCombineSelectedIds.has(table.id) && (() => {
                            // Allow tables in same virtual group as primary
                            const primaryTable = tables.find(t => t.id === virtualCombinePrimaryId)
                            const primaryGroupId = primaryTable?.virtualGroupId
                            if (table.virtualGroupId && table.virtualGroupId === primaryGroupId) {
                              return false // Same group - available
                            }
                            return (
                              Boolean(table.virtualGroupId) || // In different group
                              Boolean(table.combinedWithId) ||
                              Boolean(table.combinedTableIds && table.combinedTableIds.length > 0)
                            )
                          })()}
                          virtualGroupColor={table.virtualGroupColor || undefined}
                          onTap={() => handleTableTap(table)}
                          onDragStart={() => startDrag(table.id)}
                          onDragEnd={endDrag}
                          onLongPress={() => {
                            // Long press starts virtual combine mode (or opens manager/info panel)
                            if (virtualCombineMode) {
                              // Already in virtual combine mode - no action
                              return
                            }
                            if (table.combinedTableIds && table.combinedTableIds.length > 0) {
                              // Physical combined table - open info panel
                              openInfoPanel(table.id)
                            } else if (table.virtualGroupId) {
                              // Already in a virtual group - open virtual group manager modal
                              setVirtualGroupManagerTableId(table.id)
                            } else {
                              // Start virtual combine mode with this table
                              startVirtualCombineMode(table.id)
                            }
                          }}
                          onSeatTap={(seatNumber) => handleSeatTap(table.id, seatNumber)}
                        />
                      )
                    })}
                  </AnimatePresence>

                  {/* Virtual Group Perimeter Seats - distributed around combined table shapes */}
                  {/* Only rendered for SNAPPED groups (drag-drop). Static groups (long-hold) keep their own seats. */}
                  {showSeats && Array.from(virtualGroupSeats.entries()).map(([groupId, groupData]) => {
                    // Skip static groups - they keep their individual table seats
                    if (groupData.isStatic) return null

                    // Only show seats for tables in the currently selected section
                    const groupTablesInSection = tables.filter(t =>
                      t.virtualGroupId === groupId &&
                      (selectedSectionId === null || t.sectionId === selectedSectionId || t.sectionId === null)
                    )
                    if (groupTablesInSection.length === 0) return null

                    const SEAT_SIZE = 24
                    const SEAT_HALF = SEAT_SIZE / 2

                    return (
                      <div key={`virtual-group-seats-${groupId}`}>
                        {/* Group display name label */}
                        {groupData.virtualSeats.length > 0 && (() => {
                          // Calculate center of the group for label placement
                          const minX = Math.min(...groupData.virtualSeats.map(s => s.absoluteX))
                          const maxX = Math.max(...groupData.virtualSeats.map(s => s.absoluteX))
                          const minY = Math.min(...groupData.virtualSeats.map(s => s.absoluteY))
                          const labelX = (minX + maxX) / 2
                          const labelY = minY - 50

                          // Check if this banner is dismissed
                          const isDismissed = dismissedBanners.has(groupId)

                          return (
                            <AnimatePresence>
                              {!isDismissed && (
                                <motion.div
                                  initial={{ opacity: 0, y: -10 }}
                                  animate={{ opacity: 1, y: 0 }}
                                  exit={{ opacity: 0, y: -10 }}
                                  transition={{ duration: 0.3 }}
                                  onClick={() => {
                                    setDismissedBanners(prev => new Set([...prev, groupId]))
                                  }}
                                  style={{
                                    position: 'absolute',
                                    left: labelX,
                                    top: labelY,
                                    transform: 'translateX(-50%)',
                                    background: `${groupData.groupColor}dd`,
                                    color: 'white',
                                    padding: '6px 12px',
                                    borderRadius: '16px',
                                    fontSize: '12px',
                                    fontWeight: 600,
                                    whiteSpace: 'nowrap',
                                    zIndex: 25,
                                    boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
                                    cursor: 'pointer',
                                  }}
                                >
                                  {groupData.displayName}
                                </motion.div>
                              )}
                            </AnimatePresence>
                          )
                        })()}

                        {/* Virtual seats around perimeter */}
                        {groupData.virtualSeats.map((seat) => {
                          const isSelected = selectedSeat?.tableId === groupData.tableIds[0] &&
                            selectedSeat?.seatNumber === seat.perimeterNumber

                          return (
                            <motion.div
                              key={seat.id}
                              initial={{ scale: 0, opacity: 0 }}
                              animate={{ scale: 1, opacity: 1 }}
                              exit={{ scale: 0, opacity: 0 }}
                              onClick={(e) => {
                                e.stopPropagation()
                                // Find the primary table for this group
                                const primaryTable = tables.find(t =>
                                  t.virtualGroupId === groupId && t.virtualGroupPrimary
                                )
                                if (primaryTable) {
                                  handleSeatTap(primaryTable.id, seat.perimeterNumber)
                                }
                              }}
                              style={{
                                position: 'absolute',
                                left: seat.absoluteX - SEAT_HALF,
                                top: seat.absoluteY - SEAT_HALF,
                                width: SEAT_SIZE,
                                height: SEAT_SIZE,
                                backgroundColor: isSelected
                                  ? groupData.groupColor
                                  : `${groupData.groupColor}30`,
                                border: `2px solid ${groupData.groupColor}`,
                                borderRadius: '50%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '10px',
                                fontWeight: 600,
                                color: isSelected ? 'white' : groupData.groupColor,
                                cursor: 'pointer',
                                zIndex: isSelected ? 30 : 20,
                                boxShadow: isSelected
                                  ? `0 0 12px ${groupData.groupColor}`
                                  : '0 2px 4px rgba(0,0,0,0.2)',
                                transition: 'all 0.2s ease',
                              }}
                              whileHover={{ scale: 1.1 }}
                              whileTap={{ scale: 0.95 }}
                            >
                              {seat.perimeterNumber}
                            </motion.div>
                          )
                        })}
                      </div>
                    )
                  })}

                  {/* Floor Plan Elements - filtered by selected section */}
                  {elements
                    .filter(element => {
                      // Show all elements when "All" is selected
                      if (selectedSectionId === null) return true
                      // Show elements in the selected section (or unassigned elements)
                      return element.sectionId === selectedSectionId || element.sectionId === null
                    })
                    .map(element => {
                      // Render entertainment items with FloorPlanEntertainment (SVG visuals)
                      if (element.elementType === 'entertainment') {
                        return (
                          <div
                            key={element.id}
                            style={{
                              position: 'absolute',
                              left: element.posX,
                              top: element.posY,
                              zIndex: 10,
                            }}
                          >
                            <FloorPlanEntertainment
                              element={element}
                              isSelected={false}
                              mode="service"
                              onSelect={() => {
                                // Handle tapping on entertainment item - start timed rental
                                if (element.linkedMenuItem) {
                                  const menuItem: MenuItem = {
                                    id: element.linkedMenuItem.id,
                                    name: element.linkedMenuItem.name,
                                    price: element.linkedMenuItem.price,
                                    categoryId: '',
                                    itemType: 'timed_rental',
                                    entertainmentStatus: element.linkedMenuItem.entertainmentStatus as 'available' | 'in_use' | 'maintenance' | undefined,
                                    blockTimeMinutes: element.linkedMenuItem.blockTimeMinutes || undefined,
                                  }
                                  // Use existing handleMenuItemTap which handles timed rentals
                                  handleMenuItemTap(menuItem)
                                }
                              }}
                            />
                          </div>
                        )
                      }

                      // Render fixtures (walls, bars, etc.) as solid colored rectangles with glassmorphism
                      return (
                        <div
                          key={element.id}
                          style={{
                            position: 'absolute',
                            left: element.posX,
                            top: element.posY,
                            width: element.width,
                            height: element.height,
                            transform: `rotate(${element.rotation}deg)`,
                            transformOrigin: 'center',
                            backgroundColor: element.fillColor || 'rgba(156, 163, 175, 0.7)',
                            backdropFilter: 'blur(8px)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                            opacity: element.opacity,
                            borderRadius: '4px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            pointerEvents: 'none',
                            zIndex: 5,
                          }}
                        >
                          <span
                            style={{
                              fontSize: '12px',
                              fontWeight: 600,
                              color: 'rgba(255, 255, 255, 0.9)',
                              textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                              textAlign: 'center',
                              whiteSpace: 'nowrap',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              maxWidth: '90%',
                            }}
                          >
                            {element.name}
                          </span>
                        </div>
                      )
                    })}

                  {/* Ghost Preview */}
                  {ghostPreview && (
                    <motion.div
                      className="table-ghost-preview"
                      initial={{ opacity: 0, scale: 0.9 }}
                      animate={{ opacity: 0.6, scale: 1 }}
                      exit={{ opacity: 0, scale: 0.9 }}
                      style={{
                        position: 'absolute',
                        left: ghostPreview.posX,
                        top: ghostPreview.posY,
                        width: ghostPreview.width,
                        height: ghostPreview.height,
                        borderRadius: '12px',
                        border: '2px dashed #22c55e',
                        backgroundColor: 'rgba(34, 197, 94, 0.15)',
                        pointerEvents: 'none',
                        zIndex: 90,
                      }}
                    >
                      <div
                        style={{
                          position: 'absolute',
                          bottom: '-24px',
                          left: '50%',
                          transform: 'translateX(-50%)',
                          fontSize: '11px',
                          fontWeight: 600,
                          color: '#22c55e',
                          textTransform: 'uppercase',
                          whiteSpace: 'nowrap',
                        }}
                      >
                        Attach {ghostPreview.side}
                      </div>
                    </motion.div>
                  )}
                  </div>
                  {/* End of auto-scaled content wrapper */}
                </>
              )}
            </div>
            </>
          ) : (
            /* Menu Items Grid - replaces tables when category is selected */
            <div
              style={{ flex: 1, overflow: 'auto', padding: '20px' }}
              onClick={(e) => {
                // Click on empty area deselects category
                if (e.target === e.currentTarget) {
                  setSelectedCategoryId(null)
                  setViewMode('tables')
                  setMenuItems([])
                }
              }}
            >
              {loadingMenuItems ? (
                <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%', color: '#64748b' }}>
                  <motion.div
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
                  >
                    <svg width="32" height="32" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                  </motion.div>
                </div>
              ) : menuItems.length === 0 ? (
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#64748b' }}>
                  <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ opacity: 0.5, marginBottom: '16px' }}>
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4" />
                  </svg>
                  <p style={{ fontSize: '14px' }}>No items in this category</p>
                  <p style={{ fontSize: '12px', marginTop: '4px', opacity: 0.6 }}>Tap the category again to go back</p>
                </div>
              ) : (
                  <div
                    style={{
                      display: 'grid',
                      gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))',
                      gap: '16px',
                    }}
                  >
                    {menuItems.map((item) => {
                      const customStyle = menuItemColors[item.id]
                      const inQuickBar = isInQuickBar(item.id)
                      // Check if item is 86'd (ingredient-level or out of prep stock)
                      const isItem86d = item.is86d || item.stockStatus === 'out'
                      const bgColor = isItem86d
                        ? 'rgba(100, 100, 100, 0.3)'
                        : (customStyle?.bgColor || 'rgba(255, 255, 255, 0.03)')
                      const textColor = isItem86d
                        ? '#6b7280'
                        : (customStyle?.textColor || '#e2e8f0')

                      return (
                        <motion.button
                          key={item.id}
                          onClick={() => {
                            if (isItem86d) {
                              // Show toast explaining why item is unavailable
                              const reason = item.reasons86d?.length
                                ? `${item.name} is unavailable - ${item.reasons86d.join(', ')} is out`
                                : item.stockIngredientName
                                  ? `${item.name} is unavailable - ${item.stockIngredientName} is out`
                                  : `${item.name} is currently unavailable`
                              toast.warning(reason)
                            } else {
                              handleMenuItemTap(item)
                            }
                          }}
                          onContextMenu={(e) => handleMenuItemContextMenu(e, item)}
                          whileHover={isItem86d ? {} : { scale: 1.02, y: -2 }}
                          whileTap={isItem86d ? {} : { scale: 0.98 }}
                          className={inQuickBar ? 'ring-2 ring-amber-400/50' : ''}
                          style={{
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '20px 16px',
                            background: bgColor,
                            border: `1px solid ${isItem86d ? 'rgba(239, 68, 68, 0.3)' : 'rgba(255, 255, 255, 0.08)'}`,
                            borderRadius: '14px',
                            cursor: isItem86d ? 'not-allowed' : 'pointer',
                            minHeight: '110px',
                            transition: 'all 0.15s ease',
                            position: 'relative',
                            opacity: isItem86d ? 0.6 : 1,
                          }}
                          onMouseOver={(e) => {
                            if (!isItem86d) {
                              if (!customStyle?.bgColor) {
                                e.currentTarget.style.background = 'rgba(99, 102, 241, 0.15)'
                              }
                              e.currentTarget.style.borderColor = 'rgba(99, 102, 241, 0.3)'
                            }
                          }}
                          onMouseOut={(e) => {
                            e.currentTarget.style.background = bgColor
                            e.currentTarget.style.borderColor = isItem86d
                              ? 'rgba(239, 68, 68, 0.3)'
                              : 'rgba(255, 255, 255, 0.08)'
                          }}
                        >
                          {/* Quick bar indicator */}
                          {inQuickBar && !isItem86d && (
                            <span className="absolute top-1 left-1 text-amber-400 z-10">
                              <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                              </svg>
                            </span>
                          )}
                          {/* 86 badge - ingredient-level */}
                          {item.is86d && (
                            <span
                              className="absolute top-1 right-1 px-1.5 py-0.5 bg-red-600 text-white text-[10px] font-bold rounded z-10"
                              title={item.reasons86d?.length
                                ? `Out: ${item.reasons86d.join(', ')}`
                                : 'Out of stock'}
                            >
                              86
                            </span>
                          )}
                          {/* Prep stock status badge (low/critical/out) */}
                          {!item.is86d && item.stockStatus && (
                            <StockBadge
                              status={item.stockStatus}
                              count={item.stockCount}
                              ingredientName={item.stockIngredientName}
                            />
                          )}
                          {/* Striped overlay for 86'd items */}
                          {isItem86d && (
                            <div
                              className="absolute inset-0 rounded-[14px] pointer-events-none"
                              style={{
                                background: 'repeating-linear-gradient(135deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px)',
                              }}
                            />
                          )}
                          <span
                            style={{
                              fontSize: '15px',
                              fontWeight: 500,
                              color: textColor,
                              textAlign: 'center',
                              marginBottom: '8px',
                              lineHeight: 1.3,
                              textDecoration: isItem86d ? 'line-through' : 'none',
                            }}
                          >
                            {item.name}
                          </span>
                          <span
                            style={{
                              fontSize: '15px',
                              fontWeight: 600,
                              color: isItem86d ? '#6b7280' : '#22c55e',
                            }}
                          >
                            ${item.price.toFixed(2)}
                          </span>
                          {item.hasModifiers && !isItem86d && (
                            <span
                              style={{
                                fontSize: '11px',
                                color: '#94a3b8',
                                marginTop: '6px',
                              }}
                            >
                              + options
                            </span>
                          )}
                        </motion.button>
                      )
                    })}
                  </div>
                )}
            </div>
          )}
        </div>
          </div>{/* end floor-plan-main */}
        </div>{/* end Left Column */}

        {/* Right Panel - Order Panel (always visible, full height from below header) */}
        <div
          style={{
            width: 360,
            flexShrink: 0,
            borderLeft: '1px solid rgba(255, 255, 255, 0.08)',
            background: 'rgba(15, 23, 42, 0.6)',
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
            minHeight: 0,
          }}
        >
              {/* Order Panel Header - Fixed, doesn't scroll */}
              <div
                style={{
                  padding: '16px 20px',
                  borderBottom: '1px solid rgba(255, 255, 255, 0.08)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  flexShrink: 0,
                }}
              >
                <div style={{ flex: 1, minWidth: 0 }}>
                  <h3 style={{ fontSize: '16px', fontWeight: 600, color: '#f1f5f9', margin: 0 }}>
                    {activeTable
                      ? activeTable.virtualGroupId
                        ? 'Virtual Group'
                        : getCombinedTableCount(activeTable) > 1
                          ? `Combined ${getCombinedTableCount(activeTable)} Tables`
                          : activeTable.name
                      : activeOrderType === 'bar_tab' ? 'Bar Tab'
                      : activeOrderType === 'takeout' ? 'Takeout'
                      : activeOrderType === 'delivery' ? 'Delivery'
                      : 'New Order'}
                  </h3>
                  {/* Virtual group: Show table list with primary indicator + Ungroup button */}
                  {activeTable?.virtualGroupId && (
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginTop: '4px', flexWrap: 'wrap' }}>
                      {getVirtualGroupTables(activeTable).map((t, i) => (
                        <span
                          key={t.id}
                          style={{
                            fontSize: '11px',
                            fontWeight: t.virtualGroupPrimary ? 600 : 400,
                            color: t.virtualGroupPrimary ? '#06b6d4' : '#94a3b8',
                            padding: '2px 6px',
                            background: t.virtualGroupPrimary ? 'rgba(6, 182, 212, 0.15)' : 'rgba(255, 255, 255, 0.05)',
                            borderRadius: '4px',
                          }}
                        >
                          {t.abbreviation || t.name}{t.virtualGroupPrimary ? ' ' : ''}
                        </span>
                      ))}
                      {/* Ungroup button - opens VirtualGroupManagerModal */}
                      <button
                        onClick={() => setVirtualGroupManagerTableId(activeTable.id)}
                        style={{
                          fontSize: '11px',
                          fontWeight: 500,
                          color: '#f87171',
                          padding: '2px 8px',
                          background: 'rgba(248, 113, 113, 0.15)',
                          border: '1px solid rgba(248, 113, 113, 0.3)',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          marginLeft: '4px',
                        }}
                      >
                        Ungroup
                      </button>
                    </div>
                  )}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '2px' }}>
                    {activeOrderNumber && (
                      <span style={{ fontSize: '12px', color: '#64748b' }}>
                        Order #{activeOrderNumber}
                      </span>
                    )}
                    {activeTable && getTotalSeats(activeTable) > 0 && (
                      <span style={{ fontSize: '11px', color: '#64748b', padding: '2px 6px', background: 'rgba(255, 255, 255, 0.05)', borderRadius: '4px' }}>
                        {getTotalSeats(activeTable)} seats
                      </span>
                    )}
                  </div>
                </div>
              </div>

              {/* Seat Selection Buttons (for table orders with seats) - Fixed, doesn't scroll */}
              {activeTable && getTotalSeats(activeTable) > 0 && (
                <div
                  style={{
                    padding: '10px 20px',
                    borderBottom: '1px solid rgba(255, 255, 255, 0.08)',
                    background: 'rgba(255, 255, 255, 0.02)',
                    flexShrink: 0,
                    maxHeight: '150px',
                    overflowY: 'auto',
                  }}
                >
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                    <span style={{ fontSize: '11px', color: '#64748b', fontWeight: 500 }}>Assign to seat:</span>
                    {activeSeatNumber && (
                      <span style={{ fontSize: '10px', color: '#c084fc' }}>
                        New items  {activeSourceTableId && activeTable.virtualGroupId
                          ? `${tables.find(t => t.id === activeSourceTableId)?.abbreviation || tables.find(t => t.id === activeSourceTableId)?.name || 'Table'}-S${activeSeatNumber}`
                          : `Seat ${activeSeatNumber}`}
                      </span>
                    )}
                  </div>

                  {/* "Shared" button */}
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', marginBottom: activeTable.virtualGroupId ? '12px' : '0' }}>
                    <button
                      onClick={() => {
                        setActiveSeatNumber(null)
                        setActiveSourceTableId(null)
                        clearSelectedSeat() // Sync visual selection
                      }}
                      style={{
                        padding: '6px 12px',
                        borderRadius: '6px',
                        border: `1px solid ${!activeSeatNumber ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
                        background: !activeSeatNumber ? 'rgba(168, 85, 247, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                        color: !activeSeatNumber ? '#c084fc' : '#94a3b8',
                        fontSize: '12px',
                        fontWeight: !activeSeatNumber ? 600 : 400,
                        cursor: 'pointer',
                        transition: 'all 0.15s ease',
                      }}
                    >
                      Shared
                    </button>
                  </div>

                  {/* Virtual Group: Show seats grouped by table */}
                  {activeTable.virtualGroupId ? (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                      {getVirtualGroupTables(activeTable).map((groupTable) => (
                        <div key={groupTable.id} style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
                          {/* Table label */}
                          <span
                            style={{
                              fontSize: '11px',
                              fontWeight: 600,
                              color: groupTable.virtualGroupPrimary ? '#06b6d4' : '#94a3b8',
                              padding: '4px 8px',
                              background: groupTable.virtualGroupPrimary ? 'rgba(6, 182, 212, 0.15)' : 'rgba(255, 255, 255, 0.05)',
                              borderRadius: '4px',
                              minWidth: '50px',
                              textAlign: 'center',
                            }}
                          >
                            {groupTable.abbreviation || groupTable.name}
                            {groupTable.virtualGroupPrimary && ' '}
                          </span>

                          {/* Seat buttons for this table */}
                          <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                            {Array.from({ length: getTableSeatCount(groupTable) }, (_, i) => i + 1).map(seatNum => {
                              const isSelected = activeSeatNumber === seatNum && activeSourceTableId === groupTable.id
                              return (
                                <button
                                  key={`${groupTable.id}-${seatNum}`}
                                  onClick={() => {
                                    setActiveSeatNumber(seatNum)
                                    setActiveSourceTableId(groupTable.id)
                                    selectSeat(groupTable.id, seatNum)
                                  }}
                                  style={{
                                    width: '28px',
                                    height: '28px',
                                    borderRadius: '5px',
                                    border: `1px solid ${isSelected ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
                                    background: isSelected ? 'rgba(168, 85, 247, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                                    color: isSelected ? '#c084fc' : '#94a3b8',
                                    fontSize: '11px',
                                    fontWeight: isSelected ? 600 : 400,
                                    cursor: 'pointer',
                                    transition: 'all 0.15s ease',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                  }}
                                >
                                  {seatNum}
                                </button>
                              )
                            })}

                            {/* Add Seat Button for this table in virtual group */}
                            <button
                              onClick={() => handleAddSeat(groupTable.id)}
                              title={`Add a seat to ${groupTable.name}`}
                              style={{
                                width: '28px',
                                height: '28px',
                                borderRadius: '5px',
                                border: '2px dashed rgba(34, 197, 94, 0.4)',
                                background: 'rgba(34, 197, 94, 0.1)',
                                color: '#22c55e',
                                fontSize: '14px',
                                fontWeight: 600,
                                cursor: 'pointer',
                                transition: 'all 0.15s ease',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                              }}
                              onMouseEnter={(e) => {
                                e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)'
                                e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)'
                              }}
                              onMouseLeave={(e) => {
                                e.currentTarget.style.background = 'rgba(34, 197, 94, 0.1)'
                                e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)'
                              }}
                            >
                              +
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  ) : (
                    /* Single table or physical combine: Show flat seat list */
                    <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', alignItems: 'center' }}>
                      {Array.from({ length: getTotalSeats(activeTable) }, (_, i) => i + 1).map(seatNum => (
                        <button
                          key={seatNum}
                          onClick={() => {
                            setActiveSeatNumber(seatNum)
                            setActiveSourceTableId(activeTable.id)
                            // Sync visual selection on table
                            if (activeTableId) {
                              selectSeat(activeTableId, seatNum)
                            }
                          }}
                          style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '6px',
                            border: `1px solid ${activeSeatNumber === seatNum ? 'rgba(168, 85, 247, 0.5)' : 'rgba(255, 255, 255, 0.1)'}`,
                            background: activeSeatNumber === seatNum ? 'rgba(168, 85, 247, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                            color: activeSeatNumber === seatNum ? '#c084fc' : '#94a3b8',
                            fontSize: '13px',
                            fontWeight: activeSeatNumber === seatNum ? 600 : 400,
                            cursor: 'pointer',
                            transition: 'all 0.15s ease',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                          }}
                        >
                          {seatNum}
                        </button>
                      ))}

                      {/* Add Seat Button (Skill 121) - works with or without active order */}
                      <button
                        onClick={() => handleAddSeat()}
                        title="Add a seat for extra guest"
                          style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '6px',
                            border: '2px dashed rgba(34, 197, 94, 0.4)',
                            background: 'rgba(34, 197, 94, 0.1)',
                            color: '#22c55e',
                            fontSize: '18px',
                            fontWeight: 600,
                            cursor: 'pointer',
                            transition: 'all 0.15s ease',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)'
                            e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)'
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.background = 'rgba(34, 197, 94, 0.1)'
                            e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)'
                          }}
                        >
                          +
                        </button>
                    </div>
                  )}
                </div>
              )}

              {/* Order Panel  shared component replaces inline rendering + OrderPanelActions */}
              <OrderPanel
                orderId={activeOrderId}
                orderNumber={activeOrderNumber ? Number(activeOrderNumber) : undefined}
                orderType={activeOrderType || undefined}
                locationId={locationId}
                items={inlineOrderItems.map(i => ({
                  id: i.id,
                  name: i.name,
                  quantity: i.quantity,
                  price: i.price,
                  modifiers: i.modifiers?.map(m => ({ name: m.name, price: m.price })),
                  specialNotes: i.specialNotes,
                  kitchenStatus: i.kitchenStatus as OrderPanelItemData['kitchenStatus'],
                  isHeld: i.isHeld,
                  isCompleted: i.isCompleted,
                  isTimedRental: i.isTimedRental,
                  menuItemId: i.menuItemId,
                  blockTimeMinutes: i.blockTimeMinutes,
                  blockTimeStartedAt: i.blockTimeStartedAt,
                  blockTimeExpiresAt: i.blockTimeExpiresAt,
                  seatNumber: i.seatNumber,
                  courseNumber: i.courseNumber,
                  courseStatus: i.courseStatus,
                  sentToKitchen: i.sentToKitchen,
                  resendCount: i.resendCount,
                  completedAt: i.completedAt,
                  createdAt: i.createdAt,
                }))}
                seatGroups={seatGroupsForPanel}
                subtotal={orderSubtotal}
                tax={tax}
                total={orderTotal}
                showItemControls={true}
                showEntertainmentTimers={true}
                onItemClick={(item) => {
                  const fullItem = inlineOrderItems.find(i => i.id === item.id)
                  if (fullItem) handleOrderItemTap(fullItem)
                }}
                onItemRemove={handleRemoveItem}
                onQuantityChange={handleUpdateQuantity}
                onItemHoldToggle={handleToggleHold}
                onItemNoteEdit={handleOpenNotesEditor}
                onItemCourseChange={handleUpdateCourse}
                onItemEditModifiers={(itemId) => {
                  const editItem = inlineOrderItems.find(i => i.id === itemId)
                  if (editItem) handleEditItem(editItem)
                }}
                onItemCompVoid={(itemId) => {
                  const voidItem = inlineOrderItems.find(i => i.id === itemId)
                  if (voidItem) handleOpenCompVoid(voidItem)
                }}
                onItemResend={(itemId) => {
                  const resendItem = inlineOrderItems.find(i => i.id === itemId)
                  if (resendItem) handleResendItem(itemId, resendItem.name)
                }}
                onItemSplit={(itemId) => {
                  setSplitItemId(itemId)
                  setShowSplitTicketManager(true)
                }}
                expandedItemId={expandedItemId}
                onItemToggleExpand={(id) => setExpandedItemId(prev => prev === id ? null : id)}
                onItemSeatChange={handleUpdateSeat}
                maxSeats={Math.max(guestCount, 4)}
                maxCourses={5}
                onSend={handleSendToKitchen}
                isSending={isSendingOrder}
                terminalId="terminal-1"
                employeeId={employeeId}
                onPaymentSuccess={handlePaymentSuccess}
                cashDiscountRate={CASH_DISCOUNT_RATE}
                taxRate={TAX_RATE}
                onPaymentModeChange={(mode) => setPaymentMode(mode)}
                onSaveOrderFirst={handleSaveOrderForPayment}
                autoShowPayment={pendingPayAfterSave}
                onAutoShowPaymentHandled={() => setPendingPayAfterSave(false)}
                hideHeader={true}
                className="flex-1"
              />
        </div>
      </div>

      {/* Virtual Combine Bar */}
      <VirtualCombineBar
        tables={tables}
        onConfirm={() => handleConfirmVirtualCombine()}
        onCancel={cancelVirtualCombineMode}
        isConfirming={isCreatingVirtualGroup}
      />

      {/* Existing Orders Modal (for virtual combine) */}
      <ExistingOrdersModal
        isOpen={showExistingOrdersModal}
        existingOrders={pendingExistingOrders}
        primaryTableName={tables.find(t => t.id === virtualCombinePrimaryId)?.name || 'Primary'}
        onConfirm={(actions) => handleConfirmVirtualCombine(actions)}
        onCancel={() => {
          setShowExistingOrdersModal(false)
          setPendingExistingOrders([])
        }}
        onCloseOrder={(orderId) => {
          // Redirect to payment for this order
          if (onOpenPayment) {
            onOpenPayment(orderId)
          }
        }}
        isProcessing={isCreatingVirtualGroup}
      />

      {/* Virtual Group Manager Modal (for managing/dissolving virtual groups) */}
      {virtualGroupManagerTableId && (() => {
        const managerTable = tables.find(t => t.id === virtualGroupManagerTableId)
        if (!managerTable?.virtualGroupId) return null
        const groupTables = tables.filter(t => t.virtualGroupId === managerTable.virtualGroupId)
        const primaryTable = groupTables.find(t => t.virtualGroupPrimary) || groupTables[0]
        return (
          <VirtualGroupManagerModal
            isOpen={true}
            onClose={() => setVirtualGroupManagerTableId(null)}
            groupTables={groupTables}
            primaryTableId={primaryTable?.id || managerTable.id}
            virtualGroupId={managerTable.virtualGroupId}
            locationId={locationId}
            employeeId={employeeId}
            onGroupUpdated={() => {
              // Clear extra seats for all tables in this group (they were virtual/temporary)
              const tableIdsInGroup = groupTables.map(t => t.id)
              setExtraSeats(prev => {
                const next = new Map(prev)
                tableIdsInGroup.forEach(id => next.delete(id))
                return next
              })
              loadFloorPlanData(false)
              setVirtualGroupManagerTableId(null)
            }}
          />
        )
      })()}

      {/* Table Info Panel (for combined table management) */}
      {infoPanelTableId && (
        <TableInfoPanel
          table={tables.find(t => t.id === infoPanelTableId) || null}
          isOpen={true}
          onClose={closeInfoPanel}
          onAddItems={() => {
            const table = tables.find(t => t.id === infoPanelTableId)
            if (table) handleTableTap(table)
            closeInfoPanel()
          }}
          onViewCheck={() => {
            const table = tables.find(t => t.id === infoPanelTableId)
            if (table) handleTableTap(table)
            closeInfoPanel()
          }}
          onMarkDirty={() => {
            if (infoPanelTableId) handleUpdateStatus(infoPanelTableId, 'dirty')
          }}
          onMarkAvailable={() => {
            if (infoPanelTableId) handleUpdateStatus(infoPanelTableId, 'available')
          }}
          onResetToDefault={
            tables.find(t => t.id === infoPanelTableId)?.combinedTableIds?.length
              ? () => handleResetToDefault([infoPanelTableId])
              : undefined
          }
        />
      )}

      {/* Notes Editor Modal */}
      <AnimatePresence>
        {editingNotesItemId && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            style={{
              position: 'fixed',
              inset: 0,
              background: 'rgba(0, 0, 0, 0.6)',
              backdropFilter: 'blur(4px)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
            }}
            onClick={() => setEditingNotesItemId(null)}
          >
            <motion.div
              initial={{ scale: 0.95, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.95, opacity: 0 }}
              onClick={(e) => e.stopPropagation()}
              style={{
                background: 'rgba(15, 23, 42, 0.98)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '16px',
                padding: '24px',
                width: '100%',
                maxWidth: '400px',
                margin: '20px',
                boxShadow: '0 20px 60px rgba(0, 0, 0, 0.5)',
              }}
            >
              <h3 style={{ fontSize: '18px', fontWeight: 600, color: '#f1f5f9', marginBottom: '16px' }}>
                Kitchen Note
              </h3>
              <p style={{ fontSize: '12px', color: '#64748b', marginBottom: '12px' }}>
                This note will be sent to the kitchen with the order.
              </p>
              <textarea
                value={editingNotesText}
                onChange={(e) => setEditingNotesText(e.target.value)}
                placeholder="e.g., No onions, extra pickles, allergic to nuts..."
                autoFocus
                style={{
                  width: '100%',
                  minHeight: '100px',
                  padding: '12px',
                  background: 'rgba(255, 255, 255, 0.05)',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  borderRadius: '10px',
                  color: '#e2e8f0',
                  fontSize: '14px',
                  resize: 'vertical',
                  outline: 'none',
                }}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                    handleSaveNotes()
                  }
                  if (e.key === 'Escape') {
                    setEditingNotesItemId(null)
                  }
                }}
              />
              <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
                <button
                  onClick={() => setEditingNotesItemId(null)}
                  style={{
                    flex: 1,
                    padding: '12px',
                    background: 'rgba(255, 255, 255, 0.05)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    borderRadius: '10px',
                    color: '#94a3b8',
                    fontSize: '14px',
                    fontWeight: 500,
                    cursor: 'pointer',
                  }}
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveNotes}
                  style={{
                    flex: 1,
                    padding: '12px',
                    background: '#f59e0b',
                    border: 'none',
                    borderRadius: '10px',
                    color: '#fff',
                    fontSize: '14px',
                    fontWeight: 600,
                    cursor: 'pointer',
                  }}
                >
                  Save Note
                </button>
              </div>
              <p style={{ fontSize: '11px', color: '#475569', marginTop: '12px', textAlign: 'center' }}>
                Press +Enter to save  Esc to cancel
              </p>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Menu Item Context Menu (right-click) */}
      {contextMenu && (
        <MenuItemContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          itemId={contextMenu.item.id}
          itemName={contextMenu.item.name}
          isInQuickBar={isInQuickBar(contextMenu.item.id)}
          onClose={closeContextMenu}
          onAddToQuickBar={() => addToQuickBar(contextMenu.item.id)}
          onRemoveFromQuickBar={() => removeFromQuickBar(contextMenu.item.id)}
        />
      )}

      {/* Room Reorder Modal */}
      <RoomReorderModal
        isOpen={showRoomReorderModal}
        onClose={() => setShowRoomReorderModal(false)}
        rooms={sections.map(s => ({ id: s.id, name: s.name, color: s.color }))}
        currentOrder={preferredRoomOrder}
        onSave={handleSaveRoomOrder}
      />

      {/* Resend to Kitchen Modal */}
      {resendModal && (
        <div
          style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.7)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 9999,
          }}
        >
          <div
            style={{
              background: '#1e293b',
              borderRadius: '12px',
              padding: '24px',
              width: '400px',
              maxWidth: '90vw',
              border: '1px solid rgba(245, 158, 11, 0.3)',
            }}
          >
            <h3
              style={{
                color: '#f1f5f9',
                fontSize: '18px',
                fontWeight: 600,
                marginBottom: '16px',
              }}
            >
              Resend to Kitchen
            </h3>
            <p
              style={{
                color: '#94a3b8',
                fontSize: '14px',
                marginBottom: '16px',
              }}
            >
              Resending: <strong style={{ color: '#e2e8f0' }}>{resendModal.itemName}</strong>
            </p>
            <textarea
              value={resendNote}
              onChange={(e) => setResendNote(e.target.value)}
              placeholder="Add a note for the kitchen (optional)"
              style={{
                width: '100%',
                padding: '12px',
                borderRadius: '8px',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                background: 'rgba(255, 255, 255, 0.05)',
                color: '#e2e8f0',
                fontSize: '14px',
                resize: 'none',
                height: '80px',
                marginBottom: '16px',
                fontFamily: 'inherit',
              }}
            />
            <div
              style={{
                display: 'flex',
                gap: '12px',
                justifyContent: 'flex-end',
              }}
            >
              <button
                onClick={() => setResendModal(null)}
                style={{
                  padding: '10px 20px',
                  background: 'rgba(255, 255, 255, 0.05)',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  borderRadius: '8px',
                  color: '#94a3b8',
                  fontSize: '14px',
                  fontWeight: 500,
                  cursor: 'pointer',
                  transition: 'all 0.15s ease',
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                }}
              >
                Cancel
              </button>
              <button
                onClick={confirmResendItem}
                disabled={resendLoading}
                style={{
                  padding: '10px 20px',
                  background: resendLoading ? 'rgba(245, 158, 11, 0.5)' : '#f59e0b',
                  border: 'none',
                  borderRadius: '8px',
                  color: '#fff',
                  fontSize: '14px',
                  fontWeight: 600,
                  cursor: resendLoading ? 'not-allowed' : 'pointer',
                  transition: 'all 0.15s ease',
                  opacity: resendLoading ? 0.7 : 1,
                }}
                onMouseEnter={(e) => {
                  if (!resendLoading) {
                    e.currentTarget.style.background = '#d97706'
                  }
                }}
                onMouseLeave={(e) => {
                  if (!resendLoading) {
                    e.currentTarget.style.background = '#f59e0b'
                  }
                }}
              >
                {resendLoading ? 'Sending...' : 'Resend'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Comp/Void Modal */}
      {compVoidItem && activeOrderId && employeeId && (
        <CompVoidModal
          isOpen={true}
          onClose={() => setCompVoidItem(null)}
          orderId={activeOrderId}
          item={{
            id: compVoidItem.id,
            name: compVoidItem.name,
            price: compVoidItem.price,
            quantity: compVoidItem.quantity,
            modifiers: compVoidItem.modifiers,
            status: compVoidItem.status,
          }}
          employeeId={employeeId}
          locationId={locationId}
          onComplete={async () => {
            setCompVoidItem(null)
            // Refresh order data by reloading the order
            if (activeOrderId) {
              try {
                const response = await fetch(`/api/orders/${activeOrderId}`)
                if (response.ok) {
                  const orderData = await response.json()
                  // Update inline order items from the fresh order data
                  const freshItems = orderData.items?.map((item: any) => ({
                    id: item.id,
                    menuItemId: item.menuItemId,
                    name: item.name,
                    price: Number(item.price),
                    quantity: item.quantity,
                    modifiers: item.modifiers?.map((mod: any) => ({
                      id: mod.modifierId,
                      name: mod.name,
                      price: Number(mod.price),
                    })) || [],
                    seatNumber: item.seatNumber,
                    courseNumber: item.courseNumber,
                    specialNotes: item.specialNotes,
                    sentToKitchen: true,
                    resendCount: item.resendCount,
                  })) || []
                  setInlineOrderItems(freshItems)
                }
              } catch (error) {
                console.error('Failed to refresh order:', error)
              }
            }
            toast.success('Item comped/voided successfully')
          }}
        />
      )}

      {/* Split Ticket Manager */}
      {showSplitTicketManager && activeOrderId && (
        <SplitTicketManager
          orderId={activeOrderId}
          isOpen={showSplitTicketManager}
          onClose={() => {
            setShowSplitTicketManager(false)
            setSplitItemId(null)
          }}
          orderNumber={activeOrderNumber || ''}
          items={inlineOrderItems.map(item => ({
            id: item.id,
            tempId: item.id,
            name: item.name,
            price: item.price,
            quantity: item.quantity,
            modifiers: (item.modifiers || []).map(m => ({ name: m.name, price: m.price })),
          }))}
          orderDiscount={0}
          taxRate={0.08}
          onSplitComplete={async () => {
            // Refresh order data by reloading the order
            if (activeOrderId) {
              try {
                const response = await fetch(`/api/orders/${activeOrderId}`)
                if (response.ok) {
                  const orderData = await response.json()
                  // Update inline order items from the fresh order data
                  const freshItems = orderData.items?.map((item: any) => ({
                    id: item.id,
                    menuItemId: item.menuItemId,
                    name: item.name,
                    price: Number(item.price),
                    quantity: item.quantity,
                    modifiers: item.modifiers?.map((mod: any) => ({
                      id: mod.modifierId,
                      name: mod.name,
                      price: Number(mod.price),
                    })) || [],
                    seatNumber: item.seatNumber,
                    courseNumber: item.courseNumber,
                    specialNotes: item.specialNotes,
                    sentToKitchen: true,
                    resendCount: item.resendCount,
                  })) || []
                  setInlineOrderItems(freshItems)
                }
              } catch (error) {
                console.error('Failed to refresh order:', error)
              }
            }
            setShowSplitTicketManager(false)
            setSplitItemId(null)
            toast.success('Item moved to split check')
          }}
        />
      )}
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/FloorPlanTable.tsx
################################################################################

'use client'

import { useState, useEffect, useCallback, useRef, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { FloorPlanTable as TableType, FloorPlanSeat } from './use-floor-plan'
import { SeatInfo, determineSeatStatus, SEAT_STATUS_COLORS } from '@/lib/seat-utils'
import { distributeSeatsOnPerimeter, type TableRect, type Point } from '@/lib/table-geometry'

interface FloorPlanTableProps {
  table: TableType
  mode: 'admin' | 'service'
  isSelected: boolean
  isDragging?: boolean
  isDropTarget?: boolean
  combinedGroupColor?: string
  showSeats?: boolean
  selectedSeatNumber?: number | null
  tableRotation?: number
  /** All tables in the combined group (for perimeter-based seating) */
  groupTables?: TableRect[]
  onSeatTap?: (seatNumber: number) => void
  onSeatRemove?: (seatIndex: number) => void
  onSeatSelect?: (seatIndex: number | null) => void
  onSeatPositionChange?: (seatIndex: number, relativeX: number, relativeY: number) => void
  flashMessage?: string | null
}

/**
 * FloorPlanTable - Renders the table surface and orbital seats with auto-spacing
 *
 * This component handles:
 * - Table shape rendering (circle, square, rectangle, booth, bar)
 * - Visual states (selected, dragging, drop target)
 * - Combined table grouping colors
 * - Automatic orbital seat spacing with layout animations
 * - Counter-rotation for upright seat labels
 * - Interactive seat rendering with status colors in service mode
 */
export function FloorPlanTable({
  table,
  mode,
  isSelected,
  isDragging = false,
  isDropTarget = false,
  combinedGroupColor,
  showSeats = false,
  selectedSeatNumber,
  tableRotation = 0,
  groupTables,
  onSeatTap,
  onSeatRemove,
  onSeatSelect,
  onSeatPositionChange,
  flashMessage,
}: FloorPlanTableProps) {
  const isRound = table.shape === 'circle'
  const isBooth = table.shape === 'booth'
  const isBar = table.shape === 'bar'

  // Calculate border radius based on shape
  const getBorderRadius = () => {
    if (isRound) return '50%'
    if (isBooth) return '16px 16px 4px 4px'
    if (isBar) return '8px'
    return '12px'
  }

  // Get status-based styling
  const getStatusStyles = () => {
    const status = table.status || 'available'
    switch (status) {
      case 'occupied':
        return {
          borderColor: 'rgba(34, 197, 94, 0.6)',
          background: 'rgba(34, 197, 94, 0.15)',
        }
      case 'reserved':
        return {
          borderColor: 'rgba(234, 179, 8, 0.6)',
          background: 'rgba(234, 179, 8, 0.15)',
        }
      case 'dirty':
        return {
          borderColor: 'rgba(239, 68, 68, 0.6)',
          background: 'rgba(239, 68, 68, 0.15)',
        }
      default:
        return {
          borderColor: 'rgba(100, 116, 139, 0.4)',
          background: 'rgba(15, 23, 42, 0.8)',
        }
    }
  }

  const statusStyles = getStatusStyles()

  // Build seat info from table seats for orbital display
  const seatInfoList: SeatInfo[] = (table.seats || []).map((seat: FloorPlanSeat) => {
    const orderItems = table.currentOrder?.items || []
    const seatItems = orderItems.filter((item: any) => item.seatNumber === seat.seatNumber)
    const subtotal = seatItems.reduce((sum: number, item: any) => sum + item.price * item.quantity, 0)
    const taxAmount = subtotal * 0.0825
    const seatTotal = subtotal + taxAmount

    return {
      seatNumber: seat.seatNumber,
      status: mode === 'admin' ? 'empty' : determineSeatStatus(seatItems, seat.seatNumber),
      subtotal,
      taxAmount,
      total: seatTotal,
      itemCount: seatItems.length,
    }
  })

  return (
    <div className="relative w-full h-full group">
      {/* 1. The Table Surface */}
      <motion.div
        className="w-full h-full flex items-center justify-center transition-all"
        style={{
          borderRadius: getBorderRadius(),
          border: `2px solid ${
            isDropTarget
              ? 'rgba(99, 102, 241, 0.8)'
              : isSelected
                ? 'rgba(99, 102, 241, 0.6)'
                : combinedGroupColor
                  ? combinedGroupColor
                  : statusStyles.borderColor
          }`,
          background: isDropTarget
            ? 'rgba(99, 102, 241, 0.2)'
            : isSelected
              ? 'rgba(99, 102, 241, 0.15)'
              : statusStyles.background,
          boxShadow: isDragging
            ? '0 20px 40px rgba(0, 0, 0, 0.4), 0 0 20px rgba(99, 102, 241, 0.3)'
            : isSelected
              ? '0 8px 24px rgba(0, 0, 0, 0.3), 0 0 12px rgba(99, 102, 241, 0.2)'
              : '0 4px 12px rgba(0, 0, 0, 0.2)',
          transform: isDragging ? 'scale(1.05)' : 'scale(1)',
        }}
        animate={{
          scale: isDragging ? 1.05 : 1,
        }}
        transition={{ type: 'spring', stiffness: 400, damping: 25 }}
      >
        {/* Table Label */}
        <div className="flex flex-col items-center justify-center">
          <span className="text-[11px] font-black text-slate-300 select-none uppercase tracking-tighter">
            {table.abbreviation || table.name}
          </span>

          {/* Capacity indicator */}
          {mode === 'service' && table.currentOrder && (
            <span className="text-[9px] text-emerald-400 mt-0.5">
              {table.currentOrder.guestCount}/{table.capacity}
            </span>
          )}
        </div>

        {/* Flash Message Overlay */}
        {flashMessage && (
          <motion.div
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 flex items-center justify-center bg-amber-500/90 rounded-inherit"
            style={{ borderRadius: getBorderRadius() }}
          >
            <span className="text-[10px] font-bold text-white uppercase tracking-wider">{flashMessage}</span>
          </motion.div>
        )}
      </motion.div>

      {/* 2. Orbital Seat Rendering with Auto-Spacing (or Perimeter for combined groups) */}
      {showSeats && (
        <OrbitalSeats
          seats={table.seats || []}
          seatInfo={seatInfoList}
          tableWidth={table.width}
          tableHeight={table.height}
          tablePosX={table.posX}
          tablePosY={table.posY}
          tableRotation={tableRotation}
          groupTables={groupTables}
          mode={mode}
          selectedSeatNumber={selectedSeatNumber}
          onSeatTap={onSeatTap}
          onSeatRemove={onSeatRemove}
          onSeatSelect={onSeatSelect}
          onSeatPositionChange={onSeatPositionChange}
        />
      )}

      {/* 3. Drag Handle Decoration (Admin only) */}
      {mode === 'admin' && (
        <div className="absolute -top-2 -right-2 w-4 h-4 bg-indigo-600 rounded-full border-2 border-white scale-0 group-hover:scale-100 transition-transform flex items-center justify-center shadow-lg">
          <div className="w-1.5 h-1.5 bg-white rounded-full" />
        </div>
      )}

      {/* 4. Combined Group Indicator */}
      {combinedGroupColor && (
        <div
          className="absolute -bottom-1 left-1/2 -translate-x-1/2 px-1.5 py-0.5 rounded-full text-[8px] font-bold text-white"
          style={{ backgroundColor: combinedGroupColor }}
        >
          COMBINED
        </div>
      )}
    </div>
  )
}

/**
 * OrbitalSeats - Renders seats with automatic orbital spacing and layout animations
 *
 * Features:
 * - Auto-spacing: Seats automatically redistribute when one is removed
 * - Layout animations: Framer Motion's layout prop makes seats slide smoothly
 * - Counter-rotation: Seat numbers stay upright regardless of table rotation
 * - Drag support: In admin mode, seats can be manually positioned
 */
interface OrbitalSeatsProps {
  seats: FloorPlanSeat[]
  seatInfo: SeatInfo[]
  tableWidth: number
  tableHeight: number
  tablePosX: number
  tablePosY: number
  tableRotation: number
  /** All tables in combined group for perimeter-based seating */
  groupTables?: TableRect[]
  mode: 'admin' | 'service'
  selectedSeatNumber?: number | null
  onSeatTap?: (seatNumber: number) => void
  onSeatRemove?: (seatIndex: number) => void
  onSeatSelect?: (seatIndex: number | null) => void
  onSeatPositionChange?: (seatIndex: number, relativeX: number, relativeY: number) => void
}

function OrbitalSeats({
  seats,
  seatInfo,
  tableWidth,
  tableHeight,
  tablePosX,
  tablePosY,
  tableRotation,
  groupTables,
  mode,
  selectedSeatNumber,
  onSeatTap,
  onSeatRemove,
  onSeatSelect,
  onSeatPositionChange,
}: OrbitalSeatsProps) {
  const isAdmin = mode === 'admin'
  const [localSelectedIndex, setLocalSelectedIndex] = useState<number | null>(null)
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)

  // Current capacity for auto-spacing calculations
  const currentCapacity = seats.length

  // Dynamic seat sizing based on count (shrink if >8 seats to prevent overflow)
  const seatSize = currentCapacity > 12 ? 16 : currentCapacity > 8 ? 20 : 24
  const seatFontSize = currentCapacity > 12 ? 8 : currentCapacity > 8 ? 9 : 10

  // Orbital geometry
  const centerX = tableWidth / 2
  const centerY = tableHeight / 2
  const orbitRadius = Math.max(tableWidth, tableHeight) / 2 + 20

  // Check if this table is part of a combined group
  const isInCombinedGroup = groupTables && groupTables.length > 1

  // For combined groups: seats use their DATABASE positions (relativeX/Y) which are
  // calculated by the combine API using the true L/T/U shape perimeter.
  // We don't recalculate in frontend because each table renders independently and
  // would produce incorrect overlapping positions.
  //
  // For single tables: use orbital auto-spacing around the table.
  const perimeterPositions = useMemo(() => {
    // Combined groups: use database positions (don't recalculate)
    if (isInCombinedGroup) return null

    // Single table: no perimeter calculation needed, use orbital spacing
    return null
  }, [isInCombinedGroup])

  // Calculate auto-spaced orbital position for a seat
  const getAutoSpacedPosition = useCallback(
    (index: number, total: number) => {
      // If we have perimeter positions for combined groups, use those
      if (perimeterPositions && perimeterPositions[index]) {
        return perimeterPositions[index]
      }
      // Evenly distribute seats around the orbit
      // Start from top (-90) and go clockwise
      const angle = (index * 2 * Math.PI) / total - Math.PI / 2
      return {
        x: centerX + Math.cos(angle) * orbitRadius,
        y: centerY + Math.sin(angle) * orbitRadius,
      }
    },
    [centerX, centerY, orbitRadius, perimeterPositions]
  )

  // Orbit constraints for manual positioning
  const minOrbitRadius = Math.max(tableWidth, tableHeight) / 2 + 12
  const maxOrbitRadius = Math.max(tableWidth, tableHeight) / 2 + 50

  // Constrain position to orbit range (for manual drag)
  const constrainToOrbit = useCallback(
    (x: number, y: number) => {
      const dx = x - centerX
      const dy = y - centerY
      const distance = Math.sqrt(dx * dx + dy * dy)
      const angle = Math.atan2(dy, dx)

      const clampedDistance = Math.max(minOrbitRadius, Math.min(maxOrbitRadius, distance))

      return {
        x: centerX + Math.cos(angle) * clampedDistance,
        y: centerY + Math.sin(angle) * clampedDistance,
      }
    },
    [centerX, centerY, minOrbitRadius, maxOrbitRadius]
  )

  // Convert screen coordinates to local (unrotated) coordinates
  const screenToLocal = useCallback(
    (screenX: number, screenY: number) => {
      const radians = -(tableRotation || 0) * (Math.PI / 180)
      const relX = screenX - centerX
      const relY = screenY - centerY
      const localX = relX * Math.cos(radians) - relY * Math.sin(radians)
      const localY = relX * Math.sin(radians) + relY * Math.cos(radians)
      return {
        x: localX + centerX,
        y: localY + centerY,
      }
    },
    [tableRotation, centerX, centerY]
  )

  // Handle keyboard navigation for fine-tuning
  useEffect(() => {
    if (!isAdmin || localSelectedIndex === null) return

    const handleKeyDown = (e: KeyboardEvent) => {
      const step = e.shiftKey ? 10 : 3
      const seat = seats[localSelectedIndex]
      if (!seat) return

      // Get current position in ABSOLUTE coordinates (for constraint calculations)
      const hasCustomPosition = seat.relativeX !== 0 || seat.relativeY !== 0
      const autoPos = getAutoSpacedPosition(localSelectedIndex, currentCapacity)
      // Convert relative to absolute, or use auto position
      const currentAbsX = hasCustomPosition ? (centerX + seat.relativeX) : autoPos.x
      const currentAbsY = hasCustomPosition ? (centerY + seat.relativeY) : autoPos.y

      let newAbsX = currentAbsX
      let newAbsY = currentAbsY

      switch (e.key) {
        case 'ArrowUp':
          newAbsY = currentAbsY - step
          e.preventDefault()
          break
        case 'ArrowDown':
          newAbsY = currentAbsY + step
          e.preventDefault()
          break
        case 'ArrowLeft':
          newAbsX = currentAbsX - step
          e.preventDefault()
          break
        case 'ArrowRight':
          newAbsX = currentAbsX + step
          e.preventDefault()
          break
        case 'Delete':
        case 'Backspace':
          if (onSeatRemove && seats.length > 1) {
            onSeatRemove(localSelectedIndex)
            setLocalSelectedIndex(null)
          }
          e.preventDefault()
          return
        case 'Escape':
          setLocalSelectedIndex(null)
          onSeatSelect?.(null)
          e.preventDefault()
          return
        default:
          return
      }

      // Constrain to orbit (works with absolute coords), then convert to relative
      const constrained = constrainToOrbit(newAbsX, newAbsY)
      const relativeX = constrained.x - centerX
      const relativeY = constrained.y - centerY
      onSeatPositionChange?.(localSelectedIndex, relativeX, relativeY)
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [
    isAdmin,
    localSelectedIndex,
    seats,
    currentCapacity,
    centerX,
    centerY,
    getAutoSpacedPosition,
    constrainToOrbit,
    onSeatPositionChange,
    onSeatRemove,
    onSeatSelect,
  ])

  return (
    <div ref={containerRef} className="absolute inset-0 pointer-events-none">
      <AnimatePresence mode="popLayout">
        {seats.map((seat, index) => {
          const seatNumber = seat.seatNumber

          // Seat positioning logic:
          // 1. Combined groups: ALWAYS use database positions (set by combine API)
          // 2. Single tables with custom position: use database position
          // 3. Single tables without custom position: use orbital auto-spacing
          const hasCustomPosition = seat.relativeX !== 0 || seat.relativeY !== 0
          const useDbPosition = isInCombinedGroup || hasCustomPosition
          const autoPos = getAutoSpacedPosition(index, currentCapacity)
          const x = useDbPosition ? (centerX + seat.relativeX) : autoPos.x
          const y = useDbPosition ? (centerY + seat.relativeY) : autoPos.y

          const info = seatInfo[index]
          const isSelected = localSelectedIndex === index || selectedSeatNumber === seatNumber
          const statusColor = isAdmin ? '#64748b' : SEAT_STATUS_COLORS[info?.status || 'empty']
          const bgColor = isAdmin ? 'rgba(100, 116, 139, 0.2)' : `${statusColor}20`

          const handleClick = (e: React.MouseEvent) => {
            e.stopPropagation()
            if (isAdmin) {
              setLocalSelectedIndex(index)
              onSeatSelect?.(index)
            } else if (onSeatTap) {
              onSeatTap(seatNumber)
            }
          }

          const handlePointerDown = (e: React.PointerEvent) => {
            if (!isAdmin) return
            e.stopPropagation()
            setDraggedIndex(index)
            setLocalSelectedIndex(index)
            onSeatSelect?.(index)
            ;(e.target as HTMLElement).setPointerCapture(e.pointerId)
          }

          const handlePointerMove = (e: React.PointerEvent) => {
            if (!isAdmin || draggedIndex !== index) return
            e.stopPropagation()

            const container = containerRef.current
            if (!container) return

            const rect = container.getBoundingClientRect()
            const screenX = e.clientX - rect.left
            const screenY = e.clientY - rect.top
            const local = screenToLocal(screenX, screenY)
            const constrained = constrainToOrbit(local.x, local.y)
            // Convert absolute position to relative (for storage)
            const relativeX = constrained.x - centerX
            const relativeY = constrained.y - centerY
            onSeatPositionChange?.(index, relativeX, relativeY)
          }

          const handlePointerUp = (e: React.PointerEvent) => {
            if (draggedIndex === index) {
              setDraggedIndex(null)
              ;(e.target as HTMLElement).releasePointerCapture(e.pointerId)
            }
          }

          return (
            <motion.div
              key={`seat-${seat.id || seatNumber}`}
              layout //  Enables smooth sliding to new positions on re-spacing
              initial={{ scale: 0, opacity: 0 }}
              animate={{
                scale: draggedIndex === index ? 1.2 : 1,
                opacity: 1,
                left: x - 12,
                top: y - 12,
              }}
              exit={{ scale: 0, opacity: 0 }}
              transition={{
                layout: { type: 'spring', stiffness: 400, damping: 30 },
                scale: { type: 'spring', stiffness: 400, damping: 25 },
                opacity: { duration: 0.2 },
              }}
              onClick={handleClick}
              onPointerDown={handlePointerDown}
              onPointerMove={handlePointerMove}
              onPointerUp={handlePointerUp}
              onPointerCancel={handlePointerUp}
              className={`absolute flex items-center justify-center rounded-full pointer-events-auto ${
                isAdmin
                  ? isSelected
                    ? 'ring-2 ring-indigo-500 ring-offset-2 ring-offset-slate-900'
                    : 'hover:ring-2 hover:ring-indigo-400/50'
                  : ''
              }`}
              style={{
                width: seatSize,
                height: seatSize,
                backgroundColor: isSelected ? 'rgba(99, 102, 241, 0.3)' : bgColor,
                border: `2px solid ${isSelected ? '#6366f1' : statusColor}`,
                boxShadow: isSelected
                  ? '0 0 12px rgba(99, 102, 241, 0.6)'
                  : draggedIndex === index
                    ? '0 4px 12px rgba(0, 0, 0, 0.4)'
                    : '0 2px 4px rgba(0, 0, 0, 0.3)',
                cursor: isAdmin ? (draggedIndex === index ? 'grabbing' : 'grab') : onSeatTap ? 'pointer' : 'default',
                zIndex: isSelected ? 30 : draggedIndex === index ? 50 : 10,
                touchAction: 'none',
                transition: 'width 0.2s, height 0.2s', // Smooth size transition when seats change
              }}
              title={isAdmin ? 'Drag to position  Arrow keys to fine-tune  Delete to remove' : undefined}
            >
              {/*  Counter-rotate the number to keep it upright */}
              <motion.span
                animate={{ rotate: -(tableRotation || 0) }}
                className="font-bold select-none pointer-events-none"
                style={{
                  fontSize: `${seatFontSize}px`,
                  color: isSelected ? '#a5b4fc' : statusColor
                }}
              >
                {seatNumber}
              </motion.span>
            </motion.div>
          )
        })}
      </AnimatePresence>

      {/* Instructions overlay when seat selected in admin mode */}
      {isAdmin && localSelectedIndex !== null && (
        <div className="absolute -bottom-8 left-1/2 -translate-x-1/2 whitespace-nowrap pointer-events-none">
          <span className="text-[9px] text-indigo-400 bg-slate-900/90 px-2 py-1 rounded-full">
            Arrow keys to nudge  Shift+Arrow for bigger steps  Delete to remove
          </span>
        </div>
      )}
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/hooks/index.ts
################################################################################

/**
 * Floor Plan Hooks
 *
 * Custom hooks extracted from FloorPlanHome to reduce complexity
 * and enable reuse across components.
 */

export { useFloorPlanAutoScale } from './useFloorPlanAutoScale'
export { useFloorPlanDrag } from './useFloorPlanDrag'



################################################################################
# FILE: src/components/floor-plan/hooks/useFloorPlanAutoScale.ts
################################################################################

/**
 * useFloorPlanAutoScale Hook
 *
 * Handles auto-scaling of the floor plan to fit all tables/elements
 * within the container while maintaining usability.
 *
 * Features:
 * - ResizeObserver for responsive container sizing
 * - Calculates bounding box of all visible tables and elements
 * - Computes scale factor to fit content (min 0.3, max 1.0)
 * - Calculates offset to center scaled content
 */

import { useState, useEffect, useMemo, RefObject } from 'react'

interface TableLike {
  posX: number
  posY: number
  width?: number
  height?: number
  section?: { id: string } | null
}

interface ElementLike {
  posX: number
  posY: number
  width?: number
  height?: number
  sectionId?: string | null
}

interface UseFloorPlanAutoScaleOptions {
  containerRef: RefObject<HTMLDivElement | null>
  tables: TableLike[]
  elements: ElementLike[]
  selectedSectionId: string | null
  padding?: number
  minScale?: number
  maxScale?: number
}

interface AutoScaleResult {
  containerSize: { width: number; height: number }
  tableBounds: {
    minX: number
    minY: number
    maxX: number
    maxY: number
    width: number
    height: number
  } | null
  autoScale: number
  autoScaleOffset: { x: number; y: number }
}

export function useFloorPlanAutoScale({
  containerRef,
  tables,
  elements,
  selectedSectionId,
  padding = 60,
  minScale = 0.3,
  maxScale = 1,
}: UseFloorPlanAutoScaleOptions): AutoScaleResult {
  // Container size state
  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 })

  // Measure container size with ResizeObserver
  useEffect(() => {
    if (!containerRef.current) return

    const observer = new ResizeObserver(entries => {
      const { width, height } = entries[0].contentRect
      setContainerSize({ width, height })
    })

    observer.observe(containerRef.current)
    return () => observer.disconnect()
  }, [containerRef])

  // Calculate bounding box of all visible tables and elements
  const tableBounds = useMemo(() => {
    // Filter tables by selected section
    const visibleTables = selectedSectionId === null
      ? tables
      : tables.filter(t => t.section?.id === selectedSectionId)

    // Filter elements by selected section
    const visibleElements = selectedSectionId === null
      ? elements
      : elements.filter(e => e.sectionId === selectedSectionId || e.sectionId === null)

    if (visibleTables.length === 0 && visibleElements.length === 0) return null

    let minX = Infinity
    let minY = Infinity
    let maxX = -Infinity
    let maxY = -Infinity

    visibleTables.forEach(table => {
      minX = Math.min(minX, table.posX)
      minY = Math.min(minY, table.posY)
      maxX = Math.max(maxX, table.posX + (table.width || 100))
      maxY = Math.max(maxY, table.posY + (table.height || 100))
    })

    // Also consider entertainment elements
    visibleElements.forEach(element => {
      minX = Math.min(minX, element.posX)
      minY = Math.min(minY, element.posY)
      maxX = Math.max(maxX, element.posX + (element.width || 100))
      maxY = Math.max(maxY, element.posY + (element.height || 100))
    })

    return {
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY,
    }
  }, [tables, elements, selectedSectionId])

  // Calculate scale factor to fit all tables in container
  const autoScale = useMemo(() => {
    if (!tableBounds || containerSize.width === 0 || containerSize.height === 0) {
      return 1
    }

    const availableWidth = containerSize.width - padding * 2
    const availableHeight = containerSize.height - padding * 2

    // Only scale down if content is larger than container
    if (tableBounds.width <= availableWidth && tableBounds.height <= availableHeight) {
      return 1
    }

    const scaleX = availableWidth / tableBounds.width
    const scaleY = availableHeight / tableBounds.height

    // Use smaller scale to fit both dimensions
    // Cap between minScale and maxScale
    return Math.max(minScale, Math.min(scaleX, scaleY, maxScale))
  }, [tableBounds, containerSize, padding, minScale, maxScale])

  // Calculate offset to center the scaled content
  const autoScaleOffset = useMemo(() => {
    if (!tableBounds || autoScale === 1) {
      return { x: 0, y: 0 }
    }

    const scaledWidth = tableBounds.width * autoScale
    const scaledHeight = tableBounds.height * autoScale

    // Center the content, accounting for the minX/minY offset
    const offsetX = (containerSize.width - scaledWidth) / 2 - tableBounds.minX * autoScale
    const offsetY = (containerSize.height - scaledHeight) / 2 - tableBounds.minY * autoScale

    return { x: offsetX, y: offsetY }
  }, [tableBounds, autoScale, containerSize])

  return {
    containerSize,
    tableBounds,
    autoScale,
    autoScaleOffset,
  }
}



################################################################################
# FILE: src/components/floor-plan/hooks/useFloorPlanDrag.ts
################################################################################

/**
 * useFloorPlanDrag Hook
 *
 * Handles table drag-and-drop for combining tables in the floor plan.
 *
 * Features:
 * - Pointer move/up handlers for drag operations
 * - Coordinate transformation for auto-scaled floor plans
 * - Ghost preview calculation for visual feedback
 * - Drop target detection with hit testing
 * - Collision detection with fixtures (walls, bar counters, etc.)
 */

import { useState, useCallback, useMemo, RefObject } from 'react'
import { calculateAttachSide, calculateAttachPosition } from '../table-positioning'
import { checkTableAllFixturesCollision, type FixtureBounds } from '@/domains/floor-plan/shared/collisionDetection'

interface TableLike {
  id: string
  posX: number
  posY: number
  width: number
  height: number
  combinedWithId?: string | null
  combinedTableIds?: string[] | null
}

interface FixtureLike {
  id: string
  visualType: string
  posX: number
  posY: number
  width: number
  height: number
  geometry?: any
  thickness?: number
}

interface UseFloorPlanDragOptions {
  containerRef: RefObject<HTMLDivElement | null>
  tablesRef: RefObject<TableLike[]>
  fixturesRef: RefObject<FixtureLike[]>
  autoScaleRef: RefObject<number>
  autoScaleOffsetRef: RefObject<{ x: number; y: number }>
  draggedTableId: string | null
  dropTargetTableId: string | null
  updateDragTarget: (tableId: string | null, position?: { x: number; y: number }) => void
  endDrag: () => void
  onCombine: (sourceId: string, targetId: string, dropPosition?: { x: number; y: number }) => Promise<boolean>
}

interface GhostPreview {
  posX: number
  posY: number
  width: number
  height: number
  side: 'top' | 'bottom' | 'left' | 'right'
}

interface UseFloorPlanDragResult {
  handlePointerMove: (e: React.PointerEvent) => void
  handlePointerUp: () => Promise<void>
  ghostPreview: GhostPreview | null
  lastDropPosition: { x: number; y: number } | null
  isColliding: boolean
}

export function useFloorPlanDrag({
  containerRef,
  tablesRef,
  fixturesRef,
  autoScaleRef,
  autoScaleOffsetRef,
  draggedTableId,
  dropTargetTableId,
  updateDragTarget,
  endDrag,
  onCombine,
}: UseFloorPlanDragOptions): UseFloorPlanDragResult {
  // Track drop position for ghost preview and combine API
  const [lastDropPosition, setLastDropPosition] = useState<{ x: number; y: number } | null>(null)

  // Track collision state for visual feedback
  const [isColliding, setIsColliding] = useState(false)

  // Handle pointer move during drag
  // Transforms screen coordinates to floor plan coordinates when auto-scaled
  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!draggedTableId || !containerRef.current) return

    const rect = containerRef.current.getBoundingClientRect()
    let x = e.clientX - rect.left
    let y = e.clientY - rect.top

    // Transform screen coords to floor plan coords when auto-scaled
    // The floor plan content is wrapped in a scaled/translated div, so pointer
    // coordinates need to be reverse-transformed to match table positions
    const scale = autoScaleRef.current
    const offset = autoScaleOffsetRef.current
    if (scale < 1) {
      x = (x - offset.x) / scale
      y = (y - offset.y) / scale
    }

    setLastDropPosition({ x, y })

    // Get dragged table for collision checking
    const draggedTable = tablesRef.current.find(t => t.id === draggedTableId)
    if (!draggedTable) return

    // Check collision with fixtures at the current drag position
    // Convert fixtures to FixtureBounds format for collision detection
    const fixtureBounds: FixtureBounds[] = fixturesRef.current.map(fixture => {
      // Determine fixture type based on visualType
      let fixtureType: 'wall' | 'rectangle' | 'circle' = 'rectangle'
      if (fixture.visualType === 'wall' || fixture.geometry?.start) {
        fixtureType = 'wall'
      } else if (fixture.visualType === 'pillar' || fixture.visualType === 'planter_builtin') {
        fixtureType = 'circle'
      }

      return {
        id: fixture.id,
        type: fixtureType,
        visualType: fixture.visualType,
        x: fixture.posX + fixture.width / 2, // Convert to center-based coords
        y: fixture.posY + fixture.height / 2,
        width: fixture.width,
        height: fixture.height,
        centerX: fixtureType === 'circle' ? fixture.posX + fixture.width / 2 : undefined,
        centerY: fixtureType === 'circle' ? fixture.posY + fixture.height / 2 : undefined,
        radius: fixtureType === 'circle' ? Math.max(fixture.width, fixture.height) / 2 : undefined,
        geometry: fixture.geometry,
        thickness: fixture.thickness,
      }
    })

    // Check if table would collide with any fixtures at current position
    const collisionResult = checkTableAllFixturesCollision(
      {
        x: x + draggedTable.width / 2, // Convert to center-based coords
        y: y + draggedTable.height / 2,
        width: draggedTable.width,
        height: draggedTable.height,
      },
      fixtureBounds
    )

    // Update collision state for visual feedback
    setIsColliding(collisionResult.collides)

    // Hit test against all tables except the dragged one
    for (const table of tablesRef.current) {
      if (table.id === draggedTableId) continue

      if (
        x >= table.posX &&
        x <= table.posX + table.width &&
        y >= table.posY &&
        y <= table.posY + table.height
      ) {
        updateDragTarget(table.id, { x, y })
        return
      }
    }
    updateDragTarget(null)
  }, [draggedTableId, containerRef, autoScaleRef, autoScaleOffsetRef, tablesRef, fixturesRef, updateDragTarget])

  // Handle pointer up - execute combine if dropped on a target
  const handlePointerUp = useCallback(async () => {
    // Prevent combine if colliding with fixtures
    if (isColliding) {
      console.warn('[useFloorPlanDrag] Cannot place table - collides with fixture')
      endDrag()
      setLastDropPosition(null)
      setIsColliding(false)
      return
    }

    if (draggedTableId && dropTargetTableId) {
      await onCombine(draggedTableId, dropTargetTableId, lastDropPosition || undefined)
    }
    endDrag()
    setLastDropPosition(null)
    setIsColliding(false)
  }, [draggedTableId, dropTargetTableId, isColliding, onCombine, endDrag, lastDropPosition])

  // Calculate ghost preview position for visual feedback
  const ghostPreview = useMemo((): GhostPreview | null => {
    if (!draggedTableId || !dropTargetTableId || !lastDropPosition) return null

    const tables = tablesRef.current
    const sourceTable = tables.find(t => t.id === draggedTableId)
    const targetTable = tables.find(t => t.id === dropTargetTableId)
    if (!sourceTable || !targetTable) return null

    // If target is part of a combined group, use the combined bounding box
    // This matches what the API does for positioning
    let effectiveTargetRect = {
      id: targetTable.id,
      posX: targetTable.posX,
      posY: targetTable.posY,
      width: targetTable.width,
      height: targetTable.height,
    }

    // Find the primary table if target is combined
    const primaryTableId = targetTable.combinedWithId ||
      (targetTable.combinedTableIds?.length ? targetTable.id : null)

    if (primaryTableId) {
      const primaryTable = tables.find(t => t.id === primaryTableId)
      if (primaryTable) {
        // Calculate combined bounding box
        const combinedIds = primaryTable.combinedTableIds || []
        const allGroupTables = [primaryTable, ...combinedIds.map(id => tables.find(t => t.id === id)).filter(Boolean)] as TableLike[]

        if (allGroupTables.length > 1) {
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity
          for (const t of allGroupTables) {
            minX = Math.min(minX, t.posX)
            minY = Math.min(minY, t.posY)
            maxX = Math.max(maxX, t.posX + t.width)
            maxY = Math.max(maxY, t.posY + t.height)
          }
          effectiveTargetRect = {
            id: primaryTableId,
            posX: minX,
            posY: minY,
            width: maxX - minX,
            height: maxY - minY,
          }
        }
      }
    }

    const sourceRect = {
      id: sourceTable.id,
      posX: sourceTable.posX,
      posY: sourceTable.posY,
      width: sourceTable.width,
      height: sourceTable.height,
    }

    const side = calculateAttachSide(lastDropPosition.x, lastDropPosition.y, effectiveTargetRect)
    const position = calculateAttachPosition(sourceRect, effectiveTargetRect, side)

    return {
      ...position,
      width: sourceTable.width,
      height: sourceTable.height,
      side,
    }
  }, [draggedTableId, dropTargetTableId, lastDropPosition, tablesRef])

  return {
    handlePointerMove,
    handlePointerUp,
    ghostPreview,
    lastDropPosition,
    isColliding,
  }
}



################################################################################
# FILE: src/components/floor-plan/index.ts
################################################################################

// Floor Plan Components (Skill 106/107 + T017 Premium UI)
export { InteractiveFloorPlan } from './InteractiveFloorPlan'
export { TableShape } from './TableShape'
export { SeatDot } from './SeatDot'
export { SectionBackground } from './SectionBackground'

// Premium UI Components (T017 + T023)
// FloorPlanHome is THE main order screen - floor plan with inline ordering
export { FloorPlanHome } from './FloorPlanHome'
export { TableNode } from './TableNode'
export { TableInfoPanel } from './TableInfoPanel'
export { CategoriesBar } from './CategoriesBar'

// Unified Floor Plan (T019 - Consolidation)
// UnifiedFloorPlan is the shared component for admin and POS modes
export { UnifiedFloorPlan } from './UnifiedFloorPlan'
export { FloorPlanTable } from './FloorPlanTable'
export { SeatNode, TableSeats } from './SeatNode'
export { TableEditPanel } from './panels/TableEditPanel'
export { PropertiesSidebar } from './PropertiesSidebar'
export { RoomTabs } from './RoomTabs'
export { AddRoomModal } from './AddRoomModal'
export { VirtualGroupManagerModal } from './VirtualGroupManagerModal'
export { SectionSettings } from './SectionSettings'
export { RoomReorderModal } from './RoomReorderModal'

// Seat Components (Skill 121 - Atomic Seat Management)
export { SeatOrbiter, SeatBar, SeatStatusLegend } from './SeatOrbiter'

// Entertainment Visuals
export { EntertainmentVisual, ENTERTAINMENT_VISUAL_OPTIONS } from './entertainment-visuals'
export type { EntertainmentVisualType } from './entertainment-visuals'
export { AddEntertainmentPalette } from './AddEntertainmentPalette'
export { FloorPlanEntertainment } from './FloorPlanEntertainment'

export {
  useFloorPlanStore,
  type FloorPlanTable as FloorPlanTableType,
  type FloorPlanSeat,
  type FloorPlanSection,
  type FloorPlanElement,
  type TableStatus,
  type ElementStatus,
  type SeatPattern,
} from './use-floor-plan'



################################################################################
# FILE: src/components/floor-plan/InteractiveFloorPlan.tsx
################################################################################

'use client'

import { useEffect, useRef, useState, useCallback } from 'react'
import { useFloorPlanStore, FloorPlanTable, TableStatus } from './use-floor-plan'
import { TableShape } from './TableShape'
import { SectionBackground } from './SectionBackground'

interface InteractiveFloorPlanProps {
  locationId: string
  filterSectionId?: string | null
  filterStatus?: TableStatus | null
  onTableSelect?: (table: FloorPlanTable) => void
  onTableCombine?: (sourceTableId: string, targetTableId: string) => Promise<boolean>
  onTableSplit?: (tableId: string, splitMode: 'even' | 'by_seat') => Promise<boolean>
  readOnly?: boolean
}

export function InteractiveFloorPlan({
  locationId,
  filterSectionId,
  filterStatus,
  onTableSelect,
  onTableCombine,
  onTableSplit,
  readOnly = false,
}: InteractiveFloorPlanProps) {
  const svgRef = useRef<SVGSVGElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)

  const {
    tables,
    sections,
    viewportX,
    viewportY,
    zoom,
    selectedTableId,
    draggedTableId,
    dropTargetTableId,
    showCombineIndicator,
    combinePosition,
    undoStack,
    isLoading,
    error,
    setTables,
    setSections,
    setZoom,
    pan,
    zoomIn,
    zoomOut,
    resetView,
    selectTable,
    startDrag,
    updateDragTarget,
    endDrag,
    addUndoAction,
    popUndoAction,
    clearExpiredUndos,
    setLoading,
    setError,
  } = useFloorPlanStore()

  // Split modal state
  const [showSplitModal, setShowSplitModal] = useState(false)
  const [splitTableId, setSplitTableId] = useState<string | null>(null)

  // Drag state for pointer tracking
  const isPanning = useRef(false)
  const lastPanPos = useRef({ x: 0, y: 0 })

  // Load data
  useEffect(() => {
    loadFloorPlanData()
  }, [locationId])

  // Clear expired undos periodically
  useEffect(() => {
    const interval = setInterval(clearExpiredUndos, 5000)
    return () => clearInterval(interval)
  }, [clearExpiredUndos])

  const loadFloorPlanData = async () => {
    setLoading(true)
    setError(null)

    try {
      const [tablesRes, sectionsRes] = await Promise.all([
        fetch(`/api/tables?locationId=${locationId}&includeSeats=true`),
        fetch(`/api/sections?locationId=${locationId}`),
      ])

      if (!tablesRes.ok) throw new Error('Failed to fetch tables')
      if (!sectionsRes.ok) throw new Error('Failed to fetch sections')

      const tablesData = await tablesRes.json()
      const sectionsData = await sectionsRes.json()

      setTables(tablesData.tables || [])
      setSections(sectionsData.sections || [])
    } catch (err) {
      console.error('[FloorPlan] Load error:', err)
      setError(err instanceof Error ? err.message : 'Failed to load floor plan')
    } finally {
      setLoading(false)
    }
  }

  // Filter tables
  const filteredTables = tables.filter(table => {
    // Hide tables that are combined into another (they're "absorbed")
    if (table.combinedWithId) return false
    if (filterSectionId && table.section?.id !== filterSectionId) return false
    if (filterStatus && table.status !== filterStatus) return false
    return true
  })

  // Get SVG point from screen coordinates
  const getSVGPoint = useCallback((clientX: number, clientY: number) => {
    if (!svgRef.current) return { x: 0, y: 0 }
    const svg = svgRef.current
    const pt = svg.createSVGPoint()
    pt.x = clientX
    pt.y = clientY
    const transformed = pt.matrixTransform(svg.getScreenCTM()?.inverse())
    return { x: transformed.x, y: transformed.y }
  }, [])

  // Find table at position
  const findTableAtPosition = useCallback((x: number, y: number): FloorPlanTable | null => {
    for (const table of filteredTables) {
      if (table.id === draggedTableId) continue // Skip dragged table

      const inBounds =
        x >= table.posX &&
        x <= table.posX + table.width &&
        y >= table.posY &&
        y <= table.posY + table.height

      if (inBounds) return table
    }
    return null
  }, [filteredTables, draggedTableId])

  // Handle pointer move for drag
  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    const svgPoint = getSVGPoint(e.clientX, e.clientY)

    // Handle panning
    if (isPanning.current) {
      const deltaX = e.clientX - lastPanPos.current.x
      const deltaY = e.clientY - lastPanPos.current.y
      pan(deltaX / zoom, deltaY / zoom)
      lastPanPos.current = { x: e.clientX, y: e.clientY }
      return
    }

    // Handle table drag
    if (draggedTableId && !readOnly) {
      const targetTable = findTableAtPosition(svgPoint.x, svgPoint.y)
      updateDragTarget(targetTable?.id || null, targetTable ? svgPoint : undefined)
    }
  }, [getSVGPoint, draggedTableId, readOnly, findTableAtPosition, updateDragTarget, pan, zoom])

  // Handle drag end / drop
  const handlePointerUp = useCallback(async () => {
    isPanning.current = false

    if (!draggedTableId || readOnly) {
      endDrag()
      return
    }

    // Check if dropped on another table
    if (dropTargetTableId && onTableCombine) {
      const success = await onTableCombine(draggedTableId, dropTargetTableId)
      if (success) {
        // Add to undo stack
        addUndoAction({
          type: 'combine',
          sourceTableId: draggedTableId,
          targetTableId: dropTargetTableId,
          timestamp: Date.now(),
        })
        // Refresh data
        loadFloorPlanData()
      }
    }

    endDrag()
  }, [draggedTableId, dropTargetTableId, readOnly, onTableCombine, addUndoAction, endDrag])

  // Handle background click for panning
  const handleBackgroundPointerDown = useCallback((e: React.PointerEvent) => {
    // Only pan on middle click or two-finger touch
    if (e.button === 1 || e.pointerType === 'touch') {
      isPanning.current = true
      lastPanPos.current = { x: e.clientX, y: e.clientY }
    } else {
      // Deselect on background click
      selectTable(null)
    }
  }, [selectTable])

  // Handle wheel for zoom
  const handleWheel = useCallback((e: React.WheelEvent) => {
    e.preventDefault()
    const delta = e.deltaY > 0 ? -0.1 : 0.1
    setZoom(zoom + delta)
  }, [zoom, setZoom])

  // Handle table selection
  const handleTableSelect = useCallback((table: FloorPlanTable) => {
    selectTable(table.id)
    onTableSelect?.(table)
  }, [selectTable, onTableSelect])

  // Handle long press for split
  const handleTableLongPress = useCallback((tableId: string) => {
    const table = tables.find(t => t.id === tableId)
    if (!table || !table.combinedTableIds || table.combinedTableIds.length === 0) {
      return // Can only split combined tables
    }
    setSplitTableId(tableId)
    setShowSplitModal(true)
  }, [tables])

  // Handle split action
  const handleSplit = useCallback(async (mode: 'even' | 'by_seat') => {
    if (!splitTableId || !onTableSplit) return

    const success = await onTableSplit(splitTableId, mode)
    if (success) {
      loadFloorPlanData()
    }

    setShowSplitModal(false)
    setSplitTableId(null)
  }, [splitTableId, onTableSplit])

  // Handle undo
  const handleUndo = useCallback(async () => {
    const action = popUndoAction()
    if (!action) return

    // For combine undo, we need to split
    if (action.type === 'combine' && onTableSplit) {
      await onTableSplit(action.targetTableId, 'even')
      loadFloorPlanData()
    }
  }, [popUndoAction, onTableSplit])

  // Calculate viewBox
  const viewBox = `${-viewportX} ${-viewportY} ${(containerRef.current?.clientWidth || 800) / zoom} ${(containerRef.current?.clientHeight || 600) / zoom}`

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50 rounded-lg">
        <div className="text-gray-500">Loading floor plan...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50 rounded-lg">
        <div className="text-red-500">{error}</div>
      </div>
    )
  }

  return (
    <div ref={containerRef} className="relative w-full h-full bg-gray-100 rounded-lg overflow-hidden">
      {/* Controls */}
      <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
        {/* Zoom controls */}
        <div className="bg-white rounded-lg shadow-lg flex flex-col">
          <button
            onClick={zoomIn}
            className="p-2 hover:bg-gray-100 rounded-t-lg border-b"
            title="Zoom in"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v12M6 12h12" />
            </svg>
          </button>
          <button
            onClick={zoomOut}
            className="p-2 hover:bg-gray-100 rounded-b-lg"
            title="Zoom out"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 12h12" />
            </svg>
          </button>
        </div>

        {/* Reset view */}
        <button
          onClick={resetView}
          className="p-2 bg-white rounded-lg shadow-lg hover:bg-gray-100"
          title="Reset view"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
          </svg>
        </button>

        {/* Undo button (only show if undos available) */}
        {undoStack.length > 0 && (
          <button
            onClick={handleUndo}
            className="p-2 bg-yellow-100 text-yellow-700 rounded-lg shadow-lg hover:bg-yellow-200 animate-pulse"
            title="Undo last combine"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
            </svg>
          </button>
        )}
      </div>

      {/* Zoom indicator */}
      <div className="absolute bottom-4 right-4 z-10 bg-white/80 backdrop-blur-sm px-3 py-1 rounded-full text-sm text-gray-600 shadow">
        {Math.round(zoom * 100)}%
      </div>

      {/* Combine indicator tooltip */}
      {showCombineIndicator && combinePosition && (
        <div
          className="absolute z-20 px-3 py-2 bg-green-500 text-white rounded-lg shadow-lg text-sm font-medium pointer-events-none animate-bounce"
          style={{
            left: combinePosition.x * zoom + viewportX,
            top: combinePosition.y * zoom + viewportY - 40,
            transform: 'translateX(-50%)',
          }}
        >
          Drop to combine tables
        </div>
      )}

      {/* Main SVG */}
      <svg
        ref={svgRef}
        className="w-full h-full"
        viewBox={viewBox}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerDown={handleBackgroundPointerDown}
        onWheel={handleWheel}
        style={{ touchAction: 'none' }}
      >
        {/* Grid pattern */}
        <defs>
          <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
            <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#e5e7eb" strokeWidth="1" />
          </pattern>
        </defs>
        <rect x="-2000" y="-2000" width="4000" height="4000" fill="url(#grid)" />

        {/* Render sections first (background) */}
        {sections.map(section => (
          <SectionBackground key={section.id} section={section} />
        ))}

        {/* Render tables */}
        {filteredTables.map(table => (
          <TableShape
            key={table.id}
            table={table}
            isSelected={selectedTableId === table.id}
            isDragging={draggedTableId === table.id}
            isDropTarget={dropTargetTableId === table.id}
            isCombined={Boolean(table.combinedTableIds && table.combinedTableIds.length > 0)}
            onSelect={() => handleTableSelect(table)}
            onDragStart={() => !readOnly && startDrag(table.id)}
            onDragEnd={endDrag}
            onLongPress={() => handleTableLongPress(table.id)}
          />
        ))}
      </svg>

      {/* Split Modal */}
      {showSplitModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-sm shadow-xl">
            <h3 className="text-lg font-bold mb-4">Split Combined Tables</h3>
            <p className="text-sm text-gray-600 mb-4">
              How would you like to split the items?
            </p>

            <div className="space-y-3">
              <button
                onClick={() => handleSplit('even')}
                className="w-full px-4 py-3 bg-blue-50 hover:bg-blue-100 border border-blue-200 rounded-lg text-left"
              >
                <div className="font-medium text-blue-800">Split Evenly</div>
                <div className="text-sm text-blue-600">Items distributed randomly between tables</div>
              </button>

              <button
                onClick={() => handleSplit('by_seat')}
                className="w-full px-4 py-3 bg-purple-50 hover:bg-purple-100 border border-purple-200 rounded-lg text-left"
              >
                <div className="font-medium text-purple-800">Split by Seat</div>
                <div className="text-sm text-purple-600">Items follow their original seat assignment</div>
              </button>
            </div>

            <button
              onClick={() => {
                setShowSplitModal(false)
                setSplitTableId(null)
              }}
              className="w-full mt-4 px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
            >
              Cancel
            </button>
          </div>
        </div>
      )}
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/panels/TableEditPanel.tsx
################################################################################

'use client'

import { useState, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { FloorPlanTable, SeatPattern } from '../use-floor-plan'

interface Section {
  id: string
  name: string
  color: string
}

interface TableEditPanelProps {
  table: FloorPlanTable | null
  sections: Section[]
  isOpen: boolean
  onClose: () => void
  onUpdate: (tableId: string, updates: Partial<FloorPlanTable>) => Promise<void>
  onDelete: (tableId: string) => Promise<void>
  onRegenerateSeats: (tableId: string, pattern: SeatPattern) => Promise<void>
  onAddSeat?: (tableId: string) => Promise<void>
  onDuplicate?: (tableId: string) => Promise<void>
  onRotate?: (tableId: string, deltaRotation: number) => Promise<void>
}

const SEAT_PATTERNS: { value: SeatPattern; label: string; description: string }[] = [
  { value: 'all_around', label: 'All Around', description: 'Seats on all 4 sides' },
  { value: 'front_only', label: 'Front Only', description: 'Bar/counter style' },
  { value: 'three_sides', label: 'Three Sides', description: 'Against wall' },
  { value: 'two_sides', label: 'Two Sides', description: 'Corner booth' },
  { value: 'inside', label: 'Inside', description: 'Booth interior' },
]

const TABLE_SHAPES = [
  { value: 'rectangle', label: 'Rectangle' },
  { value: 'square', label: 'Square' },
  { value: 'circle', label: 'Circle' },
  { value: 'booth', label: 'Booth' },
  { value: 'bar', label: 'Bar' },
]

export function TableEditPanel({
  table,
  sections,
  isOpen,
  onClose,
  onUpdate,
  onDelete,
  onRegenerateSeats,
  onAddSeat,
  onDuplicate,
  onRotate,
}: TableEditPanelProps) {
  const [name, setName] = useState('')
  const [abbreviation, setAbbreviation] = useState('')
  const [capacity, setCapacity] = useState(4)
  const [shape, setShape] = useState<string>('rectangle')
  const [seatPattern, setSeatPattern] = useState<SeatPattern>('all_around')
  const [width, setWidth] = useState(100)
  const [height, setHeight] = useState(100)
  const [sectionId, setSectionId] = useState<string>('')
  const [isSaving, setIsSaving] = useState(false)
  const [isRegenerating, setIsRegenerating] = useState(false)

  // Sync local state with table prop
  useEffect(() => {
    if (table) {
      setName(table.name)
      setAbbreviation(table.abbreviation || '')
      setCapacity(table.capacity)
      setShape(table.shape)
      setSeatPattern(table.seatPattern)
      setWidth(table.width)
      setHeight(table.height)
      setSectionId(table.section?.id || '')
    }
  }, [table])

  const handleSave = async () => {
    if (!table) return
    setIsSaving(true)
    try {
      await onUpdate(table.id, {
        name,
        abbreviation: abbreviation || null,
        capacity,
        shape: shape as FloorPlanTable['shape'],
        seatPattern,
        width,
        height,
        section: sectionId ? sections.find(s => s.id === sectionId) || null : null,
      })
    } finally {
      setIsSaving(false)
    }
  }

  const handleRegenerateSeats = async () => {
    if (!table) return
    setIsRegenerating(true)
    try {
      await onRegenerateSeats(table.id, seatPattern)
    } finally {
      setIsRegenerating(false)
    }
  }

  const handleDelete = async () => {
    if (!table) return
    if (!confirm(`Delete ${table.name}? This cannot be undone.`)) return
    await onDelete(table.id)
    onClose()
  }

  const seatCount = table?.seats?.length || 0

  return (
    <AnimatePresence>
      {isOpen && table && (
        <motion.div
          initial={{ x: 400, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          exit={{ x: 400, opacity: 0 }}
          transition={{ type: 'spring', damping: 25, stiffness: 300 }}
          className="fixed right-0 top-0 bottom-0 w-96 z-50"
          style={{
            background: 'linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%)',
            backdropFilter: 'blur(20px)',
            borderLeft: '1px solid rgba(255, 255, 255, 0.1)',
          }}
        >
          {/* Header */}
          <div
            style={{
              padding: '20px',
              borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
            }}
          >
            <h2 style={{ fontSize: '18px', fontWeight: 600, color: '#f1f5f9' }}>
              Edit Table
            </h2>
            <button
              onClick={onClose}
              style={{
                width: '32px',
                height: '32px',
                borderRadius: '8px',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                color: '#94a3b8',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {/* Content */}
          <div style={{ padding: '20px', overflowY: 'auto', height: 'calc(100% - 140px)' }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
              {/* Name and Abbreviation */}
              <div style={{ display: 'grid', gridTemplateColumns: '1fr auto', gap: '12px' }}>
                <div>
                  <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                    Table Name
                  </label>
                  <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    style={{
                      width: '100%',
                      padding: '10px 12px',
                      borderRadius: '8px',
                      background: 'rgba(255, 255, 255, 0.05)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                      color: '#f1f5f9',
                      fontSize: '14px',
                    }}
                  />
                </div>
                <div style={{ width: '80px' }}>
                  <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                    Abbrev.
                  </label>
                  <input
                    type="text"
                    value={abbreviation}
                    onChange={(e) => setAbbreviation(e.target.value.slice(0, 4))}
                    placeholder="T1"
                    maxLength={4}
                    style={{
                      width: '100%',
                      padding: '10px 12px',
                      borderRadius: '8px',
                      background: 'rgba(255, 255, 255, 0.05)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                      color: '#f1f5f9',
                      fontSize: '14px',
                      textAlign: 'center',
                    }}
                    title="Short name shown on floor plan (e.g., T1, B2, PA)"
                  />
                </div>
              </div>

              {/* Capacity */}
              <div>
                <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                  Capacity (# of seats)
                </label>
                <input
                  type="number"
                  min={1}
                  max={20}
                  value={capacity}
                  onChange={(e) => setCapacity(parseInt(e.target.value) || 1)}
                  style={{
                    width: '100%',
                    padding: '10px 12px',
                    borderRadius: '8px',
                    background: 'rgba(255, 255, 255, 0.05)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    color: '#f1f5f9',
                    fontSize: '14px',
                  }}
                />
              </div>

              {/* Shape */}
              <div>
                <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                  Shape
                </label>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
                  {TABLE_SHAPES.map((s) => (
                    <button
                      key={s.value}
                      onClick={() => setShape(s.value)}
                      style={{
                        padding: '10px',
                        borderRadius: '8px',
                        background: shape === s.value ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                        border: shape === s.value ? '1px solid rgba(99, 102, 241, 0.5)' : '1px solid rgba(255, 255, 255, 0.1)',
                        color: shape === s.value ? '#818cf8' : '#94a3b8',
                        fontSize: '12px',
                        cursor: 'pointer',
                      }}
                    >
                      {s.label}
                    </button>
                  ))}
                </div>
              </div>

              {/* Section */}
              <div>
                <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                  Section
                </label>
                <select
                  value={sectionId}
                  onChange={(e) => setSectionId(e.target.value)}
                  style={{
                    width: '100%',
                    padding: '10px 12px',
                    borderRadius: '8px',
                    background: 'rgba(255, 255, 255, 0.05)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    color: '#f1f5f9',
                    fontSize: '14px',
                  }}
                >
                  <option value="">No Section</option>
                  {sections.map((section) => (
                    <option key={section.id} value={section.id}>
                      {section.name}
                    </option>
                  ))}
                </select>
              </div>

              {/* Dimensions */}
              <div>
                <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                  Dimensions
                </label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                  <div>
                    <label style={{ display: 'block', fontSize: '11px', color: '#64748b', marginBottom: '4px' }}>
                      Width
                    </label>
                    <input
                      type="number"
                      min={40}
                      max={300}
                      value={width}
                      onChange={(e) => setWidth(parseInt(e.target.value) || 40)}
                      style={{
                        width: '100%',
                        padding: '8px 10px',
                        borderRadius: '6px',
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        color: '#f1f5f9',
                        fontSize: '13px',
                      }}
                    />
                  </div>
                  <div>
                    <label style={{ display: 'block', fontSize: '11px', color: '#64748b', marginBottom: '4px' }}>
                      Height
                    </label>
                    <input
                      type="number"
                      min={40}
                      max={300}
                      value={height}
                      onChange={(e) => setHeight(parseInt(e.target.value) || 40)}
                      style={{
                        width: '100%',
                        padding: '8px 10px',
                        borderRadius: '6px',
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        color: '#f1f5f9',
                        fontSize: '13px',
                      }}
                    />
                  </div>
                </div>
              </div>

              {/* Rotation */}
              {onRotate && table && (
                <div>
                  <label style={{ display: 'block', fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }}>
                    Rotation
                    <span style={{ marginLeft: '8px', fontSize: '11px', color: '#64748b' }}>
                      ({table.rotation || 0})
                    </span>
                  </label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                    <button
                      onClick={() => onRotate(table.id, -90)}
                      style={{
                        padding: '8px 12px',
                        borderRadius: '6px',
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        color: '#94a3b8',
                        fontSize: '13px',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '4px',
                      }}
                      title="Rotate 90 counter-clockwise"
                    >
                       90
                    </button>
                    <input
                      type="number"
                      min={0}
                      max={359}
                      value={table.rotation || 0}
                      onChange={(e) => {
                        const newRotation = parseInt(e.target.value) || 0
                        const currentRotation = table.rotation || 0
                        onRotate(table.id, newRotation - currentRotation)
                      }}
                      style={{
                        flex: 1,
                        padding: '8px 10px',
                        borderRadius: '6px',
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        color: '#f1f5f9',
                        fontSize: '13px',
                        textAlign: 'center',
                      }}
                    />
                    <button
                      onClick={() => onRotate(table.id, 90)}
                      style={{
                        padding: '8px 12px',
                        borderRadius: '6px',
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        color: '#94a3b8',
                        fontSize: '13px',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '4px',
                      }}
                      title="Rotate 90 clockwise"
                    >
                       90
                    </button>
                  </div>
                  <input
                    type="range"
                    min={0}
                    max={359}
                    value={table.rotation || 0}
                    onChange={(e) => {
                      const newRotation = parseInt(e.target.value) || 0
                      const currentRotation = table.rotation || 0
                      onRotate(table.id, newRotation - currentRotation)
                    }}
                    style={{
                      width: '100%',
                      height: '6px',
                      borderRadius: '3px',
                      background: 'rgba(255, 255, 255, 0.1)',
                      cursor: 'pointer',
                    }}
                  />
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '4px' }}>
                    <span style={{ fontSize: '10px', color: '#64748b' }}>0</span>
                    <span style={{ fontSize: '10px', color: '#64748b' }}>R = 90  Shift+R = 15</span>
                    <span style={{ fontSize: '10px', color: '#64748b' }}>359</span>
                  </div>
                </div>
              )}

              {/* Seat Pattern */}
              <div style={{ paddingTop: '12px', borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px' }}>
                  <label style={{ fontSize: '13px', color: '#94a3b8' }}>
                    Seat Pattern
                  </label>
                  <span
                    style={{
                      fontSize: '12px',
                      padding: '4px 8px',
                      borderRadius: '4px',
                      background: seatCount === capacity ? 'rgba(34, 197, 94, 0.2)' : seatCount === 0 ? 'rgba(239, 68, 68, 0.2)' : 'rgba(251, 191, 36, 0.2)',
                      color: seatCount === capacity ? '#22c55e' : seatCount === 0 ? '#ef4444' : '#fbbf24',
                    }}
                  >
                    {seatCount}/{capacity} seats
                  </span>
                </div>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                  {SEAT_PATTERNS.map((pattern) => (
                    <button
                      key={pattern.value}
                      onClick={() => setSeatPattern(pattern.value)}
                      style={{
                        padding: '12px',
                        borderRadius: '8px',
                        background: seatPattern === pattern.value ? 'rgba(99, 102, 241, 0.15)' : 'rgba(255, 255, 255, 0.03)',
                        border: seatPattern === pattern.value ? '1px solid rgba(99, 102, 241, 0.4)' : '1px solid rgba(255, 255, 255, 0.08)',
                        cursor: 'pointer',
                        textAlign: 'left',
                      }}
                    >
                      <div style={{ fontSize: '13px', color: seatPattern === pattern.value ? '#a5b4fc' : '#e2e8f0', fontWeight: 500 }}>
                        {pattern.label}
                      </div>
                      <div style={{ fontSize: '11px', color: '#64748b', marginTop: '2px' }}>
                        {pattern.description}
                      </div>
                    </button>
                  ))}
                </div>
                <div style={{ display: 'flex', gap: '8px', marginTop: '12px' }}>
                  <button
                    onClick={handleRegenerateSeats}
                    disabled={isRegenerating}
                    style={{
                      flex: 1,
                      padding: '12px',
                      borderRadius: '8px',
                      background: 'rgba(99, 102, 241, 0.2)',
                      border: '1px solid rgba(99, 102, 241, 0.3)',
                      color: '#a5b4fc',
                      fontSize: '13px',
                      fontWeight: 500,
                      cursor: isRegenerating ? 'not-allowed' : 'pointer',
                      opacity: isRegenerating ? 0.6 : 1,
                    }}
                  >
                    {isRegenerating ? 'Generating...' : `Generate ${capacity}`}
                  </button>
                  {onAddSeat && table && (
                    <button
                      onClick={() => onAddSeat(table.id)}
                      style={{
                        padding: '12px 16px',
                        borderRadius: '8px',
                        background: 'rgba(34, 197, 94, 0.2)',
                        border: '1px solid rgba(34, 197, 94, 0.3)',
                        color: '#4ade80',
                        fontSize: '13px',
                        fontWeight: 500,
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '4px',
                      }}
                      title="Add a new seat to this table"
                    >
                      <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                      </svg>
                      Seat
                    </button>
                  )}
                </div>
              </div>

              {/* Actions */}
              <div style={{ paddingTop: '12px', borderTop: '1px solid rgba(255, 255, 255, 0.1)', display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {/* Duplicate */}
                {onDuplicate && table && (
                  <button
                    onClick={() => onDuplicate(table.id)}
                    style={{
                      width: '100%',
                      padding: '12px',
                      borderRadius: '8px',
                      background: 'rgba(99, 102, 241, 0.1)',
                      border: '1px solid rgba(99, 102, 241, 0.2)',
                      color: '#a5b4fc',
                      fontSize: '13px',
                      fontWeight: 500,
                      cursor: 'pointer',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                    }}
                    title="Duplicate table (Ctrl+D)"
                  >
                    <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    Duplicate Table
                  </button>
                )}

                {/* Delete */}
                <button
                  onClick={handleDelete}
                  style={{
                    width: '100%',
                    padding: '12px',
                    borderRadius: '8px',
                    background: 'rgba(239, 68, 68, 0.1)',
                    border: '1px solid rgba(239, 68, 68, 0.2)',
                    color: '#f87171',
                    fontSize: '13px',
                    fontWeight: 500,
                    cursor: 'pointer',
                  }}
                >
                  Delete Table
                </button>
              </div>
            </div>
          </div>

          {/* Footer */}
          <div
            style={{
              position: 'absolute',
              bottom: 0,
              left: 0,
              right: 0,
              padding: '16px 20px',
              borderTop: '1px solid rgba(255, 255, 255, 0.1)',
              background: 'rgba(15, 23, 42, 0.95)',
              display: 'flex',
              gap: '12px',
            }}
          >
            <button
              onClick={onClose}
              style={{
                flex: 1,
                padding: '12px',
                borderRadius: '8px',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                color: '#94a3b8',
                fontSize: '14px',
                fontWeight: 500,
                cursor: 'pointer',
              }}
            >
              Cancel
            </button>
            <button
              onClick={handleSave}
              disabled={isSaving}
              style={{
                flex: 1,
                padding: '12px',
                borderRadius: '8px',
                background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
                border: 'none',
                color: '#fff',
                fontSize: '14px',
                fontWeight: 500,
                cursor: isSaving ? 'not-allowed' : 'pointer',
                opacity: isSaving ? 0.6 : 1,
              }}
            >
              {isSaving ? 'Saving...' : 'Save Changes'}
            </button>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/PropertiesSidebar.tsx
################################################################################

'use client'

import { useCallback, useEffect, useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import {
  TrashIcon,
  ArrowPathIcon,
  UserPlusIcon,
  UserMinusIcon,
  DocumentDuplicateIcon,
  XMarkIcon,
  Squares2X2Icon,
  ScissorsIcon,
} from '@heroicons/react/24/outline'
import { FloorPlanTable, FloorPlanSection } from './use-floor-plan'

interface PropertiesSidebarProps {
  table: FloorPlanTable | null
  sections: FloorPlanSection[]
  isOpen: boolean
  onClose: () => void
  onUpdate: (tableId: string, updates: Partial<FloorPlanTable>) => void
  onDelete: (tableId: string) => void
  onDuplicate: (tableId: string) => void
  onAddSeat: (tableId: string) => void
  onRemoveSeat: (tableId: string) => void
  onResetSeats?: (tableId: string) => void
  onSplit?: (tableId: string) => void
}

const SHAPES = [
  { value: 'rectangle', label: 'Rect' },
  { value: 'square', label: 'Square' },
  { value: 'circle', label: 'Round' },
  { value: 'booth', label: 'Booth' },
  { value: 'bar', label: 'Bar' },
] as const

/**
 * PropertiesSidebar - Unified sidebar for table creation and editing
 *
 * Replaces modals with a persistent sidebar that:
 * - Slides in when a table is selected
 * - Shows live updates as you edit
 * - Handles both new and existing tables
 * - Provides manual seat building controls
 */
export function PropertiesSidebar({
  table,
  sections,
  isOpen,
  onClose,
  onUpdate,
  onDelete,
  onDuplicate,
  onAddSeat,
  onRemoveSeat,
  onResetSeats,
  onSplit,
}: PropertiesSidebarProps) {
  const [localName, setLocalName] = useState(table?.name || '')
  const [confirmDelete, setConfirmDelete] = useState(false)

  // Sync local name with table name
  useEffect(() => {
    if (table) {
      setLocalName(table.name)
    }
  }, [table?.id, table?.name])

  // Debounced name update
  useEffect(() => {
    if (!table || localName === table.name) return

    const timeout = setTimeout(() => {
      onUpdate(table.id, { name: localName })
    }, 300)

    return () => clearTimeout(timeout)
  }, [localName, table?.id, table?.name, onUpdate])

  const handleShapeChange = useCallback((shape: string) => {
    if (!table) return
    onUpdate(table.id, { shape: shape as FloorPlanTable['shape'] })
  }, [table, onUpdate])

  const handleRotate = useCallback((delta: number) => {
    if (!table) return
    const newRotation = ((table.rotation || 0) + delta + 360) % 360
    onUpdate(table.id, { rotation: newRotation })
  }, [table, onUpdate])

  const handleSectionChange = useCallback((sectionId: string) => {
    if (!table) return
    const section = sections.find(s => s.id === sectionId) || null
    onUpdate(table.id, { section })
  }, [table, sections, onUpdate])

  const handleDimensionChange = useCallback((dimension: 'width' | 'height', value: number) => {
    if (!table) return
    onUpdate(table.id, { [dimension]: Math.max(40, Math.min(300, value)) })
  }, [table, onUpdate])

  const handleDelete = useCallback(() => {
    if (!table) return
    if (confirmDelete) {
      onDelete(table.id)
      onClose()
    } else {
      setConfirmDelete(true)
      setTimeout(() => setConfirmDelete(false), 3000)
    }
  }, [table, confirmDelete, onDelete, onClose])

  return (
    <AnimatePresence>
      {isOpen && table && (
        <motion.aside
          initial={{ x: 320, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          exit={{ x: 320, opacity: 0 }}
          transition={{ type: 'spring', stiffness: 300, damping: 30 }}
          className="fixed right-0 top-0 bottom-0 w-80 z-50 flex flex-col"
          style={{
            background: 'linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%)',
            borderLeft: '1px solid rgba(255, 255, 255, 0.1)',
            backdropFilter: 'blur(20px)',
          }}
        >
          {/* Header */}
          <div className="flex items-center justify-between p-4 border-b border-white/10">
            <h2 className="text-xs font-black uppercase tracking-widest text-indigo-400">
              Table Properties
            </h2>
            <div className="flex items-center gap-2">
              <button
                onClick={() => onDuplicate(table.id)}
                className="p-2 rounded-lg hover:bg-white/5 transition-colors"
                title="Duplicate table"
              >
                <DocumentDuplicateIcon className="w-4 h-4 text-slate-400" />
              </button>
              <button
                onClick={handleDelete}
                className={`p-2 rounded-lg transition-colors ${
                  confirmDelete
                    ? 'bg-red-500/20 text-red-400'
                    : 'hover:bg-white/5 text-slate-400 hover:text-red-400'
                }`}
                title={confirmDelete ? 'Click again to confirm' : 'Delete table'}
              >
                <TrashIcon className="w-4 h-4" />
              </button>
              <button
                onClick={onClose}
                className="p-2 rounded-lg hover:bg-white/5 transition-colors"
              >
                <XMarkIcon className="w-4 h-4 text-slate-400" />
              </button>
            </div>
          </div>

          {/* Scrollable Content */}
          <div className="flex-1 overflow-y-auto p-4 space-y-6">
            {/* Table Name */}
            <div className="space-y-2">
              <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                Label
              </label>
              <input
                type="text"
                value={localName}
                onChange={(e) => setLocalName(e.target.value)}
                placeholder="Table 1, Booth A..."
                className="w-full px-3 py-2.5 rounded-lg text-sm text-slate-200 placeholder-slate-600"
                style={{
                  background: 'rgba(0, 0, 0, 0.3)',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                }}
              />
            </div>

            {/* Section Assignment */}
            {sections.length > 0 && (
              <div className="space-y-2">
                <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                  Section
                </label>
                <select
                  value={table.section?.id || ''}
                  onChange={(e) => handleSectionChange(e.target.value)}
                  className="w-full px-3 py-2.5 rounded-lg text-sm text-slate-200"
                  style={{
                    background: 'rgba(0, 0, 0, 0.3)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                  }}
                >
                  <option value="">No Section</option>
                  {sections.map(s => (
                    <option key={s.id} value={s.id}>{s.name}</option>
                  ))}
                </select>
              </div>
            )}

            {/* Shape Selection */}
            <div className="space-y-2">
              <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                Shape
              </label>
              <div className="grid grid-cols-5 gap-2">
                {SHAPES.map(({ value, label }) => (
                  <button
                    key={value}
                    onClick={() => handleShapeChange(value)}
                    className={`flex flex-col items-center gap-1 p-2 rounded-lg transition-all ${
                      table.shape === value
                        ? 'bg-indigo-500/20 border-indigo-500/50 text-indigo-400'
                        : 'bg-black/20 border-white/5 text-slate-500 hover:bg-white/5 hover:text-slate-300'
                    }`}
                    style={{ border: '1px solid' }}
                  >
                    <span className="text-[10px] font-medium">{label}</span>
                  </button>
                ))}
              </div>
            </div>

            {/* Dimensions */}
            <div className="space-y-2">
              <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                Dimensions
              </label>
              <div className="grid grid-cols-2 gap-3">
                <div className="space-y-1">
                  <span className="text-[9px] text-slate-600 uppercase">Width</span>
                  <input
                    type="number"
                    min={40}
                    max={300}
                    value={table.width}
                    onChange={(e) => handleDimensionChange('width', parseInt(e.target.value) || 80)}
                    className="w-full px-3 py-2 rounded-lg text-sm text-slate-200"
                    style={{
                      background: 'rgba(0, 0, 0, 0.3)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                    }}
                  />
                </div>
                <div className="space-y-1">
                  <span className="text-[9px] text-slate-600 uppercase">Height</span>
                  <input
                    type="number"
                    min={40}
                    max={300}
                    value={table.height}
                    onChange={(e) => handleDimensionChange('height', parseInt(e.target.value) || 80)}
                    className="w-full px-3 py-2 rounded-lg text-sm text-slate-200"
                    style={{
                      background: 'rgba(0, 0, 0, 0.3)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                    }}
                  />
                </div>
              </div>
            </div>

            {/* Rotation */}
            <div className="space-y-2">
              <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                Rotation
              </label>
              <div className="flex items-center gap-2">
                <button
                  onClick={() => handleRotate(-45)}
                  className="p-2 rounded-lg bg-black/20 border border-white/5 hover:bg-white/5 transition-colors"
                >
                  <ArrowPathIcon className="w-4 h-4 text-slate-400" />
                </button>
                <input
                  type="number"
                  value={table.rotation || 0}
                  onChange={(e) => onUpdate(table.id, { rotation: parseInt(e.target.value) || 0 })}
                  className="flex-1 px-3 py-2 rounded-lg text-sm text-slate-200 text-center"
                  style={{
                    background: 'rgba(0, 0, 0, 0.3)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                  }}
                />
                <span className="text-slate-500 text-sm"></span>
                <button
                  onClick={() => handleRotate(45)}
                  className="p-2 rounded-lg bg-black/20 border border-white/5 hover:bg-white/5 transition-colors"
                >
                  <ArrowPathIcon className="w-4 h-4 text-slate-400 transform scale-x-[-1]" />
                </button>
              </div>
            </div>

            <hr className="border-white/10" />

            {/* Manual Seat Builder */}
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                  Manual Seating
                </label>
                <span className="text-xs font-bold text-indigo-400">
                  {table.seats?.length || table.capacity || 0} seats
                </span>
              </div>

              <div
                className="p-4 rounded-xl text-center space-y-4"
                style={{
                  background: 'rgba(0, 0, 0, 0.3)',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                }}
              >
                <div className="text-[10px] text-slate-500 space-y-1">
                  <p className="font-medium text-indigo-400">Drag seats to position them</p>
                  <p className="italic">Click to select  Arrow keys to fine-tune</p>
                  {(table.seats?.length || 0) > 8 && (
                    <p className="text-amber-400">Seats auto-scale when &gt;8</p>
                  )}
                </div>

                <div className="flex flex-wrap justify-center gap-2">
                  {/* Add Seat - Always enabled ("Pull Up a Chair") */}
                  <button
                    onClick={() => onAddSeat(table.id)}
                    className="flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-all hover:scale-105"
                    style={{
                      background: 'rgba(34, 197, 94, 0.1)',
                      border: '1px solid rgba(34, 197, 94, 0.3)',
                      color: '#4ade80',
                    }}
                    title="Add a seat (smart placement)"
                  >
                    <UserPlusIcon className="w-4 h-4" />
                    + Seat
                  </button>
                  {/* Remove Seat - Disabled at 0 */}
                  <button
                    onClick={() => onRemoveSeat(table.id)}
                    disabled={(table.seats?.length || table.capacity || 0) === 0}
                    className="flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-all disabled:opacity-40"
                    style={{
                      background: 'rgba(239, 68, 68, 0.1)',
                      border: '1px solid rgba(239, 68, 68, 0.3)',
                      color: '#f87171',
                    }}
                  >
                    <UserMinusIcon className="w-4 h-4" />
                    Remove
                  </button>
                  {/* Reset Seats to Auto Layout */}
                  {onResetSeats && (table.seats?.length || 0) > 0 && (
                    <button
                      onClick={() => onResetSeats(table.id)}
                      className="flex items-center gap-2 px-3 py-2 rounded-lg text-xs font-medium transition-all"
                      style={{
                        background: 'rgba(99, 102, 241, 0.1)',
                        border: '1px solid rgba(99, 102, 241, 0.3)',
                        color: '#a5b4fc',
                      }}
                      title="Reset all seats to orbital positions"
                    >
                      <Squares2X2Icon className="w-3 h-3" />
                      Reset Layout
                    </button>
                  )}
                </div>
              </div>

              {/* Seat Preview Dots - Dynamic sizing */}
              {(table.seats?.length || table.capacity || 0) > 0 && (
                <div className="flex flex-wrap gap-2 justify-center p-3 rounded-lg bg-black/20">
                  {Array.from({ length: table.seats?.length || table.capacity || 0 }).map((_, i) => {
                    const seatCount = table.seats?.length || table.capacity || 0
                    // Dynamic seat size: shrink if >8 seats
                    const seatSize = seatCount > 12 ? 18 : seatCount > 8 ? 20 : 24
                    const fontSize = seatCount > 12 ? 7 : seatCount > 8 ? 8 : 9
                    return (
                      <div
                        key={i}
                        className="rounded-full flex items-center justify-center font-bold"
                        style={{
                          width: seatSize,
                          height: seatSize,
                          fontSize: `${fontSize}px`,
                          background: 'rgba(99, 102, 241, 0.2)',
                          border: '2px solid rgba(99, 102, 241, 0.5)',
                          color: '#a5b4fc',
                        }}
                      >
                        {i + 1}
                      </div>
                    )
                  })}
                </div>
              )}
            </div>

          </div>

          {/* Split Combined Tables - Only show for combined groups */}
          {onSplit && table.combinedTableIds && table.combinedTableIds.length > 0 && (
            <div className="p-4 border-t border-white/10">
              <p className="text-[10px] text-amber-400/70 font-medium mb-2 uppercase tracking-wider">
                Combined Table ({table.combinedTableIds.length + 1} tables)
              </p>
              <button
                onClick={() => onSplit(table.id)}
                className="w-full flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all"
                style={{
                  background: 'rgba(251, 191, 36, 0.1)',
                  border: '1px solid rgba(251, 191, 36, 0.3)',
                  color: '#fbbf24',
                }}
                title="Split combined tables back to individual tables"
              >
                <ScissorsIcon className="w-4 h-4" />
                Split Tables
              </button>
              <p className="text-[9px] text-slate-500 mt-2 text-center">
                Tables will be scattered near current position
              </p>
            </div>
          )}

          {/* Footer with keyboard shortcuts */}
          <div className="p-4 border-t border-white/10 space-y-2">
            <p className="text-[10px] text-slate-500 font-medium text-center">Keyboard Shortcuts</p>
            <div className="grid grid-cols-2 gap-1 text-[9px] text-slate-600">
              <div className="flex items-center gap-1">
                <span className="px-1.5 py-0.5 bg-slate-800 rounded text-slate-400 font-mono"></span>
                <span>Nudge 1px</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="px-1.5 py-0.5 bg-slate-800 rounded text-slate-400 font-mono">+</span>
                <span>Nudge 10px</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="px-1.5 py-0.5 bg-slate-800 rounded text-slate-400 font-mono">Esc</span>
                <span>Deselect</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="px-1.5 py-0.5 bg-slate-800 rounded text-slate-400 font-mono"></span>
                <span>Delete</span>
              </div>
            </div>
          </div>
        </motion.aside>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/RoomReorderModal.tsx
################################################################################

'use client'

import { useState, useEffect } from 'react'
import { motion, AnimatePresence, Reorder } from 'framer-motion'

interface Room {
  id: string
  name: string
  color?: string
}

interface RoomReorderModalProps {
  isOpen: boolean
  onClose: () => void
  rooms: Room[]
  currentOrder: string[] // Current preferred order (room IDs)
  onSave: (orderedRoomIds: string[]) => void
}

export function RoomReorderModal({
  isOpen,
  onClose,
  rooms,
  currentOrder,
  onSave,
}: RoomReorderModalProps) {
  const [orderedRooms, setOrderedRooms] = useState<Room[]>([])

  // Initialize order when modal opens
  useEffect(() => {
    if (isOpen) {
      // Sort rooms based on currentOrder preference
      const sorted = [...rooms].sort((a, b) => {
        const aIndex = currentOrder.indexOf(a.id)
        const bIndex = currentOrder.indexOf(b.id)

        // Rooms in preferred order come first, in that order
        // Rooms not in preferred order come after, in original order
        if (aIndex >= 0 && bIndex >= 0) return aIndex - bIndex
        if (aIndex >= 0) return -1
        if (bIndex >= 0) return 1
        return 0
      })
      setOrderedRooms(sorted)
    }
  }, [isOpen, rooms, currentOrder])

  const handleSave = () => {
    onSave(orderedRooms.map(r => r.id))
    onClose()
  }

  const handleReset = () => {
    // Reset to original room order (by name or creation order)
    setOrderedRooms([...rooms])
  }

  if (!isOpen) return null

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-center justify-center"
          style={{ background: 'rgba(0, 0, 0, 0.6)', backdropFilter: 'blur(4px)' }}
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            onClick={(e) => e.stopPropagation()}
            style={{
              width: '100%',
              maxWidth: '400px',
              background: 'linear-gradient(180deg, #1e293b 0%, #0f172a 100%)',
              borderRadius: '16px',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              overflow: 'hidden',
              boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
            }}
          >
            {/* Header */}
            <div
              style={{
                padding: '20px 24px',
                borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
              }}
            >
              <div>
                <h2 style={{ fontSize: '18px', fontWeight: 600, color: '#f1f5f9' }}>
                  Reorder Rooms
                </h2>
                <p style={{ fontSize: '13px', color: '#64748b', marginTop: '4px' }}>
                  Drag to set your preferred room order
                </p>
              </div>
              <button
                onClick={onClose}
                style={{
                  padding: '8px',
                  borderRadius: '8px',
                  background: 'transparent',
                  border: 'none',
                  color: '#64748b',
                  cursor: 'pointer',
                }}
              >
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            {/* Room List */}
            <div style={{ padding: '16px 24px', maxHeight: '400px', overflowY: 'auto' }}>
              {orderedRooms.length === 0 ? (
                <p style={{ color: '#64748b', textAlign: 'center', padding: '20px' }}>
                  No rooms to reorder
                </p>
              ) : (
                <Reorder.Group
                  axis="y"
                  values={orderedRooms}
                  onReorder={setOrderedRooms}
                  style={{ listStyle: 'none', margin: 0, padding: 0 }}
                >
                  {orderedRooms.map((room, index) => (
                    <Reorder.Item
                      key={room.id}
                      value={room}
                      style={{
                        marginBottom: '8px',
                        cursor: 'grab',
                      }}
                    >
                      <motion.div
                        whileDrag={{ scale: 1.02, boxShadow: '0 8px 20px rgba(0,0,0,0.3)' }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: '12px',
                          padding: '12px 16px',
                          borderRadius: '10px',
                          background: 'rgba(255, 255, 255, 0.05)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                        }}
                      >
                        {/* Drag Handle */}
                        <div style={{ color: '#64748b', flexShrink: 0 }}>
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="9" cy="6" r="2" />
                            <circle cx="15" cy="6" r="2" />
                            <circle cx="9" cy="12" r="2" />
                            <circle cx="15" cy="12" r="2" />
                            <circle cx="9" cy="18" r="2" />
                            <circle cx="15" cy="18" r="2" />
                          </svg>
                        </div>

                        {/* Order Number */}
                        <span
                          style={{
                            width: '24px',
                            height: '24px',
                            borderRadius: '6px',
                            background: 'rgba(99, 102, 241, 0.2)',
                            color: '#a5b4fc',
                            fontSize: '12px',
                            fontWeight: 600,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            flexShrink: 0,
                          }}
                        >
                          {index + 1}
                        </span>

                        {/* Color Indicator */}
                        {room.color && (
                          <div
                            style={{
                              width: '10px',
                              height: '10px',
                              borderRadius: '50%',
                              background: room.color,
                              boxShadow: `0 0 8px ${room.color}`,
                              flexShrink: 0,
                            }}
                          />
                        )}

                        {/* Room Name */}
                        <span
                          style={{
                            flex: 1,
                            fontSize: '14px',
                            fontWeight: 500,
                            color: '#e2e8f0',
                          }}
                        >
                          {room.name}
                        </span>
                      </motion.div>
                    </Reorder.Item>
                  ))}
                </Reorder.Group>
              )}
            </div>

            {/* Footer */}
            <div
              style={{
                padding: '16px 24px',
                borderTop: '1px solid rgba(255, 255, 255, 0.1)',
                display: 'flex',
                gap: '12px',
                justifyContent: 'space-between',
              }}
            >
              <button
                onClick={handleReset}
                style={{
                  padding: '10px 16px',
                  borderRadius: '8px',
                  background: 'transparent',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  color: '#94a3b8',
                  fontSize: '14px',
                  cursor: 'pointer',
                }}
              >
                Reset Order
              </button>
              <div style={{ display: 'flex', gap: '12px' }}>
                <button
                  onClick={onClose}
                  style={{
                    padding: '10px 20px',
                    borderRadius: '8px',
                    background: 'rgba(255, 255, 255, 0.05)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    color: '#94a3b8',
                    fontSize: '14px',
                    cursor: 'pointer',
                  }}
                >
                  Cancel
                </button>
                <button
                  onClick={handleSave}
                  style={{
                    padding: '10px 20px',
                    borderRadius: '8px',
                    background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
                    border: 'none',
                    color: '#fff',
                    fontSize: '14px',
                    fontWeight: 500,
                    cursor: 'pointer',
                  }}
                >
                  Save Order
                </button>
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/RoomTabs.tsx
################################################################################

'use client'

import { motion } from 'framer-motion'

interface Room {
  id: string
  name: string
  color?: string
}

interface RoomTabsProps {
  rooms: Room[]
  selectedRoomId: string | null  // null = "All" view
  onRoomSelect: (roomId: string | null) => void
  tableCountByRoom?: Map<string, number>  // Optional count display
  showAddButton?: boolean  // Admin only
  onAddRoom?: () => void
  showAllTab?: boolean  // Whether to show the "All" tab (default: true)
  showSettingsButton?: boolean  // Whether to show settings gear button for room ordering (POS only)
  onOpenSettings?: () => void  // Callback for settings button
}

export function RoomTabs({
  rooms,
  selectedRoomId,
  onRoomSelect,
  tableCountByRoom,
  showAddButton = false,
  onAddRoom,
  showAllTab = true,
  showSettingsButton = false,
  onOpenSettings,
}: RoomTabsProps) {
  // Calculate total tables
  const totalTables = tableCountByRoom
    ? Array.from(tableCountByRoom.values()).reduce((sum, count) => sum + count, 0)
    : undefined

  // If no rooms and showAllTab is false, show a helpful message
  if (rooms.length === 0 && !showAllTab) {
    return (
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          padding: '12px 16px',
          background: 'rgba(0, 0, 0, 0.2)',
          borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
        }}
      >
        <span style={{ color: '#64748b', fontSize: '14px' }}>
          No rooms/sections created yet.
        </span>
        {showAddButton && (
          <button
            onClick={onAddRoom}
            style={{
              padding: '6px 12px',
              borderRadius: '6px',
              background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
              border: 'none',
              color: '#fff',
              fontSize: '13px',
              fontWeight: 500,
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
            }}
          >
            <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
            Create First Section
          </button>
        )}
      </div>
    )
  }

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        gap: '8px',
        padding: '8px 16px',
        background: 'rgba(0, 0, 0, 0.2)',
        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
        overflowX: 'auto',
        flexWrap: 'nowrap',
        minHeight: '48px',
        scrollbarWidth: 'none',
      }}
    >
      {/* Settings Button (POS only) */}
      {showSettingsButton && onOpenSettings && (
        <>
          <button
            onClick={onOpenSettings}
            style={{
              padding: '8px',
              borderRadius: '8px',
              background: 'rgba(255, 255, 255, 0.05)',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              color: '#64748b',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              flexShrink: 0,
            }}
            title="Reorder Rooms"
          >
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
          </button>
          <div
            style={{
              width: '1px',
              height: '24px',
              background: 'rgba(255, 255, 255, 0.15)',
              flexShrink: 0,
            }}
          />
        </>
      )}

      {/* All Rooms Tab - only show if showAllTab is true */}
      {showAllTab && (
        <>
          <RoomTab
            room={{ id: 'all', name: 'All' }}
            isSelected={selectedRoomId === null}
            onClick={() => onRoomSelect(null)}
            count={totalTables}
          />

          {/* Divider */}
          {rooms.length > 0 && (
            <div
              style={{
                width: '1px',
                height: '24px',
                background: 'rgba(255, 255, 255, 0.15)',
                flexShrink: 0,
              }}
            />
          )}
        </>
      )}

      {/* Individual Room Tabs */}
      {rooms.map((room) => (
        <RoomTab
          key={room.id}
          room={room}
          isSelected={selectedRoomId === room.id}
          onClick={() => onRoomSelect(room.id)}
          count={tableCountByRoom?.get(room.id)}
        />
      ))}

      {/* Add Room Button (Admin only) */}
      {showAddButton && (
        <>
          <div
            style={{
              width: '1px',
              height: '24px',
              background: 'rgba(255, 255, 255, 0.15)',
            }}
          />
          <button
            onClick={onAddRoom}
            style={{
              padding: '8px 12px',
              borderRadius: '8px',
              background: 'rgba(255, 255, 255, 0.05)',
              border: '1px dashed rgba(255, 255, 255, 0.2)',
              color: '#64748b',
              fontSize: '13px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
              whiteSpace: 'nowrap',
            }}
          >
            <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
            Add Section
          </button>
        </>
      )}
    </div>
  )
}

interface RoomTabProps {
  room: Room
  isSelected: boolean
  onClick: () => void
  count?: number
}

function RoomTab({ room, isSelected, onClick, count }: RoomTabProps) {
  return (
    <motion.button
      onClick={onClick}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      style={{
        position: 'relative',
        padding: '8px 16px',
        borderRadius: '8px',
        background: isSelected
          ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.3) 0%, rgba(139, 92, 246, 0.3) 100%)'
          : 'rgba(255, 255, 255, 0.05)',
        border: isSelected
          ? '1px solid rgba(99, 102, 241, 0.5)'
          : '1px solid rgba(255, 255, 255, 0.1)',
        color: isSelected ? '#a5b4fc' : '#94a3b8',
        fontSize: '13px',
        fontWeight: isSelected ? 600 : 400,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        whiteSpace: 'nowrap',
        transition: 'all 0.2s ease',
      }}
    >
      {/* Color indicator */}
      {room.color && room.id !== 'all' && (
        <div
          style={{
            width: '8px',
            height: '8px',
            borderRadius: '50%',
            background: room.color,
            boxShadow: `0 0 6px ${room.color}`,
          }}
        />
      )}

      {room.name}

      {/* Table count badge */}
      {count !== undefined && (
        <span
          style={{
            padding: '2px 6px',
            borderRadius: '4px',
            background: isSelected ? 'rgba(255, 255, 255, 0.15)' : 'rgba(255, 255, 255, 0.08)',
            fontSize: '11px',
            color: isSelected ? '#c7d2fe' : '#64748b',
          }}
        >
          {count}
        </span>
      )}

      {/* Selected indicator */}
      {isSelected && (
        <motion.div
          layoutId="roomTabIndicator"
          style={{
            position: 'absolute',
            bottom: '-1px',
            left: '50%',
            transform: 'translateX(-50%)',
            width: '24px',
            height: '2px',
            background: 'linear-gradient(90deg, #6366f1, #8b5cf6)',
            borderRadius: '1px',
          }}
        />
      )}
    </motion.button>
  )
}



################################################################################
# FILE: src/components/floor-plan/SeatDot.tsx
################################################################################

'use client'

import { FloorPlanSeat } from './use-floor-plan'

interface SeatDotProps {
  seat: FloorPlanSeat
  tableX: number
  tableY: number
  tableWidth: number
  tableHeight: number
  isOccupied?: boolean
}

export function SeatDot({
  seat,
  tableX,
  tableY,
  tableWidth,
  tableHeight,
  isOccupied = false,
}: SeatDotProps) {
  // Calculate absolute position from table center + relative offset
  const centerX = tableX + tableWidth / 2
  const centerY = tableY + tableHeight / 2
  const x = centerX + seat.relativeX
  const y = centerY + seat.relativeY

  return (
    <g className="seat-dot">
      {/* Seat circle */}
      <circle
        cx={x}
        cy={y}
        r={10}
        fill={isOccupied ? '#3B82F6' : '#ffffff'}
        stroke={isOccupied ? '#1D4ED8' : '#9CA3AF'}
        strokeWidth={2}
        className="transition-colors duration-200"
      />
      {/* Seat label */}
      <text
        x={x}
        y={y}
        textAnchor="middle"
        dominantBaseline="central"
        fontSize={9}
        fontWeight={500}
        fill={isOccupied ? '#ffffff' : '#374151'}
        className="pointer-events-none select-none"
      >
        {seat.label}
      </text>
    </g>
  )
}



################################################################################
# FILE: src/components/floor-plan/SeatNode.tsx
################################################################################

'use client'

import { useCallback, useRef } from 'react'
import { motion } from 'framer-motion'
import { FloorPlanSeat } from './use-floor-plan'

interface SeatNodeProps {
  seat: FloorPlanSeat
  tableWidth: number
  tableHeight: number
  isSelected?: boolean
  isEditable?: boolean  // Admin mode: allow dragging
  onSelect?: (seatNumber: number) => void
  onDragStart?: (seatId: string) => void
  onDragEnd?: (seatId: string, newRelativeX: number, newRelativeY: number) => void
}

const SEAT_TYPE_COLORS: Record<string, string> = {
  standard: '#4b5563',
  premium: '#7c3aed',
  accessible: '#2563eb',
  booth_end: '#059669',
  bar: '#ea580c',
}

export function SeatNode({
  seat,
  tableWidth,
  tableHeight,
  isSelected = false,
  isEditable = false,
  onSelect,
  onDragStart,
  onDragEnd,
}: SeatNodeProps) {
  const seatSize = 24
  const isDraggingRef = useRef(false)
  const startPosRef = useRef({ x: 0, y: 0 })

  // Position: table center offset + relative seat position
  const x = tableWidth / 2 + seat.relativeX
  const y = tableHeight / 2 + seat.relativeY

  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    if (!isEditable) {
      onSelect?.(seat.seatNumber)
      return
    }

    e.stopPropagation()
    e.preventDefault()
    isDraggingRef.current = true
    startPosRef.current = { x: e.clientX, y: e.clientY }
    onDragStart?.(seat.id)

    const element = e.currentTarget as HTMLElement
    element.setPointerCapture(e.pointerId)
  }, [isEditable, seat.seatNumber, seat.id, onSelect, onDragStart])

  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!isDraggingRef.current || !isEditable) return

    const deltaX = e.clientX - startPosRef.current.x
    const deltaY = e.clientY - startPosRef.current.y

    // Update position in real-time via parent
    const newRelativeX = seat.relativeX + deltaX
    const newRelativeY = seat.relativeY + deltaY
    onDragEnd?.(seat.id, newRelativeX, newRelativeY)

    startPosRef.current = { x: e.clientX, y: e.clientY }
  }, [isEditable, seat.relativeX, seat.relativeY, seat.id, onDragEnd])

  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    if (!isDraggingRef.current) return

    isDraggingRef.current = false
    const element = e.currentTarget as HTMLElement
    element.releasePointerCapture(e.pointerId)
  }, [])

  const handleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation()
    if (!isDraggingRef.current) {
      onSelect?.(seat.seatNumber)
    }
  }, [seat.seatNumber, onSelect])

  const backgroundColor = SEAT_TYPE_COLORS[seat.seatType] || SEAT_TYPE_COLORS.standard

  return (
    <motion.div
      initial={{ scale: 0, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0, opacity: 0 }}
      transition={{ duration: 0.2 }}
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      onClick={handleClick}
      style={{
        position: 'absolute',
        left: x - seatSize / 2,
        top: y - seatSize / 2,
        width: seatSize,
        height: seatSize,
        borderRadius: '50%',
        backgroundColor,
        border: isSelected
          ? '3px solid #6366f1'
          : '2px solid rgba(255, 255, 255, 0.3)',
        boxShadow: isSelected
          ? '0 0 12px rgba(99, 102, 241, 0.5)'
          : '0 2px 4px rgba(0, 0, 0, 0.3)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '10px',
        fontWeight: 600,
        color: 'white',
        cursor: isEditable ? 'move' : 'pointer',
        zIndex: isSelected ? 20 : 10,
        transform: `rotate(${seat.angle}deg)`,
        transition: isDraggingRef.current ? 'none' : 'box-shadow 0.2s, border 0.2s',
        touchAction: 'none',
      }}
      title={`Seat ${seat.label} - ${seat.seatType}`}
    >
      {seat.label}
    </motion.div>
  )
}

// Utility function to render all seats for a table
interface RenderSeatsProps {
  seats: FloorPlanSeat[]
  tableWidth: number
  tableHeight: number
  selectedSeatNumber?: number | null
  isEditable?: boolean
  onSeatSelect?: (seatNumber: number) => void
  onSeatDragStart?: (seatId: string) => void
  onSeatDragEnd?: (seatId: string, newRelativeX: number, newRelativeY: number) => void
}

export function TableSeats({
  seats,
  tableWidth,
  tableHeight,
  selectedSeatNumber,
  isEditable = false,
  onSeatSelect,
  onSeatDragStart,
  onSeatDragEnd,
}: RenderSeatsProps) {
  return (
    <>
      {seats.map((seat) => (
        <SeatNode
          key={seat.id}
          seat={seat}
          tableWidth={tableWidth}
          tableHeight={tableHeight}
          isSelected={selectedSeatNumber === seat.seatNumber}
          isEditable={isEditable}
          onSelect={onSeatSelect}
          onDragStart={onSeatDragStart}
          onDragEnd={onSeatDragEnd}
        />
      ))}
    </>
  )
}



################################################################################
# FILE: src/components/floor-plan/SeatOrbiter.tsx
################################################################################

'use client'

import { useCallback, useMemo } from 'react'
import { motion, AnimatePresence, LayoutGroup } from 'framer-motion'
import { PlusIcon } from '@heroicons/react/24/outline'
import {
  SeatInfo,
  SEAT_STATUS_COLORS,
  SEAT_STATUS_BG_COLORS,
  SEAT_STATUS_GLOW,
  calculateSeatPositions,
  formatSeatBalance,
} from '@/lib/seat-utils'

interface SeatOrbiterProps {
  seats: SeatInfo[]
  selectedSeatNumber: number | null
  onSeatSelect: (seatNumber: number) => void
  onAddSeat?: (afterPosition: number) => void
  onRemoveSeat?: (position: number) => void
  showAddButton?: boolean
  showBalances?: boolean
  size?: 'sm' | 'md' | 'lg'
  orbitRadius?: number
  disabled?: boolean
}

const SIZE_CONFIG = {
  sm: { seatSize: 28, fontSize: 10, balanceFontSize: 8, addButtonSize: 20 },
  md: { seatSize: 36, fontSize: 12, balanceFontSize: 10, addButtonSize: 24 },
  lg: { seatSize: 44, fontSize: 14, balanceFontSize: 11, addButtonSize: 28 },
}

export function SeatOrbiter({
  seats,
  selectedSeatNumber,
  onSeatSelect,
  onAddSeat,
  showAddButton = true,
  showBalances = true,
  size = 'md',
  orbitRadius = 60,
  disabled = false,
}: SeatOrbiterProps) {
  const config = SIZE_CONFIG[size]

  // Calculate positions for all seats plus the add button
  const totalSlots = showAddButton ? seats.length + 1 : seats.length
  const positions = useMemo(
    () => calculateSeatPositions(totalSlots, orbitRadius),
    [totalSlots, orbitRadius]
  )

  const handleSeatClick = useCallback((seatNumber: number) => {
    if (!disabled) {
      onSeatSelect(seatNumber)
    }
  }, [disabled, onSeatSelect])

  const handleAddClick = useCallback(() => {
    if (!disabled && onAddSeat) {
      // Add seat at the end
      onAddSeat(seats.length + 1)
    }
  }, [disabled, onAddSeat, seats.length])

  return (
    <LayoutGroup>
      <div
        className="relative"
        style={{
          width: orbitRadius * 2 + config.seatSize,
          height: orbitRadius * 2 + config.seatSize,
        }}
      >
        <AnimatePresence mode="popLayout">
          {seats.map((seat, index) => {
            const pos = positions[index]
            const isSelected = selectedSeatNumber === seat.seatNumber
            const statusColor = SEAT_STATUS_COLORS[seat.status]
            const bgColor = SEAT_STATUS_BG_COLORS[seat.status]
            const glowColor = SEAT_STATUS_GLOW[seat.status]

            return (
              <motion.button
                key={`seat-${seat.seatNumber}`}
                layoutId={`seat-${seat.seatNumber}`}
                initial={{ scale: 0, opacity: 0 }}
                animate={{
                  scale: 1,
                  opacity: 1,
                  x: pos.x + orbitRadius,
                  y: pos.y + orbitRadius,
                }}
                exit={{ scale: 0, opacity: 0 }}
                transition={{
                  type: 'spring',
                  stiffness: 400,
                  damping: 25,
                  layout: { duration: 0.3 },
                }}
                onClick={() => handleSeatClick(seat.seatNumber)}
                disabled={disabled}
                className="absolute flex flex-col items-center justify-center rounded-full transition-shadow"
                style={{
                  width: config.seatSize,
                  height: config.seatSize,
                  marginLeft: -config.seatSize / 2,
                  marginTop: -config.seatSize / 2,
                  backgroundColor: bgColor,
                  border: `2px solid ${statusColor}`,
                  boxShadow: isSelected
                    ? `0 0 12px ${glowColor}, 0 0 20px ${glowColor}`
                    : `0 2px 4px rgba(0, 0, 0, 0.2)`,
                  cursor: disabled ? 'not-allowed' : 'pointer',
                  zIndex: isSelected ? 20 : 10,
                }}
                title={`Seat ${seat.seatNumber} - ${seat.status}${seat.total > 0 ? ` - $${seat.total.toFixed(2)}` : ''}`}
              >
                {/* Seat number */}
                <span
                  className="font-bold leading-none"
                  style={{
                    fontSize: config.fontSize,
                    color: statusColor,
                  }}
                >
                  {seat.seatNumber}
                </span>

                {/* Balance (if showBalances and has balance) */}
                {showBalances && seat.total > 0 && (
                  <span
                    className="leading-none mt-0.5 opacity-80"
                    style={{
                      fontSize: config.balanceFontSize,
                      color: statusColor,
                    }}
                  >
                    {formatSeatBalance(seat.total)}
                  </span>
                )}

                {/* Item count indicator */}
                {seat.itemCount > 0 && (
                  <motion.div
                    initial={{ scale: 0 }}
                    animate={{ scale: 1 }}
                    className="absolute -top-1 -right-1 flex items-center justify-center rounded-full"
                    style={{
                      width: 14,
                      height: 14,
                      backgroundColor: statusColor,
                      fontSize: 9,
                      fontWeight: 600,
                      color: '#fff',
                    }}
                  >
                    {seat.itemCount}
                  </motion.div>
                )}

                {/* Selected ring */}
                {isSelected && (
                  <motion.div
                    layoutId="selected-ring"
                    className="absolute inset-0 rounded-full pointer-events-none"
                    style={{
                      border: '3px solid #6366f1',
                      boxShadow: '0 0 8px rgba(99, 102, 241, 0.6)',
                    }}
                    transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                  />
                )}
              </motion.button>
            )
          })}

          {/* Add Seat Button */}
          {showAddButton && onAddSeat && (
            <motion.button
              key="add-seat"
              layoutId="add-seat"
              initial={{ scale: 0, opacity: 0 }}
              animate={{
                scale: 1,
                opacity: 1,
                x: positions[seats.length]?.x + orbitRadius || orbitRadius,
                y: positions[seats.length]?.y + orbitRadius || orbitRadius,
              }}
              exit={{ scale: 0, opacity: 0 }}
              transition={{
                type: 'spring',
                stiffness: 400,
                damping: 25,
                layout: { duration: 0.3 },
              }}
              onClick={handleAddClick}
              disabled={disabled}
              className="absolute flex items-center justify-center rounded-full border-2 border-dashed border-slate-500 bg-slate-800/50 hover:bg-slate-700/50 hover:border-emerald-500 transition-all"
              style={{
                width: config.addButtonSize,
                height: config.addButtonSize,
                marginLeft: -config.addButtonSize / 2,
                marginTop: -config.addButtonSize / 2,
                cursor: disabled ? 'not-allowed' : 'pointer',
                opacity: disabled ? 0.5 : 1,
              }}
              title="Add a seat"
            >
              <PlusIcon
                className="text-slate-400 hover:text-emerald-400 transition-colors"
                style={{ width: config.addButtonSize * 0.6, height: config.addButtonSize * 0.6 }}
              />
            </motion.button>
          )}
        </AnimatePresence>
      </div>
    </LayoutGroup>
  )
}

/**
 * Compact inline seat bar for use in order panels
 */
interface SeatBarProps {
  seats: SeatInfo[]
  selectedSeatNumber: number | null
  onSeatSelect: (seatNumber: number) => void
  onAddSeat?: () => void
  disabled?: boolean
}

export function SeatBar({
  seats,
  selectedSeatNumber,
  onSeatSelect,
  onAddSeat,
  disabled = false,
}: SeatBarProps) {
  return (
    <div className="flex items-center gap-1.5 flex-wrap">
      <AnimatePresence mode="popLayout">
        {seats.map((seat) => {
          const isSelected = selectedSeatNumber === seat.seatNumber
          const statusColor = SEAT_STATUS_COLORS[seat.status]
          const bgColor = SEAT_STATUS_BG_COLORS[seat.status]

          return (
            <motion.button
              key={`bar-seat-${seat.seatNumber}`}
              layoutId={`bar-seat-${seat.seatNumber}`}
              initial={{ scale: 0, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0, opacity: 0 }}
              transition={{
                type: 'spring',
                stiffness: 400,
                damping: 25,
              }}
              onClick={() => !disabled && onSeatSelect(seat.seatNumber)}
              disabled={disabled}
              className="relative flex items-center justify-center rounded-lg transition-all"
              style={{
                minWidth: 32,
                height: 28,
                padding: '0 8px',
                backgroundColor: bgColor,
                border: `2px solid ${isSelected ? '#6366f1' : statusColor}`,
                boxShadow: isSelected
                  ? '0 0 8px rgba(99, 102, 241, 0.5)'
                  : 'none',
                cursor: disabled ? 'not-allowed' : 'pointer',
              }}
            >
              <span
                className="font-bold text-xs"
                style={{ color: isSelected ? '#6366f1' : statusColor }}
              >
                S{seat.seatNumber}
              </span>

              {/* Item count badge */}
              {seat.itemCount > 0 && (
                <span
                  className="absolute -top-1 -right-1 flex items-center justify-center rounded-full text-white text-[9px] font-bold"
                  style={{
                    width: 14,
                    height: 14,
                    backgroundColor: statusColor,
                  }}
                >
                  {seat.itemCount}
                </span>
              )}
            </motion.button>
          )
        })}

        {/* Add button */}
        {onAddSeat && (
          <motion.button
            key="bar-add-seat"
            layoutId="bar-add-seat"
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            onClick={() => !disabled && onAddSeat()}
            disabled={disabled}
            className="flex items-center justify-center rounded-lg border-2 border-dashed border-slate-600 hover:border-emerald-500 hover:bg-emerald-500/10 transition-all"
            style={{
              width: 28,
              height: 28,
              cursor: disabled ? 'not-allowed' : 'pointer',
              opacity: disabled ? 0.5 : 1,
            }}
            title="Add a seat"
          >
            <PlusIcon className="w-4 h-4 text-slate-500 hover:text-emerald-400" />
          </motion.button>
        )}
      </AnimatePresence>
    </div>
  )
}

/**
 * Seat status legend
 */
export function SeatStatusLegend() {
  const statuses: { status: keyof typeof SEAT_STATUS_COLORS; label: string }[] = [
    { status: 'empty', label: 'Empty' },
    { status: 'active', label: 'Active' },
    { status: 'stale', label: 'Stale' },
    { status: 'printed', label: 'Printed' },
    { status: 'paid', label: 'Paid' },
  ]

  return (
    <div className="flex flex-wrap gap-3 text-xs">
      {statuses.map(({ status, label }) => (
        <div key={status} className="flex items-center gap-1.5">
          <div
            className="w-3 h-3 rounded-full"
            style={{ backgroundColor: SEAT_STATUS_COLORS[status] }}
          />
          <span className="text-slate-400">{label}</span>
        </div>
      ))}
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/SectionBackground.tsx
################################################################################

'use client'

import { FloorPlanSection } from './use-floor-plan'

interface SectionBackgroundProps {
  section: FloorPlanSection
}

export function SectionBackground({ section }: SectionBackgroundProps) {
  // Parse color to get RGB values for semi-transparent fill
  const hexToRgba = (hex: string, alpha: number) => {
    const r = parseInt(hex.slice(1, 3), 16)
    const g = parseInt(hex.slice(3, 5), 16)
    const b = parseInt(hex.slice(5, 7), 16)
    return `rgba(${r}, ${g}, ${b}, ${alpha})`
  }

  const fillColor = hexToRgba(section.color || '#3B82F6', 0.08)
  const borderColor = hexToRgba(section.color || '#3B82F6', 0.3)

  return (
    <g className="section-background">
      {/* Section fill */}
      <rect
        x={section.posX}
        y={section.posY}
        width={section.width}
        height={section.height}
        fill={fillColor}
        stroke={borderColor}
        strokeWidth={2}
        strokeDasharray="8 4"
        rx={8}
        ry={8}
        className="pointer-events-none"
      />
      {/* Section label */}
      <text
        x={section.posX + 12}
        y={section.posY + 24}
        fontSize={14}
        fontWeight={600}
        fill={section.color || '#3B82F6'}
        opacity={0.7}
        className="pointer-events-none select-none"
      >
        {section.name}
      </text>
    </g>
  )
}



################################################################################
# FILE: src/components/floor-plan/SectionSettings.tsx
################################################################################

'use client'

import { useState, useCallback } from 'react'
import { motion, AnimatePresence, Reorder } from 'framer-motion'

interface Room {
  id: string
  name: string
  color: string
  sortOrder?: number
}

interface SectionSettingsProps {
  isOpen: boolean
  onClose: () => void
  rooms: Room[]
  onReorder: (rooms: Room[]) => void
  onDelete: (roomId: string) => Promise<void>
  onRoomEdit?: (roomId: string, updates: { name?: string; color?: string }) => void
}

const THEME_COLORS = [
  '#6366f1', // Indigo
  '#10b981', // Emerald
  '#f59e0b', // Amber
  '#ef4444', // Red
  '#ec4899', // Pink
  '#8b5cf6', // Violet
  '#06b6d4', // Cyan
  '#84cc16', // Lime
]

export function SectionSettings({
  isOpen,
  onClose,
  rooms,
  onReorder,
  onDelete,
  onRoomEdit,
}: SectionSettingsProps) {
  const [deletingId, setDeletingId] = useState<string | null>(null)
  const [confirmDeleteId, setConfirmDeleteId] = useState<string | null>(null)
  const [editingId, setEditingId] = useState<string | null>(null)
  const [editName, setEditName] = useState('')

  const handleReorder = useCallback((newOrder: Room[]) => {
    onReorder(newOrder)
  }, [onReorder])

  const handleDelete = useCallback(async (roomId: string) => {
    if (rooms.length <= 1) return // Prevent deleting last room

    if (confirmDeleteId !== roomId) {
      setConfirmDeleteId(roomId)
      setTimeout(() => setConfirmDeleteId(null), 3000)
      return
    }

    setDeletingId(roomId)
    try {
      await onDelete(roomId)
    } finally {
      setDeletingId(null)
      setConfirmDeleteId(null)
    }
  }, [rooms.length, confirmDeleteId, onDelete])

  const handleStartEdit = (room: Room) => {
    setEditingId(room.id)
    setEditName(room.name)
  }

  const handleSaveEdit = async (roomId: string) => {
    if (onRoomEdit && editName.trim()) {
      onRoomEdit(roomId, { name: editName.trim() })
    }
    setEditingId(null)
  }

  const handleColorChange = (roomId: string, color: string) => {
    if (onRoomEdit) {
      onRoomEdit(roomId, { color })
    }
  }

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/40 z-40"
          />

          {/* Panel */}
          <motion.aside
            initial={{ x: 320, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 320, opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed right-0 top-0 bottom-0 w-80 z-50 flex flex-col"
            style={{
              background: 'linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%)',
              borderLeft: '1px solid rgba(255, 255, 255, 0.1)',
              backdropFilter: 'blur(20px)',
            }}
          >
            {/* Header */}
            <div className="flex items-center justify-between p-5 border-b border-white/10">
              <div className="flex items-center gap-3">
                <div className="p-2 rounded-lg bg-indigo-500/20">
                  <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" className="text-indigo-400">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
                </div>
                <h2 className="text-sm font-black uppercase tracking-widest text-white">
                  Manage Areas
                </h2>
              </div>
              <button
                onClick={onClose}
                className="p-2 rounded-lg hover:bg-white/5 transition-colors"
              >
                <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" className="text-slate-400">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            {/* Instructions */}
            <div className="px-5 py-3 border-b border-white/5">
              <p className="text-[10px] text-slate-500 italic font-bold uppercase tracking-tight">
                Drag to reorder tabs in POS view
              </p>
            </div>

            {/* Room List */}
            <div className="flex-1 overflow-y-auto p-4">
              <Reorder.Group axis="y" values={rooms} onReorder={handleReorder} className="space-y-3">
                {rooms.map((room) => (
                  <Reorder.Item
                    key={room.id}
                    value={room}
                    className="group"
                  >
                    <motion.div
                      layout
                      className="rounded-xl border transition-colors"
                      style={{
                        background: 'rgba(0, 0, 0, 0.3)',
                        borderColor: editingId === room.id ? 'rgba(99, 102, 241, 0.5)' : 'rgba(255, 255, 255, 0.1)',
                      }}
                    >
                      <div className="flex items-center gap-3 p-3">
                        {/* Drag Handle */}
                        <div className="cursor-grab active:cursor-grabbing p-1">
                          <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24" className="text-slate-600">
                            <circle cx="9" cy="6" r="1.5" />
                            <circle cx="15" cy="6" r="1.5" />
                            <circle cx="9" cy="12" r="1.5" />
                            <circle cx="15" cy="12" r="1.5" />
                            <circle cx="9" cy="18" r="1.5" />
                            <circle cx="15" cy="18" r="1.5" />
                          </svg>
                        </div>

                        {/* Color Indicator */}
                        <button
                          onClick={() => {
                            const currentIndex = THEME_COLORS.indexOf(room.color || '#6366f1')
                            const nextIndex = (currentIndex + 1) % THEME_COLORS.length
                            handleColorChange(room.id, THEME_COLORS[nextIndex])
                          }}
                          className="w-4 h-4 rounded-full flex-shrink-0 transition-transform hover:scale-125"
                          style={{
                            backgroundColor: room.color || '#6366f1',
                            boxShadow: `0 0 10px ${room.color || '#6366f1'}60`,
                          }}
                          title="Click to change color"
                        />

                        {/* Name (editable) */}
                        {editingId === room.id ? (
                          <input
                            type="text"
                            value={editName}
                            onChange={(e) => setEditName(e.target.value)}
                            onBlur={() => handleSaveEdit(room.id)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter') handleSaveEdit(room.id)
                              if (e.key === 'Escape') setEditingId(null)
                            }}
                            autoFocus
                            className="flex-1 bg-transparent text-sm text-white outline-none border-b border-indigo-500/50"
                          />
                        ) : (
                          <span
                            className="flex-1 text-sm font-medium text-slate-200 cursor-pointer hover:text-white"
                            onClick={() => handleStartEdit(room)}
                            title="Click to rename"
                          >
                            {room.name}
                          </span>
                        )}

                        {/* Delete Button */}
                        <button
                          onClick={() => handleDelete(room.id)}
                          disabled={rooms.length <= 1 || deletingId === room.id}
                          className={`p-1.5 rounded-lg transition-all ${
                            confirmDeleteId === room.id
                              ? 'bg-red-500/20 text-red-400'
                              : 'opacity-0 group-hover:opacity-100 hover:bg-red-500/10 text-slate-500 hover:text-red-400'
                          } disabled:opacity-30 disabled:cursor-not-allowed`}
                          title={
                            rooms.length <= 1
                              ? 'Cannot delete last room'
                              : confirmDeleteId === room.id
                                ? 'Click again to confirm'
                                : 'Delete room'
                          }
                        >
                          <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                          </svg>
                        </button>
                      </div>
                    </motion.div>
                  </Reorder.Item>
                ))}
              </Reorder.Group>

              {rooms.length === 0 && (
                <div className="text-center py-8">
                  <p className="text-slate-500 text-sm">No rooms created yet</p>
                </div>
              )}
            </div>

            {/* Footer Warning */}
            <div className="p-4 border-t border-white/10">
              <p className="text-[9px] text-slate-600 leading-relaxed uppercase font-bold tracking-tight">
                Note: Deleting an area will move its tables to &quot;No Section&quot; instead of deleting them.
              </p>
            </div>
          </motion.aside>
        </>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/table-positioning.ts
################################################################################

/**
 * Table Positioning Utilities
 * Handles magnetic attachment, collision detection, and auto-shift logic
 */

// Minimum gap between tables (px)
const TABLE_GAP = 12

export type AttachSide = 'left' | 'right' | 'top' | 'bottom'

export interface TableRect {
  id: string
  posX: number
  posY: number
  width: number
  height: number
}

/**
 * Determine which side to attach based on drop position relative to target center
 * Normalizes by table dimensions so wide tables can still attach on top/bottom
 */
export function calculateAttachSide(
  dropX: number,
  dropY: number,
  target: TableRect
): AttachSide {
  const targetCenterX = target.posX + target.width / 2
  const targetCenterY = target.posY + target.height / 2

  const dx = dropX - targetCenterX
  const dy = dropY - targetCenterY

  // Normalize by table dimensions to make top/bottom attachment easier for wide tables
  // This creates equal-sized zones relative to the table's aspect ratio
  const normalizedDx = Math.abs(dx) / (target.width / 2)
  const normalizedDy = Math.abs(dy) / (target.height / 2)

  if (normalizedDx > normalizedDy) {
    // Horizontal attachment
    return dx > 0 ? 'right' : 'left'
  } else {
    // Vertical attachment
    return dy > 0 ? 'bottom' : 'top'
  }
}

/**
 * Calculate the position for a table when attaching to a side
 * Aligns edges flush (not centered) for clean magnetic attachment
 */
export function calculateAttachPosition(
  source: TableRect,
  target: TableRect,
  side: AttachSide
): { posX: number; posY: number } {
  switch (side) {
    case 'right':
      return {
        posX: target.posX + target.width + TABLE_GAP,
        posY: target.posY, // Align top edges
      }
    case 'left':
      return {
        posX: target.posX - source.width - TABLE_GAP,
        posY: target.posY, // Align top edges
      }
    case 'bottom':
      return {
        posX: target.posX, // Align left edges
        posY: target.posY + target.height + TABLE_GAP,
      }
    case 'top':
      return {
        posX: target.posX, // Align left edges
        posY: target.posY - source.height - TABLE_GAP,
      }
  }
}

/**
 * Check if two rectangles overlap (with gap consideration)
 */
export function tablesOverlap(a: TableRect, b: TableRect, gap: number = 0): boolean {
  return !(
    a.posX + a.width + gap <= b.posX ||
    b.posX + b.width + gap <= a.posX ||
    a.posY + a.height + gap <= b.posY ||
    b.posY + b.height + gap <= a.posY
  )
}

/**
 * Find all tables that collide with a given table
 */
export function findCollidingTables(
  table: TableRect,
  allTables: TableRect[],
  excludeIds: string[] = []
): TableRect[] {
  return allTables.filter(
    (t) =>
      t.id !== table.id &&
      !excludeIds.includes(t.id) &&
      tablesOverlap(table, t, TABLE_GAP)
  )
}

/**
 * Find a non-overlapping position for a table
 * Tries original position first, then shifts in small increments
 */
export function findNonOverlappingPosition(
  table: TableRect,
  allTables: TableRect[],
  excludeIds: string[] = [],
  maxShift: number = 200
): { posX: number; posY: number } {
  const otherTables = allTables.filter(
    (t) => t.id !== table.id && !excludeIds.includes(t.id)
  )

  // Check if original position is fine
  if (!otherTables.some((t) => tablesOverlap(table, t, TABLE_GAP))) {
    return { posX: table.posX, posY: table.posY }
  }

  // Try shifting in a spiral pattern
  const shiftIncrement = 20
  for (let distance = shiftIncrement; distance <= maxShift; distance += shiftIncrement) {
    // Try each direction
    const directions = [
      { dx: distance, dy: 0 },      // right
      { dx: -distance, dy: 0 },     // left
      { dx: 0, dy: distance },      // down
      { dx: 0, dy: -distance },     // up
      { dx: distance, dy: distance },    // diagonal
      { dx: -distance, dy: distance },
      { dx: distance, dy: -distance },
      { dx: -distance, dy: -distance },
    ]

    for (const { dx, dy } of directions) {
      const testRect: TableRect = {
        ...table,
        posX: table.posX + dx,
        posY: table.posY + dy,
      }

      // Ensure position is valid (not negative)
      if (testRect.posX < 0 || testRect.posY < 0) continue

      if (!otherTables.some((t) => tablesOverlap(testRect, t, TABLE_GAP))) {
        return { posX: testRect.posX, posY: testRect.posY }
      }
    }
  }

  // If no position found, return original (shouldn't happen often)
  return { posX: table.posX, posY: table.posY }
}

/**
 * Shift colliding tables to make room for a new table placement
 * Returns a map of tableId -> new position
 */
export function shiftCollidingTables(
  newTable: TableRect,
  allTables: TableRect[],
  excludeIds: string[] = [],
  maxIterations: number = 5
): Map<string, { posX: number; posY: number }> {
  const shifts = new Map<string, { posX: number; posY: number }>()
  const processed = new Set<string>([...excludeIds, newTable.id])

  let tablesToCheck = [newTable]
  let iteration = 0

  while (tablesToCheck.length > 0 && iteration < maxIterations) {
    iteration++
    const nextBatch: TableRect[] = []

    for (const checkTable of tablesToCheck) {
      const collisions = findCollidingTables(checkTable, allTables, [...processed])

      for (const collision of collisions) {
        // Calculate push direction (away from the checking table)
        const dx = collision.posX + collision.width / 2 - (checkTable.posX + checkTable.width / 2)
        const dy = collision.posY + collision.height / 2 - (checkTable.posY + checkTable.height / 2)

        // Normalize and apply minimum shift
        const distance = Math.sqrt(dx * dx + dy * dy) || 1
        const shiftAmount = TABLE_GAP + 10 // Shift enough to create gap

        const shiftX = (dx / distance) * shiftAmount
        const shiftY = (dy / distance) * shiftAmount

        const newPos = {
          posX: Math.max(0, Math.round(collision.posX + shiftX)),
          posY: Math.max(0, Math.round(collision.posY + shiftY)),
        }

        shifts.set(collision.id, newPos)
        processed.add(collision.id)

        // Add to next batch to check for cascading collisions
        nextBatch.push({
          ...collision,
          posX: newPos.posX,
          posY: newPos.posY,
        })
      }
    }

    tablesToCheck = nextBatch
  }

  return shifts
}

export interface SeatPosition {
  seatNumber: number
  x: number  // Absolute position
  y: number
  angle: number  // Rotation angle for the seat indicator
}

// Seat patterns for partial coverage
export type SeatPattern =
  | 'all_around'    // Default - seats on all sides
  | 'front_only'    // Bar/counter style - seats on one side
  | 'back_only'     // Rare - seats behind
  | 'three_sides'   // Against wall - no seats on one side
  | 'two_sides'     // Corner booth - seats on two adjacent sides
  | 'inside'        // Booth interior - seats inside the table

// Arc configuration for seat distribution
export interface SeatArc {
  startAngle: number  // 0 = top, 90 = right, 180 = bottom, 270 = left
  endAngle: number
}

// Get arc configuration for a seat pattern
function getArcForPattern(pattern: SeatPattern): SeatArc {
  switch (pattern) {
    case 'front_only':
      return { startAngle: 135, endAngle: 225 } // Bottom side only
    case 'back_only':
      return { startAngle: 315, endAngle: 45 } // Top side only
    case 'three_sides':
      return { startAngle: 45, endAngle: 315 } // All except top (against wall)
    case 'two_sides':
      return { startAngle: 90, endAngle: 270 } // Right and bottom (corner)
    case 'inside':
    case 'all_around':
    default:
      return { startAngle: 0, endAngle: 360 }
  }
}

/**
 * Calculate seat positions around a table edge
 * Supports different patterns: all_around, front_only, three_sides, etc.
 */
export function calculateSeatPositions(
  table: {
    posX: number
    posY: number
    width: number
    height: number
    shape: string
  },
  seatCount: number,
  pattern: SeatPattern = 'all_around'
): SeatPosition[] {
  const positions: SeatPosition[] = []

  if (seatCount === 0) return positions

  const centerX = table.posX + table.width / 2
  const centerY = table.posY + table.height / 2
  const padding = 20 // Distance from table edge

  if (pattern === 'inside') {
    // Booth-style: seats distributed inside the table
    const innerPadding = 15
    const availableWidth = table.width - innerPadding * 2
    const spacing = seatCount > 1 ? availableWidth / (seatCount - 1) : 0

    for (let i = 0; i < seatCount; i++) {
      positions.push({
        seatNumber: i + 1,
        x: table.posX + innerPadding + (seatCount > 1 ? i * spacing : availableWidth / 2),
        y: table.posY + table.height * 0.35, // Upper portion of booth
        angle: 180, // Facing down/out
      })
    }
    return positions
  }

  if (table.shape === 'circle') {
    // Circle tables: seats distributed evenly around circumference within arc
    const arc = getArcForPattern(pattern)
    const radius = Math.max(table.width, table.height) / 2 + padding

    const startRad = (arc.startAngle * Math.PI) / 180
    const endRad = (arc.endAngle * Math.PI) / 180
    const arcLength = arc.endAngle > arc.startAngle
      ? endRad - startRad
      : (2 * Math.PI) - startRad + endRad

    const angleStep = seatCount > 1 ? arcLength / (seatCount - 1) : 0

    for (let i = 0; i < seatCount; i++) {
      const angle = startRad + i * angleStep - Math.PI / 2 // Offset so 0 = top
      positions.push({
        seatNumber: i + 1,
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        angle: (angle * 180) / Math.PI + 90, // Point toward center
      })
    }
    return positions
  }

  // Rectangle/square tables: distribute seats around perimeter based on pattern
  const arc = getArcForPattern(pattern)

  // Calculate which sides are included in the arc
  const includedSides: Array<'top' | 'right' | 'bottom' | 'left'> = []
  const sideRanges = [
    { side: 'top' as const, start: 315, end: 45 },
    { side: 'right' as const, start: 45, end: 135 },
    { side: 'bottom' as const, start: 135, end: 225 },
    { side: 'left' as const, start: 225, end: 315 },
  ]

  for (const { side, start, end } of sideRanges) {
    // Check if this side overlaps with the arc
    const arcStart = arc.startAngle
    const arcEnd = arc.endAngle === 360 ? 360 : arc.endAngle

    // Handle wrap-around
    const sideInArc = arcEnd >= arcStart
      ? (start < arcEnd && end > arcStart) || (start < arcEnd && start >= arcStart) || (end > arcStart && end <= arcEnd)
      : (start >= arcStart || start < arcEnd) || (end > arcStart || end <= arcEnd)

    if (sideInArc || arc.endAngle === 360) {
      includedSides.push(side)
    }
  }

  // If no sides included, default to all
  if (includedSides.length === 0) {
    includedSides.push('top', 'right', 'bottom', 'left')
  }

  // Calculate perimeter of included sides
  let totalPerimeter = 0
  for (const side of includedSides) {
    totalPerimeter += (side === 'top' || side === 'bottom') ? table.width : table.height
  }

  // Distribute seats evenly along included perimeter
  const spacing = totalPerimeter / seatCount
  let currentDistance = spacing / 2 // Start offset

  for (let i = 0; i < seatCount; i++) {
    let distanceAccum = 0
    let x = 0, y = 0, angle = 0

    for (const side of includedSides) {
      const sideLength = (side === 'top' || side === 'bottom') ? table.width : table.height
      const nextAccum = distanceAccum + sideLength

      if (currentDistance <= nextAccum) {
        const posOnSide = currentDistance - distanceAccum

        switch (side) {
          case 'top':
            x = table.posX + posOnSide
            y = table.posY - padding
            angle = 0
            break
          case 'right':
            x = table.posX + table.width + padding
            y = table.posY + posOnSide
            angle = 90
            break
          case 'bottom':
            x = table.posX + table.width - posOnSide
            y = table.posY + table.height + padding
            angle = 180
            break
          case 'left':
            x = table.posX - padding
            y = table.posY + table.height - posOnSide
            angle = 270
            break
        }
        break
      }
      distanceAccum = nextAccum
    }

    positions.push({ seatNumber: i + 1, x, y, angle })
    currentDistance += spacing
    if (currentDistance > totalPerimeter) {
      currentDistance -= totalPerimeter
    }
  }

  return positions
}

/**
 * Calculate seat positions for a combined table group
 * Distributes seats around the combined bounding box perimeter
 */
export function calculateCombinedSeatPositions(
  tables: Array<{
    id: string
    posX: number
    posY: number
    width: number
    height: number
    capacity: number
    shape?: string
  }>,
  pattern: SeatPattern = 'all_around'
): SeatPosition[] {
  if (tables.length === 0) return []

  // Calculate combined bounding box
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity
  let totalCapacity = 0

  for (const t of tables) {
    minX = Math.min(minX, t.posX)
    minY = Math.min(minY, t.posY)
    maxX = Math.max(maxX, t.posX + t.width)
    maxY = Math.max(maxY, t.posY + t.height)
    totalCapacity += t.capacity
  }

  // Add small padding between tables in the bounding box
  const boundingPadding = 5

  // Create a virtual combined table
  const combinedTable = {
    posX: minX - boundingPadding,
    posY: minY - boundingPadding,
    width: maxX - minX + boundingPadding * 2,
    height: maxY - minY + boundingPadding * 2,
    shape: 'rectangle',
  }

  return calculateSeatPositions(combinedTable, totalCapacity, pattern)
}

/**
 * Get the bounding box that contains all combined tables
 */
export function getCombinedBoundingBox(tables: TableRect[]): {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
} {
  if (tables.length === 0) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }
  }

  const minX = Math.min(...tables.map((t) => t.posX))
  const minY = Math.min(...tables.map((t) => t.posY))
  const maxX = Math.max(...tables.map((t) => t.posX + t.width))
  const maxY = Math.max(...tables.map((t) => t.posY + t.height))

  return {
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY,
  }
}



################################################################################
# FILE: src/components/floor-plan/TableInfoPanel.tsx
################################################################################

'use client'

import { motion, AnimatePresence } from 'framer-motion'
import { FloorPlanTable } from './use-floor-plan'

interface TableInfoPanelProps {
  table: FloorPlanTable | null
  isOpen: boolean
  onClose: () => void
  onAddItems: () => void
  onViewCheck: () => void
  onMarkDirty: () => void
  onMarkAvailable: () => void
  onResetToDefault?: () => void
}

export function TableInfoPanel({
  table,
  isOpen,
  onClose,
  onAddItems,
  onViewCheck,
  onMarkDirty,
  onMarkAvailable,
  onResetToDefault,
}: TableInfoPanelProps) {
  if (!table) return null

  const isCombined = Boolean(table.combinedTableIds && table.combinedTableIds.length > 0)
  const hasOrder = Boolean(table.currentOrder)

  const getStatusLabel = () => {
    switch (table.status) {
      case 'occupied':
        return 'Occupied'
      case 'dirty':
        return 'Needs Cleaning'
      case 'reserved':
        return 'Reserved'
      case 'in_use':
        return 'In Use'
      default:
        return 'Available'
    }
  }

  const getStatusColor = () => {
    switch (table.status) {
      case 'occupied':
        return 'text-indigo-400'
      case 'dirty':
        return 'text-amber-400'
      case 'reserved':
        return 'text-yellow-400'
      case 'in_use':
        return 'text-purple-400'
      default:
        return 'text-slate-400'
    }
  }

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            className="floor-plan-backdrop"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
          />

          {/* Panel */}
          <motion.div
            className="table-info-panel"
            initial={{ x: '100%' }}
            animate={{ x: 0 }}
            exit={{ x: '100%' }}
            transition={{ type: 'spring', damping: 25, stiffness: 200 }}
          >
            {/* Header */}
            <div className="table-info-panel-header">
              <div>
                <h2 className="table-info-panel-title">{table.name}</h2>
                <p className="table-info-panel-subtitle">
                  <span className={getStatusColor()}>{getStatusLabel()}</span>
                  {'  '}{table.capacity} seats
                  {isCombined && '  Combined'}
                </p>
              </div>
              <button className="table-info-panel-close" onClick={onClose}>
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            {/* Content */}
            <div className="table-info-panel-content">
              {/* Current Order Section */}
              {hasOrder && table.currentOrder && (
                <div className="table-info-panel-section">
                  <h3 className="table-info-panel-section-title">Current Order</h3>

                  <div className="flex items-center justify-between mb-4 text-sm">
                    <span className="text-slate-400">Order #{table.currentOrder.orderNumber}</span>
                    <span className="text-slate-400">{table.currentOrder.guestCount} guests</span>
                  </div>

                  {/* Order Items */}
                  {table.currentOrder.items && table.currentOrder.items.length > 0 ? (
                    <div className="space-y-1">
                      {table.currentOrder.items.map((item) => (
                        <div key={item.id} className="panel-order-item">
                          <div>
                            <div className="panel-order-item-name">{item.name}</div>
                            <div className="panel-order-item-qty">Qty: {item.quantity}</div>
                          </div>
                          <div className="panel-order-item-price">
                            ${(item.price * item.quantity).toFixed(2)}
                          </div>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <p className="text-sm text-slate-500 italic">Order details loading...</p>
                  )}

                  {/* Total */}
                  <div className="panel-total">
                    <span className="panel-total-label">Total</span>
                    <span className="panel-total-amount">${table.currentOrder.total.toFixed(2)}</span>
                  </div>

                  {/* Server */}
                  {table.currentOrder.server && (
                    <div className="flex items-center gap-2 mt-4 text-sm text-slate-400">
                      <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                      </svg>
                      <span>Server: {table.currentOrder.server}</span>
                    </div>
                  )}
                </div>
              )}

              {/* Section Info */}
              {table.section && (
                <div className="table-info-panel-section">
                  <h3 className="table-info-panel-section-title">Section</h3>
                  <div className="flex items-center gap-3">
                    <div
                      className="w-4 h-4 rounded"
                      style={{ backgroundColor: table.section.color }}
                    />
                    <span className="text-sm text-slate-300">{table.section.name}</span>
                  </div>
                </div>
              )}

              {/* Seats Info */}
              {table.seats && table.seats.length > 0 && (
                <div className="table-info-panel-section">
                  <h3 className="table-info-panel-section-title">Seats</h3>
                  <div className="flex flex-wrap gap-2">
                    {table.seats.map((seat) => (
                      <div
                        key={seat.id}
                        className="px-3 py-1.5 bg-white/5 rounded-lg text-sm text-slate-300"
                      >
                        Seat {seat.label}
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>

            {/* Actions */}
            <div className="table-info-panel-actions">
              {hasOrder ? (
                <>
                  <button className="panel-action-btn primary" onClick={onAddItems}>
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    Add Items
                  </button>
                  <button className="panel-action-btn secondary" onClick={onViewCheck}>
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                    </svg>
                    View Check
                  </button>
                </>
              ) : (
                <button className="panel-action-btn primary" onClick={onAddItems}>
                  <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                  </svg>
                  Start Order
                </button>
              )}

              {table.status === 'dirty' ? (
                <button className="panel-action-btn secondary" onClick={onMarkAvailable}>
                  <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  Mark Clean
                </button>
              ) : !hasOrder && table.status === 'available' ? (
                <button className="panel-action-btn warning" onClick={onMarkDirty}>
                  <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                  </svg>
                  Mark Dirty
                </button>
              ) : null}

              {/* Reset to Default for combined tables */}
              {isCombined && onResetToDefault && (
                <button className="panel-action-btn secondary" onClick={onResetToDefault}>
                  <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  Reset to Default
                </button>
              )}
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/TableNode.tsx
################################################################################

'use client'

import { useRef, useCallback, useMemo, memo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { FloorPlanTable, FloorPlanSeat, TableStatus } from './use-floor-plan'

interface TableNodeProps {
  table: FloorPlanTable
  isSelected: boolean
  isDragging: boolean
  isDropTarget: boolean
  isColliding?: boolean  // Whether the table collides with fixtures during drag
  combinedGroupColor?: string  // Color shared by all tables in a combined group
  showSeats?: boolean  // Whether to display seat indicators
  selectedSeat?: { tableId: string; seatNumber: number } | null
  flashMessage?: string | null  // Flash message to display (e.g., "OPEN ORDER")
  isEditable?: boolean  // Admin mode - allow seat dragging
  combinedSeatOffset?: number  // For combined tables: offset to add to seat numbers for sequential display
  combinedTotalSeats?: number  // Total seats across all combined tables
  // Virtual combine mode props
  isVirtualCombineMode?: boolean  // Whether virtual combine mode is active
  isVirtualCombineSelected?: boolean  // Whether this table is selected for virtual combine
  isVirtualCombineUnavailable?: boolean  // Whether this table cannot be selected (already in another group)
  virtualGroupColor?: string  // Color for virtual group pulsing glow
  onTap: () => void
  onDragStart: () => void
  onDragEnd: () => void
  onLongPress: () => void
  onSeatTap?: (seatNumber: number) => void
  onSeatDrag?: (seatId: string, newRelativeX: number, newRelativeY: number) => void
  onSeatDelete?: (seatId: string) => void
}

// Colors for combined table groups (consistent matching)
const COMBINED_GROUP_COLORS = [
  '#8b5cf6', // violet
  '#ec4899', // pink
  '#f97316', // orange
  '#14b8a6', // teal
  '#eab308', // yellow
  '#6366f1', // indigo
  '#10b981', // emerald
  '#f43f5e', // rose
]

// Generate consistent color from table ID hash
function hashCode(str: string): number {
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash // Convert to 32bit integer
  }
  return Math.abs(hash)
}

export function getCombinedGroupColor(primaryTableId: string): string {
  const colorIndex = hashCode(primaryTableId) % COMBINED_GROUP_COLORS.length
  return COMBINED_GROUP_COLORS[colorIndex]
}

// Status to glow color mapping
const statusGlowColors: Record<TableStatus, string> = {
  available: 'rgba(255, 255, 255, 0.1)',
  occupied: 'rgba(99, 102, 241, 0.6)',
  reserved: 'rgba(251, 191, 36, 0.6)',
  dirty: 'rgba(245, 158, 11, 0.6)',
  in_use: 'rgba(139, 92, 246, 0.6)',
}

export const TableNode = memo(function TableNode({
  table,
  isSelected,
  isDragging,
  isDropTarget,
  isColliding = false,
  combinedGroupColor,
  showSeats = false,
  selectedSeat,
  flashMessage,
  isEditable = false,
  combinedSeatOffset = 0,
  combinedTotalSeats,
  isVirtualCombineMode = false,
  isVirtualCombineSelected = false,
  isVirtualCombineUnavailable = false,
  virtualGroupColor,
  onTap,
  onDragStart,
  onDragEnd,
  onLongPress,
  onSeatTap,
  onSeatDrag,
  onSeatDelete,
}: TableNodeProps) {
  const longPressTimer = useRef<NodeJS.Timeout | null>(null)
  const isCombined = Boolean(table.combinedTableIds && table.combinedTableIds.length > 0)
  const isPartOfCombinedGroup = Boolean(table.combinedWithId) // This table is combined INTO another
  const isLocked = table.isLocked
  const isBooth = table.shape === 'booth'

  // Virtual group state
  const isInVirtualGroup = Boolean(table.virtualGroupId)
  const isVirtualGroupPrimary = table.virtualGroupPrimary
  const effectiveVirtualGroupColor = virtualGroupColor || table.virtualGroupColor || (isInVirtualGroup ? '#06b6d4' : null)

  // Calculate dynamic font sizes based on table dimensions
  const minDimension = Math.min(table.width, table.height)
  const isNarrow = table.width < 70 || table.height < 70
  const isSmall = minDimension < 80

  // Font sizes scale with table size
  const nameFontSize = isSmall ? Math.max(11, minDimension * 0.18) : Math.min(18, minDimension * 0.2)
  const infoFontSize = isSmall ? Math.max(9, minDimension * 0.12) : Math.min(12, minDimension * 0.14)

  // For very narrow tables, we might want to rotate the text 90
  const shouldRotateText = table.width < 60 && table.height > table.width * 1.5

  // Use database seats instead of calculating positions
  // Each seat has relativeX/relativeY (relative to table center) stored in DB
  // This ensures seat 1 is ALWAYS seat 1, regardless of table position/combine state
  const databaseSeats = useMemo(() => {
    // Don't show seats if showSeats is false
    if (!showSeats) return []

    // Always use the table's database seats - they belong to THIS table permanently
    // Even in combined groups, each table's seats render relative to their own table
    const seats = table.seats || []

    // Sort seats by seatNumber - this is the intended visual order around the table
    // The seatNumber was assigned sequentially when seats were created around the perimeter
    // (angle property indicates which edge, not sequential position)
    const sortedSeats = [...seats].sort((a, b) => a.seatNumber - b.seatNumber)


    // Convert relative positions (from table center) to positions relative to table's top-left
    return sortedSeats.map(seat => ({
      id: seat.id,
      seatNumber: seat.seatNumber,
      label: seat.label,
      // Position: table center offset + relative seat position
      x: table.width / 2 + seat.relativeX,
      y: table.height / 2 + seat.relativeY,
      angle: seat.angle,
      seatType: seat.seatType,
    }))
  }, [showSeats, table.seats, table.width, table.height])

  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    // In virtual combine mode, we're just selecting tables - handle tap directly
    if (isVirtualCombineMode) {
      return
    }

    // Locked tables cannot be dragged
    if (isLocked) {
      return
    }

    longPressTimer.current = setTimeout(() => {
      onLongPress()
    }, 500)
    onDragStart()
  }, [onDragStart, onLongPress, isLocked, isVirtualCombineMode])

  const handlePointerUp = useCallback(() => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
    }
    // In virtual combine mode, handle as a tap to toggle selection
    if (isVirtualCombineMode) {
      onTap()
      return
    }
    // Only call onDragEnd if THIS table was being dragged
    // This prevents clearing draggedTableId when releasing over a different table (drop target)
    if (isDragging) {
      onDragEnd()
    }
  }, [onDragEnd, isDragging, isVirtualCombineMode, onTap])

  const handlePointerMove = useCallback(() => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
    }
  }, [])

  // Use combined group color for glow if table is part of a combined group
  const hasCombinedColor = combinedGroupColor && (isCombined || isPartOfCombinedGroup)
  const glowColor = hasCombinedColor
    ? `${combinedGroupColor}99` // Add alpha for glow effect
    : statusGlowColors[table.status]
  const isReserved = table.status === 'reserved'

  // Calculate table dimensions based on shape
  const getShapeStyle = () => {
    switch (table.shape) {
      case 'circle':
        return { borderRadius: '50%' }
      case 'booth':
        return { borderRadius: '12px 12px 24px 24px' }
      case 'bar':
        return { borderRadius: '24px' }
      default:
        return { borderRadius: '12px' }
    }
  }

  return (
    <motion.div
      className={`table-node status-${table.status} ${isSelected ? 'selected' : ''} ${isDropTarget ? 'drop-target' : ''} ${isColliding ? 'colliding' : ''} ${isCombined ? 'combined' : ''} ${isLocked ? 'locked' : ''} ${isInVirtualGroup ? 'virtual-combined' : ''} ${isVirtualCombineSelected ? 'virtual-combine-selected' : ''} ${isVirtualCombineUnavailable ? 'virtual-combine-unavailable' : ''}`}
      style={{
        left: table.posX,
        top: table.posY,
        width: table.width,
        height: table.height,
        zIndex: isDragging ? 100 : isSelected ? 50 : 1,
        // Dim and disable unavailable tables during virtual combine mode
        ...(isVirtualCombineUnavailable ? {
          opacity: 0.4,
          filter: 'grayscale(0.7)',
          pointerEvents: 'none' as const,
        } : {}),
      }}
      initial={{ opacity: 0, scale: 0.9, rotate: 0 }}
      animate={{
        opacity: isColliding ? 0.7 : 1,
        scale: isDragging ? 1.05 : isSelected ? 1.02 : 1,
        rotate: table.rotation || 0,
      }}
      exit={{ opacity: 0, scale: 0.9 }}
      transition={{ duration: 0.2, ease: 'easeOut' }}
      onClick={(e) => {
        // Only handle click when NOT in virtual combine mode
        // (virtual combine mode uses pointerUp to avoid double-toggle)
        if (!isVirtualCombineMode) {
          e.stopPropagation()
          onTap()
        }
      }}
      onPointerDown={handlePointerDown}
      onPointerUp={handlePointerUp}
      onPointerMove={handlePointerMove}
      onPointerCancel={handlePointerUp}
      whileTap={{ scale: 0.98 }}
    >
      {/* Static subtle glow for virtual combined tables - OUTSIDE table-node-inner to avoid overflow:hidden clipping */}
      {isInVirtualGroup && (
        <div
          className="absolute virtual-group-glow"
          style={{
            inset: -4,
            borderRadius: 'inherit',
            pointerEvents: 'none',
            zIndex: 0,
            boxShadow: `0 0 8px ${effectiveVirtualGroupColor || '#06b6d4'}50, 0 0 16px ${effectiveVirtualGroupColor || '#06b6d4'}25`,
          }}
        />
      )}

      {/* Soft border indicator for virtual groups - OUTSIDE table-node-inner to avoid overflow:hidden clipping */}
      {isInVirtualGroup && (
        <div
          style={{
            position: 'absolute',
            inset: -3,
            borderRadius: 12,
            border: `2px solid ${effectiveVirtualGroupColor || '#06b6d4'}`,
            opacity: 0.8,
            pointerEvents: 'none',
            zIndex: 1,
          }}
        />
      )}

      <motion.div
        className="table-node-inner"
        style={{
          ...getShapeStyle(),
          width: '100%',
          height: '100%',
        }}
        animate={{
          boxShadow: isColliding
            ? [
                `inset 0 1px 1px rgba(255, 255, 255, 0.05)`,
                `0 4px 12px rgba(0, 0, 0, 0.3)`,
                `0 0 30px rgba(239, 68, 68, 0.8)`,
                `0 0 50px rgba(239, 68, 68, 0.5)`,
              ].join(', ')
            : [
                `inset 0 1px 1px rgba(255, 255, 255, 0.05)`,
                `0 4px 12px rgba(0, 0, 0, 0.3)`,
                `0 0 ${isSelected ? '30px' : '20px'} ${glowColor}`,
                `0 0 ${isSelected ? '50px' : '40px'} ${hasCombinedColor ? `${combinedGroupColor}4D` : glowColor.replace(/[\d.]+\)$/, '0.3)')}`,
              ].join(', '),
          borderColor: isColliding
            ? '#ef4444'
            : isDropTarget
              ? '#22c55e'
              : hasCombinedColor
                ? combinedGroupColor
                : isInVirtualGroup
                  ? (effectiveVirtualGroupColor || '#06b6d4')
                  : isSelected
                    ? '#6366f1'
                    : 'rgba(255, 255, 255, 0.1)',
          borderWidth: isColliding || isDropTarget || isSelected || hasCombinedColor || isInVirtualGroup ? '3px' : '1px',
          borderStyle: isColliding ? 'solid' : isDropTarget || isCombined || isPartOfCombinedGroup ? 'dashed' : 'solid',
        }}
        transition={{ duration: 0.3 }}
      >
        {/* Animated glow pulse for reserved tables */}
        {isReserved && (
          <motion.div
            className="absolute inset-0 rounded-inherit"
            style={{ borderRadius: 'inherit' }}
            animate={{
              boxShadow: [
                `0 0 20px rgba(251, 191, 36, 0.3)`,
                `0 0 40px rgba(251, 191, 36, 0.5)`,
                `0 0 20px rgba(251, 191, 36, 0.3)`,
              ],
            }}
            transition={{ duration: 2, repeat: Infinity, ease: 'easeInOut' }}
          />
        )}

        {/* Collision indicator - shows when dragging over fixture */}
        <AnimatePresence>
          {isColliding && (
            <motion.div
              className="absolute inset-0 flex items-center justify-center pointer-events-none"
              initial={{ opacity: 0, scale: 0.5 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.5 }}
              transition={{ duration: 0.2 }}
            >
              <motion.div
                className="bg-red-500 rounded-full p-2 shadow-lg"
                animate={{
                  scale: [1, 1.1, 1],
                }}
                transition={{ duration: 1, repeat: Infinity, ease: 'easeInOut' }}
              >
                <svg width="24" height="24" fill="white" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M13.477 14.89A6 6 0 015.11 6.524l8.367 8.368zm1.414-1.414L6.524 5.11a6 6 0 018.367 8.367zM18 10a8 8 0 11-16 0 8 8 0 0116 0z" clipRule="evenodd" />
                </svg>
              </motion.div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Selection checkmark for virtual combine mode */}
        {isVirtualCombineMode && isVirtualCombineSelected && (
          <motion.div
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            className="absolute -top-2 -right-2 w-6 h-6 bg-cyan-500 rounded-full flex items-center justify-center shadow-lg z-20"
          >
            <svg className="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
            </svg>
          </motion.div>
        )}

        {/* Table Content - Counter-rotate text so it stays readable */}
        <div
          className="table-node-content"
          style={{
            transform: `rotate(${-(table.rotation || 0)}deg)${shouldRotateText ? ' rotate(90deg)' : ''}`,
          }}
        >
          {/* Table name - show abbreviation if set, otherwise full name */}
          <div
            className="table-node-name"
            style={{
              fontSize: `${nameFontSize}px`,
              lineHeight: 1.2,
            }}
            title={table.name} // Full name on hover
          >
            {table.abbreviation || table.name}
          </div>

          {/* Order info or seat count */}
          {table.currentOrder ? (
            <>
              <div className="table-node-info" style={{ fontSize: `${infoFontSize}px` }}>
                #{table.currentOrder.orderNumber}  {table.currentOrder.guestCount} guests
              </div>
              <div className="table-node-total" style={{ fontSize: `${infoFontSize + 2}px` }}>
                ${table.currentOrder.total.toFixed(2)}
              </div>
            </>
          ) : (
            <div className="table-node-info" style={{ fontSize: `${infoFontSize}px` }}>
              {/* For combined tables, show total seats across group */}
              {combinedTotalSeats
                ? `${combinedTotalSeats} seat${combinedTotalSeats !== 1 ? 's' : ''}`
                : `${table.seats?.length || table.capacity} seat${(table.seats?.length || table.capacity) !== 1 ? 's' : ''}`
              }
            </div>
          )}
        </div>

        {/* Combined badge - shows on primary table that has others combined to it */}
        <AnimatePresence>
          {isCombined && (
            <motion.div
              className="combined-badge"
              style={combinedGroupColor ? { backgroundColor: combinedGroupColor } : undefined}
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0 }}
            >
              +{table.combinedTableIds?.length}
            </motion.div>
          )}
        </AnimatePresence>

        {/* Combined indicator - shows on tables that are combined INTO a primary */}
        <AnimatePresence>
          {isPartOfCombinedGroup && !isCombined && (
            <motion.div
              className="combined-child-badge"
              style={combinedGroupColor ? { backgroundColor: combinedGroupColor } : undefined}
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0 }}
            >
              
            </motion.div>
          )}
        </AnimatePresence>

        {/* Lock icon for locked tables */}
        {isLocked && (
          <div className="locked-badge" title="This table is locked and cannot be moved">
            <svg width="12" height="12" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
            </svg>
          </div>
        )}

        {/* Virtual group chain link badge */}
        <AnimatePresence>
          {isInVirtualGroup && (
            <motion.div
              className="virtual-group-badge"
              style={{
                backgroundColor: effectiveVirtualGroupColor || '#06b6d4',
                position: 'absolute',
                top: -6,
                left: -6,
                width: 26,
                height: 26,
                borderRadius: '50%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                border: '3px solid white',
                boxShadow: `0 0 10px ${effectiveVirtualGroupColor || '#06b6d4'}`,
                zIndex: 15,
              }}
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0 }}
              title={isVirtualGroupPrimary ? 'Primary table of virtual group' : 'Part of virtual group'}
            >
              <svg width="12" height="12" fill="white" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clipRule="evenodd" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>

      {/* Drop target indicator */}
      <AnimatePresence>
        {isDropTarget && (
          <motion.div
            className="absolute inset-[-8px] border-2 border-dashed border-green-500 rounded-2xl"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />
        )}
      </AnimatePresence>

      {/* Seat indicators from database (permanently assigned to this table) */}
      {showSeats && databaseSeats.length > 0 && (
        <>
          {databaseSeats.map((seat, index) => {
            // Check if this table is part of a combined group (either primary or child)
            // combinedTotalSeats is set for any table in a combined group
            const isInCombinedGroup = Boolean(combinedTotalSeats)

            // For combined tables, use seat.label from database - it was set to the correct
            // sequential number (1, 2, 3...) based on clockwise position during combine.
            // For single tables, use seatNumber.
            // Parse label as number for selection matching
            const displayNumber = isInCombinedGroup
              ? parseInt(seat.label, 10) || seat.seatNumber
              : seat.seatNumber

            // For combined groups, check tableId matches the primary (or this table if it IS primary)
            // Child tables: selectedSeat.tableId should match table.combinedWithId (the primary)
            // Primary tables: selectedSeat.tableId should match table.id
            const expectedTableId = table.combinedWithId || table.id
            const isSelectedSeat = isInCombinedGroup
              ? selectedSeat?.tableId === expectedTableId && selectedSeat?.seatNumber === displayNumber
              : selectedSeat?.tableId === table.id && selectedSeat?.seatNumber === seat.seatNumber
            const seatColor = combinedGroupColor || '#6366f1'
            // Calculate position relative to table center for drag calculations
            const seatRelativeX = seat.x - table.width / 2
            const seatRelativeY = seat.y - table.height / 2

            // Display the label - for combined tables this is the clockwise sequential number
            // For single tables this is the original label
            const displayLabel = seat.label

            return (
              <motion.div
                key={`seat-${seat.id}`}
                className={`seat-indicator ${isSelectedSeat ? 'selected' : ''} ${isBooth ? 'booth-seat' : ''} ${isEditable ? 'editable' : ''}`}
                drag={isEditable}
                dragMomentum={false}
                dragElastic={0}
                dragConstraints={{
                  // Constrain drag to ~150px from current position (prevents losing seats)
                  left: -150,
                  right: 150,
                  top: -150,
                  bottom: 150,
                }}
                onDragEnd={(e, info) => {
                  if (isEditable && onSeatDrag) {
                    // Calculate new relative position from table center
                    let newRelativeX = Math.round(seatRelativeX + info.offset.x)
                    let newRelativeY = Math.round(seatRelativeY + info.offset.y)

                    // Constrain to max 150px from center
                    const maxDistance = 150
                    const distance = Math.sqrt(newRelativeX * newRelativeX + newRelativeY * newRelativeY)
                    if (distance > maxDistance) {
                      const scale = maxDistance / distance
                      newRelativeX = Math.round(newRelativeX * scale)
                      newRelativeY = Math.round(newRelativeY * scale)
                    }

                    onSeatDrag(seat.id, newRelativeX, newRelativeY)
                  }
                }}
                style={{
                  position: 'absolute',
                  left: seat.x - 12, // Center the 24px dot
                  top: seat.y - 12,
                  width: 24,
                  height: 24,
                  borderRadius: '50%',
                  backgroundColor: isSelectedSeat ? seatColor : isEditable ? 'rgba(99, 102, 241, 0.3)' : 'rgba(255, 255, 255, 0.15)',
                  border: `2px solid ${isSelectedSeat ? seatColor : isEditable ? 'rgba(99, 102, 241, 0.5)' : 'rgba(255, 255, 255, 0.3)'}`,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 10,
                  fontWeight: 600,
                  color: isSelectedSeat ? 'white' : isEditable ? '#c7d2fe' : 'rgba(255, 255, 255, 0.7)',
                  cursor: isEditable ? 'grab' : 'pointer',
                  zIndex: isSelectedSeat ? 20 : 10,
                  boxShadow: isSelectedSeat
                    ? `0 0 10px ${seatColor}80`
                    : isEditable
                      ? '0 2px 8px rgba(99, 102, 241, 0.3)'
                      : '0 2px 4px rgba(0, 0, 0, 0.3)',
                  // Don't rotate the seat circle - keep it as a simple circle
                  // Text inside will counter-rotate for table rotation only
                }}
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                exit={{ scale: 0 }}
                whileHover={{ scale: 1.15 }}
                whileTap={{ scale: 0.95 }}
                whileDrag={{ scale: 1.2, cursor: 'grabbing' }}
                onClick={(e) => {
                  e.stopPropagation()
                  // Use the display number (from seat.label for combined, seatNumber for single)
                  onSeatTap?.(displayNumber)
                }}
                title={
                  isEditable
                    ? isSelectedSeat
                      ? `Seat ${displayLabel} - Arrow keys: 5px, Shift+Arrows: 20px, Del: remove`
                      : `Seat ${displayLabel} - Click to select, drag to move`
                    : `Seat ${displayLabel}`
                }
              >
                {/* Counter-rotate label by table rotation only so ALL seat numbers face upright */}
                <span style={{ transform: `rotate(${-(table.rotation || 0)}deg)` }}>
                  {displayLabel}
                </span>
                {/* Delete button for selected seat in edit mode - counter-rotate to stay upright */}
                {isEditable && isSelectedSeat && onSeatDelete && (
                  <motion.button
                    initial={{ scale: 0 }}
                    animate={{ scale: 1 }}
                    style={{
                      position: 'absolute',
                      top: -8,
                      right: -8,
                      width: 16,
                      height: 16,
                      borderRadius: '50%',
                      background: '#ef4444',
                      border: '2px solid #1e293b',
                      color: 'white',
                      fontSize: 10,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor: 'pointer',
                      padding: 0,
                      transform: `rotate(${-(table.rotation || 0)}deg)`,
                    }}
                    onClick={(e) => {
                      e.stopPropagation()
                      onSeatDelete(seat.id)
                    }}
                    title="Delete seat"
                  >
                    
                  </motion.button>
                )}
                {/* Keyboard hint for selected seat - counter-rotate to stay readable */}
                {isEditable && isSelectedSeat && (
                  <motion.div
                    initial={{ opacity: 0, y: 5 }}
                    animate={{ opacity: 1, y: 0 }}
                    style={{
                      position: 'absolute',
                      bottom: -28,
                      left: '50%',
                      transform: `translateX(-50%) rotate(${-(table.rotation || 0)}deg)`,
                      whiteSpace: 'nowrap',
                      fontSize: 9,
                      fontWeight: 500,
                      color: '#a5b4fc',
                      background: 'rgba(15, 23, 42, 0.95)',
                      padding: '3px 8px',
                      borderRadius: 4,
                      border: '1px solid rgba(99, 102, 241, 0.3)',
                      pointerEvents: 'none',
                    }}
                  >
                        move  Shift: 20px
                  </motion.div>
                )}
              </motion.div>
            )
          })}
        </>
      )}

      {/* Flash message overlay (e.g., "OPEN ORDER") */}
      <AnimatePresence>
        {flashMessage && (
          <motion.div
            className="flash-message-overlay"
            style={{
              position: 'absolute',
              inset: 0,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              backgroundColor: 'rgba(239, 68, 68, 0.9)',
              borderRadius: 'inherit',
              zIndex: 100,
            }}
            initial={{ opacity: 0 }}
            animate={{ opacity: [1, 0.7, 1, 0.7, 1] }}
            exit={{ opacity: 0 }}
            transition={{ duration: 2, times: [0, 0.25, 0.5, 0.75, 1] }}
          >
            <span style={{ color: 'white', fontWeight: 700, fontSize: 12, textTransform: 'uppercase' }}>
              {flashMessage}
            </span>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  )
})




################################################################################
# FILE: src/components/floor-plan/TableShape.tsx
################################################################################

'use client'

import { useRef, useState, useCallback } from 'react'
import { FloorPlanTable, TableStatus } from './use-floor-plan'
import { SeatDot } from './SeatDot'

// Status color mapping
const STATUS_COLORS: Record<TableStatus, { fill: string; stroke: string; text: string }> = {
  available: { fill: '#DCFCE7', stroke: '#22C55E', text: '#166534' },
  occupied: { fill: '#DBEAFE', stroke: '#3B82F6', text: '#1E40AF' },
  reserved: { fill: '#FEF9C3', stroke: '#EAB308', text: '#854D0E' },
  dirty: { fill: '#FED7AA', stroke: '#F97316', text: '#9A3412' },
  in_use: { fill: '#E0E7FF', stroke: '#6366F1', text: '#3730A3' },
}

interface TableShapeProps {
  table: FloorPlanTable
  isSelected: boolean
  isDragging: boolean
  isDropTarget: boolean
  isCombined: boolean
  onSelect: () => void
  onDragStart: () => void
  onDragEnd: () => void
  onLongPress: () => void
}

export function TableShape({
  table,
  isSelected,
  isDragging,
  isDropTarget,
  isCombined,
  onSelect,
  onDragStart,
  onDragEnd,
  onLongPress,
}: TableShapeProps) {
  const colors = STATUS_COLORS[table.status] || STATUS_COLORS.available
  const longPressTimer = useRef<NodeJS.Timeout | null>(null)
  const [isDragActive, setIsDragActive] = useState(false)

  // Touch handling for drag
  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    e.preventDefault()
    e.stopPropagation()

    // Start long press timer for split action
    longPressTimer.current = setTimeout(() => {
      onLongPress()
    }, 500)

    // Mark as potentially dragging
    setIsDragActive(true)
    onDragStart()
  }, [onDragStart, onLongPress])

  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    e.preventDefault()

    // Clear long press timer
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
    }

    if (isDragActive) {
      setIsDragActive(false)
      onDragEnd()
    }
  }, [isDragActive, onDragEnd])

  const handlePointerMove = useCallback(() => {
    // Cancel long press if moved
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
    }
  }, [])

  const handleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation()
    onSelect()
  }, [onSelect])

  // Calculate center for text
  const centerX = table.posX + table.width / 2
  const centerY = table.posY + table.height / 2

  // Render shape based on type
  const renderShape = () => {
    const baseProps = {
      fill: colors.fill,
      stroke: isSelected ? '#2563EB' : isDropTarget ? '#22C55E' : colors.stroke,
      strokeWidth: isSelected ? 3 : isDropTarget ? 4 : 2,
      style: {
        filter: isDragging
          ? 'drop-shadow(0 8px 12px rgba(0,0,0,0.25))'
          : isDropTarget
          ? 'drop-shadow(0 0 12px rgba(34,197,94,0.5))'
          : isSelected
          ? 'drop-shadow(0 4px 8px rgba(37,99,235,0.3))'
          : 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))',
        transition: 'all 0.15s ease-out',
        transform: isDragging ? 'scale(1.05)' : undefined,
        transformOrigin: `${centerX}px ${centerY}px`,
      },
    }

    switch (table.shape) {
      case 'circle':
        return (
          <ellipse
            cx={centerX}
            cy={centerY}
            rx={table.width / 2}
            ry={table.height / 2}
            {...baseProps}
          />
        )
      case 'square':
      case 'rectangle':
      default:
        return (
          <rect
            x={table.posX}
            y={table.posY}
            width={table.width}
            height={table.height}
            rx={8}
            ry={8}
            {...baseProps}
          />
        )
      case 'booth':
        // Booth shape - rounded on one side
        return (
          <path
            d={`
              M ${table.posX + 8} ${table.posY}
              H ${table.posX + table.width}
              V ${table.posY + table.height}
              H ${table.posX + 8}
              Q ${table.posX} ${table.posY + table.height} ${table.posX} ${table.posY + table.height - 8}
              V ${table.posY + 8}
              Q ${table.posX} ${table.posY} ${table.posX + 8} ${table.posY}
              Z
            `}
            {...baseProps}
          />
        )
      case 'bar':
        // Bar counter - long rectangle with rounded ends
        return (
          <rect
            x={table.posX}
            y={table.posY}
            width={table.width}
            height={table.height}
            rx={table.height / 2}
            ry={table.height / 2}
            {...baseProps}
          />
        )
    }
  }

  // Determine display name (combined tables show "T1+T2")
  const displayName = table.combinedTableIds && table.combinedTableIds.length > 0
    ? table.name // Already shows combined name like "T1+T2"
    : table.name

  return (
    <g
      className={`table-shape cursor-pointer ${isDragging ? 'opacity-90' : ''}`}
      onClick={handleClick}
      onPointerDown={handlePointerDown}
      onPointerUp={handlePointerUp}
      onPointerMove={handlePointerMove}
      onPointerCancel={handlePointerUp}
      style={{ touchAction: 'none' }}
    >
      {/* Drop zone indicator */}
      {isDropTarget && (
        <rect
          x={table.posX - 8}
          y={table.posY - 8}
          width={table.width + 16}
          height={table.height + 16}
          rx={12}
          fill="none"
          stroke="#22C55E"
          strokeWidth={3}
          strokeDasharray="6 4"
          className="animate-pulse"
        />
      )}

      {/* Main table shape */}
      {renderShape()}

      {/* Combined indicator badge */}
      {isCombined && (
        <g>
          <circle
            cx={table.posX + table.width - 8}
            cy={table.posY + 8}
            r={12}
            fill="#8B5CF6"
            stroke="#ffffff"
            strokeWidth={2}
          />
          <text
            x={table.posX + table.width - 8}
            y={table.posY + 8}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize={10}
            fontWeight={700}
            fill="#ffffff"
          >
            +
          </text>
        </g>
      )}

      {/* Table name */}
      <text
        x={centerX}
        y={centerY - (table.currentOrder ? 10 : 0)}
        textAnchor="middle"
        dominantBaseline="central"
        fontSize={14}
        fontWeight={700}
        fill={colors.text}
        className="pointer-events-none select-none"
      >
        {displayName}
      </text>

      {/* Order info (if occupied) */}
      {table.currentOrder && (
        <>
          <text
            x={centerX}
            y={centerY + 8}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize={11}
            fill={colors.text}
            opacity={0.8}
            className="pointer-events-none select-none"
          >
            #{table.currentOrder.orderNumber}
          </text>
          <text
            x={centerX}
            y={centerY + 22}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize={10}
            fill={colors.text}
            opacity={0.7}
            className="pointer-events-none select-none"
          >
            ${table.currentOrder.total.toFixed(2)}
          </text>
        </>
      )}

      {/* Capacity indicator (when no order) */}
      {!table.currentOrder && (
        <text
          x={centerX}
          y={centerY + 14}
          textAnchor="middle"
          dominantBaseline="central"
          fontSize={10}
          fill={colors.text}
          opacity={0.6}
          className="pointer-events-none select-none"
        >
          {table.capacity} seats
        </text>
      )}

      {/* Render seats */}
      {table.seats?.map(seat => (
        <SeatDot
          key={seat.id}
          seat={seat}
          tableX={table.posX}
          tableY={table.posY}
          tableWidth={table.width}
          tableHeight={table.height}
          isOccupied={table.status === 'occupied'}
        />
      ))}
    </g>
  )
}



################################################################################
# FILE: src/components/floor-plan/UnifiedFloorPlan.tsx
################################################################################

'use client'

import { useEffect, useState, useCallback, useRef, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { useFloorPlanStore, FloorPlanTable, FloorPlanSection, SeatPattern } from './use-floor-plan'
import { TableNode, getCombinedGroupColor } from './TableNode'
import { TableInfoPanel } from './TableInfoPanel'
import { TableEditPanel } from './panels/TableEditPanel'
import { RoomTabs } from './RoomTabs'
import { calculateAttachSide, calculateAttachPosition } from './table-positioning'
import './styles/floor-plan.css'

type FloorPlanMode = 'admin' | 'pos'

interface UnifiedFloorPlanProps {
  mode: FloorPlanMode
  locationId: string
  employeeId?: string
  roomId?: string  // For multi-room support
  // Admin mode callbacks
  onTableUpdate?: (tableId: string, updates: Partial<FloorPlanTable>) => Promise<void>
  onTableDelete?: (tableId: string) => Promise<void>
  onTableCreate?: () => void
  // POS mode callbacks
  onTableSelect?: (table: FloorPlanTable) => void
  onTableCombine?: (sourceId: string, targetId: string) => Promise<boolean>
  onTableSplit?: (tableId: string) => Promise<void>
  // Shared
  showSeatsToggle?: boolean
  hideToolbar?: boolean  // Hide the top toolbar (when parent page provides its own)
  className?: string
}

export function UnifiedFloorPlan({
  mode,
  locationId,
  employeeId,
  roomId,
  onTableUpdate,
  onTableDelete,
  onTableCreate,
  onTableSelect,
  onTableCombine,
  onTableSplit,
  showSeatsToggle = true,
  hideToolbar = false,
  className = '',
}: UnifiedFloorPlanProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const [editingTableId, setEditingTableId] = useState<string | null>(null)
  const [lastDropPosition, setLastDropPosition] = useState<{ x: number; y: number } | null>(null)
  const [selectedSectionId, setSelectedSectionId] = useState<string | null>(null)

  // Auto-scaling state for floor plan
  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 })

  const {
    tables,
    sections,
    selectedTableId,
    draggedTableId,
    dropTargetTableId,
    infoPanelTableId,
    isLoading,
    showSeats,
    selectedSeat,
    flashingTables,
    setTables,
    setSections,
    selectTable,
    startDrag,
    updateDragTarget,
    endDrag,
    openInfoPanel,
    closeInfoPanel,
    toggleShowSeats,
    selectSeat,
    clearSelectedSeat,
    flashTableMessage,
    clearExpiredFlashes,
    setLoading,
  } = useFloorPlanStore()

  // Load data on mount
  useEffect(() => {
    loadFloorPlanData()
  }, [locationId, roomId])

  // Clear expired flashes
  useEffect(() => {
    const interval = setInterval(() => {
      clearExpiredFlashes()
    }, 1000)
    return () => clearInterval(interval)
  }, [clearExpiredFlashes])

  const loadFloorPlanData = async () => {
    setLoading(true)
    try {
      const roomParam = roomId ? `&roomId=${roomId}` : ''
      const [tablesRes, sectionsRes] = await Promise.all([
        fetch(`/api/tables?locationId=${locationId}&includeSeats=true${roomParam}`),
        fetch(`/api/sections?locationId=${locationId}${roomParam}`),
      ])

      if (tablesRes.ok) {
        const data = await tablesRes.json()
        setTables(data.tables || [])
      }
      if (sectionsRes.ok) {
        const data = await sectionsRes.json()
        setSections(data.sections || [])
      }
    } catch (error) {
      console.error('[UnifiedFloorPlan] Load error:', error)
    } finally {
      setLoading(false)
    }
  }

  // Auto-scaling: Measure container size with ResizeObserver (POS mode only)
  useEffect(() => {
    if (mode === 'admin' || !containerRef.current) return
    const observer = new ResizeObserver(entries => {
      const { width, height } = entries[0].contentRect
      setContainerSize({ width, height })
    })
    observer.observe(containerRef.current)
    return () => observer.disconnect()
  }, [mode])

  // Auto-scaling: Calculate bounding box of all visible tables (POS mode only)
  const tableBounds = useMemo(() => {
    if (mode === 'admin') return null

    // Filter tables by selected section
    const visibleTables = selectedSectionId === null
      ? tables
      : tables.filter(t => t.section?.id === selectedSectionId)

    if (visibleTables.length === 0) return null

    let minX = Infinity, minY = Infinity
    let maxX = -Infinity, maxY = -Infinity

    visibleTables.forEach(table => {
      minX = Math.min(minX, table.posX)
      minY = Math.min(minY, table.posY)
      maxX = Math.max(maxX, table.posX + (table.width || 100))
      maxY = Math.max(maxY, table.posY + (table.height || 100))
    })

    return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY }
  }, [tables, selectedSectionId, mode])

  // Auto-scaling: Calculate scale factor to fit all tables in container (POS mode only)
  const autoScale = useMemo(() => {
    if (mode === 'admin' || !tableBounds || containerSize.width === 0 || containerSize.height === 0) return 1

    const padding = 60
    const availableWidth = containerSize.width - padding * 2
    const availableHeight = containerSize.height - padding * 2

    if (tableBounds.width <= availableWidth && tableBounds.height <= availableHeight) {
      return 1
    }

    const scaleX = availableWidth / tableBounds.width
    const scaleY = availableHeight / tableBounds.height

    return Math.max(0.3, Math.min(scaleX, scaleY, 1))
  }, [tableBounds, containerSize, mode])

  // Auto-scaling: Calculate offset to center the scaled content
  const autoScaleOffset = useMemo(() => {
    if (mode === 'admin' || !tableBounds || autoScale === 1) {
      return { x: 0, y: 0 }
    }

    const scaledWidth = tableBounds.width * autoScale
    const scaledHeight = tableBounds.height * autoScale

    const offsetX = (containerSize.width - scaledWidth) / 2 - tableBounds.minX * autoScale
    const offsetY = (containerSize.height - scaledHeight) / 2 - tableBounds.minY * autoScale

    return { x: offsetX, y: offsetY }
  }, [tableBounds, autoScale, containerSize, mode])

  // Calculate combined group colors
  const combinedGroupColors = new Map<string, string>()
  tables.forEach(table => {
    if (table.combinedTableIds && table.combinedTableIds.length > 0) {
      const color = getCombinedGroupColor(table.id)
      combinedGroupColors.set(table.id, color)
      table.combinedTableIds.forEach(childId => {
        combinedGroupColors.set(childId, color)
      })
    }
  })

  // Calculate combined seat offsets for sequential numbering
  // When tables are combined, seats should be numbered 1, 2, 3... across all tables
  const combinedSeatOffsets = new Map<string, number>()
  const combinedTotalSeats = new Map<string, number>()
  tables.forEach(table => {
    if (table.combinedTableIds && table.combinedTableIds.length > 0) {
      // This is a primary table with children combined to it
      const primarySeatCount = table.seats?.length || 0
      let runningOffset = primarySeatCount

      // Primary table starts at offset 0
      combinedSeatOffsets.set(table.id, 0)

      // Calculate offset for each child table
      table.combinedTableIds.forEach(childId => {
        combinedSeatOffsets.set(childId, runningOffset)
        const childTable = tables.find(t => t.id === childId)
        runningOffset += childTable?.seats?.length || 0
      })

      // Total seats is the final running offset
      const totalSeats = runningOffset
      combinedTotalSeats.set(table.id, totalSeats)
      table.combinedTableIds.forEach(childId => {
        combinedTotalSeats.set(childId, totalSeats)
      })
    }
  })

  // Handle table tap based on mode
  const handleTableTap = useCallback((table: FloorPlanTable) => {
    if (mode === 'admin') {
      setEditingTableId(table.id)
      selectTable(table.id)
    } else {
      // POS mode - trigger order flow
      onTableSelect?.(table)
    }
  }, [mode, selectTable, onTableSelect])

  // Handle drag for table repositioning (admin mode)
  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!draggedTableId || !containerRef.current) return

    const rect = containerRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    setLastDropPosition({ x, y })

    // Check for drop target (combining tables in POS mode, or just repositioning in admin)
    if (mode === 'pos') {
      const targetTable = tables.find(t =>
        t.id !== draggedTableId &&
        x >= t.posX && x <= t.posX + t.width &&
        y >= t.posY && y <= t.posY + t.height
      )
      updateDragTarget(targetTable?.id || null)
    }
  }, [draggedTableId, tables, mode, updateDragTarget])

  const handlePointerUp = useCallback(async () => {
    if (!draggedTableId) return

    const draggedTable = tables.find(t => t.id === draggedTableId)
    if (!draggedTable) {
      endDrag()
      return
    }

    // Admin mode: just update position
    if (mode === 'admin' && lastDropPosition) {
      const newPosX = Math.max(0, lastDropPosition.x - draggedTable.width / 2)
      const newPosY = Math.max(0, lastDropPosition.y - draggedTable.height / 2)

      try {
        await fetch(`/api/tables/${draggedTableId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ posX: Math.round(newPosX), posY: Math.round(newPosY) }),
        })

        setTables(tables.map(t =>
          t.id === draggedTableId
            ? { ...t, posX: Math.round(newPosX), posY: Math.round(newPosY) }
            : t
        ))
      } catch (error) {
        console.error('Failed to update table position:', error)
      }
    }

    // POS mode: check for combine
    if (mode === 'pos' && dropTargetTableId && onTableCombine) {
      const success = await onTableCombine(draggedTableId, dropTargetTableId)
      if (success) {
        loadFloorPlanData() // Refresh
      }
    }

    endDrag()
    setLastDropPosition(null)
  }, [draggedTableId, dropTargetTableId, tables, mode, lastDropPosition, onTableCombine, endDrag, setTables])

  // Handle table update from edit panel
  const handleTableUpdate = useCallback(async (tableId: string, updates: Partial<FloorPlanTable>) => {
    if (onTableUpdate) {
      await onTableUpdate(tableId, updates)
    } else {
      // Default implementation - convert section to sectionId for API
      const { section, ...restUpdates } = updates
      const apiUpdates = {
        ...restUpdates,
        ...(section !== undefined ? { sectionId: section?.id || null } : {}),
      }
      try {
        const response = await fetch(`/api/tables/${tableId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(apiUpdates),
        })
        if (response.ok) {
          setTables(tables.map(t =>
            t.id === tableId ? { ...t, ...updates } : t
          ))
        }
      } catch (error) {
        console.error('Failed to update table:', error)
      }
    }
  }, [tables, setTables, onTableUpdate])

  // Handle table delete
  const handleTableDelete = useCallback(async (tableId: string) => {
    if (onTableDelete) {
      await onTableDelete(tableId)
    } else {
      // Default implementation
      try {
        const response = await fetch(`/api/tables/${tableId}`, {
          method: 'DELETE',
        })
        if (response.ok) {
          setTables(tables.filter(t => t.id !== tableId))
          setEditingTableId(null)
        }
      } catch (error) {
        console.error('Failed to delete table:', error)
      }
    }
  }, [tables, setTables, onTableDelete])

  // Handle seat regeneration
  const handleRegenerateSeats = useCallback(async (tableId: string, pattern: SeatPattern) => {
    const table = tables.find(t => t.id === tableId)
    if (!table) return

    try {
      const response = await fetch(`/api/tables/${tableId}/seats/auto-generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          count: table.capacity,
          seatPattern: pattern,
          replaceExisting: true,
          updateTablePattern: true,
          employeeId,
        }),
      })

      if (response.ok) {
        const data = await response.json()
        setTables(tables.map(t =>
          t.id === tableId
            ? { ...t, seats: data.seats, seatPattern: pattern }
            : t
        ))
      }
    } catch (error) {
      console.error('Failed to regenerate seats:', error)
    }
  }, [tables, setTables, employeeId])

  // Handle status update (for reset to available)
  const handleUpdateStatus = useCallback(async (tableId: string, status: string) => {
    try {
      await fetch(`/api/tables/${tableId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status }),
      })
      setTables(tables.map(t =>
        t.id === tableId ? { ...t, status: status as FloorPlanTable['status'] } : t
      ))
    } catch (error) {
      console.error('Failed to update status:', error)
    }
  }, [tables, setTables])

  // Handle reset to default (split combined tables)
  const handleResetToDefault = useCallback(async (tableIds: string[]) => {
    try {
      const response = await fetch('/api/tables/reset-to-default', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tableIds,
          locationId,
          employeeId,
        }),
      })

      if (response.ok) {
        loadFloorPlanData() // Refresh to get updated positions
      }
    } catch (error) {
      console.error('Failed to reset tables:', error)
    }
  }, [locationId, employeeId])

  // Handle seat drag (reposition) - admin mode only
  const handleSeatDrag = useCallback(async (tableId: string, seatId: string, newRelativeX: number, newRelativeY: number) => {
    if (mode !== 'admin') return

    try {
      const response = await fetch(`/api/tables/${tableId}/seats/${seatId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          relativeX: newRelativeX,
          relativeY: newRelativeY,
        }),
      })

      if (response.ok) {
        // Update local state
        setTables(tables.map(t => {
          if (t.id !== tableId) return t
          return {
            ...t,
            seats: t.seats?.map(s =>
              s.id === seatId
                ? { ...s, relativeX: newRelativeX, relativeY: newRelativeY }
                : s
            ),
          }
        }))
      }
    } catch (error) {
      console.error('Failed to update seat position:', error)
    }
  }, [mode, tables, setTables])

  // Handle add seat - admin mode only
  const handleAddSeat = useCallback(async (tableId: string) => {
    if (mode !== 'admin') return

    const table = tables.find(t => t.id === tableId)
    if (!table) return

    try {
      // Add seat at a default position (center-right of table)
      const response = await fetch(`/api/tables/${tableId}/seats`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          relativeX: table.width / 2 + 30, // Position to the right of table
          relativeY: 0,
          angle: 270,
          seatType: 'standard',
        }),
      })

      if (response.ok) {
        const data = await response.json()
        // Update local state
        setTables(tables.map(t => {
          if (t.id !== tableId) return t
          return {
            ...t,
            seats: [...(t.seats || []), data.seat],
          }
        }))
      }
    } catch (error) {
      console.error('Failed to add seat:', error)
    }
  }, [mode, tables, setTables])

  // Handle seat delete - admin mode only
  const handleSeatDelete = useCallback(async (tableId: string, seatId: string) => {
    if (mode !== 'admin') return
    if (!confirm('Delete this seat?')) return

    try {
      const response = await fetch(`/api/tables/${tableId}/seats/${seatId}?employeeId=${employeeId}`, {
        method: 'DELETE',
      })

      if (response.ok) {
        // Update local state
        setTables(tables.map(t => {
          if (t.id !== tableId) return t
          return {
            ...t,
            seats: t.seats?.filter(s => s.id !== seatId),
          }
        }))
        clearSelectedSeat()
      }
    } catch (error) {
      console.error('Failed to delete seat:', error)
    }
  }, [mode, tables, setTables, employeeId, clearSelectedSeat])

  // Handle table move by delta (for arrow keys) - admin mode only
  const handleTableMoveByDelta = useCallback(async (tableId: string, deltaX: number, deltaY: number) => {
    if (mode !== 'admin') return

    const table = tables.find(t => t.id === tableId)
    if (!table) return

    // Calculate new position (constrain to positive values)
    const newX = Math.max(0, table.posX + deltaX)
    const newY = Math.max(0, table.posY + deltaY)

    try {
      const response = await fetch(`/api/tables/${tableId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          posX: newX,
          posY: newY,
        }),
      })

      if (response.ok) {
        setTables(tables.map(t =>
          t.id === tableId ? { ...t, posX: newX, posY: newY } : t
        ))
      }
    } catch (error) {
      console.error('Failed to move table:', error)
    }
  }, [mode, tables, setTables])

  // Generate unique name for duplicated table
  const generateUniqueName = useCallback((baseName: string): string => {
    const existingNames = tables.map(t => t.name)
    // Remove existing " Copy" or " Copy 2" suffix
    const cleanName = baseName.replace(/ Copy( \d+)?$/, '')

    // Try "Name Copy", then "Name Copy 2", "Name Copy 3", etc.
    let newName = `${cleanName} Copy`
    let counter = 2

    while (existingNames.includes(newName)) {
      newName = `${cleanName} Copy ${counter}`
      counter++
    }

    return newName
  }, [tables])

  // Handle duplicate table - admin mode only
  const handleDuplicateTable = useCallback(async (tableId: string) => {
    if (mode !== 'admin') return

    const table = tables.find(t => t.id === tableId)
    if (!table) return

    const newName = generateUniqueName(table.name)

    try {
      // Create new table with offset position
      const response = await fetch('/api/tables', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          name: newName,
          capacity: table.capacity,
          shape: table.shape,
          seatPattern: table.seatPattern,
          width: table.width,
          height: table.height,
          posX: table.posX + 50,
          posY: table.posY + 50,
          rotation: table.rotation || 0,
          sectionId: table.section?.id || null,
        }),
      })

      if (response.ok) {
        const data = await response.json()
        // Add to local state and select the new table
        setTables([...tables, data.table])
        selectTable(data.table.id)
        setEditingTableId(data.table.id)
      }
    } catch (error) {
      console.error('Failed to duplicate table:', error)
    }
  }, [mode, tables, locationId, setTables, selectTable, generateUniqueName])

  // Handle table rotation - admin mode only
  const handleTableRotate = useCallback(async (tableId: string, deltaRotation: number) => {
    if (mode !== 'admin') return

    const table = tables.find(t => t.id === tableId)
    if (!table) return

    // Calculate new rotation (keep in 0-359 range)
    const currentRotation = table.rotation || 0
    let newRotation = (currentRotation + deltaRotation) % 360
    if (newRotation < 0) newRotation += 360

    try {
      const response = await fetch(`/api/tables/${tableId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          rotation: newRotation,
        }),
      })

      if (response.ok) {
        setTables(tables.map(t =>
          t.id === tableId ? { ...t, rotation: newRotation } : t
        ))
      }
    } catch (error) {
      console.error('Failed to rotate table:', error)
    }
  }, [mode, tables, setTables])

  // Handle seat move by delta (for arrow keys) - admin mode only
  const handleSeatMoveByDelta = useCallback(async (deltaX: number, deltaY: number) => {
    if (mode !== 'admin' || !selectedSeat) return

    const table = tables.find(t => t.id === selectedSeat.tableId)
    if (!table) return

    const seat = table.seats?.find(s => s.seatNumber === selectedSeat.seatNumber)
    if (!seat) return

    // Calculate new position with constraints (max 150px from table center)
    const maxDistance = 150
    let newX = seat.relativeX + deltaX
    let newY = seat.relativeY + deltaY

    // Constrain to max distance from center
    const distance = Math.sqrt(newX * newX + newY * newY)
    if (distance > maxDistance) {
      const scale = maxDistance / distance
      newX = Math.round(newX * scale)
      newY = Math.round(newY * scale)
    }

    // Update via the existing handler
    await handleSeatDrag(selectedSeat.tableId, seat.id, newX, newY)
  }, [mode, selectedSeat, tables, handleSeatDrag])

  // Keyboard handler for table and seat positioning
  useEffect(() => {
    if (mode !== 'admin') return
    // Must have either a seat or table selected
    if (!selectedSeat && !selectedTableId && !editingTableId) return

    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle if user is typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) return

      const increment = e.shiftKey ? 20 : 5
      let deltaX = 0
      let deltaY = 0

      // Handle Ctrl/Cmd+D for duplicate
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault()
        const tableId = editingTableId || selectedTableId
        if (tableId && !selectedSeat) {
          handleDuplicateTable(tableId)
        }
        return
      }

      // Handle R for rotation (table only, not seats)
      if (e.key === 'r' || e.key === 'R') {
        const tableId = editingTableId || selectedTableId
        if (tableId && !selectedSeat) {
          e.preventDefault()
          const increment = e.shiftKey ? 15 : 90  // Fine (15) or coarse (90)
          const direction = e.altKey ? -1 : 1     // Counter-clockwise if Alt
          handleTableRotate(tableId, increment * direction)
        }
        return
      }

      switch (e.key) {
        case 'ArrowUp':
          deltaY = -increment
          break
        case 'ArrowDown':
          deltaY = increment
          break
        case 'ArrowLeft':
          deltaX = -increment
          break
        case 'ArrowRight':
          deltaX = increment
          break
        case 'Delete':
        case 'Backspace':
          e.preventDefault()
          if (selectedSeat) {
            // Delete selected seat
            const table = tables.find(t => t.id === selectedSeat.tableId)
            const seat = table?.seats?.find(s => s.seatNumber === selectedSeat.seatNumber)
            if (seat) {
              handleSeatDelete(selectedSeat.tableId, seat.id)
            }
          } else {
            // Delete selected table
            const tableId = editingTableId || selectedTableId
            if (tableId) {
              handleTableDelete(tableId)
            }
          }
          return
        case 'Escape':
          if (selectedSeat) {
            clearSelectedSeat()
          } else {
            selectTable(null)
            setEditingTableId(null)
          }
          return
        default:
          return
      }

      e.preventDefault()

      if (selectedSeat) {
        // Move seat
        handleSeatMoveByDelta(deltaX, deltaY)
      } else {
        // Move table
        const tableId = editingTableId || selectedTableId
        if (tableId) {
          handleTableMoveByDelta(tableId, deltaX, deltaY)
        }
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [mode, selectedSeat, selectedTableId, editingTableId, tables, handleSeatMoveByDelta, handleSeatDelete, clearSelectedSeat, handleTableMoveByDelta, handleTableDelete, handleDuplicateTable, handleTableRotate, selectTable])

  const editingTable = editingTableId ? tables.find(t => t.id === editingTableId) || null : null

  // Calculate table counts per section for RoomTabs
  const tableCountBySection = new Map<string, number>()
  tables.forEach(table => {
    const sectionId = table.section?.id || 'none'
    tableCountBySection.set(sectionId, (tableCountBySection.get(sectionId) || 0) + 1)
  })

  // Filter tables based on selected section
  const filteredTables = selectedSectionId
    ? tables.filter(table => table.section?.id === selectedSectionId)
    : tables

  // Check if there are multiple sections to show tabs
  const showRoomTabs = sections.length > 0

  return (
    <div className={`unified-floor-plan ${className}`} style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      {/* Toolbar */}
      {/* Toolbar - can be hidden when parent provides its own */}
      {!hideToolbar && (
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '12px 16px',
            background: 'rgba(15, 23, 42, 0.8)',
            borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
          }}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <span style={{ fontSize: '14px', color: '#94a3b8' }}>
              {mode === 'admin' ? 'Floor Plan Editor' : 'Tables'}
            </span>
            <span style={{ fontSize: '12px', color: '#64748b' }}>
              {filteredTables.length}{selectedSectionId ? ` of ${tables.length}` : ''} tables
            </span>
          </div>

          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            {showSeatsToggle && (
              <button
                onClick={toggleShowSeats}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '6px',
                  padding: '8px 12px',
                  borderRadius: '8px',
                  background: showSeats ? 'rgba(99, 102, 241, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                  border: showSeats ? '1px solid rgba(99, 102, 241, 0.3)' : '1px solid rgba(255, 255, 255, 0.1)',
                  color: showSeats ? '#a5b4fc' : '#94a3b8',
                  fontSize: '13px',
                  cursor: 'pointer',
                }}
              >
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <circle cx="12" cy="12" r="3" strokeWidth={2} />
                  <path strokeWidth={2} d="M12 5v.01M12 19v.01M5 12h.01M19 12h.01M7.05 7.05l.01.01M16.95 16.95l.01.01M7.05 16.95l.01.01M16.95 7.05l.01.01" />
                </svg>
                Seats
              </button>
            )}

            {mode === 'admin' && (
              <button
                onClick={() => onTableCreate?.()}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '6px',
                  padding: '8px 16px',
                  borderRadius: '8px',
                  background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
                  border: 'none',
                  color: '#fff',
                  fontSize: '13px',
                  fontWeight: 500,
                  cursor: 'pointer',
                }}
              >
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
                Add Table
              </button>
            )}
          </div>
        </div>
      )}

      {/* Room/Section Tabs */}
      {showRoomTabs && (
        <RoomTabs
          rooms={sections.map(s => ({ id: s.id, name: s.name, color: s.color }))}
          selectedRoomId={selectedSectionId}
          onRoomSelect={setSelectedSectionId}
          tableCountByRoom={tableCountBySection}
          showAddButton={mode === 'admin'}
          onAddRoom={() => {
            // TODO: Open add section modal
            console.log('Add section clicked')
          }}
        />
      )}

      {/* Canvas */}
      <div
        ref={containerRef}
        className="floor-plan-canvas"
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onClick={() => {
          selectTable(null)
          setEditingTableId(null)
        }}
        style={{ flex: 1, position: 'relative', overflow: 'hidden' }}
      >
        {isLoading ? (
          <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            color: '#64748b'
          }}>
            <motion.div
              animate={{ rotate: 360 }}
              transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
            >
              <svg width="32" height="32" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
            </motion.div>
          </div>
        ) : filteredTables.length === 0 ? (
          <div style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            color: '#64748b'
          }}>
            <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ opacity: 0.5, marginBottom: '16px' }}>
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
            </svg>
            <p style={{ fontSize: '14px' }}>
              {selectedSectionId ? 'No tables in this section' : 'No tables configured'}
            </p>
            {mode === 'admin' && (
              <p style={{ fontSize: '12px', marginTop: '4px', opacity: 0.6 }}>
                Click "Add Table" to get started
              </p>
            )}
          </div>
        ) : (
          <>
            {/* Scale indicator - show when auto-scaled (POS mode only) */}
            {mode === 'pos' && autoScale < 1 && (
              <div
                style={{
                  position: 'absolute',
                  top: '8px',
                  right: '8px',
                  padding: '4px 8px',
                  borderRadius: '6px',
                  background: 'rgba(99, 102, 241, 0.2)',
                  border: '1px solid rgba(99, 102, 241, 0.3)',
                  color: '#a5b4fc',
                  fontSize: '11px',
                  fontWeight: 500,
                  zIndex: 10,
                }}
              >
                {Math.round(autoScale * 100)}% zoom
              </div>
            )}

            {/* Auto-scaled content wrapper */}
            <div
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                transform: mode === 'pos' && autoScale < 1
                  ? `translate(${autoScaleOffset.x}px, ${autoScaleOffset.y}px) scale(${autoScale})`
                  : undefined,
                transformOrigin: 'top left',
                pointerEvents: 'auto',
              }}
            >
            {/* Section labels */}
            {sections.map(section => (
              <div
                key={section.id}
                className="section-label"
                style={{
                  position: 'absolute',
                  left: 10,
                  top: 10,
                  color: section.color,
                  fontSize: '12px',
                  fontWeight: 600,
                  textTransform: 'uppercase',
                  letterSpacing: '0.05em',
                }}
              >
                {section.name}
              </div>
            ))}

            {/* Tables */}
            <AnimatePresence>
              {filteredTables.map(table => {
                const flash = flashingTables.get(table.id)
                const flashMessage = flash && flash.expiresAt > Date.now() ? flash.message : null

                return (
                  <TableNode
                    key={table.id}
                    table={table}
                    isSelected={selectedTableId === table.id || editingTableId === table.id}
                    isDragging={draggedTableId === table.id}
                    isDropTarget={dropTargetTableId === table.id}
                    combinedGroupColor={combinedGroupColors.get(table.id)}
                    showSeats={showSeats}
                    selectedSeat={selectedSeat}
                    flashMessage={flashMessage}
                    combinedSeatOffset={combinedSeatOffsets.get(table.id) || 0}
                    combinedTotalSeats={combinedTotalSeats.get(table.id)}
                    onTap={() => handleTableTap(table)}
                    onDragStart={() => startDrag(table.id)}
                    onDragEnd={endDrag}
                    onLongPress={() => {
                      if (mode === 'pos' && table.combinedTableIds && table.combinedTableIds.length > 0) {
                        openInfoPanel(table.id)
                      }
                    }}
                    onSeatTap={(seatNumber) => selectSeat(table.id, seatNumber)}
                    isEditable={mode === 'admin'}
                    onSeatDrag={(seatId, newX, newY) => handleSeatDrag(table.id, seatId, newX, newY)}
                    onSeatDelete={(seatId) => handleSeatDelete(table.id, seatId)}
                  />
                )
              })}
            </AnimatePresence>
            </div>
            {/* End of auto-scaled content wrapper */}
          </>
        )}
      </div>

      {/* Admin Edit Panel */}
      {mode === 'admin' && (
        <TableEditPanel
          table={editingTable}
          sections={sections}
          isOpen={!!editingTableId}
          onClose={() => setEditingTableId(null)}
          onUpdate={handleTableUpdate}
          onDelete={handleTableDelete}
          onRegenerateSeats={handleRegenerateSeats}
          onAddSeat={handleAddSeat}
          onDuplicate={handleDuplicateTable}
          onRotate={handleTableRotate}
        />
      )}

      {/* POS Info Panel (for combined table management) */}
      {mode === 'pos' && infoPanelTableId && (
        <TableInfoPanel
          table={tables.find(t => t.id === infoPanelTableId) || null}
          isOpen={true}
          onClose={closeInfoPanel}
          onAddItems={() => {
            const table = tables.find(t => t.id === infoPanelTableId)
            if (table) onTableSelect?.(table)
            closeInfoPanel()
          }}
          onViewCheck={() => {
            const table = tables.find(t => t.id === infoPanelTableId)
            if (table) onTableSelect?.(table)
            closeInfoPanel()
          }}
          onMarkDirty={() => {
            if (infoPanelTableId) handleUpdateStatus(infoPanelTableId, 'dirty')
          }}
          onMarkAvailable={() => {
            if (infoPanelTableId) handleUpdateStatus(infoPanelTableId, 'available')
          }}
          onResetToDefault={
            tables.find(t => t.id === infoPanelTableId)?.combinedTableIds?.length
              ? () => handleResetToDefault([infoPanelTableId])
              : undefined
          }
        />
      )}
    </div>
  )
}



################################################################################
# FILE: src/components/floor-plan/use-floor-plan.ts
################################################################################

import { create } from 'zustand'

// Table status types
export type TableStatus = 'available' | 'occupied' | 'reserved' | 'dirty' | 'in_use'

// Table data from API
// Seat patterns for partial coverage
export type SeatPattern =
  | 'all_around'    // Default - seats on all sides
  | 'front_only'    // Bar/counter style - seats on one side
  | 'three_sides'   // Against wall - no seats on one side
  | 'two_sides'     // Corner booth - seats on two adjacent sides
  | 'inside'        // Booth interior - seats inside the table

export interface FloorPlanTable {
  id: string
  name: string
  abbreviation: string | null  // Short display name for floor plan: "T1", "B3"
  capacity: number
  posX: number
  posY: number
  width: number
  height: number
  rotation: number
  shape: 'rectangle' | 'circle' | 'square' | 'booth' | 'bar'
  seatPattern: SeatPattern  // How seats are distributed around the table
  status: TableStatus
  section: { id: string; name: string; color: string } | null
  combinedWithId: string | null
  combinedTableIds: string[] | null
  originalName: string | null
  originalPosX: number | null
  originalPosY: number | null
  isLocked: boolean  // Locked items cannot be moved (bolted down furniture)
  // Virtual combine fields
  virtualGroupId: string | null
  virtualGroupPrimary: boolean
  virtualGroupColor: string | null
  virtualGroupOffsetX: number | null  // Visual offset for snapped position in virtual group
  virtualGroupOffsetY: number | null  // Visual offset for snapped position in virtual group
  sectionId: string | null  // Section ID for filtering by room
  currentOrder: {
    id: string
    orderNumber: number
    guestCount: number
    total: number
    openedAt: string
    server: string
    items?: Array<{
      id: string
      name: string
      quantity: number
      price: number
    }>
  } | null
  seats: FloorPlanSeat[]
}

export interface FloorPlanSeat {
  id: string
  label: string
  seatNumber: number
  relativeX: number
  relativeY: number
  angle: number
  seatType: string
}

export interface FloorPlanSection {
  id: string
  name: string
  color: string
  posX: number
  posY: number
  width: number
  height: number
}

// Floor plan element types (entertainment, decorations, etc.)
export type ElementStatus = 'available' | 'in_use' | 'reserved' | 'maintenance'

export interface FloorPlanElement {
  id: string
  name: string
  abbreviation: string | null
  elementType: string // 'entertainment' | 'decoration' | etc.
  visualType: string // 'pool_table' | 'dartboard' | etc.
  linkedMenuItemId: string | null
  linkedMenuItem: {
    id: string
    name: string
    price: number
    itemType: string
    entertainmentStatus: string | null
    blockTimeMinutes: number | null
  } | null
  sectionId: string | null
  section: { id: string; name: string; color: string } | null
  posX: number
  posY: number
  width: number
  height: number
  rotation: number
  fillColor: string | null
  strokeColor: string | null
  opacity: number
  status: ElementStatus
  currentOrderId: string | null
  sessionStartedAt: string | null
  sessionExpiresAt: string | null
  isLocked: boolean
  isVisible: boolean
  waitlistCount: number
}

// Undo action for combines
interface UndoAction {
  type: 'combine'
  sourceTableId: string
  targetTableId: string
  timestamp: number
}

interface FloorPlanState {
  // Data
  tables: FloorPlanTable[]
  sections: FloorPlanSection[]
  elements: FloorPlanElement[]

  // View state
  viewportX: number
  viewportY: number
  zoom: number

  // Selection state
  selectedTableId: string | null
  selectedElementId: string | null
  draggedTableId: string | null
  dropTargetTableId: string | null

  // Info panel
  infoPanelTableId: string | null

  // Combine indicator
  showCombineIndicator: boolean
  combinePosition: { x: number; y: number } | null

  // Seat visualization
  showSeats: boolean
  selectedSeat: { tableId: string; seatNumber: number } | null

  // Flash messages for tables (e.g., "OPEN ORDER" on reset skip)
  flashingTables: Map<string, { message: string; expiresAt: number }>

  // Undo stack (30-second window)
  undoStack: UndoAction[]

  // Virtual combine mode
  virtualCombineMode: boolean
  virtualCombineSelectedIds: Set<string>
  virtualCombinePrimaryId: string | null

  // Loading state
  isLoading: boolean
  error: string | null

  // Actions
  setTables: (tables: FloorPlanTable[]) => void
  setSections: (sections: FloorPlanSection[]) => void
  setElements: (elements: FloorPlanElement[]) => void

  // View actions
  setViewport: (x: number, y: number) => void
  setZoom: (zoom: number) => void
  pan: (deltaX: number, deltaY: number) => void
  zoomIn: () => void
  zoomOut: () => void
  resetView: () => void

  // Selection actions
  selectTable: (tableId: string | null) => void
  selectElement: (elementId: string | null) => void
  openInfoPanel: (tableId: string) => void
  closeInfoPanel: () => void

  // Drag & drop actions
  startDrag: (tableId: string) => void
  updateDragTarget: (targetTableId: string | null, position?: { x: number; y: number }) => void
  endDrag: () => void

  // Combine/Split actions
  addUndoAction: (action: UndoAction) => void
  popUndoAction: () => UndoAction | null
  clearExpiredUndos: () => void

  // Seat visualization actions
  toggleShowSeats: () => void
  setShowSeats: (show: boolean) => void
  selectSeat: (tableId: string, seatNumber: number) => void
  clearSelectedSeat: () => void

  // Flash message actions
  flashTableMessage: (tableId: string, message: string, durationMs?: number) => void
  clearExpiredFlashes: () => void

  // Data actions
  updateTableStatus: (tableId: string, status: TableStatus) => void
  updateTablePosition: (tableId: string, posX: number, posY: number) => void
  batchUpdatePositions: (updates: Array<{ id: string; posX: number; posY: number; width?: number; height?: number }>) => void
  refreshTable: (tableId: string, tableData: Partial<FloorPlanTable>) => void

  // Loading
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void

  // Virtual combine actions
  startVirtualCombineMode: (tableId: string) => void
  toggleVirtualCombineSelection: (tableId: string) => void
  cancelVirtualCombineMode: () => void
  setVirtualCombinePrimary: (tableId: string) => void
  clearVirtualCombineMode: () => void
  updateTablesWithVirtualGroup: (updates: Array<{ id: string; virtualGroupId: string | null; virtualGroupPrimary: boolean; virtualGroupColor: string | null }>) => void

  // Seat management actions
  removeSeatAt: (tableId: string, index: number) => void
  addSeatToTable: (tableId: string, seat: FloorPlanSeat) => void
  updateSeatPosition: (tableId: string, seatIndex: number, relativeX: number, relativeY: number) => void

  // Room/Section management actions
  addSection: (section: FloorPlanSection) => void
  updateSection: (sectionId: string, updates: Partial<FloorPlanSection>) => void
  deleteSection: (sectionId: string) => void
  reorderSections: (sections: FloorPlanSection[]) => void

  // Element management actions
  addElement: (element: FloorPlanElement) => void
  updateElement: (elementId: string, updates: Partial<FloorPlanElement>) => void
  updateElementPosition: (elementId: string, posX: number, posY: number) => void
  updateElementSize: (elementId: string, width: number, height: number) => void
  deleteElement: (elementId: string) => void
}

const UNDO_WINDOW_MS = 300000 // 5 minutes

export const useFloorPlanStore = create<FloorPlanState>((set, get) => ({
  // Initial data
  tables: [],
  sections: [],
  elements: [],

  // Initial view state
  viewportX: 0,
  viewportY: 0,
  zoom: 1,

  // Initial selection state
  selectedTableId: null,
  selectedElementId: null,
  draggedTableId: null,
  dropTargetTableId: null,

  // Info panel
  infoPanelTableId: null,

  // Combine indicator
  showCombineIndicator: false,
  combinePosition: null,

  // Seat visualization
  showSeats: false,
  selectedSeat: null,

  // Flash messages
  flashingTables: new Map(),

  // Undo stack
  undoStack: [],

  // Virtual combine mode
  virtualCombineMode: false,
  virtualCombineSelectedIds: new Set(),
  virtualCombinePrimaryId: null,

  // Loading state
  isLoading: false,
  error: null,

  // Data setters
  setTables: (tables) => set({ tables }),
  setSections: (sections) => set({ sections }),
  setElements: (elements) => set({ elements }),

  // View actions
  setViewport: (x, y) => set({ viewportX: x, viewportY: y }),
  setZoom: (zoom) => set({ zoom: Math.max(0.25, Math.min(2, zoom)) }),

  pan: (deltaX, deltaY) => {
    const { viewportX, viewportY } = get()
    set({
      viewportX: viewportX + deltaX,
      viewportY: viewportY + deltaY,
    })
  },

  zoomIn: () => {
    const { zoom } = get()
    set({ zoom: Math.min(2, zoom + 0.1) })
  },

  zoomOut: () => {
    const { zoom } = get()
    set({ zoom: Math.max(0.25, zoom - 0.1) })
  },

  resetView: () => set({ viewportX: 0, viewportY: 0, zoom: 1 }),

  // Selection actions
  selectTable: (tableId) => set({ selectedTableId: tableId, selectedElementId: null }),
  selectElement: (elementId) => set({ selectedElementId: elementId, selectedTableId: null }),
  openInfoPanel: (tableId) => set({ infoPanelTableId: tableId, selectedTableId: tableId }),
  closeInfoPanel: () => set({ infoPanelTableId: null }),

  // Drag & drop actions
  startDrag: (tableId) => {
    console.log('[STORE] startDrag called:', tableId)
    set({
      draggedTableId: tableId,
      selectedTableId: tableId,
    })
  },

  updateDragTarget: (targetTableId, position) => {
    const { draggedTableId } = get()
    // Can't drop on self
    if (targetTableId === draggedTableId) {
      set({
        dropTargetTableId: null,
        showCombineIndicator: false,
        combinePosition: null,
      })
      return
    }

    set({
      dropTargetTableId: targetTableId,
      showCombineIndicator: targetTableId !== null,
      combinePosition: position || null,
    })
  },

  endDrag: () => set({
    draggedTableId: null,
    dropTargetTableId: null,
    showCombineIndicator: false,
    combinePosition: null,
  }),

  // Undo actions
  addUndoAction: (action) => {
    const { undoStack } = get()
    set({ undoStack: [...undoStack, action] })
  },

  popUndoAction: () => {
    const { undoStack } = get()
    if (undoStack.length === 0) return null

    const now = Date.now()
    // Find the most recent valid undo (within 30 seconds)
    const validUndos = undoStack.filter(u => now - u.timestamp < UNDO_WINDOW_MS)

    if (validUndos.length === 0) {
      set({ undoStack: [] })
      return null
    }

    const lastUndo = validUndos[validUndos.length - 1]
    set({ undoStack: validUndos.slice(0, -1) })
    return lastUndo
  },

  clearExpiredUndos: () => {
    const { undoStack } = get()
    const now = Date.now()
    const validUndos = undoStack.filter(u => now - u.timestamp < UNDO_WINDOW_MS)
    if (validUndos.length !== undoStack.length) {
      set({ undoStack: validUndos })
    }
  },

  // Seat visualization actions
  toggleShowSeats: () => {
    const { showSeats } = get()
    set({ showSeats: !showSeats })
  },

  setShowSeats: (show) => set({ showSeats: show }),

  selectSeat: (tableId, seatNumber) => {
    set({ selectedSeat: { tableId, seatNumber } })
  },

  clearSelectedSeat: () => set({ selectedSeat: null }),

  // Flash message actions
  flashTableMessage: (tableId, message, durationMs = 2000) => {
    const { flashingTables } = get()
    const newFlashes = new Map(flashingTables)
    newFlashes.set(tableId, {
      message,
      expiresAt: Date.now() + durationMs,
    })
    set({ flashingTables: newFlashes })
  },

  clearExpiredFlashes: () => {
    const { flashingTables } = get()
    const now = Date.now()
    let hasExpired = false
    for (const [, flash] of flashingTables) {
      if (flash.expiresAt <= now) {
        hasExpired = true
        break
      }
    }
    if (hasExpired) {
      const newFlashes = new Map<string, { message: string; expiresAt: number }>()
      for (const [id, flash] of flashingTables) {
        if (flash.expiresAt > now) {
          newFlashes.set(id, flash)
        }
      }
      set({ flashingTables: newFlashes })
    }
  },

  // Data updates
  updateTableStatus: (tableId, status) => {
    const { tables } = get()
    set({
      tables: tables.map(t =>
        t.id === tableId ? { ...t, status } : t
      ),
    })
  },

  updateTablePosition: (tableId, posX, posY) => {
    const { tables } = get()
    set({
      tables: tables.map(t =>
        t.id === tableId ? { ...t, posX, posY } : t
      ),
    })
  },

  // Batch position update (for drag-and-drop saves)
  batchUpdatePositions: (updates: Array<{ id: string; posX: number; posY: number; width?: number; height?: number }>) => {
    const { tables } = get()
    const updateMap = new Map(updates.map(u => [u.id, u]))
    set({
      tables: tables.map(t => {
        const update = updateMap.get(t.id)
        if (!update) return t
        return {
          ...t,
          posX: update.posX,
          posY: update.posY,
          ...(update.width !== undefined && { width: update.width }),
          ...(update.height !== undefined && { height: update.height }),
        }
      }),
    })
  },

  refreshTable: (tableId, tableData) => {
    const { tables } = get()
    set({
      tables: tables.map(t =>
        t.id === tableId ? { ...t, ...tableData } : t
      ),
    })
  },

  // Loading
  setLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),

  // Virtual combine actions
  startVirtualCombineMode: (tableId) => {
    console.log('[VirtualCombine Store] startVirtualCombineMode called with tableId:', tableId)
    set({
      virtualCombineMode: true,
      virtualCombineSelectedIds: new Set([tableId]),
      virtualCombinePrimaryId: tableId,
      selectedTableId: tableId,
      // Close any open info panel
      infoPanelTableId: null,
    })
    console.log('[VirtualCombine Store] Virtual combine mode started, primary table:', tableId)
  },

  toggleVirtualCombineSelection: (tableId) => {
    const { virtualCombineSelectedIds, virtualCombinePrimaryId } = get()
    console.log('[VirtualCombine Store] toggleVirtualCombineSelection called:', { tableId, currentSelectedIds: Array.from(virtualCombineSelectedIds), primaryId: virtualCombinePrimaryId })

    const newSet = new Set(virtualCombineSelectedIds)

    if (newSet.has(tableId)) {
      // Don't allow removing the primary table
      if (tableId === virtualCombinePrimaryId) {
        console.log('[VirtualCombine Store] Cannot remove primary table')
        return
      }
      newSet.delete(tableId)
      console.log('[VirtualCombine Store] Removed table from selection')
    } else {
      newSet.add(tableId)
      console.log('[VirtualCombine Store] Added table to selection')
    }

    console.log('[VirtualCombine Store] New selected IDs:', Array.from(newSet))
    set({ virtualCombineSelectedIds: newSet })
  },

  cancelVirtualCombineMode: () => {
    set({
      virtualCombineMode: false,
      virtualCombineSelectedIds: new Set(),
      virtualCombinePrimaryId: null,
    })
  },

  setVirtualCombinePrimary: (tableId) => {
    const { virtualCombineSelectedIds } = get()
    // Can only set primary if table is selected
    if (!virtualCombineSelectedIds.has(tableId)) return
    set({ virtualCombinePrimaryId: tableId })
  },

  clearVirtualCombineMode: () => {
    set({
      virtualCombineMode: false,
      virtualCombineSelectedIds: new Set(),
      virtualCombinePrimaryId: null,
    })
  },

  updateTablesWithVirtualGroup: (updates) => {
    const { tables } = get()
    const updateMap = new Map(updates.map(u => [u.id, u]))

    set({
      tables: tables.map(t => {
        const update = updateMap.get(t.id)
        if (update) {
          return {
            ...t,
            virtualGroupId: update.virtualGroupId,
            virtualGroupPrimary: update.virtualGroupPrimary,
            virtualGroupColor: update.virtualGroupColor,
          }
        }
        return t
      }),
    })
  },

  // Seat management actions
  removeSeatAt: (tableId, index) => {
    const { tables } = get()
    set({
      tables: tables.map((t) => {
        if (t.id !== tableId) return t

        // 1. Remove the seat from the array
        const remaining = [...(t.seats || [])]
        remaining.splice(index, 1)

        // 2. Re-index remaining seats to be consecutive 1, 2, 3...
        const reindexed = remaining.map((s, i) => ({
          ...s,
          seatNumber: i + 1,
          // Reset custom positions so seats auto-redistribute
          relativeX: 0,
          relativeY: 0,
        }))

        return {
          ...t,
          seats: reindexed,
          capacity: reindexed.length,
        }
      }),
    })
  },

  addSeatToTable: (tableId, seat) => {
    const { tables } = get()
    set({
      tables: tables.map((t) => {
        if (t.id !== tableId) return t
        const newSeats = [...(t.seats || []), seat]
        return {
          ...t,
          seats: newSeats,
          capacity: newSeats.length,
        }
      }),
    })
  },

  updateSeatPosition: (tableId, seatIndex, relativeX, relativeY) => {
    const { tables } = get()
    set({
      tables: tables.map((t) => {
        if (t.id !== tableId) return t
        const updatedSeats = (t.seats || []).map((s, i) =>
          i === seatIndex ? { ...s, relativeX, relativeY } : s
        )
        return {
          ...t,
          seats: updatedSeats,
        }
      }),
    })
  },

  // Room/Section management actions
  addSection: (section) => {
    const { sections } = get()
    set({ sections: [...sections, section] })
  },

  updateSection: (sectionId, updates) => {
    const { sections, tables } = get()
    set({
      sections: sections.map((s) =>
        s.id === sectionId ? { ...s, ...updates } : s
      ),
      // Also update any tables that reference this section
      tables: tables.map((t) =>
        t.section?.id === sectionId
          ? { ...t, section: { ...t.section, ...updates } }
          : t
      ),
    })
  },

  deleteSection: (sectionId) => {
    const { sections, tables } = get()
    set({
      sections: sections.filter((s) => s.id !== sectionId),
      // Clear section reference from tables in this section
      tables: tables.map((t) =>
        t.section?.id === sectionId ? { ...t, section: null } : t
      ),
    })
  },

  reorderSections: (reorderedSections) => {
    set({ sections: reorderedSections })
  },

  // Element management actions
  addElement: (element) => {
    const { elements } = get()
    set({ elements: [...elements, element] })
  },

  updateElement: (elementId, updates) => {
    const { elements } = get()
    set({
      elements: elements.map((el) =>
        el.id === elementId ? { ...el, ...updates } : el
      ),
    })
  },

  updateElementPosition: (elementId, posX, posY) => {
    const { elements } = get()
    set({
      elements: elements.map((el) =>
        el.id === elementId ? { ...el, posX, posY } : el
      ),
    })
  },

  updateElementSize: (elementId, width, height) => {
    const { elements } = get()
    set({
      elements: elements.map((el) =>
        el.id === elementId ? { ...el, width, height } : el
      ),
    })
  },

  deleteElement: (elementId) => {
    const { elements, selectedElementId } = get()
    set({
      elements: elements.filter((el) => el.id !== elementId),
      selectedElementId: selectedElementId === elementId ? null : selectedElementId,
    })
  },
}))



################################################################################
# FILE: src/components/floor-plan/VirtualCombineBar.tsx
################################################################################

'use client'

import { motion, AnimatePresence } from 'framer-motion'
import { XMarkIcon, LinkIcon } from '@heroicons/react/24/outline'
import { useFloorPlanStore, type FloorPlanTable } from './use-floor-plan'

interface VirtualCombineBarProps {
  tables: FloorPlanTable[]
  onConfirm: () => void
  onCancel: () => void
  isConfirming?: boolean
}

export function VirtualCombineBar({
  tables,
  onConfirm,
  onCancel,
  isConfirming = false,
}: VirtualCombineBarProps) {
  const {
    virtualCombineMode,
    virtualCombineSelectedIds,
    virtualCombinePrimaryId,
    setVirtualCombinePrimary,
  } = useFloorPlanStore()

  if (!virtualCombineMode) return null

  const selectedTables = tables.filter(t => virtualCombineSelectedIds.has(t.id))
  const primaryTable = tables.find(t => t.id === virtualCombinePrimaryId)
  const canConfirm = virtualCombineSelectedIds.size >= 2 && !isConfirming

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 50 }}
        transition={{ type: 'spring', damping: 25, stiffness: 300 }}
        className="fixed bottom-6 left-1/2 -translate-x-1/2 z-50"
      >
        <div className="flex flex-col items-center gap-3">
          {/* Selected tables display */}
          <div className="flex items-center gap-2 px-4 py-2 bg-slate-800/90 backdrop-blur-sm rounded-lg border border-slate-600/50">
            <LinkIcon className="w-4 h-4 text-cyan-400" />
            <span className="text-sm text-slate-300">
              {selectedTables.map((t, i) => (
                <span key={t.id}>
                  <button
                    onClick={() => setVirtualCombinePrimary(t.id)}
                    className={`px-1.5 py-0.5 rounded text-xs font-medium transition-colors ${
                      t.id === virtualCombinePrimaryId
                        ? 'bg-cyan-500 text-white'
                        : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                    }`}
                    title={t.id === virtualCombinePrimaryId ? 'Primary table' : 'Click to make primary'}
                  >
                    {t.abbreviation || t.name}
                    {t.id === virtualCombinePrimaryId && ' (Primary)'}
                  </button>
                  {i < selectedTables.length - 1 && <span className="mx-1 text-slate-500">+</span>}
                </span>
              ))}
            </span>
          </div>

          {/* Main action bar */}
          <div className="flex items-center gap-4 px-6 py-3 bg-slate-900/95 backdrop-blur-md rounded-full shadow-xl border border-slate-700/50">
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-cyan-400 animate-pulse" />
              <span className="text-white font-medium">
                {virtualCombineSelectedIds.size} table{virtualCombineSelectedIds.size !== 1 ? 's' : ''} selected
              </span>
            </div>

            <div className="w-px h-6 bg-slate-600" />

            <span className="text-sm text-slate-400">
              Tap tables to add/remove
            </span>

            <div className="w-px h-6 bg-slate-600" />

            <button
              onClick={onCancel}
              className="flex items-center gap-1.5 px-3 py-1.5 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors"
            >
              <XMarkIcon className="w-4 h-4" />
              Cancel
            </button>

            <button
              onClick={onConfirm}
              disabled={!canConfirm}
              className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all ${
                canConfirm
                  ? 'bg-cyan-500 text-white hover:bg-cyan-400 shadow-lg shadow-cyan-500/25'
                  : 'bg-slate-700 text-slate-400 cursor-not-allowed'
              }`}
            >
              <LinkIcon className="w-4 h-4" />
              {isConfirming ? 'Creating...' : 'Create Virtual Group'}
            </button>
          </div>

          {/* Help text */}
          {virtualCombineSelectedIds.size < 2 && (
            <motion.p
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="text-sm text-slate-400"
            >
              Select at least 2 tables to create a virtual group
            </motion.p>
          )}
        </div>
      </motion.div>
    </AnimatePresence>
  )
}



################################################################################
# FILE: src/components/floor-plan/VirtualGroupManagerModal.tsx
################################################################################

'use client'

import { useState, useEffect, useCallback } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { toast } from '@/stores/toast-store'
import type { FloorPlanTable } from './use-floor-plan'

interface VirtualGroupManagerModalProps {
  isOpen: boolean
  onClose: () => void
  groupTables: FloorPlanTable[]
  primaryTableId: string
  virtualGroupId: string
  locationId: string
  employeeId: string
  onGroupUpdated: () => void // Callback to refresh floor plan data
}

interface TableOrderStatus {
  tableId: string
  hasUnpaidItems: boolean
  itemCount: number
}

export function VirtualGroupManagerModal({
  isOpen,
  onClose,
  groupTables,
  primaryTableId,
  virtualGroupId,
  locationId,
  employeeId,
  onGroupUpdated,
}: VirtualGroupManagerModalProps) {
  const [isLoading, setIsLoading] = useState(false)
  const [removingTableId, setRemovingTableId] = useState<string | null>(null)
  const [orderStatuses, setOrderStatuses] = useState<Map<string, TableOrderStatus>>(new Map())
  const [loadingStatuses, setLoadingStatuses] = useState(true)

  // Fetch order status for each table
  useEffect(() => {
    if (!isOpen || groupTables.length === 0) return

    const fetchStatuses = async () => {
      setLoadingStatuses(true)
      const statuses = new Map<string, TableOrderStatus>()

      for (const table of groupTables) {
        // Check if table has an open order with items (items on open order = unpaid)
        const itemCount = table.currentOrder?.items?.length ?? 0
        const hasUnpaid = itemCount > 0

        statuses.set(table.id, {
          tableId: table.id,
          hasUnpaidItems: hasUnpaid,
          itemCount,
        })
      }

      setOrderStatuses(statuses)
      setLoadingStatuses(false)
    }

    fetchStatuses()
  }, [isOpen, groupTables])

  const handleRemoveTable = useCallback(async (tableId: string, tableName: string) => {
    const status = orderStatuses.get(tableId)
    if (status?.hasUnpaidItems) {
      toast.warning(`Cannot remove ${tableName} - has unpaid items`)
      return
    }

    setRemovingTableId(tableId)

    try {
      const response = await fetch(`/api/tables/virtual-combine/${virtualGroupId}/remove`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tableId,
          locationId,
          employeeId,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        if (data.error === 'table_has_open_order') {
          toast.warning(data.message || `Cannot remove ${tableName} with open order`)
        } else {
          toast.error(data.error || 'Failed to remove table')
        }
        return
      }

      toast.success(`${tableName} removed from group`)
      onGroupUpdated()

      // If group was dissolved, close the modal
      if (data.data?.dissolved) {
        onClose()
      }
    } catch (error) {
      console.error('Failed to remove table:', error)
      toast.error('Network error - please try again')
    } finally {
      setRemovingTableId(null)
    }
  }, [virtualGroupId, locationId, employeeId, orderStatuses, onGroupUpdated, onClose])

  const handleDissolveGroup = useCallback(async () => {
    // Check if any table has unpaid items
    const tablesWithUnpaid = groupTables.filter(table => {
      const status = orderStatuses.get(table.id)
      return status?.hasUnpaidItems
    })

    if (tablesWithUnpaid.length > 0) {
      toast.warning(
        `Cannot dissolve - ${tablesWithUnpaid.length} table(s) have unpaid items`
      )
      return
    }

    setIsLoading(true)

    try {
      const response = await fetch(`/api/tables/virtual-combine/${virtualGroupId}/dissolve`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          employeeId,
          splitOrder: true, // Split items back to their source tables
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        if (data.error === 'tables_have_open_orders') {
          toast.warning(data.message || 'Cannot dissolve - tables have unpaid items')
        } else {
          toast.error(data.error || 'Failed to dissolve group')
        }
        return
      }

      toast.success('Virtual group dissolved')
      onGroupUpdated()
      onClose()
    } catch (error) {
      console.error('Failed to dissolve group:', error)
      toast.error('Network error - please try again')
    } finally {
      setIsLoading(false)
    }
  }, [virtualGroupId, locationId, employeeId, groupTables, orderStatuses, onGroupUpdated, onClose])

  const primaryTable = groupTables.find(t => t.id === primaryTableId)
  const groupColor = primaryTable?.virtualGroupColor || '#6366f1'

  // Check if dissolve is allowed
  const canDissolve = !loadingStatuses && !Array.from(orderStatuses.values()).some(s => s.hasUnpaidItems)

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50"
            onClick={onClose}
          />

          {/* Modal */}
          <motion.div
            initial={{ opacity: 0, scale: 0.95, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: 20 }}
            transition={{ type: 'spring', damping: 25, stiffness: 300 }}
            className="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-50 w-[90vw] max-w-md"
          >
            <div className="bg-slate-900/95 backdrop-blur-xl rounded-2xl border border-white/10 shadow-2xl overflow-hidden">
              {/* Header */}
              <div
                className="px-6 py-4 border-b border-white/10"
                style={{ backgroundColor: `${groupColor}20` }}
              >
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <div
                      className="w-4 h-4 rounded-full"
                      style={{ backgroundColor: groupColor }}
                    />
                    <h2 className="text-lg font-semibold text-white">
                      Virtual Group
                    </h2>
                  </div>
                  <button
                    onClick={onClose}
                    className="p-2 rounded-lg hover:bg-white/10 transition-colors"
                    disabled={isLoading || removingTableId !== null}
                  >
                    <svg className="w-5 h-5 text-white/60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>
                <p className="text-sm text-white/60 mt-1">
                  {groupTables.length} tables linked together
                </p>
              </div>

              {/* Table List */}
              <div className="p-4 space-y-2 max-h-[50vh] overflow-y-auto">
                {loadingStatuses ? (
                  <div className="flex items-center justify-center py-8">
                    <div className="w-6 h-6 border-2 border-white/20 border-t-white/60 rounded-full animate-spin" />
                  </div>
                ) : (
                  groupTables.map(table => {
                    const isPrimary = table.id === primaryTableId
                    const status = orderStatuses.get(table.id)
                    const canRemove = !status?.hasUnpaidItems && groupTables.length > 2
                    const isRemoving = removingTableId === table.id

                    return (
                      <div
                        key={table.id}
                        className={`
                          flex items-center justify-between p-3 rounded-xl
                          ${isPrimary ? 'bg-white/10 border border-white/20' : 'bg-white/5'}
                        `}
                      >
                        <div className="flex items-center gap-3">
                          <div
                            className="w-10 h-10 rounded-lg flex items-center justify-center text-white font-semibold"
                            style={{
                              backgroundColor: isPrimary ? groupColor : `${groupColor}60`,
                            }}
                          >
                            {table.abbreviation || table.name.slice(0, 2)}
                          </div>
                          <div>
                            <div className="flex items-center gap-2">
                              <span className="text-white font-medium">{table.name}</span>
                              {isPrimary && (
                                <span className="px-2 py-0.5 rounded-full bg-amber-500/20 text-amber-400 text-xs font-medium">
                                  Primary
                                </span>
                              )}
                            </div>
                            <div className="flex items-center gap-2 text-xs text-white/50">
                              <span className={`capitalize ${
                                table.status === 'available' ? 'text-emerald-400' :
                                table.status === 'occupied' ? 'text-amber-400' :
                                'text-white/50'
                              }`}>
                                {table.status}
                              </span>
                              {status?.itemCount ? (
                                <>
                                  <span></span>
                                  <span>{status.itemCount} item{status.itemCount !== 1 ? 's' : ''}</span>
                                  {status.hasUnpaidItems && (
                                    <span className="text-amber-400">(unpaid)</span>
                                  )}
                                </>
                              ) : null}
                            </div>
                          </div>
                        </div>

                        {/* Remove Button */}
                        {groupTables.length > 2 && (
                          <button
                            onClick={() => handleRemoveTable(table.id, table.name)}
                            disabled={!canRemove || isRemoving || isLoading}
                            className={`
                              px-3 py-1.5 rounded-lg text-sm font-medium transition-all
                              ${canRemove
                                ? 'bg-red-500/20 text-red-400 hover:bg-red-500/30'
                                : 'bg-white/5 text-white/30 cursor-not-allowed'
                              }
                            `}
                            title={!canRemove ? 'Cannot remove - has unpaid items' : 'Remove from group'}
                          >
                            {isRemoving ? (
                              <div className="w-4 h-4 border-2 border-red-400/30 border-t-red-400 rounded-full animate-spin" />
                            ) : (
                              'Remove'
                            )}
                          </button>
                        )}
                      </div>
                    )
                  })
                )}
              </div>

              {/* Actions */}
              <div className="px-4 py-4 border-t border-white/10 space-y-3">
                {/* Dissolve Group Button */}
                <button
                  onClick={handleDissolveGroup}
                  disabled={!canDissolve || isLoading}
                  className={`
                    w-full py-3 rounded-xl font-medium transition-all
                    ${canDissolve
                      ? 'bg-red-500/20 text-red-400 hover:bg-red-500/30 border border-red-500/30'
                      : 'bg-white/5 text-white/30 cursor-not-allowed border border-white/10'
                    }
                  `}
                >
                  {isLoading ? (
                    <div className="flex items-center justify-center gap-2">
                      <div className="w-4 h-4 border-2 border-red-400/30 border-t-red-400 rounded-full animate-spin" />
                      <span>Dissolving...</span>
                    </div>
                  ) : (
                    'Dissolve Group'
                  )}
                </button>

                {!canDissolve && !loadingStatuses && (
                  <p className="text-xs text-amber-400/80 text-center">
                    Pay all items before dissolving the group
                  </p>
                )}

                {/* Close Button */}
                <button
                  onClick={onClose}
                  disabled={isLoading || removingTableId !== null}
                  className="w-full py-3 rounded-xl bg-white/10 text-white font-medium hover:bg-white/20 transition-colors"
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  )
}


================================================================================
SECTION 3: API ROUTES - TABLES
================================================================================

################################################################################
# FILE: src/app/api/tables/[id]/remove-from-group/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { Prisma } from '@prisma/client'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * POST /api/tables/[id]/remove-from-group
 *
 * Remove a single table from a combined group (undo last combine).
 * This is different from split which breaks apart ALL tables.
 *
 * - Removes the specified table from its combined group
 * - Restores the table's original position and name
 * - Restores the table's seats to original positions
 * - Updates the primary table's combinedTableIds
 * - Recalculates seat labels for remaining combined tables
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableIdToRemove } = await params
    const body = await request.json()
    const { locationId, employeeId } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Fetch the table to remove
    const tableToRemove = await db.table.findFirst({
      where: { id: tableIdToRemove, locationId, deletedAt: null },
    })

    if (!tableToRemove) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // Check if this table is part of a combined group
    const primaryTableId = tableToRemove.combinedWithId

    if (!primaryTableId) {
      // This table might BE the primary - check if it has combined tables
      const combinedIds = (tableToRemove.combinedTableIds as string[]) || []
      if (combinedIds.length === 0) {
        return NextResponse.json(
          { error: 'This table is not part of a combined group' },
          { status: 400 }
        )
      }

      // This is the primary table - remove the LAST combined table instead
      const lastCombinedId = combinedIds[combinedIds.length - 1]

      // Recursively call this endpoint for the last combined table
      const recursiveRes = await fetch(
        `${request.nextUrl.origin}/api/tables/${lastCombinedId}/remove-from-group`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locationId, employeeId }),
        }
      )

      const recursiveData = await recursiveRes.json()
      return NextResponse.json(recursiveData, { status: recursiveRes.status })
    }

    // Fetch the primary table
    const primaryTable = await db.table.findFirst({
      where: { id: primaryTableId, locationId, deletedAt: null },
    })

    if (!primaryTable) {
      return NextResponse.json(
        { error: 'Primary table not found' },
        { status: 404 }
      )
    }

    const combinedTableIds = (primaryTable.combinedTableIds as string[]) || []

    if (!combinedTableIds.includes(tableIdToRemove)) {
      return NextResponse.json(
        { error: 'Table is not in the combined group' },
        { status: 400 }
      )
    }

    // Start transaction
    const result = await db.$transaction(async (tx) => {
      // 1. Remove the table from the combined group
      const newCombinedIds = combinedTableIds.filter(id => id !== tableIdToRemove)

      // 2. Update the removed table - restore to original state
      await tx.table.update({
        where: { id: tableIdToRemove },
        data: {
          combinedWithId: null,
          name: tableToRemove.originalName || tableToRemove.name,
          originalName: null,
          status: 'available',
          // Restore original position
          posX: tableToRemove.originalPosX ?? tableToRemove.posX,
          posY: tableToRemove.originalPosY ?? tableToRemove.posY,
          originalPosX: null,
          originalPosY: null,
        },
      })

      // 3. Restore seat labels for the removed table
      const removedTableSeats = await tx.seat.findMany({
        where: { tableId: tableIdToRemove, deletedAt: null }
      })

      for (const seat of removedTableSeats) {
        await tx.seat.update({
          where: { id: seat.id },
          data: { label: String(seat.seatNumber) }
        })
      }

      // 4. Update primary table
      let newPrimaryName = primaryTable.originalName || primaryTable.name.split('+')[0]
      let newCapacity = primaryTable.capacity - (tableToRemove.capacity || 0)

      if (newCombinedIds.length > 0) {
        // Still has combined tables - update the combined name
        const remainingTables = await tx.table.findMany({
          where: { id: { in: newCombinedIds } },
          select: { name: true, originalName: true },
        })

        const allNames = [
          newPrimaryName,
          ...remainingTables.map(t => t.originalName || t.name)
        ]
        newPrimaryName = allNames.join('+')
      } else {
        // No more combined tables - fully restore primary
        newCapacity = Math.round(primaryTable.capacity / 2) // Approximate original
      }

      const updatedPrimary = await tx.table.update({
        where: { id: primaryTableId },
        data: {
          combinedTableIds: newCombinedIds.length > 0 ? newCombinedIds : Prisma.JsonNull,
          name: newPrimaryName,
          originalName: newCombinedIds.length > 0 ? primaryTable.originalName : null,
          capacity: Math.max(newCapacity, 1),
        },
      })

      // 5. If group was fully dissolved, restore primary table's seat labels
      if (newCombinedIds.length === 0) {
        const primaryTableSeats = await tx.seat.findMany({
          where: { tableId: primaryTableId, deletedAt: null }
        })

        for (const seat of primaryTableSeats) {
          await tx.seat.update({
            where: { id: seat.id },
            data: { label: String(seat.seatNumber) }
          })
        }
      }

      // 6. Seat label recalculation will be done via API after transaction

      // 7. Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'table_removed_from_group',
          entityType: 'table',
          entityId: tableIdToRemove,
          details: {
            removedTableId: tableIdToRemove,
            removedTableName: tableToRemove.originalName || tableToRemove.name,
            primaryTableId,
            remainingCombinedIds: newCombinedIds,
          },
        },
      })

      return {
        removedTable: tableToRemove,
        primaryTable: updatedPrimary,
        remainingCombinedIds: newCombinedIds,
      }
    })

    // Fire-and-forget API calls for seat operations (after transaction completes)
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'

    // 1. Restore the removed table's seats to original positions
    fetch(`${baseUrl}/api/seats/bulk-operations?action=restore-original`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        locationId,
        tableIds: [tableIdToRemove]
      })
    }).catch(err => console.error('[RemoveFromGroup] Seat restore failed:', err))

    // 2. If tables remain in group, recalculate their seat labels
    if (result.remainingCombinedIds.length > 0) {
      // Fetch all remaining tables to get positions
      const allTables = await db.table.findMany({
        where: {
          id: { in: [primaryTableId, ...result.remainingCombinedIds] },
          isActive: true,
        },
        select: { id: true, posX: true, posY: true, width: true, height: true },
      })

      const remainingTablePositions = allTables.map(t => ({
        id: t.id,
        posX: t.posX,
        posY: t.posY,
        width: t.width,
        height: t.height
      }))

      fetch(`${baseUrl}/api/seats/bulk-operations?action=recalculate-labels`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          tableIds: [primaryTableId, ...result.remainingCombinedIds],
          tablePositions: remainingTablePositions
        })
      }).catch(err => console.error('[RemoveFromGroup] Seat recalculate failed:', err))
    } else {
      // 3. If this was the last child, restore primary's seats too
      fetch(`${baseUrl}/api/seats/bulk-operations?action=restore-original`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          locationId,
          tableIds: [primaryTableId]
        })
      }).catch(err => console.error('[RemoveFromGroup] Primary seat restore failed:', err))
    }

    // Emit real-time event
    tableEvents.tablesSplit({
      primaryTableId,
      restoredTableIds: [tableIdToRemove],
      locationId,
      splitMode: 'even', // Using 'even' for API compatibility - actual mode is remove_one
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: {
        removedTableId: tableIdToRemove,
        removedTableName: result.removedTable.originalName || result.removedTable.name,
        primaryTableId,
        remainingCombinedIds: result.remainingCombinedIds,
        message: `Removed ${result.removedTable.originalName || result.removedTable.name} from group`,
      },
    })
  } catch (error) {
    console.error('[RemoveFromGroup] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to remove table from group' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import { softDeleteData } from '@/lib/floorplan/queries'
import { Prisma } from '@prisma/client'

// GET - Get a single table
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    const table = await db.table.findFirst({
      where: { id, locationId, deletedAt: null },
      include: {
        section: {
          select: { id: true, name: true, color: true },
        },
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            employee: {
              select: { displayName: true, firstName: true, lastName: true },
            },
            items: {
              where: { deletedAt: null },
              include: { modifiers: true },
            },
          },
        },
      },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      table: {
        id: table.id,
        name: table.name,
        abbreviation: table.abbreviation,
        capacity: table.capacity,
        posX: table.posX,
        posY: table.posY,
        width: table.width,
        height: table.height,
        rotation: table.rotation,
        shape: table.shape,
        status: table.status,
        section: table.section,
        currentOrder: table.orders[0] ? {
          id: table.orders[0].id,
          orderNumber: table.orders[0].orderNumber,
          guestCount: table.orders[0].guestCount,
          total: Number(table.orders[0].total),
          openedAt: table.orders[0].createdAt.toISOString(),
          server: table.orders[0].employee?.displayName ||
            `${table.orders[0].employee?.firstName || ''} ${table.orders[0].employee?.lastName || ''}`.trim(),
          items: table.orders[0].items.map(item => ({
            id: item.id,
            name: item.name,
            quantity: item.quantity,
            price: Number(item.price),
            modifiers: item.modifiers.map(m => ({
              name: m.name,
              price: Number(m.price),
            })),
          })),
        } : null,
      },
    })
  } catch (error) {
    console.error('Failed to fetch table:', error)
    return NextResponse.json(
      { error: 'Failed to fetch table' },
      { status: 500 }
    )
  }
}

// PUT - Update a table
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const {
      name,
      abbreviation,
      sectionId,
      capacity,
      posX,
      posY,
      width,
      height,
      rotation,
      shape,
      seatPattern,
      status,
    } = body

    // Build type-safe update data
    const updateData: Prisma.TableUpdateInput = {}

    if (name !== undefined) updateData.name = name
    if (abbreviation !== undefined) updateData.abbreviation = abbreviation ?? null
    if (sectionId !== undefined) {
      updateData.section = sectionId ? { connect: { id: sectionId } } : { disconnect: true }
    }
    if (capacity !== undefined) updateData.capacity = capacity
    if (posX !== undefined) updateData.posX = posX
    if (posY !== undefined) updateData.posY = posY
    if (width !== undefined) updateData.width = width
    if (height !== undefined) updateData.height = height
    if (rotation !== undefined) updateData.rotation = rotation
    if (shape !== undefined) updateData.shape = shape
    if (seatPattern !== undefined) updateData.seatPattern = seatPattern
    if (status !== undefined) updateData.status = status

    // Update table (will throw P2025 if not found)
    const table = await db.table.update({
      where: { id },
      data: updateData,
      include: {
        section: {
          select: { id: true, name: true, color: true },
        },
        _count: {
          select: {
            seats: { where: { isActive: true, deletedAt: null } },
          },
        },
      },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      table: {
        id: table.id,
        name: table.name,
        abbreviation: table.abbreviation,
        capacity: table.capacity,
        seatCount: table._count.seats,
        posX: table.posX,
        posY: table.posY,
        width: table.width,
        height: table.height,
        rotation: table.rotation,
        shape: table.shape,
        seatPattern: table.seatPattern,
        status: table.status,
        section: table.section,
      },
    })
  } catch (error) {
    // Handle Prisma P2025 error (record not found)
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return NextResponse.json({ error: 'Table not found' }, { status: 404 })
    }
    console.error('Failed to update table:', error)
    return NextResponse.json(
      { error: 'Failed to update table' },
      { status: 500 }
    )
  }
}

// DELETE - Delete (deactivate) a table
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params

    // Check for open orders
    const openOrders = await db.order.count({
      where: { tableId: id, status: 'open' },
    })

    if (openOrders > 0) {
      return NextResponse.json(
        { error: 'Cannot delete table with open orders' },
        { status: 400 }
      )
    }

    // Soft delete and get locationId for socket dispatch
    const table = await db.table.update({
      where: { id },
      data: softDeleteData(),
      select: { locationId: true },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to delete table:', error)
    return NextResponse.json(
      { error: 'Failed to delete table' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/[seatId]/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { softDeleteData } from '@/lib/floorplan/queries'
import { Prisma } from '@prisma/client'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// GET - Get a single seat
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; seatId: string }> }
) {
  try {
    const { id: tableId, seatId } = await params

    const seat = await db.seat.findFirst({
      where: {
        id: seatId,
        tableId,
        isActive: true,
        deletedAt: null,
      },
    })

    if (!seat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      seat: {
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      },
    })
  } catch (error) {
    console.error('Failed to fetch seat:', error)
    return NextResponse.json(
      { error: 'Failed to fetch seat' },
      { status: 500 }
    )
  }
}

// PUT - Update a seat
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; seatId: string }> }
) {
  try {
    const { id: tableId, seatId } = await params
    const body = await request.json()
    const {
      label,
      seatNumber,
      relativeX,
      relativeY,
      angle,
      seatType,
      updateOriginal = false, // If true, also update the "builder default" position
    } = body

    // Verify seat exists and belongs to this table
    // Also check if table is part of a combined group
    const existingSeat = await db.seat.findFirst({
      where: {
        id: seatId,
        tableId,
        isActive: true,
        deletedAt: null,
      },
      include: {
        table: {
          select: {
            locationId: true,
            combinedWithId: true,
            combinedTableIds: true,
          },
        },
      },
    })

    if (!existingSeat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      )
    }

    // Determine if we should update original positions
    // Update originals if:
    // 1. Explicitly requested (updateOriginal = true)
    // 2. OR if the table is NOT combined (we're in the floor plan builder)
    const isTableCombined = existingSeat.table.combinedWithId ||
      (existingSeat.table.combinedTableIds && (existingSeat.table.combinedTableIds as string[]).length > 0)

    const shouldUpdateOriginal = updateOriginal || !isTableCombined

    // Build type-safe update data
    const updateData: Prisma.SeatUpdateInput = {}

    if (label !== undefined) updateData.label = label
    if (seatNumber !== undefined) updateData.seatNumber = seatNumber
    if (relativeX !== undefined) {
      updateData.relativeX = relativeX
      if (shouldUpdateOriginal) updateData.originalRelativeX = relativeX
    }
    if (relativeY !== undefined) {
      updateData.relativeY = relativeY
      if (shouldUpdateOriginal) updateData.originalRelativeY = relativeY
    }
    if (angle !== undefined) {
      updateData.angle = angle
      if (shouldUpdateOriginal) updateData.originalAngle = angle
    }
    if (seatType !== undefined) updateData.seatType = seatType

    const seat = await db.seat.update({
      where: { id: seatId },
      data: updateData,
    })

    dispatchFloorPlanUpdate(existingSeat.table.locationId, { async: true })

    return NextResponse.json({
      seat: {
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      },
    })
  } catch (error) {
    console.error('Failed to update seat:', error)
    return NextResponse.json(
      { error: 'Failed to update seat' },
      { status: 500 }
    )
  }
}

// DELETE - Delete (deactivate) a seat
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; seatId: string }> }
) {
  try {
    const { id: tableId, seatId } = await params
    const { searchParams } = new URL(request.url)
    const employeeId = searchParams.get('employeeId')

    // Verify seat exists and belongs to this table (with table info for logging)
    const existingSeat = await db.seat.findFirst({
      where: {
        id: seatId,
        tableId,
        isActive: true,
      },
      include: {
        table: {
          select: { locationId: true, name: true },
        },
      },
    })

    if (!existingSeat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      )
    }

    // Check if seat has any active tickets (sold, held, or checked in)
    const activeTickets = await db.ticket.count({
      where: {
        seatId,
        status: { in: ['sold', 'held', 'checked_in'] },
      },
    })

    if (activeTickets > 0) {
      return NextResponse.json(
        { error: 'Cannot delete seat with active tickets' },
        { status: 400 }
      )
    }

    // Use transaction to soft delete and log
    await db.$transaction(async (tx) => {
      // Soft delete
      await tx.seat.update({
        where: { id: seatId },
        data: { isActive: false, deletedAt: new Date() },
      })

      // Audit log
      await tx.auditLog.create({
        data: {
          locationId: existingSeat.table.locationId,
          employeeId: employeeId || null,
          action: 'seat_deleted',
          entityType: 'seat',
          entityId: seatId,
          details: {
            tableId,
            tableName: existingSeat.table.name,
            seatNumber: existingSeat.seatNumber,
            seatLabel: existingSeat.label,
          },
        },
      })
    })

    console.log(`[Seats] Deleted seat ${existingSeat.seatNumber} from table ${existingSeat.table.name}`)

    dispatchFloorPlanUpdate(existingSeat.table.locationId, { async: true })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to delete seat:', error)
    return NextResponse.json(
      { error: 'Failed to delete seat' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/auto-generate/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import { generateSeatPositions as generateSeatPositionsFromLib, type SeatPattern as LibSeatPattern } from '@/lib/seat-generation'
import { SEAT_RADIUS } from '@/lib/floorplan/constants'

type LabelPattern = 'numeric' | 'alpha' | 'alphanumeric'

// Helper function to generate seat labels
function getLabel(index: number, pattern: LabelPattern): string {
  switch (pattern) {
    case 'alpha':
      return String.fromCharCode(65 + index) // A, B, C...
    case 'alphanumeric':
      return `S${index + 1}` // S1, S2, S3...
    default:
      return String(index + 1) // 1, 2, 3...
  }
}

// Collision detection constants
const COLLISION_PADDING = 5 // Extra padding for collision checks

interface CollisionResult {
  hasCollisions: boolean
  collisions: {
    seatNumber: number
    collidedWith: string // 'table:T1' or 'fixture:Wall' or 'seat:T2-S3'
    type: 'table' | 'fixture' | 'seat'
  }[]
}

// Check if a point collides with a rectangle (with rotation support)
function pointInRotatedRect(
  px: number,
  py: number,
  rectX: number,
  rectY: number,
  rectW: number,
  rectH: number,
  rectRotation: number = 0
): boolean {
  // Get rect center
  const cx = rectX + rectW / 2
  const cy = rectY + rectH / 2

  // Translate point to rect's local space
  const dx = px - cx
  const dy = py - cy

  // Rotate point in opposite direction
  const rad = (-rectRotation * Math.PI) / 180
  const cos = Math.cos(rad)
  const sin = Math.sin(rad)
  const localX = dx * cos - dy * sin
  const localY = dx * sin + dy * cos

  // Check if local point is within rect bounds (with padding for seat radius)
  const halfW = rectW / 2 + SEAT_RADIUS + COLLISION_PADDING
  const halfH = rectH / 2 + SEAT_RADIUS + COLLISION_PADDING

  return Math.abs(localX) <= halfW && Math.abs(localY) <= halfH
}

// POST - Auto-generate seats for a table based on capacity and pattern
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const {
      count,
      seatPattern,
      labelPattern = 'numeric',
      replaceExisting = true,
      updateTablePattern = true, // Also update table's seatPattern field
      employeeId, // For audit logging
      checkCollisions = true, // New: whether to check for collisions
      forceGenerate = false, // New: generate even if collisions detected
      availableSpace, // Optional: space available around table (for dynamic compression)
    } = body

    // Verify table exists and get details
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: {
        id: true,
        name: true,
        locationId: true,
        capacity: true,
        width: true,
        height: true,
        posX: true,
        posY: true,
        rotation: true,
        shape: true,
        seatPattern: true,
      },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    const seatCount = count || table.capacity

    // Map local patterns to library patterns
    const patternMap: Record<string, LibSeatPattern> = {
      'all_around': 'all_around',
      'front_only': 'one_side',
      'two_sides': 'two_sides',
      'three_sides': 'booth', // Maps to booth pattern (3 sides)
      'inside': 'booth', // Maps to booth pattern
    }

    // Use provided pattern, or infer from table shape, or use table's existing pattern
    let localPattern = seatPattern || table.seatPattern || 'all_around'

    // Auto-infer pattern from shape if not explicitly set
    if (!seatPattern && table.seatPattern === 'all_around') {
      if (table.shape === 'bar') localPattern = 'front_only'
      else if (table.shape === 'booth') localPattern = 'inside'
    }

    // Map to library pattern
    const libraryPattern = patternMap[localPattern as string] || 'all_around'

    // Generate seat positions using library function
    const baseSeatPositions = generateSeatPositionsFromLib({
      shape: table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth',
      pattern: libraryPattern,
      capacity: seatCount,
      width: table.width,
      height: table.height,
    })

    // Add labels to seat positions
    const seatPositions = baseSeatPositions.map((pos, index) => ({
      ...pos,
      label: getLabel(index, labelPattern as LabelPattern),
    }))

    // Check for collisions if requested
    let collisionResult: CollisionResult = { hasCollisions: false, collisions: [] }

    if (checkCollisions) {
      // Skip collision checks if table hasn't been positioned yet
      if (table.posX == null || table.posY == null) {
        console.warn('[Seats] Skipping collision check - table has no position yet')
        // Generate seats without collision checking
      } else {
        // Get all other tables in the location (for collision detection)
        const otherTables = await db.table.findMany({
          where: {
            locationId: table.locationId,
            id: { not: tableId },
            isActive: true,
            deletedAt: null,
          },
          select: {
            id: true,
            name: true,
            posX: true,
            posY: true,
            width: true,
            height: true,
            rotation: true,
            seats: {
              where: { isActive: true, deletedAt: null },
              select: {
                id: true,
                seatNumber: true,
                relativeX: true,
                relativeY: true,
              },
            },
          },
        })

        // Get all fixtures (walls, bars) in the location
        const fixtures = await db.floorPlanElement.findMany({
          where: {
            locationId: table.locationId,
            deletedAt: null,
          },
          select: {
            id: true,
            name: true,
            elementType: true,
            posX: true,
            posY: true,
            width: true,
            height: true,
            rotation: true,
          },
        })

        // Calculate table center for seat absolute positions
        const tableCenterX = (table.posX ?? 0) + table.width / 2
        const tableCenterY = (table.posY ?? 0) + table.height / 2
        const tableRotation = (table.rotation ?? 0) * Math.PI / 180
        const cos = Math.cos(tableRotation)
        const sin = Math.sin(tableRotation)

        // Check each generated seat for collisions
        for (const seat of seatPositions) {
          // Calculate absolute seat position (applying table rotation)
          const rotatedX = seat.relativeX * cos - seat.relativeY * sin
          const rotatedY = seat.relativeX * sin + seat.relativeY * cos
          const seatAbsX = tableCenterX + rotatedX
          const seatAbsY = tableCenterY + rotatedY

          // Check against other tables
          for (const otherTable of otherTables) {
            // Skip tables with invalid positions
            if (otherTable.posX == null || otherTable.posY == null) continue

            if (pointInRotatedRect(
              seatAbsX, seatAbsY,
              otherTable.posX, otherTable.posY,
              otherTable.width, otherTable.height,
              otherTable.rotation ?? 0
            )) {
              collisionResult.hasCollisions = true
              collisionResult.collisions.push({
                seatNumber: seat.seatNumber,
                collidedWith: `table:${otherTable.name || otherTable.id}`,
                type: 'table',
              })
            }

            // Check against seats of other tables
            const otherTableCenterX = otherTable.posX + otherTable.width / 2
            const otherTableCenterY = otherTable.posY + otherTable.height / 2
            const otherRotation = (otherTable.rotation ?? 0) * Math.PI / 180
            const otherCos = Math.cos(otherRotation)
            const otherSin = Math.sin(otherRotation)

            for (const otherSeat of otherTable.seats) {
              const otherRotatedX = otherSeat.relativeX * otherCos - otherSeat.relativeY * otherSin
              const otherRotatedY = otherSeat.relativeX * otherSin + otherSeat.relativeY * otherCos
              const otherSeatAbsX = otherTableCenterX + otherRotatedX
              const otherSeatAbsY = otherTableCenterY + otherRotatedY

              const distance = Math.hypot(seatAbsX - otherSeatAbsX, seatAbsY - otherSeatAbsY)
              if (distance < (SEAT_RADIUS * 2 + COLLISION_PADDING)) {
                collisionResult.hasCollisions = true
                collisionResult.collisions.push({
                  seatNumber: seat.seatNumber,
                  collidedWith: `seat:${otherTable.name || otherTable.id}-S${otherSeat.seatNumber}`,
                  type: 'seat',
                })
              }
            }
          }

          // Check against fixtures (walls, bars, etc.)
          for (const fixture of fixtures) {
            // Skip fixtures with invalid positions
            if (fixture.posX == null || fixture.posY == null) continue

            if (pointInRotatedRect(
              seatAbsX, seatAbsY,
              fixture.posX, fixture.posY,
              fixture.width, fixture.height,
              fixture.rotation ?? 0
            )) {
              collisionResult.hasCollisions = true
              collisionResult.collisions.push({
                seatNumber: seat.seatNumber,
                collidedWith: `fixture:${fixture.name || fixture.elementType}`,
                type: 'fixture',
              })
            }
          }
        }

        // Log collisions but proceed anyway - let the user arrange tables as needed
        if (collisionResult.hasCollisions) {
          console.warn(`[Seats] Detected ${collisionResult.collisions.length} potential collisions, proceeding anyway`)
        }
      } // End else block (table has valid position)
    } // End if (checkCollisions)

    // Use transaction to replace existing seats and optionally update table pattern
    const result = await db.$transaction(async (tx) => {
      let deletedCount = 0

      if (replaceExisting) {
        // Hard delete existing seats - regeneration is a complete replacement
        // and soft-deleted seats would conflict with unique constraint on (tableId, seatNumber)
        const deleted = await tx.seat.deleteMany({
          where: { tableId },
        })
        deletedCount = deleted.count
      }

      // Update table's seatPattern if requested
      if (updateTablePattern && seatPattern) {
        await tx.table.update({
          where: { id: tableId },
          data: { seatPattern: localPattern },
        })
      }

      // Create new seats with original positions saved as "builder defaults"
      const createdSeats = await Promise.all(
        seatPositions.map(pos =>
          tx.seat.create({
            data: {
              locationId: table.locationId,
              tableId,
              label: pos.label,
              seatNumber: pos.seatNumber,
              relativeX: Math.round(pos.relativeX),
              relativeY: Math.round(pos.relativeY),
              angle: Math.round(pos.angle),
              seatType: 'standard',
              // Save as "builder default" for restore after combine/split
              originalRelativeX: Math.round(pos.relativeX),
              originalRelativeY: Math.round(pos.relativeY),
              originalAngle: Math.round(pos.angle),
            },
          })
        )
      )

      // Audit log the seat regeneration
      await tx.auditLog.create({
        data: {
          locationId: table.locationId,
          employeeId: employeeId || null,
          action: 'seats_regenerated',
          entityType: 'table',
          entityId: tableId,
          details: {
            tableName: table.name || tableId,
            previousSeatsDeleted: deletedCount,
            newSeatsCreated: createdSeats.length,
            seatPattern: localPattern,
            labelPattern,
          },
        },
      })

      console.log(`[Seats] Regenerated ${createdSeats.length} seats for table (deleted ${deletedCount} previous)`)

      return createdSeats
    })

    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      seats: result.map(seat => ({
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      })),
      generated: result.length,
      seatPattern: localPattern,
      // Include collision warning if seats were forced despite collisions
      ...(collisionResult.hasCollisions ? {
        warning: 'Seats generated with collisions (forceGenerate was true)',
        collisions: collisionResult.collisions,
      } : {}),
    })
  } catch (error) {
    console.error('Failed to auto-generate seats:', error)
    // Return detailed error for debugging
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    const errorStack = error instanceof Error ? error.stack : undefined
    return NextResponse.json(
      {
        error: 'Failed to auto-generate seats',
        details: errorMessage,
        stack: process.env.NODE_ENV === 'development' ? errorStack : undefined
      },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/bulk/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

interface SeatUpdate {
  id: string
  label?: string
  seatNumber?: number
  relativeX?: number
  relativeY?: number
  angle?: number
  seatType?: string
}

// PUT - Bulk update seat positions
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const { seats } = body as { seats: SeatUpdate[] }

    if (!seats || !Array.isArray(seats)) {
      return NextResponse.json(
        { error: 'Seats array is required' },
        { status: 400 }
      )
    }

    // Verify table exists
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: { id: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // Verify all seats belong to this table
    const seatIds = seats.map(s => s.id)
    const existingSeats = await db.seat.findMany({
      where: {
        id: { in: seatIds },
        tableId,
        isActive: true,
      },
      select: { id: true },
    })

    if (existingSeats.length !== seatIds.length) {
      return NextResponse.json(
        { error: 'One or more seats not found or do not belong to this table' },
        { status: 400 }
      )
    }

    // Update all seats in a transaction
    const updatedSeats = await db.$transaction(
      seats.map(seatUpdate =>
        db.seat.update({
          where: { id: seatUpdate.id },
          data: {
            ...(seatUpdate.label !== undefined ? { label: seatUpdate.label } : {}),
            ...(seatUpdate.seatNumber !== undefined ? { seatNumber: seatUpdate.seatNumber } : {}),
            ...(seatUpdate.relativeX !== undefined ? { relativeX: seatUpdate.relativeX } : {}),
            ...(seatUpdate.relativeY !== undefined ? { relativeY: seatUpdate.relativeY } : {}),
            ...(seatUpdate.angle !== undefined ? { angle: seatUpdate.angle } : {}),
            ...(seatUpdate.seatType !== undefined ? { seatType: seatUpdate.seatType } : {}),
          },
        })
      )
    )

    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      seats: updatedSeats.map(seat => ({
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      })),
      updated: updatedSeats.length,
    })
  } catch (error) {
    console.error('Failed to bulk update seats:', error)
    return NextResponse.json(
      { error: 'Failed to bulk update seats' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/generate/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';
import { generateSeatPositions, type SeatPattern } from '@/lib/seat-generation';

// POST - Generate/regenerate default seat layout
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params;
    const body = await request.json();
    const {
      pattern,
      count,
      saveAsDefault = false,
    } = body;

    // Get table details
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: {
        id: true,
        locationId: true,
        name: true,
        width: true,
        height: true,
        shape: true,
        capacity: true,
        seatPattern: true,
      },
    });

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      );
    }

    // Use defaults from table if not provided
    const finalPattern = (pattern || table.seatPattern || 'all_around') as SeatPattern;
    const finalCount = count || table.capacity;

    // Generate seat positions using params object
    const seatPositions = generateSeatPositions({
      shape: (table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth') || 'rectangle',
      pattern: finalPattern,
      capacity: finalCount,
      width: table.width,
      height: table.height,
    });

    // Hard delete existing seats - regeneration is a complete replacement
    // and soft-deleted seats would conflict with unique constraint on (tableId, seatNumber)
    await db.seat.deleteMany({
      where: { tableId },
    });

    // Create new seats
    const createdSeats = await Promise.all(
      seatPositions.map((pos) =>
        db.seat.create({
          data: {
            locationId: table.locationId,
            tableId,
            seatNumber: pos.seatNumber,
            label: String(pos.seatNumber), // Generate label from seat number
            relativeX: Math.round(pos.relativeX),
            relativeY: Math.round(pos.relativeY),
            angle: Math.round(pos.angle),
            seatType: 'standard',
            // If saveAsDefault, set original positions for restore capability
            ...(saveAsDefault
              ? {
                  originalRelativeX: Math.round(pos.relativeX),
                  originalRelativeY: Math.round(pos.relativeY),
                  originalAngle: Math.round(pos.angle),
                }
              : {}),
          },
        })
      )
    );

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true });

    return NextResponse.json({
      seats: createdSeats.map((s) => ({
        id: s.id,
        label: s.label,
        seatNumber: s.seatNumber,
        relativeX: s.relativeX,
        relativeY: s.relativeY,
        angle: s.angle,
        seatType: s.seatType,
        isActive: s.isActive,
      })),
    });
  } catch (error) {
    console.error('Failed to generate seats:', error);
    return NextResponse.json(
      { error: 'Failed to generate seats' },
      { status: 500 }
    );
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/reflow/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';

// POST - Reflow seats when table is resized
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params;
    const body = await request.json();
    const { oldWidth, oldHeight, newWidth, newHeight, availableSpace } = body;

    if (!oldWidth || !oldHeight || !newWidth || !newHeight) {
      return NextResponse.json(
        { error: 'Missing dimension parameters' },
        { status: 400 }
      );
    }

    // Helper to calculate dynamic clearance based on available space
    const getDynamicClearance = (availableSpace: number | undefined, baseClearance: number = 25): number => {
      const SEAT_RADIUS = 20;
      const MIN_CLEARANCE = 10;
      const MAX_CLEARANCE = 50;

      if (availableSpace === undefined) return baseClearance;

      // Compress clearance if space is limited
      return Math.max(MIN_CLEARANCE, Math.min(baseClearance, availableSpace - SEAT_RADIUS));
    };

    // Get table and its active seats
    const table = await db.table.findUnique({
      where: { id: tableId },
      include: {
        seats: {
          where: { isActive: true, deletedAt: null },
          orderBy: { seatNumber: 'asc' },
        },
      },
    });

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      );
    }

    // Calculate dynamic clearance for each side
    const baseClearance = 25;
    const topClearance = getDynamicClearance(availableSpace?.top, baseClearance);
    const bottomClearance = getDynamicClearance(availableSpace?.bottom, baseClearance);
    const leftClearance = getDynamicClearance(availableSpace?.left, baseClearance);
    const rightClearance = getDynamicClearance(availableSpace?.right, baseClearance);

    // Handle round/oval tables differently
    const isRoundTable = table.shape === 'round' || table.shape === 'oval';

    // Update each seat's position using edge-relative positioning
    const updatedSeats = await Promise.all(
      table.seats.map((seat) => {
        const oldHalfW = oldWidth / 2;
        const oldHalfH = oldHeight / 2;
        const newHalfW = newWidth / 2;
        const newHalfH = newHeight / 2;

        let newRelX: number;
        let newRelY: number;

        if (isRoundTable) {
          // For round/oval tables: maintain radial distance from center
          // Calculate current angle and distance from center
          const currentAngle = Math.atan2(seat.relativeY, seat.relativeX);

          // Use average clearance for round tables (simplified)
          const avgClearance = (topClearance + bottomClearance + leftClearance + rightClearance) / 4;

          // For oval, use ellipse formula; for round, use circle
          let newRadius: number;
          if (table.shape === 'oval') {
            // Ellipse: maintain position on ellipse perimeter + clearance
            newRadius = Math.sqrt(
              Math.pow(newHalfW * Math.cos(currentAngle), 2) +
              Math.pow(newHalfH * Math.sin(currentAngle), 2)
            ) + avgClearance;
          } else {
            // Circle: use smaller dimension as radius
            newRadius = Math.min(newHalfW, newHalfH) + avgClearance;
          }

          newRelX = newRadius * Math.cos(currentAngle);
          newRelY = newRadius * Math.sin(currentAngle);
        } else {
          // For rectangular tables: determine which edge the seat belongs to
          const absX = Math.abs(seat.relativeX);
          const absY = Math.abs(seat.relativeY);

          // Normalize to see which edge dominates
          const normalizedX = absX / oldHalfW;  // 0 = center, 1 = edge
          const normalizedY = absY / oldHalfH;

          if (normalizedY >= normalizedX) {
            // Seat is on top or bottom edge
            // Use dynamic clearance based on side
            const direction = seat.relativeY >= 0 ? 1 : -1;
            const clearance = direction > 0 ? bottomClearance : topClearance;
            newRelY = direction * (newHalfH + clearance);

            // Scale X position proportionally along the edge
            newRelX = seat.relativeX * (newWidth / oldWidth);
          } else {
            // Seat is on left or right edge
            // Use dynamic clearance based on side
            const direction = seat.relativeX >= 0 ? 1 : -1;
            const clearance = direction > 0 ? rightClearance : leftClearance;
            newRelX = direction * (newHalfW + clearance);

            // Scale Y position proportionally along the edge
            newRelY = seat.relativeY * (newHeight / oldHeight);
          }
        }

        // Update seat position
        return db.seat.update({
          where: { id: seat.id },
          data: {
            relativeX: Math.round(newRelX),
            relativeY: Math.round(newRelY),
          },
        });
      })
    );

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true });

    return NextResponse.json({
      seats: updatedSeats.map((s) => ({
        id: s.id,
        seatNumber: s.seatNumber,
        label: s.label,
        relativeX: s.relativeX,
        relativeY: s.relativeY,
        angle: s.angle,
      })),
      message: `Reflowed ${updatedSeats.length} seats`,
    });
  } catch (error) {
    console.error('Failed to reflow seats:', error);
    return NextResponse.json(
      { error: 'Failed to reflow seats' },
      { status: 500 }
    );
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// GET - List all seats for a table
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const searchParams = request.nextUrl.searchParams
    const includeInactive = searchParams.get('includeInactive') === 'true'

    // Verify table exists
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: { id: true, name: true, shape: true, capacity: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    const seats = await db.seat.findMany({
      where: {
        tableId,
        deletedAt: null,
        ...(includeInactive ? {} : { isActive: true }),
      },
      orderBy: { seatNumber: 'asc' },
    })

    return NextResponse.json({
      seats: seats.map(seat => ({
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        originalRelativeX: seat.originalRelativeX,
        originalRelativeY: seat.originalRelativeY,
        originalAngle: seat.originalAngle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      })),
      table: {
        id: table.id,
        name: table.name,
        shape: table.shape,
        capacity: table.capacity,
      },
    })
  } catch (error) {
    console.error('Failed to fetch seats:', error)
    return NextResponse.json(
      { error: 'Failed to fetch seats' },
      { status: 500 }
    )
  }
}

// POST - Add a seat to table
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const {
      label,
      seatNumber,
      relativeX,
      relativeY,
      angle,
      seatType,
      insertAt,
    } = body

    // Verify table exists and get locationId
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: { id: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // If insertAt is provided, renumber existing seats >= insertAt
    if (insertAt !== undefined && insertAt > 0) {
      await db.seat.updateMany({
        where: {
          tableId,
          seatNumber: { gte: insertAt },
          deletedAt: null,
        },
        data: {
          seatNumber: { increment: 1 },
        },
      })
    }

    // Determine final seat number
    let finalSeatNumber = seatNumber ?? insertAt
    if (!finalSeatNumber) {
      const maxSeat = await db.seat.findFirst({
        where: { tableId, deletedAt: null },
        orderBy: { seatNumber: 'desc' },
        select: { seatNumber: true },
      })
      finalSeatNumber = (maxSeat?.seatNumber ?? 0) + 1
    }

    // Calculate final positions
    const finalRelativeX = relativeX ?? 0
    const finalRelativeY = relativeY ?? 0
    const finalAngle = angle ?? 0

    const seat = await db.seat.create({
      data: {
        locationId: table.locationId,
        tableId,
        label: label ?? String(finalSeatNumber),
        seatNumber: finalSeatNumber,
        relativeX: finalRelativeX,
        relativeY: finalRelativeY,
        angle: finalAngle,
        seatType: seatType ?? 'standard',
        // Save initial position as the "builder default" for restore after combine/split
        originalRelativeX: finalRelativeX,
        originalRelativeY: finalRelativeY,
        originalAngle: finalAngle,
      },
    })

    // Fetch all seats for UI update
    const allSeats = await db.seat.findMany({
      where: { tableId, deletedAt: null, isActive: true },
      orderBy: { seatNumber: 'asc' },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      seat: {
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      },
      seats: allSeats.map(s => ({
        id: s.id,
        label: s.label,
        seatNumber: s.seatNumber,
        relativeX: s.relativeX,
        relativeY: s.relativeY,
        angle: s.angle,
        seatType: s.seatType,
        isActive: s.isActive,
      })),
    })
  } catch (error) {
    console.error('Failed to create seat:', error)
    return NextResponse.json(
      { error: 'Failed to create seat' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/save-as-default/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * POST /api/tables/[id]/seats/save-as-default
 *
 * Save all current seat positions as the "builder default" positions.
 * This is used by admins to explicitly save seat arrangements from the floor plan builder.
 * When tables are split/reset, seats will return to these saved positions.
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const { locationId, employeeId } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Verify table exists
    const table = await db.table.findFirst({
      where: { id: tableId, locationId, deletedAt: null },
      select: { id: true, name: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // Get all active seats for this table
    const seats = await db.seat.findMany({
      where: {
        tableId,
        isActive: true,
        deletedAt: null,
      },
    })

    if (seats.length === 0) {
      return NextResponse.json(
        { error: 'No seats found for this table' },
        { status: 400 }
      )
    }

    // Update all seats to save current positions as original/default
    const result = await db.$transaction(async (tx) => {
      const updatedSeats = []

      for (const seat of seats) {
        const updated = await tx.seat.update({
          where: { id: seat.id },
          data: {
            originalRelativeX: seat.relativeX,
            originalRelativeY: seat.relativeY,
            originalAngle: seat.angle,
          },
        })
        updatedSeats.push(updated)
      }

      // Audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'seats_saved_as_default',
          entityType: 'table',
          entityId: tableId,
          details: {
            tableName: table.name,
            seatCount: updatedSeats.length,
            positions: updatedSeats.map(s => ({
              id: s.id,
              label: s.label,
              relativeX: s.relativeX,
              relativeY: s.relativeY,
              angle: s.angle,
            })),
          },
        },
      })

      return updatedSeats
    })

    return NextResponse.json({
      data: {
        tableId,
        tableName: table.name,
        savedCount: result.length,
        message: `Saved ${result.length} seat positions as default for ${table.name}`,
      },
    })
  } catch (error) {
    console.error('[SaveSeatsAsDefault] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to save seat positions as default' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/split/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { Prisma } from '@prisma/client'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * POST /api/tables/[id]/split
 *
 * Split a combined table back into its original tables:
 * - Option A: Split evenly (items distributed randomly)
 * - Option B: Split by seat (items follow original seat assignment)
 * - Restore table names
 * - Create new orders for split tables
 * - Audit log the split
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const { locationId, employeeId, splitMode = 'even' } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    if (!['even', 'by_seat'].includes(splitMode)) {
      return NextResponse.json(
        { error: 'splitMode must be "even" or "by_seat"' },
        { status: 400 }
      )
    }

    // Fetch the combined table with its orders and combined table data
    const primaryTable = await db.table.findFirst({
      where: { id: tableId, locationId, deletedAt: null },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
              include: { modifiers: true },
            },
            employee: { select: { id: true, displayName: true } },
          },
        },
      },
    })

    if (!primaryTable) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    const combinedTableIds = (primaryTable.combinedTableIds as string[]) || []

    if (combinedTableIds.length === 0) {
      return NextResponse.json(
        { error: 'This table is not combined with any other tables' },
        { status: 400 }
      )
    }

    // Fetch all the combined tables
    const combinedTables = await db.table.findMany({
      where: {
        id: { in: combinedTableIds },
        locationId,
        deletedAt: null,
      },
    })

    if (combinedTables.length !== combinedTableIds.length) {
      return NextResponse.json(
        { error: 'Some combined tables not found' },
        { status: 400 }
      )
    }

    // SAFETY CHECK: Cannot split tables with open orders
    // This protects active service - close the check first before splitting
    const currentOrder = primaryTable.orders[0]
    if (currentOrder) {
      return NextResponse.json(
        { error: 'Cannot split tables with open orders. Close the check first.' },
        { status: 400 }
      )
    }

    // Start transaction
    // Since we prevent split with open orders (safety check above),
    // we can directly restore tables without handling order distribution
    const result = await db.$transaction(async (tx) => {
      const restoredTables: string[] = []

      // Restore the combined tables with scattered positions
      // Use scatter offset to prevent tables stacking at 0,0
      const basePosX = primaryTable.posX || 100
      const basePosY = primaryTable.posY || 100
      const scatterOffset = 40 // px between scattered tables

      for (let i = 0; i < combinedTables.length; i++) {
        const combinedTable = combinedTables[i]
        // Use original position if saved, otherwise scatter from primary's position
        const restoredPosX = combinedTable.originalPosX ?? (basePosX + (i + 1) * scatterOffset)
        const restoredPosY = combinedTable.originalPosY ?? (basePosY + (i + 1) * scatterOffset)

        await tx.table.update({
          where: { id: combinedTable.id },
          data: {
            status: 'available',
            combinedWithId: null,
            name: combinedTable.originalName || combinedTable.name.split('+').pop() || combinedTable.name,
            // Restore to admin-defined position or scatter if not available
            posX: restoredPosX > 0 ? restoredPosX : basePosX + (i + 1) * scatterOffset,
            posY: restoredPosY > 0 ? restoredPosY : basePosY + (i + 1) * scatterOffset,
          },
        })

        restoredTables.push(combinedTable.id)
      }

      // Restore primary table with original position
      const originalCapacity = Math.floor(
        primaryTable.capacity / (combinedTables.length + 1)
      )

      // Use original position if saved, otherwise keep current (which is already basePosX/Y)
      const primaryRestoredPosX = primaryTable.originalPosX ?? basePosX
      const primaryRestoredPosY = primaryTable.originalPosY ?? basePosY

      const updatedPrimary = await tx.table.update({
        where: { id: primaryTable.id },
        data: {
          combinedTableIds: Prisma.JsonNull,
          name: primaryTable.originalName || primaryTable.name.split('+')[0],
          originalName: null,
          capacity: originalCapacity > 0 ? originalCapacity : primaryTable.capacity,
          status: 'available', // Always available since we require closing orders before split
          // Restore to admin-defined position or keep current if not available
          posX: primaryRestoredPosX > 0 ? primaryRestoredPosX : 100,
          posY: primaryRestoredPosY > 0 ? primaryRestoredPosY : 100,
        },
      })

      // Restore seats to their original positions from floor plan builder
      const allSplitTableIds = [primaryTable.id, ...combinedTableIds]

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'tables_split',
          entityType: 'table',
          entityId: primaryTable.id,
          details: {
            primaryTableId: primaryTable.id,
            restoredTableIds: restoredTables,
            splitMode,
            hadActiveOrder: false, // We return early if there's an active order
          },
        },
      })

      return {
        primaryTable: updatedPrimary,
        restoredTables,
      }
    })

    // Call Seats API to restore original positions for all split tables
    const allSplitTableIds = [tableId, ...result.restoredTables]
    fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/seats/bulk-operations?action=restore-original`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        locationId,
        tableIds: allSplitTableIds
      })
    }).catch(err => console.error('[TablesSplit] Seat restore failed:', err))

    // Emit real-time event
    tableEvents.tablesSplit({
      primaryTableId: tableId,
      restoredTableIds: result.restoredTables,
      locationId,
      splitMode,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: {
        primaryTableId: result.primaryTable.id,
        primaryTableName: result.primaryTable.name,
        restoredTableIds: result.restoredTables,
        message: `Tables split successfully using ${splitMode} mode`,
      },
    })
  } catch (error) {
    console.error('[TablesSplit] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to split tables' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/transfer/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// POST - Transfer table to another server
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const { toEmployeeId, fromEmployeeId, reason } = body

    if (!toEmployeeId) {
      return NextResponse.json(
        { error: 'Target employee ID is required' },
        { status: 400 }
      )
    }

    // Get the table
    const table = await db.table.findUnique({
      where: { id: tableId },
      include: {
        section: true,
      },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // Verify target employee exists
    const toEmployee = await db.employee.findUnique({
      where: { id: toEmployeeId },
      select: { id: true, firstName: true, lastName: true, displayName: true },
    })

    if (!toEmployee) {
      return NextResponse.json(
        { error: 'Target employee not found' },
        { status: 404 }
      )
    }

    // Find all open orders for this table and transfer them
    const openOrders = await db.order.findMany({
      where: {
        tableId,
        status: { in: ['open', 'sent'] },
      },
    })

    // Update all orders to new employee
    if (openOrders.length > 0) {
      await db.order.updateMany({
        where: {
          tableId,
          status: { in: ['open', 'sent'] },
        },
        data: {
          employeeId: toEmployeeId,
        },
      })
    }

    // Create audit log entry for each transferred order
    for (const order of openOrders) {
      await db.auditLog.create({
        data: {
          locationId: table.locationId,
          employeeId: fromEmployeeId,
          action: 'table_transfer',
          entityType: 'order',
          entityId: order.id,
          details: {
            tableId,
            tableName: table.name,
            orderId: order.id,
            orderNumber: order.orderNumber,
            fromEmployeeId,
            toEmployeeId,
            toEmployeeName: toEmployee.displayName || `${toEmployee.firstName} ${toEmployee.lastName}`,
            reason,
          },
        },
      })
    }

    // Also create a single audit log for the table transfer
    await db.auditLog.create({
      data: {
        locationId: table.locationId,
        employeeId: fromEmployeeId,
        action: 'table_transfer',
        entityType: 'table',
        entityId: tableId,
        details: {
          tableName: table.name,
          ordersTransferred: openOrders.length,
          fromEmployeeId,
          toEmployeeId,
          toEmployeeName: toEmployee.displayName || `${toEmployee.firstName} ${toEmployee.lastName}`,
          reason,
        },
      },
    })

    // Notify POS terminals of table transfer
    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      success: true,
      table: {
        id: table.id,
        name: table.name,
      },
      toEmployee: {
        id: toEmployee.id,
        name: toEmployee.displayName || `${toEmployee.firstName} ${toEmployee.lastName}`,
      },
      ordersTransferred: openOrders.length,
      orderIds: openOrders.map(o => o.id),
    })
  } catch (error) {
    console.error('Failed to transfer table:', error)
    return NextResponse.json(
      { error: 'Failed to transfer table' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/bulk-update/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { normalizeCoord } from '@/lib/table-geometry'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

interface TablePositionUpdate {
  id: string
  posX: number
  posY: number
  width?: number
  height?: number
  rotation?: number
}

/**
 * Bulk update table positions in a single transaction
 * Used by the Floor Plan Editor for efficient saves
 *
 * IMPORTANT: All positions are normalized to grid alignment server-side
 * to ensure DB and UI are always on the same grid (prevents phantom "unsaved changes")
 */
export async function PUT(request: NextRequest) {
  try {
    const { tables, locationId } = await request.json() as {
      tables: TablePositionUpdate[]
      locationId: string
    }

    if (!tables || !Array.isArray(tables) || tables.length === 0) {
      return NextResponse.json(
        { error: 'No tables provided for update' },
        { status: 400 }
      )
    }

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Normalize all positions to grid alignment before saving
    // This ensures DB values match what the editor displays (same grid snapping)
    const normalizedTables = tables.map(t => ({
      ...t,
      posX: normalizeCoord(t.posX),
      posY: normalizeCoord(t.posY),
    }))

    // Perform all updates in a single transaction for atomicity
    // ALSO save as default positions to prevent layout getting wonky on reload
    const results = await db.$transaction(
      normalizedTables.map((t) =>
        db.table.update({
          where: {
            id: t.id,
            locationId, // Security: ensure table belongs to this location
          },
          data: {
            posX: t.posX,
            posY: t.posY,
            // Also save as default so positions persist on reload
            defaultPosX: t.posX,
            defaultPosY: t.posY,
            ...(t.width !== undefined && { width: Math.round(t.width) }),
            ...(t.height !== undefined && { height: Math.round(t.height) }),
            ...(t.rotation !== undefined && { rotation: t.rotation }),
            updatedAt: new Date(),
          },
        })
      )
    )

    // Notify POS terminals of bulk position updates
    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      success: true,
      updated: results.length,
      tables: results.map(t => ({
        id: t.id,
        posX: t.posX,
        posY: t.posY,
        width: t.width,
        height: t.height,
      })),
    })
  } catch (error) {
    console.error('[Tables Bulk Update] Error:', error)
    return NextResponse.json(
      { error: 'Bulk update failed' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/combine/route.ts
################################################################################

// src/app/api/tables/combine/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import {
  getCombinedGroupTables,
  getGroupBoundingBox,
  distributeSeatsOnPerimeter,
  type TableRect,
} from '@/lib/table-geometry'
import {
  calculateAttachSide,
  calculateAttachPosition,
  shiftCollidingTables,
  type TableRect as PositioningTableRect,
  type AttachSide,
} from '@/components/floor-plan/table-positioning'

interface CombineRequestBody {
  sourceTableId: string
  targetTableId: string
  locationId: string
  employeeId?: string
  dropX?: number
  dropY?: number
  attachSide?: AttachSide
  allTables?: Array<{
    id: string
    posX: number
    posY: number
    width: number
    height: number
  }>
}

/**
 * POST /api/tables/combine
 *
 * Physical combine:
 * - Resolve primary target
 * - Merge/move orders
 * - Attach source to group with magnetic positioning
 * - Shift colliding tables (pockets allowed)
 * - Rebuild seats around true perimeter; label 1..N clockwise
 */
export async function POST(request: NextRequest) {
  let body: CombineRequestBody
  try {
    body = (await request.json()) as CombineRequestBody
  } catch (err) {
    return NextResponse.json(
      { error: 'Invalid JSON in request body', details: String(err) },
      { status: 400 }
    )
  }

  const {
    sourceTableId,
    targetTableId,
    locationId,
    employeeId,
    dropX,
    dropY,
    attachSide,
    allTables,
  } = body

  if (!sourceTableId || !targetTableId || !locationId) {
    return NextResponse.json(
      { error: 'sourceTableId, targetTableId, and locationId are required' },
      { status: 400 }
    )
  }
  if (sourceTableId === targetTableId) {
    return NextResponse.json(
      { error: 'Cannot combine a table with itself' },
      { status: 400 }
    )
  }

  try {
    // 1) Load source + target with open orders
    const [sourceTable, targetTable] = await Promise.all([
      db.table.findFirst({
        where: { id: sourceTableId, locationId, deletedAt: null },
        include: {
          orders: {
            where: { status: 'open', deletedAt: null },
            include: { items: true },
          },
        },
      }),
      db.table.findFirst({
        where: { id: targetTableId, locationId, deletedAt: null },
        include: {
          orders: {
            where: { status: 'open', deletedAt: null },
            include: { items: true },
          },
        },
      }),
    ])

    if (!sourceTable) {
      return NextResponse.json({ error: 'Source table not found' }, { status: 404 })
    }
    if (!targetTable) {
      return NextResponse.json({ error: 'Target table not found' }, { status: 404 })
    }

    // 2) If source is child in another group, detach first
    if (sourceTable.combinedWithId) {
      const currentPrimaryId = sourceTable.combinedWithId
      const currentPrimary = await db.table.findFirst({
        where: { id: currentPrimaryId, locationId, deletedAt: null },
      })

      if (currentPrimary) {
        const currentIds = (currentPrimary.combinedTableIds as string[]) || []
        const newIds = currentIds.filter(id => id !== sourceTableId)

        await db.table.update({
          where: { id: currentPrimaryId },
          data: {
            combinedTableIds: newIds.length ? newIds : [],
            name:
              newIds.length > 0
                ? currentPrimary.name
                : currentPrimary.originalName || currentPrimary.name,
          },
        })

        await db.table.update({
          where: { id: sourceTableId },
          data: { combinedWithId: null },
        })
      }
    }

    // 3) Resolve primary target if target is child
    let actualTargetTable = targetTable
    let actualTargetId = targetTableId

    if (targetTable.combinedWithId) {
      const primaryTable = await db.table.findFirst({
        where: { id: targetTable.combinedWithId, locationId, deletedAt: null },
        include: {
          orders: {
            where: { status: 'open', deletedAt: null },
            include: { items: true },
          },
        },
      })
      if (primaryTable) {
        actualTargetTable = primaryTable
        actualTargetId = primaryTable.id
      }
    }

    const existingCombinedIds: string[] =
      (actualTargetTable.combinedTableIds as string[]) || []
    const newCombinedIds = [...existingCombinedIds, sourceTableId]

    const baseName = actualTargetTable.originalName || actualTargetTable.name
    const combinedName =
      existingCombinedIds.length > 0
        ? `${actualTargetTable.name}+${sourceTable.name}`
        : `${baseName}+${sourceTable.name}`

    // 4) Build combined bounding box for side calc
    let combinedBoundingBox: PositioningTableRect = {
      id: actualTargetId,
      posX: actualTargetTable.posX,
      posY: actualTargetTable.posY,
      width: actualTargetTable.width,
      height: actualTargetTable.height,
    }

    if (existingCombinedIds.length > 0 && allTables && Array.isArray(allTables)) {
      const combinedRects = allTables.filter(
        t => existingCombinedIds.includes(t.id) || t.id === actualTargetId
      )

      if (combinedRects.length > 0) {
        let minX = actualTargetTable.posX
        let minY = actualTargetTable.posY
        let maxX = actualTargetTable.posX + actualTargetTable.width
        let maxY = actualTargetTable.posY + actualTargetTable.height

        for (const t of combinedRects) {
          minX = Math.min(minX, t.posX)
          minY = Math.min(minY, t.posY)
          maxX = Math.max(maxX, t.posX + t.width)
          maxY = Math.max(maxY, t.posY + t.height)
        }

        combinedBoundingBox = {
          id: actualTargetId,
          posX: minX,
          posY: minY,
          width: maxX - minX,
          height: maxY - minY,
        }
      }
    }

    const sourceRect: PositioningTableRect = {
      id: sourceTable.id,
      posX: sourceTable.posX,
      posY: sourceTable.posY,
      width: sourceTable.width,
      height: sourceTable.height,
    }

    // 5) Attach side + magnetic position
    let side: AttachSide = attachSide || 'right'
    if (!attachSide && dropX !== undefined && dropY !== undefined) {
      side = calculateAttachSide(dropX, dropY, combinedBoundingBox)
    }
    const magneticPos = calculateAttachPosition(sourceRect, combinedBoundingBox, side)

    const shiftedPositions = new Map<string, { posX: number; posY: number }>()

    // 6) Transaction: orders, collisions, tables, seats
    const result = await db.$transaction(async tx => {
      const sourceOrder = sourceTable.orders[0]
      const targetOrder = actualTargetTable.orders[0]

      // 6a) Orders (merge or move)
      if (sourceOrder) {
        if (targetOrder) {
          await tx.orderItem.updateMany({
            where: {
              orderId: sourceOrder.id,
              locationId,
              deletedAt: null,
            },
            data: { orderId: targetOrder.id },
          })

          const newGuestCount = targetOrder.guestCount + sourceOrder.guestCount
          const newSubtotal =
            Number(targetOrder.subtotal) + Number(sourceOrder.subtotal)
          const newTax = Number(targetOrder.taxTotal) + Number(sourceOrder.taxTotal)
          const newTotal = Number(targetOrder.total) + Number(sourceOrder.total)

          await tx.order.update({
            where: { id: targetOrder.id },
            data: {
              guestCount: newGuestCount,
              subtotal: newSubtotal,
              taxTotal: newTax,
              total: newTotal,
              notes: targetOrder.notes
                ? `${targetOrder.notes}\n[Combined from ${sourceTable.name}]`
                : `[Combined from ${sourceTable.name}]`,
            },
          })

          await tx.order.update({
            where: { id: sourceOrder.id },
            data: {
              status: 'merged',
              notes: `Merged into order #${targetOrder.orderNumber} on table ${actualTargetTable.name}`,
            },
          })
        } else {
          await tx.order.update({
            where: { id: sourceOrder.id },
            data: { tableId: actualTargetId },
          })
        }
      }

      // 6b) Collision shifting (preserve pockets)
      if (allTables && Array.isArray(allTables)) {
        const tableRects: TableRect[] = allTables.map(t => ({
          id: t.id,
          posX: t.id === sourceTableId ? magneticPos.posX : t.posX,
          posY: t.id === sourceTableId ? magneticPos.posY : t.posY,
          width: t.width,
          height: t.height,
        }))

        const newSourceRect: TableRect = {
          id: sourceRect.id,
          posX: magneticPos.posX,
          posY: magneticPos.posY,
          width: sourceRect.width,
          height: sourceRect.height,
        }

        const excludeIds = [sourceTableId, actualTargetId, ...existingCombinedIds]

        const shifts = shiftCollidingTables(newSourceRect, tableRects, excludeIds, 5)

        for (const [tableId, pos] of shifts) {
          await tx.table.update({
            where: { id: tableId },
            data: { posX: pos.posX, posY: pos.posY },
          })
          shiftedPositions.set(tableId, pos)
        }
      }

      // 6c) Mark source as child; move to magnetic pos
      await tx.table.update({
        where: { id: sourceTableId },
        data: {
          combinedWithId: actualTargetId,
          originalPosX: sourceTable.originalPosX ?? sourceTable.posX,
          originalPosY: sourceTable.originalPosY ?? sourceTable.posY,
          posX: magneticPos.posX,
          posY: magneticPos.posY,
          status: sourceOrder ? 'occupied' : actualTargetTable.status,
          originalName: sourceTable.originalName || sourceTable.name,
        },
      })

      // 6d) Update primary target
      const updatedTarget = await tx.table.update({
        where: { id: actualTargetId },
        data: {
          combinedTableIds: newCombinedIds,
          name: combinedName,
          originalName: actualTargetTable.originalName || actualTargetTable.name,
          capacity: actualTargetTable.capacity + sourceTable.capacity,
          status: sourceOrder || targetOrder ? 'occupied' : actualTargetTable.status,
        },
        include: {
          section: { select: { id: true, name: true, color: true } },
          orders: {
            where: { status: 'open', deletedAt: null },
            select: {
              id: true,
              orderNumber: true,
              guestCount: true,
              total: true,
              createdAt: true,
            },
          },
        },
      })

      // 6e) Seats: perimeter + clockwise labels
      const allCombinedTableIds = [actualTargetId, sourceTableId, ...existingCombinedIds]

      const allSeats = await tx.seat.findMany({
        where: { tableId: { in: allCombinedTableIds }, isActive: true, deletedAt: null },
        orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
      })

      if (allSeats.length > 0) {
        const tablePositions = new Map<
          string,
          { posX: number; posY: number; width: number; height: number }
        >()

        tablePositions.set(actualTargetId, {
          posX: actualTargetTable.posX,
          posY: actualTargetTable.posY,
          width: actualTargetTable.width,
          height: actualTargetTable.height,
        })

        tablePositions.set(sourceTableId, {
          posX: magneticPos.posX,
          posY: magneticPos.posY,
          width: sourceTable.width,
          height: sourceTable.height,
        })

        if (allTables && Array.isArray(allTables)) {
          for (const childId of existingCombinedIds) {
            const child = allTables.find(t => t.id === childId)
            if (child) {
              tablePositions.set(childId, {
                posX: child.posX,
                posY: child.posY,
                width: child.width,
                height: child.height,
              })
            }
          }
        }

        const groupRects: TableRect[] = []
        for (const [tableId, pos] of tablePositions) {
          groupRects.push({
            id: tableId,
            posX: pos.posX,
            posY: pos.posY,
            width: pos.width,
            height: pos.height,
            combinedWithId: null,
            combinedTableIds: null,
          })
        }

        if (groupRects.length > 0) {
          const perimeterPositions = distributeSeatsOnPerimeter(
            groupRects,
            allSeats.length
          )

          const bounds = getGroupBoundingBox(groupRects)
          const centerX = bounds ? bounds.minX + bounds.width / 2 : 0
          const centerY = bounds ? bounds.minY + bounds.height / 2 : 0

          const seatsWithPos = allSeats
            .map(seat => {
              const tablePos = tablePositions.get(seat.tableId)
              if (!tablePos) return null

              const tableCenterX = tablePos.posX + tablePos.width / 2
              const tableCenterY = tablePos.posY + tablePos.height / 2
              const absX = tableCenterX + seat.relativeX
              const absY = tableCenterY + seat.relativeY

              const dx = absX - centerX
              const dy = absY - centerY
              let angle = (Math.atan2(dy, dx) * 180) / Math.PI
              angle = (angle + 450) % 360 // top=0, clockwise

              return { seat, absX, absY, angle }
            })
            .filter(Boolean) as {
            seat: (typeof allSeats)[number]
            absX: number
            absY: number
            angle: number
          }[]

          seatsWithPos.sort((a, b) => a.angle - b.angle)

          for (let i = 0; i < seatsWithPos.length; i++) {
            const item = seatsWithPos[i]
            const newPos = perimeterPositions[i]
            if (!newPos) continue

            const tablePos = tablePositions.get(item.seat.tableId)
            if (!tablePos) continue

            const tableCenterX = tablePos.posX + tablePos.width / 2
            const tableCenterY = tablePos.posY + tablePos.height / 2

            const newRelativeX = Math.round(newPos.x - tableCenterX)
            const newRelativeY = Math.round(newPos.y - tableCenterY)

            const angleToCenter =
              (Math.atan2(centerY - newPos.y, centerX - newPos.x) * 180) / Math.PI
            const newAngle = Math.round(angleToCenter)

            await tx.seat.update({
              where: { id: item.seat.id },
              data: {
                relativeX: newRelativeX,
                relativeY: newRelativeY,
                angle: newAngle,
                label: String(i + 1),
              },
            })
          }
        }
      }

      const updatedSeats = await tx.seat.findMany({
        where: { tableId: { in: allCombinedTableIds }, isActive: true, deletedAt: null },
        select: {
          id: true,
          tableId: true,
          label: true,
          seatNumber: true,
          relativeX: true,
          relativeY: true,
          angle: true,
        },
        orderBy: { seatNumber: 'asc' },
      })

      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId ?? null,
          action: 'tables_combined',
          entityType: 'table',
          entityId: actualTargetId,
          details: {
            sourceTableId,
            sourceTableName: sourceTable.name,
            targetTableId: actualTargetId,
            targetTableName: actualTargetTable.name,
            originalDropTargetId: targetTableId !== actualTargetId ? targetTableId : undefined,
            combinedName,
            attachSide: side,
            seatsRepositioned: updatedSeats.length,
          },
        },
      })

      return { updatedTarget, updatedSeats }
    })

    // 7) Emit realtime + response
    const shiftedTablesObj: Record<string, { posX: number; posY: number }> = {}
    for (const [tableId, pos] of shiftedPositions) {
      shiftedTablesObj[tableId] = pos
    }

    tableEvents.tablesCombined({
      sourceTableId,
      targetTableId: actualTargetId,
      locationId,
      combinedName,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    const targetOrder = result.updatedTarget.orders[0] || null

    return NextResponse.json({
      data: {
        table: {
          id: result.updatedTarget.id,
          name: result.updatedTarget.name,
          capacity: result.updatedTarget.capacity,
          status: result.updatedTarget.status,
          combinedTableIds: result.updatedTarget.combinedTableIds,
          originalName: result.updatedTarget.originalName,
          section: result.updatedTarget.section,
          currentOrder: targetOrder
            ? {
                id: targetOrder.id,
                orderNumber: targetOrder.orderNumber,
                guestCount: targetOrder.guestCount,
                total: Number(targetOrder.total),
                openedAt: targetOrder.createdAt.toISOString(),
              }
            : null,
        },
        sourceTable: {
          id: sourceTableId,
          posX: magneticPos.posX,
          posY: magneticPos.posY,
        },
        attachSide: side,
        shiftedTables: shiftedTablesObj,
        seats: result.updatedSeats,
        message: `Tables combined: ${combinedName}`,
      },
    })
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error'
    const stack = error instanceof Error ? error.stack : undefined

    return NextResponse.json(
      {
        error: 'Failed to combine tables',
        details: msg,
        stack,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/reset-to-default/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { Prisma } from '@prisma/client'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * POST /api/tables/reset-to-default
 *
 * Reset combined tables to their original (admin-defined) positions:
 * - Uncombine all specified tables
 * - Restore original positions (originalPosX, originalPosY)
 * - Restore original names
 * - SKIP tables with open orders (protect active service)
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { tableIds, locationId, employeeId } = body

    if (!tableIds || !Array.isArray(tableIds) || tableIds.length === 0) {
      return NextResponse.json(
        { error: 'tableIds array is required' },
        { status: 400 }
      )
    }

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Fetch all tables to reset, including their orders
    const tablesToReset = await db.table.findMany({
      where: {
        id: { in: tableIds },
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: {
            status: { in: ['open', 'in_progress'] },
            deletedAt: null,
          },
        },
      },
    })

    if (tablesToReset.length === 0) {
      return NextResponse.json(
        { error: 'No tables found to reset' },
        { status: 404 }
      )
    }

    // Track reset and skipped tables
    const skippedTableIds: string[] = []

    const result = await db.$transaction(async (tx) => {
      const resetResults: Array<{ id: string; name: string; wasReset: boolean; reason?: string }> = []

      for (const table of tablesToReset) {
        const combinedTableIds = (table.combinedTableIds as string[]) || []

        // CHECK FOR OPEN ORDERS - skip if table has active orders
        if (table.orders.length > 0) {
          resetResults.push({
            id: table.id,
            name: table.name,
            wasReset: false,
            reason: 'open_order',
          })
          skippedTableIds.push(table.id)
          continue
        }

        // If this table has combined tables, uncombine them
        if (combinedTableIds.length > 0) {
          // First, get all the combined tables with their orders
          const combinedTables = await tx.table.findMany({
            where: {
              id: { in: combinedTableIds },
              locationId,
              deletedAt: null,
            },
            include: {
              orders: {
                where: {
                  status: { in: ['open', 'in_progress'] },
                  deletedAt: null,
                },
              },
            },
          })

          // Check if ANY of the combined tables have open orders
          const hasOpenOrders = combinedTables.some(ct => ct.orders.length > 0)
          if (hasOpenOrders) {
            resetResults.push({
              id: table.id,
              name: table.name,
              wasReset: false,
              reason: 'combined_table_has_order',
            })
            skippedTableIds.push(table.id)
            continue
          }

          // Restore each combined table
          for (const combined of combinedTables) {
            await tx.table.update({
              where: { id: combined.id },
              data: {
                combinedWithId: null,
                // Restore position: originalPosX (pre-combine)  defaultPosX (admin default)  posX (current)
                // This ensures tables return to where they were before combining
                posX: combined.originalPosX ?? combined.defaultPosX ?? combined.posX,
                posY: combined.originalPosY ?? combined.defaultPosY ?? combined.posY,
                sectionId: combined.defaultSectionId ?? combined.sectionId,
                // Restore original name if available
                name: combined.originalName || combined.name,
                originalName: null,
                // Clear combine-related original positions (already consumed above)
                originalPosX: null,
                originalPosY: null,
                status: 'available',
              },
            })

            resetResults.push({
              id: combined.id,
              name: combined.originalName || combined.name,
              wasReset: true,
            })
          }

          // Restore seats for all child tables
          const childTableIds = combinedTables.map(ct => ct.id)
          if (childTableIds.length > 0) {
            fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/seats/bulk-operations?action=restore-original`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                locationId,
                tableIds: childTableIds
              })
            }).catch(err => console.error('Child seat restore failed:', err))
          }

          // Calculate original capacity (divide current by number of tables)
          const originalCapacity = Math.floor(
            table.capacity / (combinedTableIds.length + 1)
          )

          // Reset the primary table
          await tx.table.update({
            where: { id: table.id },
            data: {
              combinedTableIds: Prisma.JsonNull,
              // Restore position: originalPosX (pre-combine)  defaultPosX (admin default)  posX (current)
              // Primary table typically doesn't move during combine, but check originalPosX just in case
              posX: table.originalPosX ?? table.defaultPosX ?? table.posX,
              posY: table.originalPosY ?? table.defaultPosY ?? table.posY,
              sectionId: table.defaultSectionId ?? table.sectionId,
              // Restore original name
              name: table.originalName || table.name.split('+')[0],
              originalName: null,
              // Clear combine-related original positions (already consumed above)
              originalPosX: null,
              originalPosY: null,
              // Restore original capacity (approximation)
              capacity: originalCapacity > 0 ? originalCapacity : table.capacity,
              status: 'available',
            },
          })

          // Restore primary table's seats
          fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/seats/bulk-operations?action=restore-original`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              locationId,
              tableIds: [table.id]
            })
          }).catch(err => console.error('Primary seat restore failed:', err))

          resetResults.push({
            id: table.id,
            name: table.originalName || table.name.split('+')[0],
            wasReset: true,
          })
        } else if (table.combinedWithId) {
          // This table is combined INTO another - it will be handled by its parent
          continue
        } else {
          // Not combined - reset to admin-defined default position if available
          if (table.defaultPosX !== null || table.defaultPosY !== null) {
            await tx.table.update({
              where: { id: table.id },
              data: {
                posX: table.defaultPosX ?? table.posX,
                posY: table.defaultPosY ?? table.posY,
                sectionId: table.defaultSectionId ?? table.sectionId,
              },
            })

            resetResults.push({
              id: table.id,
              name: table.name,
              wasReset: true,
            })
          } else {
            // No default layout saved - skip this table
            resetResults.push({
              id: table.id,
              name: table.name,
              wasReset: false,
              reason: 'no_default_layout',
            })
          }
        }
      }

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'tables_reset_to_default',
          entityType: 'table',
          entityId: tableIds[0],
          details: {
            tableIds,
            resetResults,
            skippedDueToOrders: skippedTableIds,
          },
        },
      })

      return resetResults
    })

    // Emit real-time events for each reset table
    for (const table of result.filter(r => r.wasReset)) {
      tableEvents.tablesSplit({
        primaryTableId: table.id,
        restoredTableIds: [],
        locationId,
        splitMode: 'even',
        timestamp: new Date().toISOString(),
        triggeredBy: employeeId,
      })
    }

    dispatchFloorPlanUpdate(locationId, { async: true })

    const resetCount = result.filter(r => r.wasReset).length
    const skippedCount = skippedTableIds.length

    return NextResponse.json({
      data: {
        resetCount,
        skippedCount,
        tables: result,
        skippedTableIds,  // Return IDs for flash feedback on UI
        message: skippedCount > 0
          ? `Reset ${resetCount} table(s). ${skippedCount} table(s) skipped due to open orders.`
          : `Reset ${resetCount} table(s) to default positions`,
      },
    })
  } catch (error) {
    console.error('[TablesResetToDefault] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to reset tables' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// Table status validation
const VALID_STATUSES = ['available', 'occupied', 'dirty', 'reserved'] as const
type TableStatus = typeof VALID_STATUSES[number]

function isValidStatus(s: string | null): s is TableStatus {
  return s !== null && VALID_STATUSES.includes(s as TableStatus)
}

// GET - List all tables for a location
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const locationId = searchParams.get('locationId')
    const sectionId = searchParams.get('sectionId')
    const rawStatus = searchParams.get('status')
    const includeSeats = searchParams.get('includeSeats') === 'true'
    const includeOrders = searchParams.get('includeOrders') === 'true'
    const includeOrderItems = searchParams.get('includeOrderItems') === 'true'

    if (!locationId) {
      return NextResponse.json(
        { error: 'Location ID is required' },
        { status: 400 }
      )
    }

    // Validate status parameter
    const status = isValidStatus(rawStatus) ? rawStatus : undefined

    const tables = await db.table.findMany({
      where: {
        locationId,
        isActive: true,
        deletedAt: null,
        ...(sectionId ? { sectionId } : {}),
        ...(status ? { status } : {}),
      },
      include: {
        section: {
          select: { id: true, name: true, color: true },
        },
        // Always include count (lightweight)
        _count: {
          select: {
            seats: { where: { isActive: true, deletedAt: null } },
          },
        },
        // Conditionally include orders
        ...(includeOrders ? {
          orders: {
            where: { status: 'open', deletedAt: null },
            select: {
              id: true,
              orderNumber: true,
              guestCount: true,
              total: true,
              createdAt: true,
              employee: {
                select: { displayName: true, firstName: true, lastName: true },
              },
              ...(includeOrderItems ? {
                items: {
                  where: { deletedAt: null },
                  select: {
                    id: true,
                    name: true,
                    quantity: true,
                    price: true,
                  },
                  orderBy: { createdAt: 'asc' as const },
                  take: 10, // Limit for performance
                },
              } : {}),
            },
          },
        } : {}),
        // Conditionally include seats
        ...(includeSeats ? {
          seats: {
            where: { isActive: true, deletedAt: null },
            select: {
              id: true,
              label: true,
              seatNumber: true,
              relativeX: true,
              relativeY: true,
              angle: true,
              seatType: true,
            },
            orderBy: { seatNumber: 'asc' },
          },
        } : {}),
      },
      orderBy: [
        { section: { name: 'asc' } },
        { name: 'asc' },
      ],
    })

    return NextResponse.json({
      tables: tables.map(table => ({
        id: table.id,
        name: table.name,
        abbreviation: table.abbreviation,
        capacity: table.capacity,
        // Seat count from _count (always included, lightweight)
        seatCount: table._count.seats,
        posX: table.posX,
        posY: table.posY,
        width: table.width,
        height: table.height,
        rotation: table.rotation,
        shape: table.shape,
        seatPattern: table.seatPattern,
        status: table.status,
        section: table.section,
        sectionId: table.sectionId,  // Section ID for filtering
        // Combine fields (Skill 106/107)
        combinedWithId: table.combinedWithId,
        combinedTableIds: table.combinedTableIds as string[] | null,
        originalName: table.originalName,
        // Original position for reset-to-default (T017)
        originalPosX: table.originalPosX,
        originalPosY: table.originalPosY,
        // Locked status (T019) - bolted down furniture
        isLocked: table.isLocked,
        // Virtual combine fields
        virtualGroupId: table.virtualGroupId,
        virtualGroupPrimary: table.virtualGroupPrimary,
        virtualGroupColor: table.virtualGroupColor,
        virtualGroupOffsetX: table.virtualGroupOffsetX,
        virtualGroupOffsetY: table.virtualGroupOffsetY,
        // Seats (if requested)
        seats: includeSeats && 'seats' in table ? table.seats : [],
        // Current order info (if orders included)
        currentOrder: (includeOrders && 'orders' in table && table.orders[0]) ? {
          id: table.orders[0].id,
          orderNumber: table.orders[0].orderNumber,
          guestCount: table.orders[0].guestCount,
          total: Number(table.orders[0].total),
          openedAt: table.orders[0].createdAt.toISOString(),
          server: (table.orders[0] as any).employee?.displayName ||
            `${(table.orders[0] as any).employee?.firstName || ''} ${(table.orders[0] as any).employee?.lastName || ''}`.trim(),
          // Order items for info panel (if requested)
          items: includeOrderItems && 'items' in table.orders[0]
            ? ((table.orders[0] as any).items as Array<{ id: string; name: string; quantity: number; price: unknown }>).map((item) => ({
                id: item.id,
                name: item.name,
                quantity: item.quantity,
                price: Number(item.price),
              }))
            : undefined,
        } : null,
      })),
    })
  } catch (error) {
    console.error('Failed to fetch tables:', error)
    return NextResponse.json(
      { error: 'Failed to fetch tables' },
      { status: 500 }
    )
  }
}

// POST - Create a new table
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      locationId,
      sectionId,
      name,
      abbreviation,
      capacity,
      posX,
      posY,
      width,
      height,
      rotation,
      shape,
      seatPattern,
    } = body

    if (!locationId || !name) {
      return NextResponse.json(
        { error: 'Location ID and name are required' },
        { status: 400 }
      )
    }

    const tableCapacity = capacity ?? 4
    const tableWidth = width ?? 100
    const tableHeight = height ?? 100
    const tableShape = shape ?? 'rectangle'
    const tableSeatPattern = seatPattern ?? 'all_around'
    const tableRotation = rotation ?? 0
    const tablePosX = posX ?? 0
    const tablePosY = posY ?? 0

    // Create the table
    const table = await db.table.create({
      data: {
        locationId,
        sectionId: sectionId ?? null,
        name,
        abbreviation: abbreviation ?? null,
        capacity: tableCapacity,
        posX: tablePosX,
        posY: tablePosY,
        width: tableWidth,
        height: tableHeight,
        rotation: tableRotation,
        shape: tableShape,
        seatPattern: tableSeatPattern,
      },
      include: {
        section: {
          select: { id: true, name: true, color: true },
        },
        _count: {
          select: {
            seats: { where: { isActive: true, deletedAt: null } },
          },
        },
      },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      table: {
        id: table.id,
        name: table.name,
        abbreviation: table.abbreviation,
        capacity: table.capacity,
        seatCount: table._count.seats,
        posX: table.posX,
        posY: table.posY,
        width: table.width,
        height: table.height,
        rotation: table.rotation,
        shape: table.shape,
        seatPattern: table.seatPattern,
        status: table.status,
        section: table.section,
        combinedWithId: null,
        combinedTableIds: null,
        originalName: null,
        originalPosX: null,
        originalPosY: null,
        isLocked: false,
        currentOrder: null,
      },
    })
  } catch (error) {
    console.error('Failed to create table:', error)
    return NextResponse.json(
      { error: 'Failed to create table' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/save-default-layout/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * POST /api/tables/save-default-layout
 *
 * Saves the current table positions as the "default layout" for reset operations.
 * This allows admins to define the canonical position for each table,
 * which will be restored when "Reset to Default" is triggered.
 *
 * Payload:
 * {
 *   locationId: string,
 *   tables: [{ id, defaultPosX, defaultPosY, defaultSectionId? }]
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { locationId, tables } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    if (!tables || !Array.isArray(tables) || tables.length === 0) {
      return NextResponse.json(
        { error: 'tables array is required' },
        { status: 400 }
      )
    }

    // Validate all tables exist and belong to this location
    const tableIds = tables.map((t: { id: string }) => t.id)
    const existingTables = await db.table.findMany({
      where: {
        id: { in: tableIds },
        locationId,
        deletedAt: null,
      },
      select: { id: true },
    })

    if (existingTables.length !== tableIds.length) {
      return NextResponse.json(
        { error: 'Some tables not found or do not belong to this location' },
        { status: 400 }
      )
    }

    // Update all tables with their default positions
    await db.$transaction(
      tables.map((t: { id: string; defaultPosX: number; defaultPosY: number; defaultSectionId?: string | null }) =>
        db.table.update({
          where: { id: t.id },
          data: {
            defaultPosX: t.defaultPosX,
            defaultPosY: t.defaultPosY,
            defaultSectionId: t.defaultSectionId ?? null,
          },
        })
      )
    )

    // Notify POS terminals of default layout save
    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: {
        updatedCount: tables.length,
        message: `Default layout saved for ${tables.length} table(s)`,
      },
    })
  } catch (error) {
    console.error('[SaveDefaultLayout] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to save default layout' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/seats/generate-all/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import { generateSeatPositions as generateSeatPositionsFromLib, type SeatPattern as LibSeatPattern } from '@/lib/seat-generation'

// Helper function to generate seat labels
function getLabel(index: number): string {
  return String(index + 1)
}

/**
 * POST /api/tables/seats/generate-all
 *
 * Bulk-generate seats for all tables that don't have any seats.
 * This is a one-time migration endpoint.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { locationId, forceRegenerate = false, employeeId } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Get all active tables for this location
    const tables = await db.table.findMany({
      where: {
        locationId,
        isActive: true,
        deletedAt: null,
      },
      include: {
        seats: {
          where: { isActive: true, deletedAt: null },
          select: { id: true },
        },
      },
    })

    const results: { tableId: string; tableName: string; seatsGenerated: number }[] = []
    let skipped = 0

    for (const table of tables) {
      // Skip if table already has seats (unless forceRegenerate)
      if (table.seats.length > 0 && !forceRegenerate) {
        skipped++
        continue
      }

      // If forceRegenerate, soft-delete existing seats first
      if (forceRegenerate && table.seats.length > 0) {
        await db.seat.updateMany({
          where: {
            tableId: table.id,
            isActive: true,
          },
          data: {
            isActive: false,
            deletedAt: new Date(),
          },
        })
      }

      // Map local patterns to library patterns
      const patternMap: Record<string, LibSeatPattern> = {
        'all_around': 'all_around',
        'front_only': 'one_side',
        'two_sides': 'two_sides',
        'three_sides': 'booth', // Maps to booth pattern (3 sides)
        'inside': 'booth', // Maps to booth pattern
      }

      // Determine seat pattern based on shape or stored pattern
      let localPattern = table.seatPattern || 'all_around'
      if (table.shape === 'bar') localPattern = 'front_only'
      else if (table.shape === 'booth') localPattern = 'inside'

      // Map to library pattern
      const libraryPattern = patternMap[localPattern as string] || 'all_around'

      // Generate seat positions using library function
      const baseSeatPositions = generateSeatPositionsFromLib({
        shape: table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth',
        pattern: libraryPattern,
        capacity: table.capacity,
        width: table.width,
        height: table.height,
      })

      // Add labels to seat positions
      const seatPositions = baseSeatPositions.map((pos, index) => ({
        ...pos,
        label: getLabel(index),
      }))

      // Create seats in database
      await db.seat.createMany({
        data: seatPositions.map(pos => ({
          locationId,
          tableId: table.id,
          label: pos.label,
          seatNumber: pos.seatNumber,
          relativeX: pos.relativeX,
          relativeY: pos.relativeY,
          angle: pos.angle,
          seatType: 'standard',
        })),
      })

      results.push({
        tableId: table.id,
        tableName: table.name,
        seatsGenerated: seatPositions.length,
      })
    }

    // Create audit log for bulk operation
    if (results.length > 0) {
      await db.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'seats_bulk_generated',
          entityType: 'table',
          entityId: locationId, // Use locationId since this affects multiple tables
          details: {
            totalTables: tables.length,
            tablesUpdated: results.length,
            tablesSkipped: skipped,
            forceRegenerate,
            tableNames: results.map(r => r.tableName),
          },
        },
      })

      console.log(`[GenerateAllSeats] Generated seats for ${results.length} tables (${skipped} skipped)`)
    }

    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      success: true,
      totalTables: tables.length,
      tablesUpdated: results.length,
      tablesSkipped: skipped,
      results,
    })
  } catch (error) {
    console.error('[GenerateAllSeats] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to generate seats' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/seats/reflow/route.ts
################################################################################

// src/app/api/tables/seats/reflow/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import {
  distributeSeatsOnPerimeter,
  getGroupBoundingBox,
  type TableRect,
} from '@/lib/table-geometry'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

interface ReflowSeatsBody {
  locationId: string
  /** Physical group or virtual group: all tables that share one perimeter */
  tableIds: string[]
  /** Optional: override seat count; if omitted, keep current seat count */
  seatCount?: number
}

/**
 * POST /api/tables/seats/reflow
 *
 * Rebuilds seat positions for a set of tables that form one logical group:
 * - Uses true perimeter of all tables (L/T/U/22)
 * - Distributes seats evenly around perimeter
 * - Sorts clockwise and labels seats 1..N
 *
 * Used by:
 * - Add/remove seat in admin
 * - Virtual group capacity changes
 * - Manual "fix seats" actions
 */
export async function POST(request: NextRequest) {
  let body: ReflowSeatsBody
  try {
    body = (await request.json()) as ReflowSeatsBody
  } catch (err) {
    return NextResponse.json(
      { error: 'Invalid JSON in request body', details: String(err) },
      { status: 400 }
    )
  }

  const { locationId, tableIds, seatCount } = body

  if (!locationId || !tableIds || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'locationId and tableIds[] are required' },
      { status: 400 }
    )
  }

  try {
    // 1) Load tables + seats
    const tables = await db.table.findMany({
      where: {
        id: { in: tableIds },
        locationId,
        deletedAt: null,
      },
      select: {
        id: true,
        posX: true,
        posY: true,
        width: true,
        height: true,
      },
    })

    if (tables.length === 0) {
      return NextResponse.json(
        { error: 'No tables found for given IDs' },
        { status: 404 }
      )
    }

    const seats = await db.seat.findMany({
      where: {
        tableId: { in: tableIds },
        isActive: true,
        deletedAt: null,
      },
      orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
    })

    const targetSeatCount = seatCount ?? seats.length

    if (targetSeatCount <= 0) {
      // No seats desired: mark existing seats inactive
      await db.seat.updateMany({
        where: { tableId: { in: tableIds }, isActive: true, deletedAt: null },
        data: { isActive: false },
      })

      return NextResponse.json({
        data: {
          seats: [],
          message: 'All seats removed for group',
        },
      })
    }

    // 2) Build TableRect array for perimeter
    const groupRects: TableRect[] = tables.map(t => ({
      id: t.id,
      posX: t.posX,
      posY: t.posY,
      width: t.width,
      height: t.height,
      combinedWithId: null,
      combinedTableIds: null,
    }))

    const perimeterPositions = distributeSeatsOnPerimeter(groupRects, targetSeatCount)
    if (perimeterPositions.length === 0) {
      return NextResponse.json(
        { error: 'Unable to compute perimeter positions for seats' },
        { status: 500 }
      )
    }

    const bounds = getGroupBoundingBox(groupRects)
    const centerX = bounds ? bounds.minX + bounds.width / 2 : 0
    const centerY = bounds ? bounds.minY + bounds.height / 2 : 0

    // 3) Ensure we have exactly targetSeatCount seats
    //    - If fewer: create new ones on the first tableId
    //    - If more: keep first N by seatNumber, mark rest inactive
    const firstTableId = tables[0].id

    if (seats.length < targetSeatCount) {
      const toCreate = targetSeatCount - seats.length
      const created = await db.$transaction(async tx => {
        const createdSeats = []
        for (let i = 0; i < toCreate; i++) {
          const seat = await tx.seat.create({
            data: {
              locationId,
              tableId: firstTableId,
              label: '',
              seatNumber: seats.length + i + 1,
              relativeX: 0,
              relativeY: 0,
              angle: 0,
              isActive: true,
            },
          })
          createdSeats.push(seat)
        }
        return createdSeats
      })
      seats.push(...created)
    } else if (seats.length > targetSeatCount) {
      const toDeactivate = seats.slice(targetSeatCount)
      const idsToDeactivate = toDeactivate.map(s => s.id)
      await db.seat.updateMany({
        where: { id: { in: idsToDeactivate } },
        data: { isActive: false },
      })
    }

    const activeSeats = seats.slice(0, targetSeatCount)

    // 4) Map each perimeter point to a seat, compute relative positions & inward angle
    const tableMap = new Map<
      string,
      { posX: number; posY: number; width: number; height: number }
    >()
    tables.forEach(t => {
      tableMap.set(t.id, {
        posX: t.posX,
        posY: t.posY,
        width: t.width,
        height: t.height,
      })
    })

    // Assign perimeter positions in order; then sort clockwise and relabel
    const seatsWithWorld: {
      seat: (typeof activeSeats)[number]
      worldX: number
      worldY: number
      angle: number
    }[] = []

    for (let i = 0; i < activeSeats.length; i++) {
      const seat = activeSeats[i]
      const pos = perimeterPositions[i]
      const worldX = pos.x
      const worldY = pos.y

      const dx = worldX - centerX
      const dy = worldY - centerY
      let angle = (Math.atan2(dy, dx) * 180) / Math.PI
      angle = (angle + 450) % 360 // top=0, clockwise

      seatsWithWorld.push({ seat, worldX, worldY, angle })
    }

    seatsWithWorld.sort((a, b) => a.angle - b.angle)

    // 5) Persist updates
    await db.$transaction(async tx => {
      for (let i = 0; i < seatsWithWorld.length; i++) {
        const { seat, worldX, worldY } = seatsWithWorld[i]

        // Simple strategy: attach all new/extra seats to firstTableId
        const tableId = tableIds.includes(seat.tableId) ? seat.tableId : firstTableId
        const tablePos = tableMap.get(tableId)
        if (!tablePos) continue

        const tableCenterX = tablePos.posX + tablePos.width / 2
        const tableCenterY = tablePos.posY + tablePos.height / 2

        const relativeX = Math.round(worldX - tableCenterX)
        const relativeY = Math.round(worldY - tableCenterY)

        const angleToCenter =
          (Math.atan2(centerY - worldY, centerX - worldX) * 180) / Math.PI
        const newAngle = Math.round(angleToCenter)

        await tx.seat.update({
          where: { id: seat.id },
          data: {
            tableId,
            relativeX,
            relativeY,
            angle: newAngle,
            label: String(i + 1),
            seatNumber: i + 1,
            isActive: true,
          },
        })
      }
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    const updatedSeats = await db.seat.findMany({
      where: {
        tableId: { in: tableIds },
        isActive: true,
        deletedAt: null,
      },
      select: {
        id: true,
        tableId: true,
        label: true,
        seatNumber: true,
        relativeX: true,
        relativeY: true,
        angle: true,
      },
      orderBy: { seatNumber: 'asc' },
    })

    return NextResponse.json({
      data: {
        seats: updatedSeats,
        message: `Seats reflowed for ${tableIds.length} table(s) to ${targetSeatCount} seat(s)`,
      },
    })
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error'
    const stack = error instanceof Error ? error.stack : undefined

    return NextResponse.json(
      {
        error: 'Failed to reflow seats',
        details: msg,
        stack,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/seats/save-all-as-default/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * POST /api/tables/seats/save-all-as-default
 *
 * Save ALL current seat positions across ALL tables as the "builder default" positions.
 * This is used by admins to save the entire floor plan arrangement.
 * When tables are split/reset, seats will return to these saved positions.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { locationId, employeeId, tableIds } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Build query - either specific tables or all tables
    const tableQuery: { locationId: string; deletedAt: null; id?: { in: string[] } } = {
      locationId,
      deletedAt: null,
    }
    if (tableIds && Array.isArray(tableIds) && tableIds.length > 0) {
      tableQuery.id = { in: tableIds }
    }

    // Get all tables
    const tables = await db.table.findMany({
      where: tableQuery,
      select: { id: true, name: true },
    })

    if (tables.length === 0) {
      return NextResponse.json(
        { error: 'No tables found' },
        { status: 404 }
      )
    }

    const tableIdList = tables.map(t => t.id)

    // Get all active seats for these tables
    const seats = await db.seat.findMany({
      where: {
        tableId: { in: tableIdList },
        isActive: true,
        deletedAt: null,
      },
    })

    if (seats.length === 0) {
      return NextResponse.json({
        data: {
          savedCount: 0,
          tableCount: tables.length,
          message: 'No seats to save',
        },
      })
    }

    // Update all seats to save current positions as original/default
    const result = await db.$transaction(async (tx) => {
      let savedCount = 0

      for (const seat of seats) {
        await tx.seat.update({
          where: { id: seat.id },
          data: {
            originalRelativeX: seat.relativeX,
            originalRelativeY: seat.relativeY,
            originalAngle: seat.angle,
          },
        })
        savedCount++
      }

      // Audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'all_seats_saved_as_default',
          entityType: 'location',
          entityId: locationId,
          details: {
            tableCount: tables.length,
            seatCount: savedCount,
            tableNames: tables.map(t => t.name),
          },
        },
      })

      return savedCount
    })

    return NextResponse.json({
      data: {
        savedCount: result,
        tableCount: tables.length,
        message: `Saved ${result} seat positions across ${tables.length} tables as default`,
      },
    })
  } catch (error) {
    console.error('[SaveAllSeatsAsDefault] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to save seat positions as default' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/[groupId]/add/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'

/**
 * POST /api/tables/virtual-combine/[groupId]/add
 *
 * Add a table to an existing virtual group:
 * - Table joins the group with matching color
 * - If table has an order, optionally merge items to primary
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  try {
    const { groupId } = await params
    const body = await request.json()
    const { tableId, locationId, employeeId, mergeExistingOrder = false, offsetX = 0, offsetY = 0 } = body

    if (!tableId || !locationId) {
      return NextResponse.json(
        { error: 'tableId and locationId are required' },
        { status: 400 }
      )
    }

    // Find the virtual group's primary table
    const primaryTable = await db.table.findFirst({
      where: {
        virtualGroupId: groupId,
        virtualGroupPrimary: true,
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
        },
      },
    })

    if (!primaryTable) {
      return NextResponse.json(
        { error: 'Virtual group not found' },
        { status: 404 }
      )
    }

    // Find the table to add
    const tableToAdd = await db.table.findFirst({
      where: {
        id: tableId,
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
            },
          },
        },
      },
    })

    if (!tableToAdd) {
      return NextResponse.json(
        { error: 'Table to add not found' },
        { status: 404 }
      )
    }

    // Check if table is already in a group
    if (tableToAdd.virtualGroupId) {
      return NextResponse.json(
        { error: 'Table is already in a virtual group' },
        { status: 400 }
      )
    }

    // Check if table is physically combined
    if (tableToAdd.combinedWithId || (tableToAdd.combinedTableIds && (tableToAdd.combinedTableIds as string[]).length > 0)) {
      return NextResponse.json(
        { error: 'Table is physically combined and cannot be virtually combined' },
        { status: 400 }
      )
    }

    const tableOrder = tableToAdd.orders[0]
    const primaryOrder = primaryTable.orders[0]

    // If table has order and not merging, return requiresAction
    if (tableOrder && !mergeExistingOrder) {
      return NextResponse.json({
        requiresAction: true,
        existingOrder: {
          tableId: tableToAdd.id,
          tableName: tableToAdd.name,
          orderId: tableOrder.id,
          orderNumber: tableOrder.orderNumber,
          itemCount: tableOrder.items.length,
          total: Number(tableOrder.total),
        },
        message: 'Table has an open order that needs to be handled',
      })
    }

    // Start transaction
    const result = await db.$transaction(async (tx) => {
      // Handle existing order merge
      if (tableOrder && mergeExistingOrder) {
        if (primaryOrder) {
          // Move items to primary order with sourceTableId
          await tx.orderItem.updateMany({
            where: {
              orderId: tableOrder.id,
              locationId,
              deletedAt: null,
            },
            data: {
              orderId: primaryOrder.id,
              sourceTableId: tableToAdd.id,
            },
          })

          // Update primary order totals
          const newGuestCount = primaryOrder.guestCount + tableOrder.guestCount
          const combinedSubtotal = Number(primaryOrder.subtotal) + Number(tableOrder.subtotal)
          const combinedTax = Number(primaryOrder.taxTotal) + Number(tableOrder.taxTotal)
          const combinedTotal = Number(primaryOrder.total) + Number(tableOrder.total)

          await tx.order.update({
            where: { id: primaryOrder.id },
            data: {
              guestCount: newGuestCount,
              subtotal: combinedSubtotal,
              taxTotal: combinedTax,
              total: combinedTotal,
              notes: primaryOrder.notes
                ? `${primaryOrder.notes}\n[Added ${tableToAdd.name}]`
                : `[Added ${tableToAdd.name}]`,
            },
          })

          // Mark original order as merged
          await tx.order.update({
            where: { id: tableOrder.id },
            data: {
              status: 'merged',
              notes: `Merged into virtual group on ${primaryTable.name}`,
            },
          })
        } else {
          // No primary order - reassign this order to primary table
          await tx.orderItem.updateMany({
            where: {
              orderId: tableOrder.id,
              locationId,
              deletedAt: null,
            },
            data: {
              sourceTableId: tableToAdd.id,
            },
          })

          await tx.order.update({
            where: { id: tableOrder.id },
            data: {
              tableId: primaryTable.id,
            },
          })
        }
      }

      // Add table to virtual group
      const updatedTable = await tx.table.update({
        where: { id: tableId },
        data: {
          virtualGroupId: groupId,
          virtualGroupPrimary: false,
          virtualGroupColor: primaryTable.virtualGroupColor,
          virtualGroupCreatedAt: primaryTable.virtualGroupCreatedAt,
          virtualGroupOffsetX: offsetX,
          virtualGroupOffsetY: offsetY,
          status: tableOrder || primaryOrder ? 'occupied' : tableToAdd.status,
        },
        include: {
          section: { select: { id: true, name: true, color: true } },
        },
      })

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'virtual_group_member_added',
          entityType: 'table',
          entityId: tableId,
          details: {
            virtualGroupId: groupId,
            primaryTableId: primaryTable.id,
            addedTableId: tableId,
            addedTableName: tableToAdd.name,
            mergedOrder: mergeExistingOrder && !!tableOrder,
          },
        },
      })

      return updatedTable
    })

    // Emit real-time event
    tableEvents.virtualGroupMemberAdded?.({
      virtualGroupId: groupId,
      tableId,
      locationId,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    return NextResponse.json({
      data: {
        table: {
          id: result.id,
          name: result.name,
          virtualGroupId: result.virtualGroupId,
          virtualGroupColor: result.virtualGroupColor,
          status: result.status,
          section: result.section,
        },
        message: `${tableToAdd.name} added to virtual group`,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Add failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to add table to virtual group', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/[groupId]/dissolve/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * POST /api/tables/virtual-combine/[groupId]/dissolve
 *
 * Dissolve a virtual group:
 * - Clears virtualGroupId, virtualGroupPrimary, virtualGroupColor from all tables
 * - Optionally splits the order by table (creates separate orders)
 * - Or keeps all items on the primary table's order
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  try {
    const { groupId } = await params
    const body = await request.json()
    const { locationId, employeeId, splitOrder = false } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Find all tables in this virtual group
    const tables = await db.table.findMany({
      where: {
        virtualGroupId: groupId,
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
            },
          },
        },
      },
    })

    if (tables.length === 0) {
      return NextResponse.json(
        { error: 'Virtual group not found' },
        { status: 404 }
      )
    }

    const primaryTable = tables.find(t => t.virtualGroupPrimary)
    if (!primaryTable) {
      return NextResponse.json(
        { error: 'Primary table not found in group' },
        { status: 500 }
      )
    }

    // Check if any table has open orders with items (unless force flag is set)
    // Note: The query already filters for orders with status: 'open'
    const { force = false } = body
    if (!force) {
      const tablesWithUnpaidItems = tables.filter(table =>
        table.orders.some(order => order.items.length > 0)
      )
      if (tablesWithUnpaidItems.length > 0) {
        return NextResponse.json(
          {
            error: 'tables_have_open_orders',
            message: `Cannot dissolve group. ${tablesWithUnpaidItems.length} table(s) have unpaid items.`,
            tablesWithOrders: tablesWithUnpaidItems.map(t => ({ id: t.id, name: t.name })),
          },
          { status: 400 }
        )
      }
    }

    const primaryOrder = primaryTable.orders[0]

    // Start transaction
    await db.$transaction(async (tx) => {
      // Declare itemsByTable outside the if block so it's available in table update loop
      let itemsByTable: Map<string, typeof primaryOrder.items> | null = null

      // If splitting order by table and there's an active order
      if (splitOrder && primaryOrder) {
        // Group items by sourceTableId
        itemsByTable = new Map<string, typeof primaryOrder.items>()

        for (const item of primaryOrder.items) {
          // Items with sourceTableId go to that table
          // Items without stay on primary
          const targetTableId = item.sourceTableId || primaryTable.id
          if (!itemsByTable.has(targetTableId)) {
            itemsByTable.set(targetTableId, [])
          }
          itemsByTable.get(targetTableId)!.push(item)
        }

        // Create new orders for secondary tables
        for (const table of tables) {
          if (table.id === primaryTable.id) continue

          const tableItems = itemsByTable.get(table.id)
          if (!tableItems || tableItems.length === 0) continue

          // Calculate totals for this table's items
          const subtotal = tableItems.reduce(
            (sum, item) => sum + Number(item.itemTotal),
            0
          )
          const modifierTotal = tableItems.reduce(
            (sum, item) => sum + Number(item.modifierTotal),
            0
          )

          // Create new order for this table
          const newOrder = await tx.order.create({
            data: {
              locationId,
              employeeId: primaryOrder.employeeId,
              orderNumber: primaryOrder.orderNumber, // Keep same order number with suffix
              displayNumber: `${primaryOrder.displayNumber || primaryOrder.orderNumber}-${table.name}`,
              orderType: primaryOrder.orderType,
              orderTypeId: primaryOrder.orderTypeId,
              tableId: table.id,
              guestCount: 1,
              status: 'open',
              subtotal,
              total: subtotal + modifierTotal,
              parentOrderId: primaryOrder.id,
              notes: `Split from virtual group on ${primaryTable.name}`,
            },
          })

          // Move items to new order and clear sourceTableId
          await tx.orderItem.updateMany({
            where: {
              id: { in: tableItems.map(i => i.id) },
            },
            data: {
              orderId: newOrder.id,
              sourceTableId: null, // Clear since item now belongs to its actual table
            },
          })
        }

        // Recalculate primary order totals (items that stayed)
        const remainingItems = itemsByTable.get(primaryTable.id) || []
        const remainingSubtotal = remainingItems.reduce(
          (sum, item) => sum + Number(item.itemTotal),
          0
        )
        const remainingModifierTotal = remainingItems.reduce(
          (sum, item) => sum + Number(item.modifierTotal),
          0
        )

        await tx.order.update({
          where: { id: primaryOrder.id },
          data: {
            subtotal: remainingSubtotal,
            total: remainingSubtotal + remainingModifierTotal,
            notes: primaryOrder.notes
              ? `${primaryOrder.notes}\n[Split on dissolve]`
              : '[Split on dissolve]',
          },
        })

        // Clear sourceTableId on remaining items
        await tx.orderItem.updateMany({
          where: {
            orderId: primaryOrder.id,
            deletedAt: null,
          },
          data: {
            sourceTableId: null,
          },
        })
      }

      // Clear virtual group from all tables
      for (const table of tables) {
        await tx.table.update({
          where: { id: table.id },
          data: {
            virtualGroupId: null,
            virtualGroupPrimary: false,
            virtualGroupColor: null,
            virtualGroupCreatedAt: null,
            // Update status based on whether table still has an order
            status: splitOrder && table.id !== primaryTable.id
              ? itemsByTable?.get(table.id)?.length ? 'occupied' : 'available'
              : table.status,
          },
        })
      }

      // Restore original seat labels
      // Fetch all seats for tables in the group
      const allSeats = await tx.seat.findMany({
        where: {
          tableId: { in: tables.map(t => t.id) },
          isActive: true,
          deletedAt: null,
        },
        select: {
          id: true,
          tableId: true,
          seatNumber: true,
          label: true,
        },
      })

      // Restore each seat's original label (just the seat number)
      for (const seat of allSeats) {
        // Check if label has table prefix format (e.g., "T1-3")
        const hasTablePrefix = seat.label.includes('-')

        if (hasTablePrefix) {
          // Restore to original seat number format
          await tx.seat.update({
            where: { id: seat.id },
            data: {
              label: String(seat.seatNumber), // Simple number format
            },
          })
        }
      }

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'virtual_group_dissolved',
          entityType: 'table',
          entityId: primaryTable.id,
          details: {
            virtualGroupId: groupId,
            tableIds: tables.map(t => t.id),
            tableNames: tables.map(t => t.name),
            splitOrder,
            seatsRestored: allSeats.length,
          },
        },
      })
    })

    // Emit real-time event
    tableEvents.virtualGroupDissolved?.({
      virtualGroupId: groupId,
      tableIds: tables.map(t => t.id),
      locationId,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: {
        dissolved: true,
        tableIds: tables.map(t => t.id),
        splitOrder,
        message: `Virtual group dissolved${splitOrder ? ' with order split by table' : ''}`,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Dissolve failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to dissolve virtual group', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/[groupId]/remove/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'

/**
 * POST /api/tables/virtual-combine/[groupId]/remove
 *
 * Remove a table from a virtual group:
 * - Clears virtual group fields from the table
 * - If primary is removed, promotes another table or dissolves group
 * - Optionally creates a new order with this table's items
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  try {
    const { groupId } = await params
    const body = await request.json()
    const { tableId, locationId, employeeId, createNewOrder = false } = body

    if (!tableId || !locationId) {
      return NextResponse.json(
        { error: 'tableId and locationId are required' },
        { status: 400 }
      )
    }

    // Find all tables in this virtual group
    const allGroupTables = await db.table.findMany({
      where: {
        virtualGroupId: groupId,
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
            },
          },
        },
      },
    })

    if (allGroupTables.length === 0) {
      return NextResponse.json(
        { error: 'Virtual group not found' },
        { status: 404 }
      )
    }

    const tableToRemove = allGroupTables.find(t => t.id === tableId)
    if (!tableToRemove) {
      return NextResponse.json(
        { error: 'Table not found in this virtual group' },
        { status: 404 }
      )
    }

    // Check if table has open/unpaid order (unless force flag is set)
    // Note: The query already filters for orders with status: 'open'
    const { force = false } = body
    if (!force && tableToRemove.orders.length > 0) {
      // Table has open orders with items = unpaid items
      const hasUnpaidItems = tableToRemove.orders.some(order =>
        order.items.length > 0
      )
      if (hasUnpaidItems) {
        return NextResponse.json(
          {
            error: 'table_has_open_order',
            message: 'Cannot remove table with unpaid items. Pay or transfer items first.',
          },
          { status: 400 }
        )
      }
    }

    const primaryTable = allGroupTables.find(t => t.virtualGroupPrimary)
    const isPrimaryBeingRemoved = tableToRemove.virtualGroupPrimary
    const remainingTables = allGroupTables.filter(t => t.id !== tableId)

    // If only 2 tables and removing one, dissolve the whole group
    if (allGroupTables.length <= 2) {
      // Redirect to dissolve logic
      const result = await db.$transaction(async (tx) => {
        // Clear virtual group from all tables
        for (const table of allGroupTables) {
          await tx.table.update({
            where: { id: table.id },
            data: {
              virtualGroupId: null,
              virtualGroupPrimary: false,
              virtualGroupColor: null,
              virtualGroupCreatedAt: null,
            },
          })
        }

        // Create audit log
        await tx.auditLog.create({
          data: {
            locationId,
            employeeId: employeeId || null,
            action: 'virtual_group_dissolved',
            entityType: 'table',
            entityId: primaryTable?.id || tableId,
            details: {
              virtualGroupId: groupId,
              reason: 'Last table removed',
              removedTableId: tableId,
            },
          },
        })

        return { dissolved: true }
      })

      tableEvents.virtualGroupDissolved?.({
        virtualGroupId: groupId,
        tableIds: allGroupTables.map(t => t.id),
        locationId,
        timestamp: new Date().toISOString(),
        triggeredBy: employeeId,
      })

      return NextResponse.json({
        data: {
          dissolved: true,
          tableIds: allGroupTables.map(t => t.id),
          message: 'Virtual group dissolved (only 2 tables)',
        },
      })
    }

    // Start transaction for removing single table
    const result = await db.$transaction(async (tx) => {
      // Handle items with sourceTableId matching this table
      if (createNewOrder && primaryTable) {
        const primaryOrder = primaryTable.orders[0]
        if (primaryOrder) {
          // Find items that came from this table
          const itemsFromThisTable = primaryOrder.items.filter(
            item => item.sourceTableId === tableId
          )

          if (itemsFromThisTable.length > 0) {
            // Calculate totals
            const subtotal = itemsFromThisTable.reduce(
              (sum, item) => sum + Number(item.itemTotal),
              0
            )
            const modifierTotal = itemsFromThisTable.reduce(
              (sum, item) => sum + Number(item.modifierTotal),
              0
            )

            // Create new order for the removed table
            const newOrder = await tx.order.create({
              data: {
                locationId,
                employeeId: primaryOrder.employeeId,
                orderNumber: primaryOrder.orderNumber,
                displayNumber: `${primaryOrder.displayNumber || primaryOrder.orderNumber}-${tableToRemove.name}`,
                orderType: primaryOrder.orderType,
                orderTypeId: primaryOrder.orderTypeId,
                tableId: tableId,
                guestCount: 1,
                status: 'open',
                subtotal,
                total: subtotal + modifierTotal,
                parentOrderId: primaryOrder.id,
                notes: `Split from virtual group on ${primaryTable.name}`,
              },
            })

            // Move items to new order
            await tx.orderItem.updateMany({
              where: {
                id: { in: itemsFromThisTable.map(i => i.id) },
              },
              data: {
                orderId: newOrder.id,
                sourceTableId: null,
              },
            })

            // Recalculate primary order totals
            const remainingItems = primaryOrder.items.filter(
              item => item.sourceTableId !== tableId
            )
            const remainingSubtotal = remainingItems.reduce(
              (sum, item) => sum + Number(item.itemTotal),
              0
            )
            const remainingModifierTotal = remainingItems.reduce(
              (sum, item) => sum + Number(item.modifierTotal),
              0
            )

            await tx.order.update({
              where: { id: primaryOrder.id },
              data: {
                subtotal: remainingSubtotal,
                total: remainingSubtotal + remainingModifierTotal,
              },
            })
          }
        }
      }

      // If removing primary, promote another table
      if (isPrimaryBeingRemoved && remainingTables.length > 0) {
        const newPrimary = remainingTables[0]
        await tx.table.update({
          where: { id: newPrimary.id },
          data: {
            virtualGroupPrimary: true,
          },
        })
      }

      // Remove table from virtual group
      const updatedTable = await tx.table.update({
        where: { id: tableId },
        data: {
          virtualGroupId: null,
          virtualGroupPrimary: false,
          virtualGroupColor: null,
          virtualGroupCreatedAt: null,
          status: createNewOrder ? 'occupied' : 'available',
        },
        include: {
          section: { select: { id: true, name: true, color: true } },
        },
      })

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'virtual_group_member_removed',
          entityType: 'table',
          entityId: tableId,
          details: {
            virtualGroupId: groupId,
            removedTableId: tableId,
            removedTableName: tableToRemove.name,
            wasPrimary: isPrimaryBeingRemoved,
            newPrimaryId: isPrimaryBeingRemoved ? remainingTables[0]?.id : undefined,
            createdNewOrder: createNewOrder,
          },
        },
      })

      return updatedTable
    })

    // Emit real-time event
    tableEvents.virtualGroupMemberRemoved?.({
      virtualGroupId: groupId,
      tableId,
      locationId,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    return NextResponse.json({
      data: {
        table: {
          id: result.id,
          name: result.name,
          status: result.status,
          section: result.section,
        },
        remainingTables: remainingTables.length,
        message: `${tableToRemove.name} removed from virtual group`,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Remove failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to remove table from virtual group', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/[groupId]/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * GET /api/tables/virtual-combine/[groupId]?locationId=xxx
 *
 * Get virtual group details with per-table financial breakdown.
 * Used for GroupSummary checkout view.
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  try {
    const { groupId } = await params
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Find all tables in this virtual group with their orders
    const tables = await db.table.findMany({
      where: {
        virtualGroupId: groupId,
        locationId,
        deletedAt: null,
      },
      include: {
        section: { select: { id: true, name: true, color: true } },
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
              include: {
                menuItem: { select: { id: true, name: true } },
              },
            },
            payments: {
              where: { deletedAt: null },
            },
          },
        },
      },
      orderBy: [
        { virtualGroupPrimary: 'desc' }, // Primary first
        { name: 'asc' },
      ],
    })

    if (tables.length === 0) {
      return NextResponse.json(
        { error: 'Virtual group not found' },
        { status: 404 }
      )
    }

    const primaryTable = tables.find(t => t.virtualGroupPrimary)
    if (!primaryTable) {
      return NextResponse.json(
        { error: 'Primary table not found in group' },
        { status: 500 }
      )
    }

    const primaryOrder = primaryTable.orders[0] ?? null

    // Type for order items from the query
    type OrderItemWithMenuItem = NonNullable<typeof primaryOrder>['items'][number]

    // Build per-table financial breakdown
    const financials = tables.map((table) => {
      // Get items for this table (based on sourceTableId or direct table assignment)
      let tableItems: OrderItemWithMenuItem[] = []

      if (primaryOrder) {
        if (table.id === primaryTable.id) {
          // Primary table gets items without sourceTableId (or with its own ID)
          tableItems = primaryOrder.items.filter(
            (item) => !item.sourceTableId || item.sourceTableId === table.id
          )
        } else {
          // Secondary tables get items with their sourceTableId
          tableItems = primaryOrder.items.filter(
            (item) => item.sourceTableId === table.id
          )
        }
      }

      // Calculate financials for this table's items
      const subtotal = tableItems.reduce(
        (sum: number, item) => sum + Number(item.itemTotal) + Number(item.modifierTotal),
        0
      )

      // For simplicity, assume tax is embedded in total or calculate based on settings
      // In a real system, you'd calculate tax per item based on tax rate
      const tax = 0 // Placeholder - implement based on your tax settings

      const total = subtotal + tax

      // Calculate payments made against this table's items
      // For virtual groups, payments are on the primary order
      // We'll attribute payments proportionally based on this table's share
      let paid = 0
      if (primaryOrder && primaryOrder.payments.length > 0) {
        const orderTotal = Number(primaryOrder.total)
        const tableShare = orderTotal > 0 ? subtotal / orderTotal : 0
        const totalPaid = primaryOrder.payments.reduce(
          (sum: number, p) => sum + Number(p.amount) + Number(p.tipAmount || 0),
          0
        )
        paid = totalPaid * tableShare
      }

      const remaining = Math.max(0, total - paid)

      return {
        tableId: table.id,
        tableName: table.name,
        tableAbbreviation: table.abbreviation,
        isPrimary: table.virtualGroupPrimary,
        sectionId: table.section?.id,
        sectionName: table.section?.name,
        itemCount: tableItems.length,
        subtotal,
        tax,
        total,
        paid,
        remaining,
        items: tableItems.map((item) => ({
          id: item.id,
          name: item.menuItem?.name || item.name || 'Unknown Item',
          quantity: item.quantity,
          price: Number(item.price),
          modifierTotal: Number(item.modifierTotal),
          itemTotal: Number(item.itemTotal),
          seatNumber: item.seatNumber,
        })),
      }
    })

    // Calculate group totals
    const grandSubtotal = financials.reduce((sum, f) => sum + f.subtotal, 0)
    const grandTax = financials.reduce((sum, f) => sum + f.tax, 0)
    const grandTotal = financials.reduce((sum, f) => sum + f.total, 0)
    const grandPaid = financials.reduce((sum, f) => sum + f.paid, 0)
    const grandRemaining = financials.reduce((sum, f) => sum + f.remaining, 0)
    const totalItems = financials.reduce((sum, f) => sum + f.itemCount, 0)

    return NextResponse.json({
      data: {
        virtualGroupId: groupId,
        groupColor: primaryTable.virtualGroupColor,
        createdAt: primaryTable.virtualGroupCreatedAt?.toISOString(),
        primaryTableId: primaryTable.id,
        primaryTableName: primaryTable.name,
        tableCount: tables.length,
        order: primaryOrder
          ? {
              id: primaryOrder.id,
              orderNumber: primaryOrder.orderNumber,
              displayNumber: primaryOrder.displayNumber,
              status: primaryOrder.status,
            }
          : null,
        totals: {
          subtotal: grandSubtotal,
          tax: grandTax,
          total: grandTotal,
          paid: grandPaid,
          remaining: grandRemaining,
          itemCount: totalItems,
        },
        financials,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Get group failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to get virtual group', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/[groupId]/set-primary/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'

/**
 * POST /api/tables/virtual-combine/[groupId]/set-primary
 *
 * Change the primary table in a virtual group:
 * - The order moves from the old primary to the new primary
 * - sourceTableId on items is preserved for T-S notation
 * - UI should update to show new primary in order panel header
 *
 * Use case: Server realizes they started the group on the wrong table
 * and needs to switch which table is the "master"
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  try {
    const { groupId } = await params
    const body = await request.json()
    const { newPrimaryTableId, locationId, employeeId } = body

    if (!newPrimaryTableId || !locationId) {
      return NextResponse.json(
        { error: 'newPrimaryTableId and locationId are required' },
        { status: 400 }
      )
    }

    // Find all tables in this virtual group
    const groupTables = await db.table.findMany({
      where: {
        virtualGroupId: groupId,
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
            },
          },
        },
        section: { select: { id: true, name: true, color: true } },
      },
    })

    if (groupTables.length === 0) {
      return NextResponse.json(
        { error: 'Virtual group not found' },
        { status: 404 }
      )
    }

    const newPrimaryTable = groupTables.find(t => t.id === newPrimaryTableId)
    if (!newPrimaryTable) {
      return NextResponse.json(
        { error: 'New primary table is not part of this virtual group' },
        { status: 400 }
      )
    }

    const currentPrimaryTable = groupTables.find(t => t.virtualGroupPrimary)
    if (!currentPrimaryTable) {
      return NextResponse.json(
        { error: 'No current primary table found' },
        { status: 500 }
      )
    }

    // If already primary, nothing to do
    if (currentPrimaryTable.id === newPrimaryTableId) {
      return NextResponse.json({
        data: {
          message: 'Table is already the primary',
          primaryTableId: newPrimaryTableId,
        },
      })
    }

    const currentOrder = currentPrimaryTable.orders[0]

    // Execute the switch in a transaction
    const result = await db.$transaction(async (tx) => {
      // 1. Move the order to the new primary table
      if (currentOrder) {
        await tx.order.update({
          where: { id: currentOrder.id },
          data: {
            tableId: newPrimaryTableId,
            notes: currentOrder.notes
              ? `${currentOrder.notes}\n[Primary switched from ${currentPrimaryTable.name} to ${newPrimaryTable.name}]`
              : `[Primary switched from ${currentPrimaryTable.name} to ${newPrimaryTable.name}]`,
          },
        })
      }

      // 2. Update old primary - remove primary flag
      await tx.table.update({
        where: { id: currentPrimaryTable.id },
        data: {
          virtualGroupPrimary: false,
        },
      })

      // 3. Update new primary - set primary flag
      const updatedNewPrimary = await tx.table.update({
        where: { id: newPrimaryTableId },
        data: {
          virtualGroupPrimary: true,
        },
        include: {
          section: { select: { id: true, name: true, color: true } },
          orders: {
            where: { status: 'open', deletedAt: null },
            select: {
              id: true,
              orderNumber: true,
              guestCount: true,
              total: true,
              createdAt: true,
            },
          },
        },
      })

      // 4. Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'virtual_group_primary_changed',
          entityType: 'table',
          entityId: newPrimaryTableId,
          details: {
            virtualGroupId: groupId,
            previousPrimaryId: currentPrimaryTable.id,
            previousPrimaryName: currentPrimaryTable.name,
            newPrimaryId: newPrimaryTableId,
            newPrimaryName: newPrimaryTable.name,
            orderId: currentOrder?.id || null,
          },
        },
      })

      return updatedNewPrimary
    })

    // Emit real-time event
    tableEvents.virtualGroupPrimaryChanged?.({
      virtualGroupId: groupId,
      previousPrimaryId: currentPrimaryTable.id,
      newPrimaryId: newPrimaryTableId,
      locationId,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    return NextResponse.json({
      data: {
        table: {
          id: result.id,
          name: newPrimaryTable.name,
          virtualGroupId: result.virtualGroupId,
          virtualGroupPrimary: result.virtualGroupPrimary,
          virtualGroupColor: result.virtualGroupColor,
          status: result.status,
          section: result.section,
          currentOrder: result.orders[0]
            ? {
                id: result.orders[0].id,
                orderNumber: result.orders[0].orderNumber,
                guestCount: result.orders[0].guestCount,
                total: Number(result.orders[0].total),
                openedAt: result.orders[0].createdAt.toISOString(),
              }
            : null,
        },
        previousPrimaryId: currentPrimaryTable.id,
        message: `Primary table changed from ${currentPrimaryTable.name} to ${newPrimaryTable.name}`,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Set primary failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to change primary table', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/[groupId]/transfer/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * POST /api/tables/virtual-combine/[groupId]/transfer
 *
 * Transfer an entire virtual group to a new server.
 * This is a manager action that reassigns the order to a new employee.
 *
 * Use case: Server's shift ends but their large party is still dining.
 * Manager can transfer the entire group to the closing server in one action.
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  try {
    const { groupId } = await params
    const body = await request.json()
    const { newServerId, locationId, managerId, reason } = body

    if (!newServerId || !locationId) {
      return NextResponse.json(
        { error: 'newServerId and locationId are required' },
        { status: 400 }
      )
    }

    // Verify the new server exists and is active
    const newServer = await db.employee.findFirst({
      where: {
        id: newServerId,
        locationId,
        isActive: true,
        deletedAt: null,
      },
      select: { id: true, firstName: true, lastName: true },
    })

    if (!newServer) {
      return NextResponse.json(
        { error: 'New server not found or not active' },
        { status: 404 }
      )
    }

    // Find all tables in the virtual group
    const groupTables = await db.table.findMany({
      where: {
        virtualGroupId: groupId,
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          select: {
            id: true,
            employeeId: true,
            notes: true,
            employee: { select: { firstName: true, lastName: true } },
          },
        },
      },
    })

    if (groupTables.length === 0) {
      return NextResponse.json(
        { error: 'Virtual group not found' },
        { status: 404 }
      )
    }

    const primaryTable = groupTables.find((t) => t.virtualGroupPrimary)
    if (!primaryTable) {
      return NextResponse.json(
        { error: 'Primary table not found in group' },
        { status: 500 }
      )
    }

    const primaryOrder = primaryTable.orders[0]
    if (!primaryOrder) {
      return NextResponse.json(
        { error: 'No open order found for this group' },
        { status: 400 }
      )
    }

    const previousServer = primaryOrder.employee
    const previousServerId = primaryOrder.employeeId

    // Don't transfer if it's the same server
    if (previousServerId === newServerId) {
      return NextResponse.json({
        data: {
          message: 'Order is already assigned to this server',
          serverId: newServerId,
          serverName: `${newServer.firstName} ${newServer.lastName}`,
        },
      })
    }

    // Execute the transfer in a transaction
    await db.$transaction(async (tx) => {
      // Update the order to the new server
      await tx.order.update({
        where: { id: primaryOrder.id },
        data: {
          employeeId: newServerId,
          notes: primaryOrder.notes
            ? `${primaryOrder.notes}\n[Transferred from ${previousServer?.firstName || 'Unknown'} to ${newServer.firstName} by manager]`
            : `[Transferred from ${previousServer?.firstName || 'Unknown'} to ${newServer.firstName} by manager]`,
        },
      })

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: managerId || null,
          action: 'virtual_group_transferred',
          entityType: 'order',
          entityId: primaryOrder.id,
          details: {
            virtualGroupId: groupId,
            previousServerId,
            previousServerName: previousServer
              ? `${previousServer.firstName} ${previousServer.lastName}`
              : 'Unknown',
            newServerId,
            newServerName: `${newServer.firstName} ${newServer.lastName}`,
            tableCount: groupTables.length,
            tableNames: groupTables.map((t) => t.name),
            reason: reason || 'Shift change',
          },
        },
      })
    })

    // Notify POS terminals of virtual group transfer
    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: {
        transferred: true,
        virtualGroupId: groupId,
        orderId: primaryOrder.id,
        previousServer: previousServer
          ? {
              id: previousServerId,
              name: `${previousServer.firstName} ${previousServer.lastName}`,
            }
          : null,
        newServer: {
          id: newServerId,
          name: `${newServer.firstName} ${newServer.lastName}`,
        },
        tableCount: groupTables.length,
        message: `Group transferred from ${previousServer?.firstName || 'Unknown'} to ${newServer.firstName}`,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Transfer failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to transfer virtual group', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/active/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * GET /api/tables/virtual-combine/active?locationId=xxx
 *
 * Get all active virtual groups for the manager dashboard.
 * Returns grouped data with member tables, orders, and statistics.
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Find all tables that are in a virtual group
    const tablesInGroups = await db.table.findMany({
      where: {
        locationId,
        virtualGroupId: { not: null },
        deletedAt: null,
      },
      include: {
        section: { select: { id: true, name: true, color: true } },
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            employee: {
              select: { id: true, firstName: true, lastName: true },
            },
            items: {
              where: { deletedAt: null },
              select: { id: true },
            },
            payments: {
              where: { deletedAt: null },
              select: { id: true, amount: true, tipAmount: true },
            },
          },
        },
      },
      orderBy: { name: 'asc' },
    })

    // Group tables by virtualGroupId
    const groupsMap = new Map<string, {
      id: string
      primaryTableId: string
      primaryTableName: string
      groupColor: string
      createdAt: string
      members: typeof tablesInGroups
      totalSpend: number
      totalGuests: number
      totalItems: number
      hasPendingPayments: boolean
      serverId?: string
      serverName: string
    }>()

    for (const table of tablesInGroups) {
      const groupId = table.virtualGroupId!

      if (!groupsMap.has(groupId)) {
        groupsMap.set(groupId, {
          id: groupId,
          primaryTableId: '',
          primaryTableName: '',
          groupColor: table.virtualGroupColor || '#06b6d4',
          createdAt: table.virtualGroupCreatedAt?.toISOString() || new Date().toISOString(),
          members: [],
          totalSpend: 0,
          totalGuests: 0,
          totalItems: 0,
          hasPendingPayments: false,
          serverName: 'Unassigned',
        })
      }

      const group = groupsMap.get(groupId)!
      group.members.push(table)

      // Calculate totals from orders
      const order = table.orders[0]
      if (order) {
        group.totalSpend += Number(order.total)
        group.totalGuests += order.guestCount
        group.totalItems += order.items.length

        if (order.payments.length > 0) {
          group.hasPendingPayments = true
        }
      }

      // Track primary table info
      if (table.virtualGroupPrimary) {
        group.primaryTableId = table.id
        group.primaryTableName = table.name
        if (order?.employee) {
          group.serverId = order.employee.id
          group.serverName = `${order.employee.firstName} ${order.employee.lastName}`
        }
      }
    }

    // Convert to array and format for response
    const groups = Array.from(groupsMap.values()).map((group) => ({
      id: group.id,
      primaryTableId: group.primaryTableId,
      primaryTableName: group.primaryTableName,
      groupColor: group.groupColor,
      createdAt: group.createdAt,
      tableCount: group.members.length,
      totalSpend: group.totalSpend,
      totalGuests: group.totalGuests,
      totalItems: group.totalItems,
      hasPendingPayments: group.hasPendingPayments,
      serverId: group.serverId,
      serverName: group.serverName,
      members: group.members.map((t) => ({
        id: t.id,
        name: t.name,
        abbreviation: t.abbreviation,
        isPrimary: t.virtualGroupPrimary,
        sectionName: t.section?.name,
        currentOrder: t.orders[0]
          ? {
              id: t.orders[0].id,
              orderNumber: t.orders[0].orderNumber,
              total: Number(t.orders[0].total),
              guestCount: t.orders[0].guestCount,
              itemCount: t.orders[0].items.length,
            }
          : null,
      })),
    }))

    // Sort by creation time (oldest first - they've been waiting longest)
    groups.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())

    // Calculate summary stats
    const summary = {
      totalGroups: groups.length,
      totalTablesLinked: tablesInGroups.length,
      totalGroupSpend: groups.reduce((sum, g) => sum + g.totalSpend, 0),
      highValueGroups: groups.filter((g) => g.totalSpend >= 500).length,
    }

    return NextResponse.json({
      data: {
        summary,
        groups,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Get active groups failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to get active virtual groups', details: errorMessage },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-combine/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { tableEvents } from '@/lib/realtime/table-events'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import {
  calculateVirtualSeatNumbers,
  type TableWithSeats,
} from '@/lib/virtual-group-seats'
import { getVirtualGroupColor } from '@/lib/virtual-group-colors'

/**
 * POST /api/tables/virtual-combine
 *
 * Create a virtual group from selected tables:
 * - Tables remain in their physical positions (no movement)
 * - Each table keeps its own seat numbers (T2-S1 notation)
 * - Tables share a single order on the primary table
 * - All tables get matching pulsing glow color
 *
 * If any tables have existing orders, returns requiresAction=true
 * with the list of orders that need to be handled (merge or close)
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      tableIds,
      primaryTableId,
      locationId,
      employeeId,
      existingOrderActions, // Optional: { orderId, action: 'merge' | 'close' }[]
      visualOffsets, // Optional: { tableId: string, offsetX: number, offsetY: number }[]
    } = body

    if (!tableIds || !Array.isArray(tableIds) || tableIds.length < 2) {
      return NextResponse.json(
        { error: 'At least 2 table IDs are required' },
        { status: 400 }
      )
    }

    if (!primaryTableId || !tableIds.includes(primaryTableId)) {
      return NextResponse.json(
        { error: 'primaryTableId must be one of the selected tables' },
        { status: 400 }
      )
    }

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Fetch all selected tables
    const tables = await db.table.findMany({
      where: {
        id: { in: tableIds },
        locationId,
        deletedAt: null,
      },
      include: {
        orders: {
          where: { status: 'open', deletedAt: null },
          include: {
            items: {
              where: { deletedAt: null },
              select: { id: true, name: true, price: true, quantity: true },
            },
          },
        },
      },
    })

    if (tables.length !== tableIds.length) {
      return NextResponse.json(
        { error: 'One or more tables not found' },
        { status: 404 }
      )
    }

    // Check if any table is already in a virtual group
    const alreadyGrouped = tables.find(t => t.virtualGroupId)
    if (alreadyGrouped) {
      return NextResponse.json(
        { error: `Table "${alreadyGrouped.name}" is already in a virtual group` },
        { status: 400 }
      )
    }

    // Check if any table is already physically combined
    const alreadyCombined = tables.find(t => t.combinedWithId || (t.combinedTableIds && (t.combinedTableIds as string[]).length > 0))
    if (alreadyCombined) {
      return NextResponse.json(
        { error: `Table "${alreadyCombined.name}" is already physically combined` },
        { status: 400 }
      )
    }

    // Check for existing orders that need handling
    const tablesWithOrders = tables.filter(t => t.orders.length > 0)
    const secondaryTablesWithOrders = tablesWithOrders.filter(t => t.id !== primaryTableId)

    // If there are secondary tables with orders and no actions provided, return requiresAction
    if (secondaryTablesWithOrders.length > 0 && !existingOrderActions) {
      return NextResponse.json({
        requiresAction: true,
        existingOrders: secondaryTablesWithOrders.map(t => ({
          tableId: t.id,
          tableName: t.name,
          orderId: t.orders[0].id,
          orderNumber: t.orders[0].orderNumber,
          itemCount: t.orders[0].items.length,
          total: Number(t.orders[0].total),
        })),
        message: 'Some tables have open orders that need to be handled',
      })
    }

    // Generate virtual group ID and color
    const virtualGroupId = crypto.randomUUID()
    const virtualGroupColor = getVirtualGroupColor(virtualGroupId)
    const virtualGroupCreatedAt = new Date()

    // Start transaction
    const result = await db.$transaction(async (tx) => {
      const primaryTable = tables.find(t => t.id === primaryTableId)!
      const primaryOrder = primaryTable.orders[0]

      // Handle existing orders on secondary tables
      if (existingOrderActions && Array.isArray(existingOrderActions)) {
        for (const action of existingOrderActions) {
          const { orderId, action: orderAction } = action
          const table = tables.find(t => t.orders.some(o => o.id === orderId))

          if (!table || table.id === primaryTableId) continue

          const order = table.orders.find(o => o.id === orderId)
          if (!order) continue

          if (orderAction === 'merge') {
            // Merge items into primary order
            if (primaryOrder) {
              // Move items to primary order, setting sourceTableId
              await tx.orderItem.updateMany({
                where: {
                  orderId: order.id,
                  locationId,
                  deletedAt: null,
                },
                data: {
                  orderId: primaryOrder.id,
                  sourceTableId: table.id, // Track which table this came from
                },
              })

              // Update primary order totals
              const newGuestCount = primaryOrder.guestCount + order.guestCount
              const combinedSubtotal = Number(primaryOrder.subtotal) + Number(order.subtotal)
              const combinedTax = Number(primaryOrder.taxTotal) + Number(order.taxTotal)
              const combinedTotal = Number(primaryOrder.total) + Number(order.total)

              await tx.order.update({
                where: { id: primaryOrder.id },
                data: {
                  guestCount: newGuestCount,
                  subtotal: combinedSubtotal,
                  taxTotal: combinedTax,
                  total: combinedTotal,
                  notes: primaryOrder.notes
                    ? `${primaryOrder.notes}\n[Merged from ${table.name}]`
                    : `[Merged from ${table.name}]`,
                },
              })

              // Mark original order as merged (prevents double-counting in EOD)
              await tx.order.update({
                where: { id: order.id },
                data: {
                  status: 'merged',
                  notes: `Merged into order #${primaryOrder.orderNumber} (virtual group)`,
                },
              })
            } else {
              // No primary order - reassign this order to primary table
              // and set sourceTableId on items
              await tx.orderItem.updateMany({
                where: {
                  orderId: order.id,
                  locationId,
                  deletedAt: null,
                },
                data: {
                  sourceTableId: table.id,
                },
              })

              await tx.order.update({
                where: { id: order.id },
                data: {
                  tableId: primaryTableId,
                },
              })
            }
          }
          // 'close' action would redirect to payment flow - handled by frontend
        }
      }

      // Update all tables with virtual group info
      for (const table of tables) {
        // Find visual offset for this table (if provided)
        const offset = visualOffsets?.find((o: { tableId: string; offsetX: number; offsetY: number }) => o.tableId === table.id)

        await tx.table.update({
          where: { id: table.id },
          data: {
            virtualGroupId,
            virtualGroupPrimary: table.id === primaryTableId,
            virtualGroupColor,
            virtualGroupCreatedAt,
            // Store visual offsets for rendering after refresh
            virtualGroupOffsetX: offset?.offsetX ?? 0,
            virtualGroupOffsetY: offset?.offsetY ?? 0,
            // Update status to occupied if any table has an order
            status: tablesWithOrders.length > 0 ? 'occupied' : table.status,
          },
        })
      }

      // Handle seat renumbering for virtual group
      // Fetch all seats for the tables in the group
      const allSeats = await tx.seat.findMany({
        where: {
          tableId: { in: tableIds },
          isActive: true,
          deletedAt: null,
        },
        select: {
          id: true,
          tableId: true,
          seatNumber: true,
          label: true,
          relativeX: true,
          relativeY: true,
        },
        orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
      })

      if (allSeats.length > 0) {
        // Prepare table data for virtual seat calculation
        const tablesWithSeats: TableWithSeats[] = tables.map((table) => ({
          id: table.id,
          name: table.name,
          posX: table.posX,
          posY: table.posY,
          seats: allSeats
            .filter((seat) => seat.tableId === table.id)
            .map((seat) => ({
              id: seat.id,
              seatNumber: seat.seatNumber,
              label: seat.label,
              relativeX: seat.relativeX,
              relativeY: seat.relativeY,
            })),
        }))

        // Calculate virtual seat numbers (primary table first, then others clockwise)
        const virtualSeatInfo = calculateVirtualSeatNumbers(
          primaryTableId,
          tablesWithSeats
        )

        // Update each seat with virtual label (e.g., "T1-3")
        for (const seatInfo of virtualSeatInfo) {
          await tx.seat.update({
            where: { id: seatInfo.seatId },
            data: {
              label: seatInfo.virtualLabel, // Store "TableName-SeatNum" format
            },
          })
        }
      }

      // Create audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'virtual_group_created',
          entityType: 'table',
          entityId: primaryTableId,
          details: {
            virtualGroupId,
            primaryTableId,
            memberTableIds: tableIds,
            tableNames: tables.map(t => t.name),
            groupColor: virtualGroupColor,
            ordersHandled: existingOrderActions?.length || 0,
            seatsRenumbered: allSeats.length,
          },
        },
      })

      // Fetch updated tables for response
      const updatedTables = await tx.table.findMany({
        where: { id: { in: tableIds } },
        include: {
          section: { select: { id: true, name: true, color: true } },
          orders: {
            where: { status: 'open', deletedAt: null },
            select: {
              id: true,
              orderNumber: true,
              guestCount: true,
              total: true,
              createdAt: true,
            },
          },
        },
      })

      return updatedTables
    })

    // Emit real-time event
    tableEvents.virtualGroupCreated?.({
      virtualGroupId,
      primaryTableId,
      tableIds,
      groupColor: virtualGroupColor,
      locationId,
      timestamp: new Date().toISOString(),
      triggeredBy: employeeId,
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: {
        virtualGroupId,
        groupColor: virtualGroupColor,
        primaryTableId,
        memberTableIds: tableIds,
        tables: result.map(t => ({
          id: t.id,
          name: t.name,
          virtualGroupId: t.virtualGroupId,
          virtualGroupPrimary: t.virtualGroupPrimary,
          virtualGroupColor: t.virtualGroupColor,
          status: t.status,
          section: t.section,
          currentOrder: t.orders[0]
            ? {
                id: t.orders[0].id,
                orderNumber: t.orders[0].orderNumber,
                guestCount: t.orders[0].guestCount,
                total: Number(t.orders[0].total),
                openedAt: t.orders[0].createdAt.toISOString(),
              }
            : null,
        })),
        message: `Virtual group created with ${tableIds.length} tables`,
      },
    })
  } catch (error) {
    console.error('[VirtualCombine] Failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to create virtual group', details: errorMessage },
      { status: 500 }
    )
  }
}

/**
 * GET /api/tables/virtual-combine?locationId=xxx
 *
 * List all active virtual groups for a location
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId')

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Find all tables that are in virtual groups
    const groupedTables = await db.table.findMany({
      where: {
        locationId,
        virtualGroupId: { not: null },
        deletedAt: null,
      },
      select: {
        id: true,
        name: true,
        virtualGroupId: true,
        virtualGroupPrimary: true,
        virtualGroupColor: true,
        virtualGroupCreatedAt: true,
      },
      orderBy: { virtualGroupCreatedAt: 'desc' },
    })

    // Group by virtualGroupId
    const groups = new Map<string, typeof groupedTables>()
    for (const table of groupedTables) {
      const groupId = table.virtualGroupId!
      if (!groups.has(groupId)) {
        groups.set(groupId, [])
      }
      groups.get(groupId)!.push(table)
    }

    // Format response
    const virtualGroups = Array.from(groups.entries()).map(([groupId, tables]) => {
      const primary = tables.find(t => t.virtualGroupPrimary)
      return {
        virtualGroupId: groupId,
        primaryTableId: primary?.id,
        groupColor: primary?.virtualGroupColor,
        createdAt: primary?.virtualGroupCreatedAt,
        tables: tables.map(t => ({
          id: t.id,
          name: t.name,
          isPrimary: t.virtualGroupPrimary,
        })),
      }
    })

    return NextResponse.json({ data: virtualGroups })
  } catch (error) {
    console.error('[VirtualCombine] GET failed:', error)
    return NextResponse.json(
      { error: 'Failed to list virtual groups' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/virtual-group/route.ts
################################################################################

// src/app/api/tables/virtual-group/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { distributeSeatsOnPerimeter, getGroupBoundingBox, type TableRect } from '@/lib/table-geometry'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

type VirtualGroupAction = 'create' | 'add' | 'remove' | 'dissolve'

interface BaseBody {
  locationId: string
  employeeId?: string
  action: VirtualGroupAction
}

/**
 * CREATE: build a new virtual group from tableIds
 */
interface CreateVirtualGroupBody extends BaseBody {
  action: 'create'
  tableIds: string[] // physical tables
  primaryTableId: string // which one is the "main" virtual table
  name?: string
}

/**
 * ADD: add tableIds to an existing virtual group
 */
interface AddToVirtualGroupBody extends BaseBody {
  action: 'add'
  virtualGroupId: string
  tableIds: string[]
}

/**
 * REMOVE: remove specific tables from a virtual group
 */
interface RemoveFromVirtualGroupBody extends BaseBody {
  action: 'remove'
  virtualGroupId: string
  tableIds: string[]
}

/**
 * DISSOLVE: remove group from all tables
 */
interface DissolveVirtualGroupBody extends BaseBody {
  action: 'dissolve'
  virtualGroupId: string
}

type VirtualGroupBody =
  | CreateVirtualGroupBody
  | AddToVirtualGroupBody
  | RemoveFromVirtualGroupBody
  | DissolveVirtualGroupBody

/**
 * POST /api/tables/virtual-group
 *
 * Lightweight virtual grouping:
 * - Tables stay physically separate (no snap, no reposition)
 * - One "primary" virtual table for orders
 * - Seat layout handled via /api/tables/seats/reflow if needed
 */
export async function POST(request: NextRequest) {
  let body: VirtualGroupBody
  try {
    body = (await request.json()) as VirtualGroupBody
  } catch (err) {
    return NextResponse.json(
      { error: 'Invalid JSON in request body', details: String(err) },
      { status: 400 }
    )
  }

  const { locationId, action } = body

  if (!locationId || !action) {
    return NextResponse.json(
      { error: 'locationId and action are required' },
      { status: 400 }
    )
  }

  try {
    switch (action) {
      case 'create':
        return await handleCreate(body as CreateVirtualGroupBody)
      case 'add':
        return await handleAdd(body as AddToVirtualGroupBody)
      case 'remove':
        return await handleRemove(body as RemoveFromVirtualGroupBody)
      case 'dissolve':
        return await handleDissolve(body as DissolveVirtualGroupBody)
      default:
        return NextResponse.json(
          { error: `Unsupported action: ${action}` },
          { status: 400 }
        )
    }
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error'
    const stack = error instanceof Error ? error.stack : undefined

    return NextResponse.json(
      {
        error: 'Virtual group operation failed',
        details: msg,
        stack,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}

async function handleCreate(body: CreateVirtualGroupBody) {
  const { locationId, employeeId, tableIds, primaryTableId, name } = body

  if (!tableIds || tableIds.length < 2) {
    return NextResponse.json(
      { error: 'At least 2 tableIds are required to create a virtual group' },
      { status: 400 }
    )
  }
  if (!primaryTableId || !tableIds.includes(primaryTableId)) {
    return NextResponse.json(
      { error: 'primaryTableId must be one of tableIds' },
      { status: 400 }
    )
  }

  const tables = await db.table.findMany({
    where: { id: { in: tableIds }, locationId, deletedAt: null },
    select: {
      id: true,
      name: true,
      virtualGroupId: true,
      virtualGroupPrimary: true,
      posX: true,
      posY: true,
      width: true,
      height: true,
    },
  })

  if (tables.length !== tableIds.length) {
    return NextResponse.json(
      { error: 'One or more tables not found for this location' },
      { status: 404 }
    )
  }

  // Prevent mixing tables already in different virtual groups
  const existingGroups = new Set(
    tables.map(t => t.virtualGroupId).filter(Boolean) as string[]
  )
  if (existingGroups.size > 0) {
    return NextResponse.json(
      { error: 'Some tables are already part of another virtual group' },
      { status: 400 }
    )
  }

  const groupName =
    name ||
    tables
      .map(t => t.name)
      .sort()
      .join('+')

  const result = await db.$transaction(async tx => {
    const virtualGroup = await tx.virtualGroup.create({
      data: {
        locationId,
        name: groupName,
        primaryTableId,
      },
    })

    const color = '#38bdf8' // cyan-ish highlight

    for (const t of tables) {
      await tx.table.update({
        where: { id: t.id },
        data: {
          virtualGroupId: virtualGroup.id,
          virtualGroupPrimary: t.id === primaryTableId,
          virtualGroupColor: color,
        },
      })
    }

    await tx.auditLog.create({
      data: {
        locationId,
        employeeId: employeeId ?? null,
        action: 'virtual_group_created',
        entityType: 'virtual_group',
        entityId: virtualGroup.id,
        details: {
          tableIds,
          primaryTableId,
          name: groupName,
        },
      },
    })

    return { virtualGroup, color }
  })

  // Notify POS terminals of virtual group creation
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      virtualGroupId: result.virtualGroup.id,
      primaryTableId,
      name: result.virtualGroup.name,
      color: result.color,
      tableIds,
      message: 'Virtual group created',
    },
  })
}

async function handleAdd(body: AddToVirtualGroupBody) {
  const { locationId, employeeId, virtualGroupId, tableIds } = body

  if (!virtualGroupId) {
    return NextResponse.json(
      { error: 'virtualGroupId is required for add action' },
      { status: 400 }
    )
  }
  if (!tableIds || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'tableIds are required for add action' },
      { status: 400 }
    )
  }

  const group = await db.virtualGroup.findFirst({
    where: { id: virtualGroupId, locationId, deletedAt: null },
  })
  if (!group) {
    return NextResponse.json(
      { error: 'Virtual group not found' },
      { status: 404 }
    )
  }

  const tablesToAdd = await db.table.findMany({
    where: {
      id: { in: tableIds },
      locationId,
      deletedAt: null,
    },
    select: {
      id: true,
      name: true,
      virtualGroupId: true,
    },
  })

  if (tablesToAdd.length === 0) {
    return NextResponse.json(
      { error: 'No tables found to add' },
      { status: 404 }
    )
  }

  const conflicts = tablesToAdd.filter(
    t => t.virtualGroupId && t.virtualGroupId !== virtualGroupId
  )
  if (conflicts.length > 0) {
    return NextResponse.json(
      { error: 'Some tables are already in a different virtual group' },
      { status: 400 }
    )
  }

  const color = '#38bdf8'

  await db.$transaction(async tx => {
    for (const t of tablesToAdd) {
      await tx.table.update({
        where: { id: t.id },
        data: {
          virtualGroupId,
          virtualGroupPrimary: false,
          virtualGroupColor: color,
        },
      })
    }

    await tx.auditLog.create({
      data: {
        locationId,
        employeeId: employeeId ?? null,
        action: 'virtual_group_tables_added',
        entityType: 'virtual_group',
        entityId: virtualGroupId,
        details: {
          tableIds: tablesToAdd.map(t => t.id),
        },
      },
    })
  })

  // Notify POS terminals of tables added to virtual group
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      virtualGroupId,
      addedTableIds: tablesToAdd.map(t => t.id),
      color,
      message: 'Tables added to virtual group',
    },
  })
}

async function handleRemove(body: RemoveFromVirtualGroupBody) {
  const { locationId, employeeId, virtualGroupId, tableIds } = body

  if (!virtualGroupId) {
    return NextResponse.json(
      { error: 'virtualGroupId is required for remove action' },
      { status: 400 }
    )
  }
  if (!tableIds || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'tableIds are required for remove action' },
      { status: 400 }
    )
  }

  const group = await db.virtualGroup.findFirst({
    where: { id: virtualGroupId, locationId, deletedAt: null },
  })
  if (!group) {
    return NextResponse.json(
      { error: 'Virtual group not found' },
      { status: 404 }
    )
  }

  const tables = await db.table.findMany({
    where: {
      id: { in: tableIds },
      virtualGroupId,
      locationId,
      deletedAt: null,
    },
    select: {
      id: true,
      virtualGroupPrimary: true,
    },
  })

  if (tables.length === 0) {
    return NextResponse.json(
      { error: 'No tables from this group match given tableIds' },
      { status: 404 }
    )
  }

  const primaryIds = tables.filter(t => t.virtualGroupPrimary).map(t => t.id)

  await db.$transaction(async tx => {
    await tx.table.updateMany({
      where: { id: { in: tables.map(t => t.id) } },
      data: {
        virtualGroupId: null,
        virtualGroupPrimary: false,
        virtualGroupColor: null,
      },
    })

    // If we removed the primary, pick another remaining table as primary
    if (primaryIds.length > 0) {
      const remainingTables = await tx.table.findMany({
        where: { virtualGroupId, locationId, deletedAt: null },
        select: { id: true },
      })

      if (remainingTables.length > 0) {
        const newPrimaryId = remainingTables[0].id
        await tx.virtualGroup.update({
          where: { id: virtualGroupId },
          data: { primaryTableId: newPrimaryId },
        })
        await tx.table.update({
          where: { id: newPrimaryId },
          data: { virtualGroupPrimary: true },
        })
      } else {
        // No tables left; mark group deleted
        await tx.virtualGroup.update({
          where: { id: virtualGroupId },
          data: { deletedAt: new Date() },
        })
      }
    }

    await tx.auditLog.create({
      data: {
        locationId,
        employeeId: employeeId ?? null,
        action: 'virtual_group_tables_removed',
        entityType: 'virtual_group',
        entityId: virtualGroupId,
        details: {
          tableIds: tables.map(t => t.id),
        },
      },
    })
  })

  // Notify POS terminals of tables removed from virtual group
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      virtualGroupId,
      removedTableIds: tables.map(t => t.id),
      message: 'Tables removed from virtual group',
    },
  })
}

async function handleDissolve(body: DissolveVirtualGroupBody) {
  const { locationId, employeeId, virtualGroupId } = body

  if (!virtualGroupId) {
    return NextResponse.json(
      { error: 'virtualGroupId is required for dissolve action' },
      { status: 400 }
    )
  }

  const group = await db.virtualGroup.findFirst({
    where: { id: virtualGroupId, locationId, deletedAt: null },
  })
  if (!group) {
    return NextResponse.json(
      { error: 'Virtual group not found' },
      { status: 404 }
    )
  }

  await db.$transaction(async tx => {
    await tx.table.updateMany({
      where: { virtualGroupId, locationId, deletedAt: null },
      data: {
        virtualGroupId: null,
        virtualGroupPrimary: false,
        virtualGroupColor: null,
      },
    })

    await tx.virtualGroup.update({
      where: { id: virtualGroupId },
      data: { deletedAt: new Date() },
    })

    await tx.auditLog.create({
      data: {
        locationId,
        employeeId: employeeId ?? null,
        action: 'virtual_group_dissolved',
        entityType: 'virtual_group',
        entityId: virtualGroupId,
        details: {},
      },
    })
  })

  // Notify POS terminals of virtual group dissolution
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      virtualGroupId,
      message: 'Virtual group dissolved',
    },
  })
}


================================================================================
SECTION 4: API ROUTES - SEATS
================================================================================

################################################################################
# FILE: src/app/api/seats/[id]/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';
import { softDeleteData } from '@/lib/floorplan/queries';

// GET - Get a single seat with table info
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    const seat = await db.seat.findFirst({
      where: { id, deletedAt: null },
      include: {
        table: {
          select: {
            id: true,
            name: true,
            abbreviation: true,
            shape: true,
            capacity: true,
            width: true,
            height: true,
          },
        },
      },
    });

    if (!seat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      seat: {
        id: seat.id,
        locationId: seat.locationId,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        originalRelativeX: seat.originalRelativeX,
        originalRelativeY: seat.originalRelativeY,
        originalAngle: seat.originalAngle,
        seatType: seat.seatType,
        isActive: seat.isActive,
        table: seat.table,
      },
    });
  } catch (error) {
    console.error('Failed to fetch seat:', error);
    return NextResponse.json(
      { error: 'Failed to fetch seat' },
      { status: 500 }
    );
  }
}

// PUT - Update seat position/properties
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();
    const {
      relativeX,
      relativeY,
      angle,
      label,
      seatType,
      isActive,
      originalRelativeX,
      originalRelativeY,
      originalAngle,
    } = body;

    // Get current seat for locationId
    const currentSeat = await db.seat.findFirst({
      where: { id, deletedAt: null },
    });

    if (!currentSeat) {
      return NextResponse.json({ error: 'Seat not found' }, { status: 404 });
    }

    const seat = await db.seat.update({
      where: { id },
      data: {
        ...(relativeX !== undefined ? { relativeX } : {}),
        ...(relativeY !== undefined ? { relativeY } : {}),
        ...(angle !== undefined ? { angle } : {}),
        ...(label !== undefined ? { label } : {}),
        ...(seatType !== undefined ? { seatType } : {}),
        ...(isActive !== undefined ? { isActive } : {}),
        ...(originalRelativeX !== undefined ? { originalRelativeX } : {}),
        ...(originalRelativeY !== undefined ? { originalRelativeY } : {}),
        ...(originalAngle !== undefined ? { originalAngle } : {}),
      },
    });

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(currentSeat.locationId, { async: true });

    return NextResponse.json({
      seat: {
        id: seat.id,
        locationId: seat.locationId,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      },
    });
  } catch (error) {
    console.error('Failed to update seat:', error);
    return NextResponse.json(
      { error: 'Failed to update seat' },
      { status: 500 }
    );
  }
}

// DELETE - Soft delete seat
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // Get seat for locationId before deletion
    const seat = await db.seat.findFirst({
      where: { id, deletedAt: null },
      select: { locationId: true },
    });

    if (!seat) {
      return NextResponse.json({ error: 'Seat not found' }, { status: 404 });
    }

    // Soft delete
    await db.seat.update({
      where: { id },
      data: softDeleteData(),
    });

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(seat.locationId, { async: true });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Failed to delete seat:', error);
    return NextResponse.json(
      { error: 'Failed to delete seat' },
      { status: 500 }
    );
  }
}



################################################################################
# FILE: src/app/api/seats/bulk-operations/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import { distributeSeatsOnPerimeter, getGroupBoundingBox, type TableRect } from '@/lib/table-geometry'
import { calculateVirtualSeatNumbers, type TableWithSeats } from '@/lib/virtual-group-seats'

/**
 * POST /api/seats/bulk-operations?action=xxx
 *
 * Handles bulk seat operations to eliminate direct seat manipulation from Tables API.
 *
 * Actions:
 * - reposition-for-combine: Renumber seats around perimeter when tables are combined
 * - restore-original: Restore seats to their original positions (for split/uncombine)
 * - recalculate-labels: Recalculate seat labels in clockwise order for combined group
 * - apply-virtual-labels: Apply virtual group labels ("T1-3" format)
 * - restore-labels: Restore original labels (undo virtual labeling)
 */
export async function POST(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const action = searchParams.get('action')

    if (!action) {
      return NextResponse.json(
        { error: 'action query parameter is required' },
        { status: 400 }
      )
    }

    const body = await request.json()
    const { locationId } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    switch (action) {
      case 'reposition-for-combine':
        return await handleRepositionForCombine(body)
      case 'restore-original':
        return await handleRestoreOriginal(body)
      case 'recalculate-labels':
        return await handleRecalculateLabels(body)
      case 'apply-virtual-labels':
        return await handleApplyVirtualLabels(body)
      case 'restore-labels':
        return await handleRestoreLabels(body)
      default:
        return NextResponse.json(
          { error: `Invalid action: ${action}` },
          { status: 400 }
        )
    }
  } catch (error) {
    console.error('[Seats Bulk Operations] Error:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Bulk operation failed', details: errorMessage },
      { status: 500 }
    )
  }
}

/**
 * Action: reposition-for-combine
 *
 * Renumber seats around the perimeter when tables are combined.
 * Uses distributeSeatsOnPerimeter() for optimal seat positioning.
 */
async function handleRepositionForCombine(body: {
  locationId: string
  combinedTableIds: string[]
  tablePositions: Array<{ id: string; posX: number; posY: number; width: number; height: number }>
}) {
  const { locationId, combinedTableIds, tablePositions } = body

  if (!combinedTableIds || !Array.isArray(combinedTableIds) || combinedTableIds.length === 0) {
    return NextResponse.json(
      { error: 'combinedTableIds array is required' },
      { status: 400 }
    )
  }

  if (!tablePositions || !Array.isArray(tablePositions)) {
    return NextResponse.json(
      { error: 'tablePositions array is required' },
      { status: 400 }
    )
  }

  const result = await db.$transaction(async (tx) => {
    // Fetch all seats for the combined tables
    const allSeats = await tx.seat.findMany({
      where: {
        tableId: { in: combinedTableIds },
        locationId,
        isActive: true,
        deletedAt: null,
      },
      orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
    })

    if (allSeats.length === 0) {
      return { updatedCount: 0, seats: [] }
    }

    // Save original positions before repositioning
    for (const seat of allSeats) {
      if (seat.originalRelativeX === null && seat.originalRelativeY === null) {
        await tx.seat.update({
          where: { id: seat.id },
          data: {
            originalRelativeX: seat.relativeX,
            originalRelativeY: seat.relativeY,
            originalAngle: seat.angle,
          },
        })
      }
    }

    // Build table rectangles for geometry calculations
    const tableRects: TableRect[] = tablePositions.map((t) => ({
      id: t.id,
      posX: t.posX,
      posY: t.posY,
      width: t.width,
      height: t.height,
      combinedWithId: null,
      combinedTableIds: null,
    }))

    // Calculate perimeter positions for all seats
    const perimeterPositions = distributeSeatsOnPerimeter(tableRects, allSeats.length)

    // Get bounding box for center calculation
    const bounds = getGroupBoundingBox(tableRects)
    if (!bounds) {
      throw new Error('Failed to calculate group bounding box')
    }

    const centerX = bounds.minX + bounds.width / 2
    const centerY = bounds.minY + bounds.height / 2

    // Create table position map for relative coordinate calculation
    const tablePosMap = new Map(
      tablePositions.map((t) => [t.id, { posX: t.posX, posY: t.posY, width: t.width, height: t.height }])
    )

    // Calculate angles from center and sort clockwise
    const seatsWithAngles = allSeats
      .map((seat) => {
        const tablePos = tablePosMap.get(seat.tableId)
        if (!tablePos) return null

        const tableCenterX = tablePos.posX + tablePos.width / 2
        const tableCenterY = tablePos.posY + tablePos.height / 2
        const absX = tableCenterX + seat.relativeX
        const absY = tableCenterY + seat.relativeY

        const dx = absX - centerX
        const dy = absY - centerY
        let angle = (Math.atan2(dy, dx) * 180) / Math.PI
        angle = (angle + 450) % 360 // top=0, clockwise

        return { seat, angle }
      })
      .filter(Boolean) as Array<{ seat: typeof allSeats[number]; angle: number }>

    seatsWithAngles.sort((a, b) => a.angle - b.angle)

    // Update each seat with new position and label
    for (let i = 0; i < seatsWithAngles.length; i++) {
      const { seat } = seatsWithAngles[i]
      const newPos = perimeterPositions[i]
      if (!newPos) continue

      const tablePos = tablePosMap.get(seat.tableId)
      if (!tablePos) continue

      const tableCenterX = tablePos.posX + tablePos.width / 2
      const tableCenterY = tablePos.posY + tablePos.height / 2

      const newRelativeX = Math.round(newPos.x - tableCenterX)
      const newRelativeY = Math.round(newPos.y - tableCenterY)

      const angleToCenter = (Math.atan2(centerY - newPos.y, centerX - newPos.x) * 180) / Math.PI
      const newAngle = Math.round(angleToCenter)

      await tx.seat.update({
        where: { id: seat.id },
        data: {
          relativeX: newRelativeX,
          relativeY: newRelativeY,
          angle: newAngle,
          label: String(i + 1),
        },
      })
    }

    return {
      updatedCount: seatsWithAngles.length,
      seats: seatsWithAngles.map((s, i) => ({
        id: s.seat.id,
        tableId: s.seat.tableId,
        label: String(i + 1),
      })),
    }
  })

  // Notify POS terminals of floor plan update
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      action: 'reposition-for-combine',
      updatedCount: result.updatedCount,
      seats: result.seats,
      message: `Repositioned ${result.updatedCount} seats around perimeter`,
    },
  })
}

/**
 * Action: restore-original
 *
 * Restore seats to their original positions (for split/uncombine).
 * Restores from originalRelativeX, originalRelativeY, originalAngle.
 */
async function handleRestoreOriginal(body: {
  locationId: string
  tableIds: string[]
}) {
  const { locationId, tableIds } = body

  if (!tableIds || !Array.isArray(tableIds) || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'tableIds array is required' },
      { status: 400 }
    )
  }

  const result = await db.$transaction(async (tx) => {
    // Fetch all seats for the tables
    const seats = await tx.seat.findMany({
      where: {
        tableId: { in: tableIds },
        locationId,
        isActive: true,
        deletedAt: null,
      },
      orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
    })

    let restoredCount = 0

    // Restore each seat to its original position
    for (const seat of seats) {
      // Only restore if original positions were saved
      if (seat.originalRelativeX !== null || seat.originalRelativeY !== null) {
        await tx.seat.update({
          where: { id: seat.id },
          data: {
            relativeX: seat.originalRelativeX ?? seat.relativeX,
            relativeY: seat.originalRelativeY ?? seat.relativeY,
            angle: seat.originalAngle ?? seat.angle,
            originalRelativeX: null,
            originalRelativeY: null,
            originalAngle: null,
            label: String(seat.seatNumber),
          },
        })
        restoredCount++
      }
    }

    return { restoredCount, totalSeats: seats.length }
  })

  // Notify POS terminals of floor plan update
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      action: 'restore-original',
      restoredCount: result.restoredCount,
      totalSeats: result.totalSeats,
      message: `Restored ${result.restoredCount} of ${result.totalSeats} seats to original positions`,
    },
  })
}

/**
 * Action: recalculate-labels
 *
 * Recalculate seat labels in clockwise order for remaining combined group.
 * Used when a table is removed from a group and labels need to be renumbered.
 */
async function handleRecalculateLabels(body: {
  locationId: string
  tableIds: string[]
  tablePositions: Array<{ id: string; posX: number; posY: number; width: number; height: number }>
}) {
  const { locationId, tableIds, tablePositions } = body

  if (!tableIds || !Array.isArray(tableIds) || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'tableIds array is required' },
      { status: 400 }
    )
  }

  if (!tablePositions || !Array.isArray(tablePositions)) {
    return NextResponse.json(
      { error: 'tablePositions array is required' },
      { status: 400 }
    )
  }

  const result = await db.$transaction(async (tx) => {
    // Fetch all seats for the tables
    const seats = await tx.seat.findMany({
      where: {
        tableId: { in: tableIds },
        locationId,
        isActive: true,
        deletedAt: null,
      },
    })

    if (seats.length === 0) {
      return { updatedCount: 0 }
    }

    // Calculate combined bounding box
    let minX = Infinity
    let minY = Infinity
    let maxX = -Infinity
    let maxY = -Infinity

    const tablePosMap = new Map(
      tablePositions.map((t) => [
        t.id,
        { posX: t.posX, posY: t.posY, width: t.width, height: t.height },
      ])
    )

    for (const t of tablePositions) {
      minX = Math.min(minX, t.posX)
      minY = Math.min(minY, t.posY)
      maxX = Math.max(maxX, t.posX + t.width)
      maxY = Math.max(maxY, t.posY + t.height)
    }

    const combinedCenterX = (minX + maxX) / 2
    const combinedCenterY = (minY + maxY) / 2

    // Sort seats by clockwise position
    const seatsWithAngles = seats
      .map((seat) => {
        const tablePos = tablePosMap.get(seat.tableId)
        if (!tablePos) return null

        const tableCenterX = tablePos.posX + tablePos.width / 2
        const tableCenterY = tablePos.posY + tablePos.height / 2
        const absoluteX = tableCenterX + seat.relativeX
        const absoluteY = tableCenterY + seat.relativeY

        const dx = absoluteX - combinedCenterX
        const dy = absoluteY - combinedCenterY
        let angle = (Math.atan2(dy, dx) * 180) / Math.PI
        angle = (angle + 135 + 360) % 360

        return { seat, clockwiseAngle: angle }
      })
      .filter(Boolean) as Array<{ seat: typeof seats[number]; clockwiseAngle: number }>

    seatsWithAngles.sort((a, b) => a.clockwiseAngle - b.clockwiseAngle)

    // Update labels based on new clockwise order
    for (let i = 0; i < seatsWithAngles.length; i++) {
      await tx.seat.update({
        where: { id: seatsWithAngles[i].seat.id },
        data: { label: String(i + 1) },
      })
    }

    return { updatedCount: seatsWithAngles.length }
  })

  // Notify POS terminals of floor plan update
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      action: 'recalculate-labels',
      updatedCount: result.updatedCount,
      message: `Recalculated labels for ${result.updatedCount} seats`,
    },
  })
}

/**
 * Action: apply-virtual-labels
 *
 * Apply virtual group labels ("T1-3" format).
 * Uses calculateVirtualSeatNumbers() from virtual-group-seats.ts.
 */
async function handleApplyVirtualLabels(body: {
  locationId: string
  primaryTableId: string
  tableIds: string[]
}) {
  const { locationId, primaryTableId, tableIds } = body

  if (!primaryTableId) {
    return NextResponse.json(
      { error: 'primaryTableId is required' },
      { status: 400 }
    )
  }

  if (!tableIds || !Array.isArray(tableIds) || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'tableIds array is required' },
      { status: 400 }
    )
  }

  const result = await db.$transaction(async (tx) => {
    // Fetch all tables with their seats
    const tables = await tx.table.findMany({
      where: {
        id: { in: tableIds },
        locationId,
        deletedAt: null,
      },
      include: {
        seats: {
          where: { isActive: true, deletedAt: null },
          orderBy: { seatNumber: 'asc' },
        },
      },
    })

    if (tables.length === 0) {
      return { updatedCount: 0 }
    }

    // Prepare table data for virtual seat calculation
    const tablesWithSeats: TableWithSeats[] = tables.map((table) => ({
      id: table.id,
      name: table.name,
      posX: table.posX,
      posY: table.posY,
      seats: table.seats.map((seat) => ({
        id: seat.id,
        seatNumber: seat.seatNumber,
        label: seat.label,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
      })),
    }))

    // Calculate virtual seat numbers (primary table first, then others clockwise)
    const virtualSeatInfo = calculateVirtualSeatNumbers(primaryTableId, tablesWithSeats)

    // Update each seat with virtual label (e.g., "T1-3")
    for (const seatInfo of virtualSeatInfo) {
      await tx.seat.update({
        where: { id: seatInfo.seatId },
        data: {
          label: seatInfo.virtualLabel, // Store "TableName-SeatNum" format
        },
      })
    }

    return { updatedCount: virtualSeatInfo.length }
  })

  // Notify POS terminals of floor plan update
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      action: 'apply-virtual-labels',
      updatedCount: result.updatedCount,
      message: `Applied virtual labels to ${result.updatedCount} seats`,
    },
  })
}

/**
 * Action: restore-labels
 *
 * Restore original labels (undo virtual labeling).
 * Restores label to String(seatNumber).
 */
async function handleRestoreLabels(body: {
  locationId: string
  tableIds: string[]
}) {
  const { locationId, tableIds } = body

  if (!tableIds || !Array.isArray(tableIds) || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'tableIds array is required' },
      { status: 400 }
    )
  }

  const result = await db.$transaction(async (tx) => {
    // Fetch all seats for the tables
    const seats = await tx.seat.findMany({
      where: {
        tableId: { in: tableIds },
        locationId,
        isActive: true,
        deletedAt: null,
      },
    })

    let restoredCount = 0

    // Restore each seat's original label
    for (const seat of seats) {
      // Check if label has table prefix format (e.g., "T1-3")
      const hasTablePrefix = seat.label.includes('-')

      if (hasTablePrefix) {
        // Restore to original seat number format
        await tx.seat.update({
          where: { id: seat.id },
          data: {
            label: String(seat.seatNumber), // Simple number format
          },
        })
        restoredCount++
      }
    }

    return { restoredCount, totalSeats: seats.length }
  })

  // Notify POS terminals of floor plan update
  dispatchFloorPlanUpdate(locationId, { async: true })

  return NextResponse.json({
    data: {
      action: 'restore-labels',
      restoredCount: result.restoredCount,
      totalSeats: result.totalSeats,
      message: `Restored labels for ${result.restoredCount} of ${result.totalSeats} seats`,
    },
  })
}



################################################################################
# FILE: src/app/api/seats/cleanup-duplicates/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';

/**
 * GWI POS - Seats Cleanup API
 *
 * Clean up duplicate seats (same tableId + seatNumber).
 * Keeps the oldest seat (by createdAt) and soft-deletes the rest.
 */

// POST - Clean up duplicate seats
export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}));
    const { locationId, dryRun = true } = body;

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      );
    }

    // Find all active seats for this location
    const allSeats = await db.seat.findMany({
      where: {
        locationId,
        deletedAt: null,
        isActive: true,
      },
      orderBy: { createdAt: 'asc' }, // Oldest first
      include: {
        table: { select: { name: true } },
      },
    });

    // Group by tableId + seatNumber
    const groups = new Map<string, typeof allSeats>();
    for (const seat of allSeats) {
      const key = `${seat.tableId}:${seat.seatNumber}`;
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(seat);
    }

    // Find duplicates (groups with more than 1 seat)
    const duplicates: Array<{
      tableId: string;
      tableName: string;
      seatNumber: number;
      keepId: string;
      deleteIds: string[];
    }> = [];

    for (const [key, seats] of groups) {
      if (seats.length > 1) {
        // Keep the first (oldest), delete the rest
        const [keep, ...toDelete] = seats;
        duplicates.push({
          tableId: keep.tableId,
          tableName: keep.table?.name || 'Unknown',
          seatNumber: keep.seatNumber,
          keepId: keep.id,
          deleteIds: toDelete.map(s => s.id),
        });
      }
    }

    if (duplicates.length === 0) {
      return NextResponse.json({
        message: 'No duplicate seats found',
        duplicatesFound: 0,
      });
    }

    // If dry run, just report what would be deleted
    if (dryRun) {
      return NextResponse.json({
        message: 'Dry run complete - no changes made',
        duplicatesFound: duplicates.length,
        totalToDelete: duplicates.reduce((sum, d) => sum + d.deleteIds.length, 0),
        duplicates: duplicates.map(d => ({
          table: d.tableName,
          seatNumber: d.seatNumber,
          keeping: d.keepId,
          deleting: d.deleteIds.length,
        })),
      });
    }

    // Actually delete (soft delete) the duplicates
    const allDeleteIds = duplicates.flatMap(d => d.deleteIds);

    await db.seat.updateMany({
      where: { id: { in: allDeleteIds } },
      data: {
        deletedAt: new Date(),
        isActive: false,
      },
    });

    return NextResponse.json({
      message: `Cleaned up ${allDeleteIds.length} duplicate seats`,
      duplicatesFound: duplicates.length,
      seatsDeleted: allDeleteIds.length,
      duplicates: duplicates.map(d => ({
        table: d.tableName,
        seatNumber: d.seatNumber,
        deleted: d.deleteIds.length,
      })),
    });
  } catch (error) {
    console.error('Failed to cleanup duplicate seats:', error);
    return NextResponse.json(
      { error: 'Failed to cleanup duplicate seats' },
      { status: 500 }
    );
  }
}

// GET - Check for duplicates without modifying
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const locationId = searchParams.get('locationId');

  if (!locationId) {
    return NextResponse.json(
      { error: 'locationId query param required' },
      { status: 400 }
    );
  }

  // Reuse POST logic with dryRun=true
  const mockRequest = {
    json: async () => ({ locationId, dryRun: true }),
  } as NextRequest;

  return POST(mockRequest);
}



################################################################################
# FILE: src/app/api/seats/cleanup-orphaned-labels/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

/**
 * GET /api/seats/cleanup-orphaned-labels?locationId=xxx
 *
 * Dry run - Reports orphaned virtual seat labels without modifying data.
 * Orphaned seats are seats with hyphenated labels (e.g., "Table 6-1")
 * but whose table is no longer part of a virtual group.
 *
 * Returns list of orphaned seats with current and correct labels.
 */
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const locationId = searchParams.get('locationId')

  if (!locationId) {
    return NextResponse.json({ error: 'locationId required' }, { status: 400 })
  }

  try {
    // Find orphaned seats: have hyphenated label but table not in virtual group
    const orphanedSeats = await db.seat.findMany({
      where: {
        deletedAt: null,
        label: { contains: '-' },
        table: {
          locationId,
          virtualGroupId: null,
          deletedAt: null,
        },
      },
      include: {
        table: { select: { id: true, name: true } }
      }
    })

    return NextResponse.json({
      data: {
        orphanedCount: orphanedSeats.length,
        orphanedSeats: orphanedSeats.map(s => ({
          tableId: s.tableId,
          tableName: s.table.name,
          seatId: s.id,
          currentLabel: s.label,
          correctLabel: String(s.seatNumber)
        }))
      }
    })
  } catch (error) {
    console.error('[CleanupOrphanedLabels] GET error:', error)
    return NextResponse.json(
      { error: 'Failed to check orphaned labels' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/seats/cleanup-orphaned-labels?locationId=xxx
 *
 * Fixes orphaned virtual seat labels by resetting them to their seat number.
 * Updates all seats with hyphenated labels whose tables are no longer
 * in virtual groups.
 *
 * Returns count of fixed seats and errors.
 */
export async function POST(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const locationId = searchParams.get('locationId')

  if (!locationId) {
    return NextResponse.json({ error: 'locationId required' }, { status: 400 })
  }

  try {
    // Find orphaned seats
    const orphanedSeats = await db.seat.findMany({
      where: {
        deletedAt: null,
        label: { contains: '-' },
        table: {
          locationId,
          virtualGroupId: null,
          deletedAt: null,
        },
      },
    })

    if (orphanedSeats.length === 0) {
      return NextResponse.json({ data: { fixed: 0, errors: 0 } })
    }

    // Fix each seat
    let fixed = 0
    let errors = 0

    await db.$transaction(async (tx) => {
      for (const seat of orphanedSeats) {
        try {
          await tx.seat.update({
            where: { id: seat.id },
            data: { label: String(seat.seatNumber) }
          })
          fixed++
        } catch {
          errors++
        }
      }
    })

    // Notify clients of floor plan changes
    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      data: { fixed, errors }
    })
  } catch (error) {
    console.error('[CleanupOrphanedLabels] POST error:', error)
    return NextResponse.json(
      { error: 'Failed to cleanup orphaned labels' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/seats/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';

// GET - List seats with filters
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const locationId = searchParams.get('locationId');
    const tableId = searchParams.get('tableId');
    const virtualGroupId = searchParams.get('virtualGroupId');
    const status = searchParams.get('status');

    if (!locationId) {
      return NextResponse.json(
        { error: 'Location ID is required' },
        { status: 400 }
      );
    }

    const seats = await db.seat.findMany({
      where: {
        locationId,
        deletedAt: null,
        ...(tableId ? { tableId } : {}),
        ...(status ? { isActive: status === 'active' } : {}),
      },
      include: {
        table: {
          select: {
            id: true,
            name: true,
            shape: true,
            virtualGroupId: true,
          },
        },
      },
      orderBy: [
        { tableId: 'asc' },
        { seatNumber: 'asc' },
      ],
    });

    // Filter by virtualGroupId if provided (on related table)
    const filteredSeats = virtualGroupId
      ? seats.filter((s) => s.table.virtualGroupId === virtualGroupId)
      : seats;

    return NextResponse.json({
      seats: filteredSeats.map((seat) => ({
        id: seat.id,
        locationId: seat.locationId,
        tableId: seat.tableId,
        tableName: seat.table.name,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      })),
    });
  } catch (error) {
    console.error('Failed to fetch seats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch seats' },
      { status: 500 }
    );
  }
}

// POST - Create a single seat
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      locationId,
      tableId,
      seatNumber,
      label,
      relativeX,
      relativeY,
      angle,
      seatType,
    } = body;

    if (!locationId || !tableId) {
      return NextResponse.json(
        { error: 'Location ID and Table ID are required' },
        { status: 400 }
      );
    }

    // Auto-increment seat number if not provided
    let finalSeatNumber = seatNumber;
    if (!finalSeatNumber) {
      const maxSeat = await db.seat.findFirst({
        where: { tableId, deletedAt: null },
        orderBy: { seatNumber: 'desc' },
      });
      finalSeatNumber = (maxSeat?.seatNumber || 0) + 1;
    }

    const seat = await db.seat.create({
      data: {
        locationId,
        tableId,
        seatNumber: finalSeatNumber,
        label: label || String(finalSeatNumber),
        relativeX: relativeX || 0,
        relativeY: relativeY || 0,
        angle: angle || 0,
        seatType: seatType || 'standard',
      },
    });

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(locationId, { async: true });

    return NextResponse.json({
      seat: {
        id: seat.id,
        locationId: seat.locationId,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      },
    });
  } catch (error) {
    console.error('Failed to create seat:', error);
    return NextResponse.json(
      { error: 'Failed to create seat' },
      { status: 500 }
    );
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/[seatId]/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { softDeleteData } from '@/lib/floorplan/queries'
import { Prisma } from '@prisma/client'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// GET - Get a single seat
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; seatId: string }> }
) {
  try {
    const { id: tableId, seatId } = await params

    const seat = await db.seat.findFirst({
      where: {
        id: seatId,
        tableId,
        isActive: true,
        deletedAt: null,
      },
    })

    if (!seat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      seat: {
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      },
    })
  } catch (error) {
    console.error('Failed to fetch seat:', error)
    return NextResponse.json(
      { error: 'Failed to fetch seat' },
      { status: 500 }
    )
  }
}

// PUT - Update a seat
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; seatId: string }> }
) {
  try {
    const { id: tableId, seatId } = await params
    const body = await request.json()
    const {
      label,
      seatNumber,
      relativeX,
      relativeY,
      angle,
      seatType,
      updateOriginal = false, // If true, also update the "builder default" position
    } = body

    // Verify seat exists and belongs to this table
    // Also check if table is part of a combined group
    const existingSeat = await db.seat.findFirst({
      where: {
        id: seatId,
        tableId,
        isActive: true,
        deletedAt: null,
      },
      include: {
        table: {
          select: {
            locationId: true,
            combinedWithId: true,
            combinedTableIds: true,
          },
        },
      },
    })

    if (!existingSeat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      )
    }

    // Determine if we should update original positions
    // Update originals if:
    // 1. Explicitly requested (updateOriginal = true)
    // 2. OR if the table is NOT combined (we're in the floor plan builder)
    const isTableCombined = existingSeat.table.combinedWithId ||
      (existingSeat.table.combinedTableIds && (existingSeat.table.combinedTableIds as string[]).length > 0)

    const shouldUpdateOriginal = updateOriginal || !isTableCombined

    // Build type-safe update data
    const updateData: Prisma.SeatUpdateInput = {}

    if (label !== undefined) updateData.label = label
    if (seatNumber !== undefined) updateData.seatNumber = seatNumber
    if (relativeX !== undefined) {
      updateData.relativeX = relativeX
      if (shouldUpdateOriginal) updateData.originalRelativeX = relativeX
    }
    if (relativeY !== undefined) {
      updateData.relativeY = relativeY
      if (shouldUpdateOriginal) updateData.originalRelativeY = relativeY
    }
    if (angle !== undefined) {
      updateData.angle = angle
      if (shouldUpdateOriginal) updateData.originalAngle = angle
    }
    if (seatType !== undefined) updateData.seatType = seatType

    const seat = await db.seat.update({
      where: { id: seatId },
      data: updateData,
    })

    dispatchFloorPlanUpdate(existingSeat.table.locationId, { async: true })

    return NextResponse.json({
      seat: {
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      },
    })
  } catch (error) {
    console.error('Failed to update seat:', error)
    return NextResponse.json(
      { error: 'Failed to update seat' },
      { status: 500 }
    )
  }
}

// DELETE - Delete (deactivate) a seat
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; seatId: string }> }
) {
  try {
    const { id: tableId, seatId } = await params
    const { searchParams } = new URL(request.url)
    const employeeId = searchParams.get('employeeId')

    // Verify seat exists and belongs to this table (with table info for logging)
    const existingSeat = await db.seat.findFirst({
      where: {
        id: seatId,
        tableId,
        isActive: true,
      },
      include: {
        table: {
          select: { locationId: true, name: true },
        },
      },
    })

    if (!existingSeat) {
      return NextResponse.json(
        { error: 'Seat not found' },
        { status: 404 }
      )
    }

    // Check if seat has any active tickets (sold, held, or checked in)
    const activeTickets = await db.ticket.count({
      where: {
        seatId,
        status: { in: ['sold', 'held', 'checked_in'] },
      },
    })

    if (activeTickets > 0) {
      return NextResponse.json(
        { error: 'Cannot delete seat with active tickets' },
        { status: 400 }
      )
    }

    // Use transaction to soft delete and log
    await db.$transaction(async (tx) => {
      // Soft delete
      await tx.seat.update({
        where: { id: seatId },
        data: { isActive: false, deletedAt: new Date() },
      })

      // Audit log
      await tx.auditLog.create({
        data: {
          locationId: existingSeat.table.locationId,
          employeeId: employeeId || null,
          action: 'seat_deleted',
          entityType: 'seat',
          entityId: seatId,
          details: {
            tableId,
            tableName: existingSeat.table.name,
            seatNumber: existingSeat.seatNumber,
            seatLabel: existingSeat.label,
          },
        },
      })
    })

    console.log(`[Seats] Deleted seat ${existingSeat.seatNumber} from table ${existingSeat.table.name}`)

    dispatchFloorPlanUpdate(existingSeat.table.locationId, { async: true })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to delete seat:', error)
    return NextResponse.json(
      { error: 'Failed to delete seat' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/auto-generate/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import { generateSeatPositions as generateSeatPositionsFromLib, type SeatPattern as LibSeatPattern } from '@/lib/seat-generation'
import { SEAT_RADIUS } from '@/lib/floorplan/constants'

type LabelPattern = 'numeric' | 'alpha' | 'alphanumeric'

// Helper function to generate seat labels
function getLabel(index: number, pattern: LabelPattern): string {
  switch (pattern) {
    case 'alpha':
      return String.fromCharCode(65 + index) // A, B, C...
    case 'alphanumeric':
      return `S${index + 1}` // S1, S2, S3...
    default:
      return String(index + 1) // 1, 2, 3...
  }
}

// Collision detection constants
const COLLISION_PADDING = 5 // Extra padding for collision checks

interface CollisionResult {
  hasCollisions: boolean
  collisions: {
    seatNumber: number
    collidedWith: string // 'table:T1' or 'fixture:Wall' or 'seat:T2-S3'
    type: 'table' | 'fixture' | 'seat'
  }[]
}

// Check if a point collides with a rectangle (with rotation support)
function pointInRotatedRect(
  px: number,
  py: number,
  rectX: number,
  rectY: number,
  rectW: number,
  rectH: number,
  rectRotation: number = 0
): boolean {
  // Get rect center
  const cx = rectX + rectW / 2
  const cy = rectY + rectH / 2

  // Translate point to rect's local space
  const dx = px - cx
  const dy = py - cy

  // Rotate point in opposite direction
  const rad = (-rectRotation * Math.PI) / 180
  const cos = Math.cos(rad)
  const sin = Math.sin(rad)
  const localX = dx * cos - dy * sin
  const localY = dx * sin + dy * cos

  // Check if local point is within rect bounds (with padding for seat radius)
  const halfW = rectW / 2 + SEAT_RADIUS + COLLISION_PADDING
  const halfH = rectH / 2 + SEAT_RADIUS + COLLISION_PADDING

  return Math.abs(localX) <= halfW && Math.abs(localY) <= halfH
}

// POST - Auto-generate seats for a table based on capacity and pattern
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const {
      count,
      seatPattern,
      labelPattern = 'numeric',
      replaceExisting = true,
      updateTablePattern = true, // Also update table's seatPattern field
      employeeId, // For audit logging
      checkCollisions = true, // New: whether to check for collisions
      forceGenerate = false, // New: generate even if collisions detected
      availableSpace, // Optional: space available around table (for dynamic compression)
    } = body

    // Verify table exists and get details
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: {
        id: true,
        name: true,
        locationId: true,
        capacity: true,
        width: true,
        height: true,
        posX: true,
        posY: true,
        rotation: true,
        shape: true,
        seatPattern: true,
      },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    const seatCount = count || table.capacity

    // Map local patterns to library patterns
    const patternMap: Record<string, LibSeatPattern> = {
      'all_around': 'all_around',
      'front_only': 'one_side',
      'two_sides': 'two_sides',
      'three_sides': 'booth', // Maps to booth pattern (3 sides)
      'inside': 'booth', // Maps to booth pattern
    }

    // Use provided pattern, or infer from table shape, or use table's existing pattern
    let localPattern = seatPattern || table.seatPattern || 'all_around'

    // Auto-infer pattern from shape if not explicitly set
    if (!seatPattern && table.seatPattern === 'all_around') {
      if (table.shape === 'bar') localPattern = 'front_only'
      else if (table.shape === 'booth') localPattern = 'inside'
    }

    // Map to library pattern
    const libraryPattern = patternMap[localPattern as string] || 'all_around'

    // Generate seat positions using library function
    const baseSeatPositions = generateSeatPositionsFromLib({
      shape: table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth',
      pattern: libraryPattern,
      capacity: seatCount,
      width: table.width,
      height: table.height,
    })

    // Add labels to seat positions
    const seatPositions = baseSeatPositions.map((pos, index) => ({
      ...pos,
      label: getLabel(index, labelPattern as LabelPattern),
    }))

    // Check for collisions if requested
    let collisionResult: CollisionResult = { hasCollisions: false, collisions: [] }

    if (checkCollisions) {
      // Skip collision checks if table hasn't been positioned yet
      if (table.posX == null || table.posY == null) {
        console.warn('[Seats] Skipping collision check - table has no position yet')
        // Generate seats without collision checking
      } else {
        // Get all other tables in the location (for collision detection)
        const otherTables = await db.table.findMany({
          where: {
            locationId: table.locationId,
            id: { not: tableId },
            isActive: true,
            deletedAt: null,
          },
          select: {
            id: true,
            name: true,
            posX: true,
            posY: true,
            width: true,
            height: true,
            rotation: true,
            seats: {
              where: { isActive: true, deletedAt: null },
              select: {
                id: true,
                seatNumber: true,
                relativeX: true,
                relativeY: true,
              },
            },
          },
        })

        // Get all fixtures (walls, bars) in the location
        const fixtures = await db.floorPlanElement.findMany({
          where: {
            locationId: table.locationId,
            deletedAt: null,
          },
          select: {
            id: true,
            name: true,
            elementType: true,
            posX: true,
            posY: true,
            width: true,
            height: true,
            rotation: true,
          },
        })

        // Calculate table center for seat absolute positions
        const tableCenterX = (table.posX ?? 0) + table.width / 2
        const tableCenterY = (table.posY ?? 0) + table.height / 2
        const tableRotation = (table.rotation ?? 0) * Math.PI / 180
        const cos = Math.cos(tableRotation)
        const sin = Math.sin(tableRotation)

        // Check each generated seat for collisions
        for (const seat of seatPositions) {
          // Calculate absolute seat position (applying table rotation)
          const rotatedX = seat.relativeX * cos - seat.relativeY * sin
          const rotatedY = seat.relativeX * sin + seat.relativeY * cos
          const seatAbsX = tableCenterX + rotatedX
          const seatAbsY = tableCenterY + rotatedY

          // Check against other tables
          for (const otherTable of otherTables) {
            // Skip tables with invalid positions
            if (otherTable.posX == null || otherTable.posY == null) continue

            if (pointInRotatedRect(
              seatAbsX, seatAbsY,
              otherTable.posX, otherTable.posY,
              otherTable.width, otherTable.height,
              otherTable.rotation ?? 0
            )) {
              collisionResult.hasCollisions = true
              collisionResult.collisions.push({
                seatNumber: seat.seatNumber,
                collidedWith: `table:${otherTable.name || otherTable.id}`,
                type: 'table',
              })
            }

            // Check against seats of other tables
            const otherTableCenterX = otherTable.posX + otherTable.width / 2
            const otherTableCenterY = otherTable.posY + otherTable.height / 2
            const otherRotation = (otherTable.rotation ?? 0) * Math.PI / 180
            const otherCos = Math.cos(otherRotation)
            const otherSin = Math.sin(otherRotation)

            for (const otherSeat of otherTable.seats) {
              const otherRotatedX = otherSeat.relativeX * otherCos - otherSeat.relativeY * otherSin
              const otherRotatedY = otherSeat.relativeX * otherSin + otherSeat.relativeY * otherCos
              const otherSeatAbsX = otherTableCenterX + otherRotatedX
              const otherSeatAbsY = otherTableCenterY + otherRotatedY

              const distance = Math.hypot(seatAbsX - otherSeatAbsX, seatAbsY - otherSeatAbsY)
              if (distance < (SEAT_RADIUS * 2 + COLLISION_PADDING)) {
                collisionResult.hasCollisions = true
                collisionResult.collisions.push({
                  seatNumber: seat.seatNumber,
                  collidedWith: `seat:${otherTable.name || otherTable.id}-S${otherSeat.seatNumber}`,
                  type: 'seat',
                })
              }
            }
          }

          // Check against fixtures (walls, bars, etc.)
          for (const fixture of fixtures) {
            // Skip fixtures with invalid positions
            if (fixture.posX == null || fixture.posY == null) continue

            if (pointInRotatedRect(
              seatAbsX, seatAbsY,
              fixture.posX, fixture.posY,
              fixture.width, fixture.height,
              fixture.rotation ?? 0
            )) {
              collisionResult.hasCollisions = true
              collisionResult.collisions.push({
                seatNumber: seat.seatNumber,
                collidedWith: `fixture:${fixture.name || fixture.elementType}`,
                type: 'fixture',
              })
            }
          }
        }

        // Log collisions but proceed anyway - let the user arrange tables as needed
        if (collisionResult.hasCollisions) {
          console.warn(`[Seats] Detected ${collisionResult.collisions.length} potential collisions, proceeding anyway`)
        }
      } // End else block (table has valid position)
    } // End if (checkCollisions)

    // Use transaction to replace existing seats and optionally update table pattern
    const result = await db.$transaction(async (tx) => {
      let deletedCount = 0

      if (replaceExisting) {
        // Hard delete existing seats - regeneration is a complete replacement
        // and soft-deleted seats would conflict with unique constraint on (tableId, seatNumber)
        const deleted = await tx.seat.deleteMany({
          where: { tableId },
        })
        deletedCount = deleted.count
      }

      // Update table's seatPattern if requested
      if (updateTablePattern && seatPattern) {
        await tx.table.update({
          where: { id: tableId },
          data: { seatPattern: localPattern },
        })
      }

      // Create new seats with original positions saved as "builder defaults"
      const createdSeats = await Promise.all(
        seatPositions.map(pos =>
          tx.seat.create({
            data: {
              locationId: table.locationId,
              tableId,
              label: pos.label,
              seatNumber: pos.seatNumber,
              relativeX: Math.round(pos.relativeX),
              relativeY: Math.round(pos.relativeY),
              angle: Math.round(pos.angle),
              seatType: 'standard',
              // Save as "builder default" for restore after combine/split
              originalRelativeX: Math.round(pos.relativeX),
              originalRelativeY: Math.round(pos.relativeY),
              originalAngle: Math.round(pos.angle),
            },
          })
        )
      )

      // Audit log the seat regeneration
      await tx.auditLog.create({
        data: {
          locationId: table.locationId,
          employeeId: employeeId || null,
          action: 'seats_regenerated',
          entityType: 'table',
          entityId: tableId,
          details: {
            tableName: table.name || tableId,
            previousSeatsDeleted: deletedCount,
            newSeatsCreated: createdSeats.length,
            seatPattern: localPattern,
            labelPattern,
          },
        },
      })

      console.log(`[Seats] Regenerated ${createdSeats.length} seats for table (deleted ${deletedCount} previous)`)

      return createdSeats
    })

    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      seats: result.map(seat => ({
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      })),
      generated: result.length,
      seatPattern: localPattern,
      // Include collision warning if seats were forced despite collisions
      ...(collisionResult.hasCollisions ? {
        warning: 'Seats generated with collisions (forceGenerate was true)',
        collisions: collisionResult.collisions,
      } : {}),
    })
  } catch (error) {
    console.error('Failed to auto-generate seats:', error)
    // Return detailed error for debugging
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    const errorStack = error instanceof Error ? error.stack : undefined
    return NextResponse.json(
      {
        error: 'Failed to auto-generate seats',
        details: errorMessage,
        stack: process.env.NODE_ENV === 'development' ? errorStack : undefined
      },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/bulk/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

interface SeatUpdate {
  id: string
  label?: string
  seatNumber?: number
  relativeX?: number
  relativeY?: number
  angle?: number
  seatType?: string
}

// PUT - Bulk update seat positions
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const { seats } = body as { seats: SeatUpdate[] }

    if (!seats || !Array.isArray(seats)) {
      return NextResponse.json(
        { error: 'Seats array is required' },
        { status: 400 }
      )
    }

    // Verify table exists
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: { id: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // Verify all seats belong to this table
    const seatIds = seats.map(s => s.id)
    const existingSeats = await db.seat.findMany({
      where: {
        id: { in: seatIds },
        tableId,
        isActive: true,
      },
      select: { id: true },
    })

    if (existingSeats.length !== seatIds.length) {
      return NextResponse.json(
        { error: 'One or more seats not found or do not belong to this table' },
        { status: 400 }
      )
    }

    // Update all seats in a transaction
    const updatedSeats = await db.$transaction(
      seats.map(seatUpdate =>
        db.seat.update({
          where: { id: seatUpdate.id },
          data: {
            ...(seatUpdate.label !== undefined ? { label: seatUpdate.label } : {}),
            ...(seatUpdate.seatNumber !== undefined ? { seatNumber: seatUpdate.seatNumber } : {}),
            ...(seatUpdate.relativeX !== undefined ? { relativeX: seatUpdate.relativeX } : {}),
            ...(seatUpdate.relativeY !== undefined ? { relativeY: seatUpdate.relativeY } : {}),
            ...(seatUpdate.angle !== undefined ? { angle: seatUpdate.angle } : {}),
            ...(seatUpdate.seatType !== undefined ? { seatType: seatUpdate.seatType } : {}),
          },
        })
      )
    )

    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      seats: updatedSeats.map(seat => ({
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
      })),
      updated: updatedSeats.length,
    })
  } catch (error) {
    console.error('Failed to bulk update seats:', error)
    return NextResponse.json(
      { error: 'Failed to bulk update seats' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/generate/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';
import { generateSeatPositions, type SeatPattern } from '@/lib/seat-generation';

// POST - Generate/regenerate default seat layout
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params;
    const body = await request.json();
    const {
      pattern,
      count,
      saveAsDefault = false,
    } = body;

    // Get table details
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: {
        id: true,
        locationId: true,
        name: true,
        width: true,
        height: true,
        shape: true,
        capacity: true,
        seatPattern: true,
      },
    });

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      );
    }

    // Use defaults from table if not provided
    const finalPattern = (pattern || table.seatPattern || 'all_around') as SeatPattern;
    const finalCount = count || table.capacity;

    // Generate seat positions using params object
    const seatPositions = generateSeatPositions({
      shape: (table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth') || 'rectangle',
      pattern: finalPattern,
      capacity: finalCount,
      width: table.width,
      height: table.height,
    });

    // Hard delete existing seats - regeneration is a complete replacement
    // and soft-deleted seats would conflict with unique constraint on (tableId, seatNumber)
    await db.seat.deleteMany({
      where: { tableId },
    });

    // Create new seats
    const createdSeats = await Promise.all(
      seatPositions.map((pos) =>
        db.seat.create({
          data: {
            locationId: table.locationId,
            tableId,
            seatNumber: pos.seatNumber,
            label: String(pos.seatNumber), // Generate label from seat number
            relativeX: Math.round(pos.relativeX),
            relativeY: Math.round(pos.relativeY),
            angle: Math.round(pos.angle),
            seatType: 'standard',
            // If saveAsDefault, set original positions for restore capability
            ...(saveAsDefault
              ? {
                  originalRelativeX: Math.round(pos.relativeX),
                  originalRelativeY: Math.round(pos.relativeY),
                  originalAngle: Math.round(pos.angle),
                }
              : {}),
          },
        })
      )
    );

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true });

    return NextResponse.json({
      seats: createdSeats.map((s) => ({
        id: s.id,
        label: s.label,
        seatNumber: s.seatNumber,
        relativeX: s.relativeX,
        relativeY: s.relativeY,
        angle: s.angle,
        seatType: s.seatType,
        isActive: s.isActive,
      })),
    });
  } catch (error) {
    console.error('Failed to generate seats:', error);
    return NextResponse.json(
      { error: 'Failed to generate seats' },
      { status: 500 }
    );
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/reflow/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch';

// POST - Reflow seats when table is resized
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params;
    const body = await request.json();
    const { oldWidth, oldHeight, newWidth, newHeight, availableSpace } = body;

    if (!oldWidth || !oldHeight || !newWidth || !newHeight) {
      return NextResponse.json(
        { error: 'Missing dimension parameters' },
        { status: 400 }
      );
    }

    // Helper to calculate dynamic clearance based on available space
    const getDynamicClearance = (availableSpace: number | undefined, baseClearance: number = 25): number => {
      const SEAT_RADIUS = 20;
      const MIN_CLEARANCE = 10;
      const MAX_CLEARANCE = 50;

      if (availableSpace === undefined) return baseClearance;

      // Compress clearance if space is limited
      return Math.max(MIN_CLEARANCE, Math.min(baseClearance, availableSpace - SEAT_RADIUS));
    };

    // Get table and its active seats
    const table = await db.table.findUnique({
      where: { id: tableId },
      include: {
        seats: {
          where: { isActive: true, deletedAt: null },
          orderBy: { seatNumber: 'asc' },
        },
      },
    });

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      );
    }

    // Calculate dynamic clearance for each side
    const baseClearance = 25;
    const topClearance = getDynamicClearance(availableSpace?.top, baseClearance);
    const bottomClearance = getDynamicClearance(availableSpace?.bottom, baseClearance);
    const leftClearance = getDynamicClearance(availableSpace?.left, baseClearance);
    const rightClearance = getDynamicClearance(availableSpace?.right, baseClearance);

    // Handle round/oval tables differently
    const isRoundTable = table.shape === 'round' || table.shape === 'oval';

    // Update each seat's position using edge-relative positioning
    const updatedSeats = await Promise.all(
      table.seats.map((seat) => {
        const oldHalfW = oldWidth / 2;
        const oldHalfH = oldHeight / 2;
        const newHalfW = newWidth / 2;
        const newHalfH = newHeight / 2;

        let newRelX: number;
        let newRelY: number;

        if (isRoundTable) {
          // For round/oval tables: maintain radial distance from center
          // Calculate current angle and distance from center
          const currentAngle = Math.atan2(seat.relativeY, seat.relativeX);

          // Use average clearance for round tables (simplified)
          const avgClearance = (topClearance + bottomClearance + leftClearance + rightClearance) / 4;

          // For oval, use ellipse formula; for round, use circle
          let newRadius: number;
          if (table.shape === 'oval') {
            // Ellipse: maintain position on ellipse perimeter + clearance
            newRadius = Math.sqrt(
              Math.pow(newHalfW * Math.cos(currentAngle), 2) +
              Math.pow(newHalfH * Math.sin(currentAngle), 2)
            ) + avgClearance;
          } else {
            // Circle: use smaller dimension as radius
            newRadius = Math.min(newHalfW, newHalfH) + avgClearance;
          }

          newRelX = newRadius * Math.cos(currentAngle);
          newRelY = newRadius * Math.sin(currentAngle);
        } else {
          // For rectangular tables: determine which edge the seat belongs to
          const absX = Math.abs(seat.relativeX);
          const absY = Math.abs(seat.relativeY);

          // Normalize to see which edge dominates
          const normalizedX = absX / oldHalfW;  // 0 = center, 1 = edge
          const normalizedY = absY / oldHalfH;

          if (normalizedY >= normalizedX) {
            // Seat is on top or bottom edge
            // Use dynamic clearance based on side
            const direction = seat.relativeY >= 0 ? 1 : -1;
            const clearance = direction > 0 ? bottomClearance : topClearance;
            newRelY = direction * (newHalfH + clearance);

            // Scale X position proportionally along the edge
            newRelX = seat.relativeX * (newWidth / oldWidth);
          } else {
            // Seat is on left or right edge
            // Use dynamic clearance based on side
            const direction = seat.relativeX >= 0 ? 1 : -1;
            const clearance = direction > 0 ? rightClearance : leftClearance;
            newRelX = direction * (newHalfW + clearance);

            // Scale Y position proportionally along the edge
            newRelY = seat.relativeY * (newHeight / oldHeight);
          }
        }

        // Update seat position
        return db.seat.update({
          where: { id: seat.id },
          data: {
            relativeX: Math.round(newRelX),
            relativeY: Math.round(newRelY),
          },
        });
      })
    );

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true });

    return NextResponse.json({
      seats: updatedSeats.map((s) => ({
        id: s.id,
        seatNumber: s.seatNumber,
        label: s.label,
        relativeX: s.relativeX,
        relativeY: s.relativeY,
        angle: s.angle,
      })),
      message: `Reflowed ${updatedSeats.length} seats`,
    });
  } catch (error) {
    console.error('Failed to reflow seats:', error);
    return NextResponse.json(
      { error: 'Failed to reflow seats' },
      { status: 500 }
    );
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// GET - List all seats for a table
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const searchParams = request.nextUrl.searchParams
    const includeInactive = searchParams.get('includeInactive') === 'true'

    // Verify table exists
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: { id: true, name: true, shape: true, capacity: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    const seats = await db.seat.findMany({
      where: {
        tableId,
        deletedAt: null,
        ...(includeInactive ? {} : { isActive: true }),
      },
      orderBy: { seatNumber: 'asc' },
    })

    return NextResponse.json({
      seats: seats.map(seat => ({
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        originalRelativeX: seat.originalRelativeX,
        originalRelativeY: seat.originalRelativeY,
        originalAngle: seat.originalAngle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      })),
      table: {
        id: table.id,
        name: table.name,
        shape: table.shape,
        capacity: table.capacity,
      },
    })
  } catch (error) {
    console.error('Failed to fetch seats:', error)
    return NextResponse.json(
      { error: 'Failed to fetch seats' },
      { status: 500 }
    )
  }
}

// POST - Add a seat to table
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const {
      label,
      seatNumber,
      relativeX,
      relativeY,
      angle,
      seatType,
      insertAt,
    } = body

    // Verify table exists and get locationId
    const table = await db.table.findUnique({
      where: { id: tableId },
      select: { id: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // If insertAt is provided, renumber existing seats >= insertAt
    if (insertAt !== undefined && insertAt > 0) {
      await db.seat.updateMany({
        where: {
          tableId,
          seatNumber: { gte: insertAt },
          deletedAt: null,
        },
        data: {
          seatNumber: { increment: 1 },
        },
      })
    }

    // Determine final seat number
    let finalSeatNumber = seatNumber ?? insertAt
    if (!finalSeatNumber) {
      const maxSeat = await db.seat.findFirst({
        where: { tableId, deletedAt: null },
        orderBy: { seatNumber: 'desc' },
        select: { seatNumber: true },
      })
      finalSeatNumber = (maxSeat?.seatNumber ?? 0) + 1
    }

    // Calculate final positions
    const finalRelativeX = relativeX ?? 0
    const finalRelativeY = relativeY ?? 0
    const finalAngle = angle ?? 0

    const seat = await db.seat.create({
      data: {
        locationId: table.locationId,
        tableId,
        label: label ?? String(finalSeatNumber),
        seatNumber: finalSeatNumber,
        relativeX: finalRelativeX,
        relativeY: finalRelativeY,
        angle: finalAngle,
        seatType: seatType ?? 'standard',
        // Save initial position as the "builder default" for restore after combine/split
        originalRelativeX: finalRelativeX,
        originalRelativeY: finalRelativeY,
        originalAngle: finalAngle,
      },
    })

    // Fetch all seats for UI update
    const allSeats = await db.seat.findMany({
      where: { tableId, deletedAt: null, isActive: true },
      orderBy: { seatNumber: 'asc' },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(table.locationId, { async: true })

    return NextResponse.json({
      seat: {
        id: seat.id,
        tableId: seat.tableId,
        label: seat.label,
        seatNumber: seat.seatNumber,
        relativeX: seat.relativeX,
        relativeY: seat.relativeY,
        angle: seat.angle,
        seatType: seat.seatType,
        isActive: seat.isActive,
      },
      seats: allSeats.map(s => ({
        id: s.id,
        label: s.label,
        seatNumber: s.seatNumber,
        relativeX: s.relativeX,
        relativeY: s.relativeY,
        angle: s.angle,
        seatType: s.seatType,
        isActive: s.isActive,
      })),
    })
  } catch (error) {
    console.error('Failed to create seat:', error)
    return NextResponse.json(
      { error: 'Failed to create seat' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/[id]/seats/save-as-default/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * POST /api/tables/[id]/seats/save-as-default
 *
 * Save all current seat positions as the "builder default" positions.
 * This is used by admins to explicitly save seat arrangements from the floor plan builder.
 * When tables are split/reset, seats will return to these saved positions.
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: tableId } = await params
    const body = await request.json()
    const { locationId, employeeId } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Verify table exists
    const table = await db.table.findFirst({
      where: { id: tableId, locationId, deletedAt: null },
      select: { id: true, name: true, locationId: true },
    })

    if (!table) {
      return NextResponse.json(
        { error: 'Table not found' },
        { status: 404 }
      )
    }

    // Get all active seats for this table
    const seats = await db.seat.findMany({
      where: {
        tableId,
        isActive: true,
        deletedAt: null,
      },
    })

    if (seats.length === 0) {
      return NextResponse.json(
        { error: 'No seats found for this table' },
        { status: 400 }
      )
    }

    // Update all seats to save current positions as original/default
    const result = await db.$transaction(async (tx) => {
      const updatedSeats = []

      for (const seat of seats) {
        const updated = await tx.seat.update({
          where: { id: seat.id },
          data: {
            originalRelativeX: seat.relativeX,
            originalRelativeY: seat.relativeY,
            originalAngle: seat.angle,
          },
        })
        updatedSeats.push(updated)
      }

      // Audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'seats_saved_as_default',
          entityType: 'table',
          entityId: tableId,
          details: {
            tableName: table.name,
            seatCount: updatedSeats.length,
            positions: updatedSeats.map(s => ({
              id: s.id,
              label: s.label,
              relativeX: s.relativeX,
              relativeY: s.relativeY,
              angle: s.angle,
            })),
          },
        },
      })

      return updatedSeats
    })

    return NextResponse.json({
      data: {
        tableId,
        tableName: table.name,
        savedCount: result.length,
        message: `Saved ${result.length} seat positions as default for ${table.name}`,
      },
    })
  } catch (error) {
    console.error('[SaveSeatsAsDefault] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to save seat positions as default' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/seats/generate-all/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'
import { generateSeatPositions as generateSeatPositionsFromLib, type SeatPattern as LibSeatPattern } from '@/lib/seat-generation'

// Helper function to generate seat labels
function getLabel(index: number): string {
  return String(index + 1)
}

/**
 * POST /api/tables/seats/generate-all
 *
 * Bulk-generate seats for all tables that don't have any seats.
 * This is a one-time migration endpoint.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { locationId, forceRegenerate = false, employeeId } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Get all active tables for this location
    const tables = await db.table.findMany({
      where: {
        locationId,
        isActive: true,
        deletedAt: null,
      },
      include: {
        seats: {
          where: { isActive: true, deletedAt: null },
          select: { id: true },
        },
      },
    })

    const results: { tableId: string; tableName: string; seatsGenerated: number }[] = []
    let skipped = 0

    for (const table of tables) {
      // Skip if table already has seats (unless forceRegenerate)
      if (table.seats.length > 0 && !forceRegenerate) {
        skipped++
        continue
      }

      // If forceRegenerate, soft-delete existing seats first
      if (forceRegenerate && table.seats.length > 0) {
        await db.seat.updateMany({
          where: {
            tableId: table.id,
            isActive: true,
          },
          data: {
            isActive: false,
            deletedAt: new Date(),
          },
        })
      }

      // Map local patterns to library patterns
      const patternMap: Record<string, LibSeatPattern> = {
        'all_around': 'all_around',
        'front_only': 'one_side',
        'two_sides': 'two_sides',
        'three_sides': 'booth', // Maps to booth pattern (3 sides)
        'inside': 'booth', // Maps to booth pattern
      }

      // Determine seat pattern based on shape or stored pattern
      let localPattern = table.seatPattern || 'all_around'
      if (table.shape === 'bar') localPattern = 'front_only'
      else if (table.shape === 'booth') localPattern = 'inside'

      // Map to library pattern
      const libraryPattern = patternMap[localPattern as string] || 'all_around'

      // Generate seat positions using library function
      const baseSeatPositions = generateSeatPositionsFromLib({
        shape: table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth',
        pattern: libraryPattern,
        capacity: table.capacity,
        width: table.width,
        height: table.height,
      })

      // Add labels to seat positions
      const seatPositions = baseSeatPositions.map((pos, index) => ({
        ...pos,
        label: getLabel(index),
      }))

      // Create seats in database
      await db.seat.createMany({
        data: seatPositions.map(pos => ({
          locationId,
          tableId: table.id,
          label: pos.label,
          seatNumber: pos.seatNumber,
          relativeX: pos.relativeX,
          relativeY: pos.relativeY,
          angle: pos.angle,
          seatType: 'standard',
        })),
      })

      results.push({
        tableId: table.id,
        tableName: table.name,
        seatsGenerated: seatPositions.length,
      })
    }

    // Create audit log for bulk operation
    if (results.length > 0) {
      await db.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'seats_bulk_generated',
          entityType: 'table',
          entityId: locationId, // Use locationId since this affects multiple tables
          details: {
            totalTables: tables.length,
            tablesUpdated: results.length,
            tablesSkipped: skipped,
            forceRegenerate,
            tableNames: results.map(r => r.tableName),
          },
        },
      })

      console.log(`[GenerateAllSeats] Generated seats for ${results.length} tables (${skipped} skipped)`)
    }

    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({
      success: true,
      totalTables: tables.length,
      tablesUpdated: results.length,
      tablesSkipped: skipped,
      results,
    })
  } catch (error) {
    console.error('[GenerateAllSeats] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to generate seats' },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/seats/reflow/route.ts
################################################################################

// src/app/api/tables/seats/reflow/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import {
  distributeSeatsOnPerimeter,
  getGroupBoundingBox,
  type TableRect,
} from '@/lib/table-geometry'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

interface ReflowSeatsBody {
  locationId: string
  /** Physical group or virtual group: all tables that share one perimeter */
  tableIds: string[]
  /** Optional: override seat count; if omitted, keep current seat count */
  seatCount?: number
}

/**
 * POST /api/tables/seats/reflow
 *
 * Rebuilds seat positions for a set of tables that form one logical group:
 * - Uses true perimeter of all tables (L/T/U/22)
 * - Distributes seats evenly around perimeter
 * - Sorts clockwise and labels seats 1..N
 *
 * Used by:
 * - Add/remove seat in admin
 * - Virtual group capacity changes
 * - Manual "fix seats" actions
 */
export async function POST(request: NextRequest) {
  let body: ReflowSeatsBody
  try {
    body = (await request.json()) as ReflowSeatsBody
  } catch (err) {
    return NextResponse.json(
      { error: 'Invalid JSON in request body', details: String(err) },
      { status: 400 }
    )
  }

  const { locationId, tableIds, seatCount } = body

  if (!locationId || !tableIds || tableIds.length === 0) {
    return NextResponse.json(
      { error: 'locationId and tableIds[] are required' },
      { status: 400 }
    )
  }

  try {
    // 1) Load tables + seats
    const tables = await db.table.findMany({
      where: {
        id: { in: tableIds },
        locationId,
        deletedAt: null,
      },
      select: {
        id: true,
        posX: true,
        posY: true,
        width: true,
        height: true,
      },
    })

    if (tables.length === 0) {
      return NextResponse.json(
        { error: 'No tables found for given IDs' },
        { status: 404 }
      )
    }

    const seats = await db.seat.findMany({
      where: {
        tableId: { in: tableIds },
        isActive: true,
        deletedAt: null,
      },
      orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
    })

    const targetSeatCount = seatCount ?? seats.length

    if (targetSeatCount <= 0) {
      // No seats desired: mark existing seats inactive
      await db.seat.updateMany({
        where: { tableId: { in: tableIds }, isActive: true, deletedAt: null },
        data: { isActive: false },
      })

      return NextResponse.json({
        data: {
          seats: [],
          message: 'All seats removed for group',
        },
      })
    }

    // 2) Build TableRect array for perimeter
    const groupRects: TableRect[] = tables.map(t => ({
      id: t.id,
      posX: t.posX,
      posY: t.posY,
      width: t.width,
      height: t.height,
      combinedWithId: null,
      combinedTableIds: null,
    }))

    const perimeterPositions = distributeSeatsOnPerimeter(groupRects, targetSeatCount)
    if (perimeterPositions.length === 0) {
      return NextResponse.json(
        { error: 'Unable to compute perimeter positions for seats' },
        { status: 500 }
      )
    }

    const bounds = getGroupBoundingBox(groupRects)
    const centerX = bounds ? bounds.minX + bounds.width / 2 : 0
    const centerY = bounds ? bounds.minY + bounds.height / 2 : 0

    // 3) Ensure we have exactly targetSeatCount seats
    //    - If fewer: create new ones on the first tableId
    //    - If more: keep first N by seatNumber, mark rest inactive
    const firstTableId = tables[0].id

    if (seats.length < targetSeatCount) {
      const toCreate = targetSeatCount - seats.length
      const created = await db.$transaction(async tx => {
        const createdSeats = []
        for (let i = 0; i < toCreate; i++) {
          const seat = await tx.seat.create({
            data: {
              locationId,
              tableId: firstTableId,
              label: '',
              seatNumber: seats.length + i + 1,
              relativeX: 0,
              relativeY: 0,
              angle: 0,
              isActive: true,
            },
          })
          createdSeats.push(seat)
        }
        return createdSeats
      })
      seats.push(...created)
    } else if (seats.length > targetSeatCount) {
      const toDeactivate = seats.slice(targetSeatCount)
      const idsToDeactivate = toDeactivate.map(s => s.id)
      await db.seat.updateMany({
        where: { id: { in: idsToDeactivate } },
        data: { isActive: false },
      })
    }

    const activeSeats = seats.slice(0, targetSeatCount)

    // 4) Map each perimeter point to a seat, compute relative positions & inward angle
    const tableMap = new Map<
      string,
      { posX: number; posY: number; width: number; height: number }
    >()
    tables.forEach(t => {
      tableMap.set(t.id, {
        posX: t.posX,
        posY: t.posY,
        width: t.width,
        height: t.height,
      })
    })

    // Assign perimeter positions in order; then sort clockwise and relabel
    const seatsWithWorld: {
      seat: (typeof activeSeats)[number]
      worldX: number
      worldY: number
      angle: number
    }[] = []

    for (let i = 0; i < activeSeats.length; i++) {
      const seat = activeSeats[i]
      const pos = perimeterPositions[i]
      const worldX = pos.x
      const worldY = pos.y

      const dx = worldX - centerX
      const dy = worldY - centerY
      let angle = (Math.atan2(dy, dx) * 180) / Math.PI
      angle = (angle + 450) % 360 // top=0, clockwise

      seatsWithWorld.push({ seat, worldX, worldY, angle })
    }

    seatsWithWorld.sort((a, b) => a.angle - b.angle)

    // 5) Persist updates
    await db.$transaction(async tx => {
      for (let i = 0; i < seatsWithWorld.length; i++) {
        const { seat, worldX, worldY } = seatsWithWorld[i]

        // Simple strategy: attach all new/extra seats to firstTableId
        const tableId = tableIds.includes(seat.tableId) ? seat.tableId : firstTableId
        const tablePos = tableMap.get(tableId)
        if (!tablePos) continue

        const tableCenterX = tablePos.posX + tablePos.width / 2
        const tableCenterY = tablePos.posY + tablePos.height / 2

        const relativeX = Math.round(worldX - tableCenterX)
        const relativeY = Math.round(worldY - tableCenterY)

        const angleToCenter =
          (Math.atan2(centerY - worldY, centerX - worldX) * 180) / Math.PI
        const newAngle = Math.round(angleToCenter)

        await tx.seat.update({
          where: { id: seat.id },
          data: {
            tableId,
            relativeX,
            relativeY,
            angle: newAngle,
            label: String(i + 1),
            seatNumber: i + 1,
            isActive: true,
          },
        })
      }
    })

    dispatchFloorPlanUpdate(locationId, { async: true })

    const updatedSeats = await db.seat.findMany({
      where: {
        tableId: { in: tableIds },
        isActive: true,
        deletedAt: null,
      },
      select: {
        id: true,
        tableId: true,
        label: true,
        seatNumber: true,
        relativeX: true,
        relativeY: true,
        angle: true,
      },
      orderBy: { seatNumber: 'asc' },
    })

    return NextResponse.json({
      data: {
        seats: updatedSeats,
        message: `Seats reflowed for ${tableIds.length} table(s) to ${targetSeatCount} seat(s)`,
      },
    })
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error'
    const stack = error instanceof Error ? error.stack : undefined

    return NextResponse.json(
      {
        error: 'Failed to reflow seats',
        details: msg,
        stack,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/tables/seats/save-all-as-default/route.ts
################################################################################

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * POST /api/tables/seats/save-all-as-default
 *
 * Save ALL current seat positions across ALL tables as the "builder default" positions.
 * This is used by admins to save the entire floor plan arrangement.
 * When tables are split/reset, seats will return to these saved positions.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { locationId, employeeId, tableIds } = body

    if (!locationId) {
      return NextResponse.json(
        { error: 'locationId is required' },
        { status: 400 }
      )
    }

    // Build query - either specific tables or all tables
    const tableQuery: { locationId: string; deletedAt: null; id?: { in: string[] } } = {
      locationId,
      deletedAt: null,
    }
    if (tableIds && Array.isArray(tableIds) && tableIds.length > 0) {
      tableQuery.id = { in: tableIds }
    }

    // Get all tables
    const tables = await db.table.findMany({
      where: tableQuery,
      select: { id: true, name: true },
    })

    if (tables.length === 0) {
      return NextResponse.json(
        { error: 'No tables found' },
        { status: 404 }
      )
    }

    const tableIdList = tables.map(t => t.id)

    // Get all active seats for these tables
    const seats = await db.seat.findMany({
      where: {
        tableId: { in: tableIdList },
        isActive: true,
        deletedAt: null,
      },
    })

    if (seats.length === 0) {
      return NextResponse.json({
        data: {
          savedCount: 0,
          tableCount: tables.length,
          message: 'No seats to save',
        },
      })
    }

    // Update all seats to save current positions as original/default
    const result = await db.$transaction(async (tx) => {
      let savedCount = 0

      for (const seat of seats) {
        await tx.seat.update({
          where: { id: seat.id },
          data: {
            originalRelativeX: seat.relativeX,
            originalRelativeY: seat.relativeY,
            originalAngle: seat.angle,
          },
        })
        savedCount++
      }

      // Audit log
      await tx.auditLog.create({
        data: {
          locationId,
          employeeId: employeeId || null,
          action: 'all_seats_saved_as_default',
          entityType: 'location',
          entityId: locationId,
          details: {
            tableCount: tables.length,
            seatCount: savedCount,
            tableNames: tables.map(t => t.name),
          },
        },
      })

      return savedCount
    })

    return NextResponse.json({
      data: {
        savedCount: result,
        tableCount: tables.length,
        message: `Saved ${result} seat positions across ${tables.length} tables as default`,
      },
    })
  } catch (error) {
    console.error('[SaveAllSeatsAsDefault] Failed:', error)
    return NextResponse.json(
      { error: 'Failed to save seat positions as default' },
      { status: 500 }
    )
  }
}


================================================================================
SECTION 5: API ROUTES - FLOOR PLAN & ELEMENTS
================================================================================

################################################################################
# FILE: src/app/api/floor-plan/route.ts
################################################################################

// src/app/api/floor-plan/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

/**
 * GET /api/floor-plan?locationId=xxx&sectionId=yyy&include=tables,seats,sections,entertainment,elements,virtualGroups
 *
 * Returns complete floor plan data in a single call.
 * - tables: Table records with positions and virtual group info
 * - seats: Seat positions for all tables
 * - sections: Section/room definitions
 * - entertainment: Entertainment elements (pool tables, dartboards, etc.) with session data
 * - elements: Floor plan elements (walls, bars, etc.)
 * - virtualGroups: Combined table groups
 *
 * Used by FloorPlanHome to load initial data.
 */
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const locationId = searchParams.get('locationId')
  const sectionId = searchParams.get('sectionId')
  const includeParam = searchParams.get('include')
  const include = includeParam
    ? includeParam.split(',').map(s => s.trim())
    : ['tables', 'seats', 'sections', 'entertainment', 'elements', 'virtualGroups']

  if (!locationId) {
    return NextResponse.json(
      { error: 'locationId is required' },
      { status: 400 }
    )
  }

  try {
    // Fetch sections if requested
    const sections = include.includes('sections')
      ? await db.section.findMany({
          where: { locationId, deletedAt: null },
          select: {
            id: true,
            name: true,
            color: true,
            sortOrder: true,
          },
          orderBy: { sortOrder: 'asc' },
        })
      : []

    // Build where clause for tables
    const tableWhere: {
      locationId: string
      deletedAt: null
      sectionId?: string
    } = {
      locationId,
      deletedAt: null,
    }

    if (sectionId) {
      tableWhere.sectionId = sectionId
    }

    // Fetch tables with section info (if requested)
    const tables = include.includes('tables')
      ? await db.table.findMany({
      where: tableWhere,
      select: {
        id: true,
        name: true,
        sectionId: true,
        posX: true,
        posY: true,
        width: true,
        height: true,
        status: true,
        capacity: true,
        combinedWithId: true,
        combinedTableIds: true,
        virtualGroupId: true,
        virtualGroupPrimary: true,
        virtualGroupColor: true,
        section: {
          select: {
            id: true,
            name: true,
            color: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    })
      : []

    // Get all table IDs for seat and order queries
    const tableIds = tables.map(t => t.id)

    // Fetch seats for these tables (if requested)
    const seats = include.includes('seats') && tableIds.length > 0
      ? await db.seat.findMany({
      where: {
        tableId: { in: tableIds },
        isActive: true,
        deletedAt: null,
      },
      select: {
        id: true,
        tableId: true,
        label: true,
        seatNumber: true,
        relativeX: true,
        relativeY: true,
        angle: true,
      },
      orderBy: [{ tableId: 'asc' }, { seatNumber: 'asc' }],
    })
      : []

    // Fetch entertainment elements (if requested)
    const entertainmentElements = include.includes('entertainment')
      ? await db.floorPlanElement.findMany({
          where: {
            locationId,
            elementType: 'entertainment',
            deletedAt: null,
          },
          include: {
            linkedMenuItem: {
              select: {
                id: true,
                name: true,
                price: true,
                blockTimeMinutes: true,
                entertainmentStatus: true,
                currentOrderId: true,
              },
            },
            waitlistEntries: {
              where: { status: 'waiting', deletedAt: null },
              select: { id: true },
            },
          },
          orderBy: { sortOrder: 'asc' },
        })
      : []

    // Transform entertainment data
    const transformedEntertainment = entertainmentElements.map(el => ({
      id: el.id,
      name: el.name,
      abbreviation: el.abbreviation,
      elementType: el.elementType,
      visualType: el.visualType,
      linkedMenuItemId: el.linkedMenuItemId,
      linkedMenuItem: el.linkedMenuItem,
      posX: el.posX,
      posY: el.posY,
      width: el.width,
      height: el.height,
      rotation: el.rotation,
      status: el.status || el.linkedMenuItem?.entertainmentStatus || 'available',
      currentOrderId: el.currentOrderId,
      sessionStartedAt: el.sessionStartedAt,
      sessionExpiresAt: el.sessionExpiresAt,
      waitlistCount: el.waitlistEntries?.length || 0,
      sectionId: el.sectionId,
    }))

    // Fetch floor plan elements (if requested)
    const elements = include.includes('elements')
      ? await db.floorPlanElement.findMany({
          where: { locationId, deletedAt: null },
          select: {
            id: true,
            name: true,
            elementType: true,
            visualType: true,
            posX: true,
            posY: true,
            width: true,
            height: true,
            rotation: true,
            linkedMenuItemId: true,
            linkedMenuItem: {
              select: {
                id: true,
                name: true,
                entertainmentStatus: true,
              },
            },
          },
        })
      : []

    // Fetch open orders for these tables (status = open or in_progress)
    const openOrders = tableIds.length > 0
      ? await db.order.findMany({
      where: {
        tableId: { in: tableIds },
        status: { in: ['open', 'in_progress'] },
        deletedAt: null,
      },
      select: {
        id: true,
        orderNumber: true,
        tableId: true,
        status: true,
        total: true,
        createdAt: true,
        employee: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    })
      : []

    // Create a map of tableId -> currentOrder (most recent open order)
    const ordersByTable = new Map<string, {
      id: string
      orderNumber: number
      total: number
      openedAt: string
      server: string
    }>()

    for (const order of openOrders) {
      if (order.tableId && !ordersByTable.has(order.tableId)) {
        ordersByTable.set(order.tableId, {
          id: order.id,
          orderNumber: order.orderNumber,
          total: Number(order.total),
          openedAt: order.createdAt.toISOString(),
          server: order.employee
            ? `${order.employee.firstName} ${order.employee.lastName || ''}`.trim()
            : 'Unknown',
        })
      }
    }

    // Format tables to match store shape (with currentOrder)
    const formattedTables = tables.map(t => ({
      id: t.id,
      name: t.name,
      sectionId: t.sectionId,
      posX: t.posX,
      posY: t.posY,
      width: t.width,
      height: t.height,
      status: t.status as 'available' | 'occupied' | 'dirty' | 'reserved',
      capacity: t.capacity,
      combinedWithId: t.combinedWithId,
      combinedTableIds: t.combinedTableIds as string[] | null,
      virtualGroupId: t.virtualGroupId,
      virtualGroupPrimary: t.virtualGroupPrimary,
      virtualGroupColor: t.virtualGroupColor,
      currentOrder: ordersByTable.get(t.id) || null,
    }))

    // Format seats to match store shape
    const formattedSeats = seats.map(s => ({
      id: s.id,
      tableId: s.tableId,
      label: s.label,
      seatNumber: s.seatNumber,
      relativeX: s.relativeX,
      relativeY: s.relativeY,
      angle: s.angle,
    }))

    // Extract virtual groups from tables (if requested)
    interface VirtualGroup {
      virtualGroupId: string
      primaryTableId: string | null
      groupColor: string | null
      tableIds: string[]
      tableNames: string[]
    }

    const virtualGroupsMap = include.includes('virtualGroups')
      ? tables
          .filter(t => t.virtualGroupId)
          .reduce((acc, table) => {
            const groupId = table.virtualGroupId!
            if (!acc[groupId]) {
              acc[groupId] = {
                virtualGroupId: groupId,
                primaryTableId: null as string | null,
                groupColor: table.virtualGroupColor,
                tableIds: [],
                tableNames: [],
              }
            }
            acc[groupId].tableIds.push(table.id)
            acc[groupId].tableNames.push(table.name)
            if (table.virtualGroupPrimary) {
              acc[groupId].primaryTableId = table.id
            }
            return acc
          }, {} as Record<string, VirtualGroup>)
      : {}

    const virtualGroups = Object.values(virtualGroupsMap)

    // Build response based on include parameter
    const response: any = { data: {} }
    if (include.includes('tables')) response.data.tables = formattedTables
    if (include.includes('seats')) response.data.seats = formattedSeats
    if (include.includes('sections')) response.data.sections = sections
    if (include.includes('entertainment')) response.data.entertainment = transformedEntertainment
    if (include.includes('elements')) response.data.elements = elements
    if (include.includes('virtualGroups')) response.data.virtualGroups = virtualGroups

    return NextResponse.json(response)
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[FloorPlan API] Error:', msg)

    return NextResponse.json(
      { error: 'Failed to load floor plan', details: msg },
      { status: 500 }
    )
  }
}



################################################################################
# FILE: src/app/api/floor-plan-elements/[id]/route.ts
################################################################################

import { db } from '@/lib/db'
import { NextResponse } from 'next/server'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// GET - Get a single floor plan element
export async function GET(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params

  try {
    const { searchParams } = new URL(req.url)
    const locationId = searchParams.get('locationId')

    if (!locationId) {
      return NextResponse.json({ error: 'locationId is required' }, { status: 400 })
    }

    const element = await db.floorPlanElement.findFirst({
      where: { id, locationId, deletedAt: null },
      include: {
        linkedMenuItem: {
          select: {
            id: true,
            name: true,
            price: true,
            itemType: true,
            entertainmentStatus: true,
            blockTimeMinutes: true,
            currentOrderId: true,
          },
        },
        section: {
          select: {
            id: true,
            name: true,
            color: true,
          },
        },
        waitlistEntries: {
          where: { status: 'waiting', deletedAt: null },
          orderBy: { position: 'asc' },
          include: {
            table: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
      },
    })

    if (!element) {
      return NextResponse.json({ error: 'Element not found' }, { status: 404 })
    }

    return NextResponse.json({ element })
  } catch (error) {
    console.error('[floor-plan-elements/[id]] GET error:', error)
    return NextResponse.json({ error: 'Failed to fetch element' }, { status: 500 })
  }
}

// PUT - Update a floor plan element
export async function PUT(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params

  try {
    const body = await req.json()
    const {
      locationId,
      name,
      abbreviation,
      sectionId,
      visualType,
      linkedMenuItemId,
      posX,
      posY,
      width,
      height,
      rotation,
      geometry,
      thickness,
      fillColor,
      strokeColor,
      opacity,
      status,
      currentOrderId,
      sessionStartedAt,
      sessionExpiresAt,
      isLocked,
      isVisible,
    } = body

    if (!locationId) {
      return NextResponse.json({ error: 'locationId is required' }, { status: 400 })
    }

    // Verify the element belongs to this location
    const existing = await db.floorPlanElement.findFirst({
      where: { id, locationId, deletedAt: null },
    })

    if (!existing) {
      return NextResponse.json({ error: 'Element not found or access denied' }, { status: 404 })
    }

    const element = await db.floorPlanElement.update({
      where: { id },
      data: {
        ...(name !== undefined && { name }),
        ...(abbreviation !== undefined && { abbreviation }),
        ...(sectionId !== undefined && { sectionId: sectionId || null }),
        ...(visualType !== undefined && { visualType }),
        ...(linkedMenuItemId !== undefined && { linkedMenuItemId: linkedMenuItemId || null }),
        ...(posX !== undefined && { posX }),
        ...(posY !== undefined && { posY }),
        ...(width !== undefined && { width }),
        ...(height !== undefined && { height }),
        ...(rotation !== undefined && { rotation }),
        ...(geometry !== undefined && { geometry }),
        ...(thickness !== undefined && { thickness }),
        ...(fillColor !== undefined && { fillColor }),
        ...(strokeColor !== undefined && { strokeColor }),
        ...(opacity !== undefined && { opacity }),
        ...(status !== undefined && { status }),
        ...(currentOrderId !== undefined && { currentOrderId }),
        ...(sessionStartedAt !== undefined && { sessionStartedAt: sessionStartedAt ? new Date(sessionStartedAt) : null }),
        ...(sessionExpiresAt !== undefined && { sessionExpiresAt: sessionExpiresAt ? new Date(sessionExpiresAt) : null }),
        ...(isLocked !== undefined && { isLocked }),
        ...(isVisible !== undefined && { isVisible }),
      },
      include: {
        linkedMenuItem: {
          select: {
            id: true,
            name: true,
            price: true,
            itemType: true,
            entertainmentStatus: true,
            blockTimeMinutes: true,
          },
        },
        section: {
          select: {
            id: true,
            name: true,
            color: true,
          },
        },
      },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(element.locationId, { async: true })

    return NextResponse.json({ element })
  } catch (error) {
    console.error('[floor-plan-elements/[id]] PUT error:', error)
    return NextResponse.json({ error: 'Failed to update element' }, { status: 500 })
  }
}

// DELETE - Soft delete a floor plan element
export async function DELETE(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params

  try {
    const { searchParams } = new URL(req.url)
    const locationId = searchParams.get('locationId')

    if (!locationId) {
      return NextResponse.json({ error: 'locationId is required' }, { status: 400 })
    }

    // Verify the element belongs to this location
    const existing = await db.floorPlanElement.findFirst({
      where: { id, locationId, deletedAt: null },
    })

    if (!existing) {
      return NextResponse.json({ error: 'Element not found or access denied' }, { status: 404 })
    }

    const element = await db.floorPlanElement.update({
      where: { id },
      data: { deletedAt: new Date() },
      select: { locationId: true },
    })

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(element.locationId, { async: true })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('[floor-plan-elements/[id]] DELETE error:', error)
    return NextResponse.json({ error: 'Failed to delete element' }, { status: 500 })
  }
}



################################################################################
# FILE: src/app/api/floor-plan-elements/route.ts
################################################################################

import { db } from '@/lib/db'
import { NextResponse } from 'next/server'
import { dispatchFloorPlanUpdate } from '@/lib/socket-dispatch'

// GET - List all floor plan elements for a location (optionally filtered by section)
export async function GET(req: Request) {
  const { searchParams } = new URL(req.url)
  const locationId = searchParams.get('locationId')
  const sectionId = searchParams.get('sectionId')

  if (!locationId) {
    return NextResponse.json({ error: 'locationId required' }, { status: 400 })
  }

  try {
    const elements = await db.floorPlanElement.findMany({
      where: {
        locationId,
        deletedAt: null,
        ...(sectionId && { sectionId }),
      },
      include: {
        linkedMenuItem: {
          select: {
            id: true,
            name: true,
            price: true,
            itemType: true,
            entertainmentStatus: true,
            blockTimeMinutes: true,
          },
        },
        section: {
          select: {
            id: true,
            name: true,
            color: true,
          },
        },
        waitlistEntries: {
          where: { status: 'waiting', deletedAt: null },
          orderBy: { position: 'asc' },
          select: {
            id: true,
            customerName: true,
            partySize: true,
            requestedAt: true,
            tableId: true,
          },
        },
      },
      orderBy: { sortOrder: 'asc' },
    })

    return NextResponse.json({
      elements: elements.map((el) => ({
        id: el.id,
        name: el.name,
        abbreviation: el.abbreviation,
        elementType: el.elementType,
        visualType: el.visualType,
        linkedMenuItemId: el.linkedMenuItemId,
        linkedMenuItem: el.linkedMenuItem,
        sectionId: el.sectionId,
        section: el.section,
        posX: el.posX,
        posY: el.posY,
        width: el.width,
        height: el.height,
        rotation: el.rotation,
        geometry: el.geometry,
        thickness: el.thickness,
        fillColor: el.fillColor,
        strokeColor: el.strokeColor,
        opacity: el.opacity,
        status: el.status,
        currentOrderId: el.currentOrderId,
        sessionStartedAt: el.sessionStartedAt,
        sessionExpiresAt: el.sessionExpiresAt,
        isLocked: el.isLocked,
        isVisible: el.isVisible,
        waitlistCount: el.waitlistEntries.length,
        waitlistEntries: el.waitlistEntries,
      })),
    })
  } catch (error) {
    console.error('[floor-plan-elements] GET error:', error)
    return NextResponse.json({ error: 'Failed to fetch elements' }, { status: 500 })
  }
}

// POST - Create a new floor plan element
export async function POST(req: Request) {
  try {
    const body = await req.json()
    console.log('[floor-plan-elements] POST body:', body)

    const {
      locationId,
      sectionId,
      name,
      abbreviation,
      elementType = 'entertainment',
      visualType,
      linkedMenuItemId,
      posX = 100,
      posY = 100,
      width,
      height,
      rotation = 0,
      geometry,
      thickness = 0.5,
      fillColor,
      strokeColor,
      opacity = 1.0,
    } = body

    if (!locationId || !name || !visualType) {
      return NextResponse.json(
        { error: `Missing required fields: ${!locationId ? 'locationId ' : ''}${!name ? 'name ' : ''}${!visualType ? 'visualType' : ''}` },
        { status: 400 }
      )
    }

    // Verify linkedMenuItemId exists if provided
    if (linkedMenuItemId) {
      const menuItem = await db.menuItem.findUnique({
        where: { id: linkedMenuItemId },
        select: { id: true },
      })
      if (!menuItem) {
        return NextResponse.json(
          { error: `Menu item not found: ${linkedMenuItemId}` },
          { status: 400 }
        )
      }
    }

    // Verify sectionId exists if provided
    if (sectionId) {
      const section = await db.section.findUnique({
        where: { id: sectionId },
        select: { id: true },
      })
      if (!section) {
        return NextResponse.json(
          { error: `Section not found: ${sectionId}` },
          { status: 400 }
        )
      }
    }

    // Get highest sortOrder to place new element at end
    const lastElement = await db.floorPlanElement.findFirst({
      where: { locationId, deletedAt: null },
      orderBy: { sortOrder: 'desc' },
      select: { sortOrder: true },
    })

    console.log('[floor-plan-elements] Creating element...')

    const element = await db.floorPlanElement.create({
      data: {
        locationId,
        sectionId: sectionId || null,
        name,
        abbreviation,
        elementType,
        visualType,
        linkedMenuItemId: linkedMenuItemId || null,
        posX,
        posY,
        width: width || 100,
        height: height || 100,
        rotation,
        geometry: geometry || null,
        thickness,
        fillColor,
        strokeColor,
        opacity,
        sortOrder: (lastElement?.sortOrder ?? -1) + 1,
      },
      include: {
        linkedMenuItem: {
          select: {
            id: true,
            name: true,
            price: true,
            itemType: true,
            entertainmentStatus: true,
            blockTimeMinutes: true,
          },
        },
        section: {
          select: {
            id: true,
            name: true,
            color: true,
          },
        },
      },
    })

    console.log('[floor-plan-elements] Created element:', element.id)

    // Notify POS terminals of floor plan update
    dispatchFloorPlanUpdate(locationId, { async: true })

    return NextResponse.json({ element })
  } catch (error) {
    console.error('[floor-plan-elements] POST error:', error)
    const message = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json({ error: `Failed to create element: ${message}` }, { status: 500 })
  }
}


================================================================================
SECTION 6: LIBRARY FILES
================================================================================

################################################################################
# FILE: src/lib/seat-generation.ts
################################################################################

/**
 * GWI POS - Seat Position Generation Utilities
 *
 * Pure functions for calculating seat positions around tables.
 * All positions are in PIXELS relative to table center.
 *
 * Coordinate System:
 * - (0, 0) = Table center
 * - Positive X = Right
 * - Positive Y = Down
 * - Angle: 0 = Up, 90 = Right, 180 = Down, 270 = Left
 */

import { SEAT_RADIUS, SEAT_DEFAULT_OFFSET, ANGLE } from '@/lib/floorplan/constants';

// =============================================================================
// TYPES
// =============================================================================

export type TableShape = 'rectangle' | 'square' | 'round' | 'oval' | 'booth';
export type SeatPattern =
  | 'all_around'
  | 'two_sides'
  | 'one_side'
  | 'booth'
  | 'heads_only'
  | 'custom';

export interface SeatPosition {
  seatNumber: number; // 1-based
  relativeX: number; // Offset from table center (pixels)
  relativeY: number; // Offset from table center (pixels)
  angle: number; // Facing direction (0 = up, 90 = right, 180 = down, 270 = left)
}

export interface GenerateSeatPositionsParams {
  shape: TableShape;
  pattern: SeatPattern;
  capacity: number;
  width: number; // Table width in pixels
  height: number; // Table height in pixels
  seatRadius?: number; // Default 15px
  seatGap?: number; // Min gap between seats, default 5px
}

// =============================================================================
// CONSTANTS
// =============================================================================

const DEFAULT_SEAT_GAP = 5; // pixels
const CLEARANCE = SEAT_DEFAULT_OFFSET; // Distance from table edge to seat center

// =============================================================================
// MAIN FUNCTION
// =============================================================================

/**
 * Generate seat positions for a table based on shape and pattern
 */
export function generateSeatPositions(
  params: GenerateSeatPositionsParams
): SeatPosition[] {
  const { shape, pattern } = params;

  // Route to shape-specific generator
  if (shape === 'round') {
    return generateRoundSeats(params);
  }

  if (shape === 'oval') {
    return generateOvalSeats(params);
  }

  if (shape === 'booth') {
    return generateBoothSeats(params);
  }

  // Rectangle and square use same logic
  return generateRectangleSeats(params);
}

// =============================================================================
// RECTANGLE / SQUARE SEATS
// =============================================================================

/**
 * Generate seats for rectangle/square tables
 * Clockwise distribution: top  right  bottom  left
 */
export function generateRectangleSeats(
  params: GenerateSeatPositionsParams
): SeatPosition[] {
  const {
    pattern,
    capacity,
    width,
    height,
    seatRadius = SEAT_RADIUS,
    seatGap = DEFAULT_SEAT_GAP,
  } = params;

  const seats: SeatPosition[] = [];
  const halfW = width / 2;
  const halfH = height / 2;

  // Special patterns
  if (pattern === 'heads_only') {
    // Only 2 seats at short ends
    seats.push({
      seatNumber: 1,
      relativeX: 0,
      relativeY: -(halfH + CLEARANCE),
      angle: ANGLE.DOWN, // Face down toward table
    });
    seats.push({
      seatNumber: 2,
      relativeX: 0,
      relativeY: halfH + CLEARANCE,
      angle: ANGLE.UP, // Face up toward table
    });
    return seats;
  }

  if (pattern === 'one_side') {
    // All seats on top edge
    return distributeSeatsOnEdge(
      capacity,
      width,
      0,
      -(halfH + CLEARANCE),
      180,
      seatRadius,
      seatGap
    );
  }

  if (pattern === 'two_sides') {
    // Split between top and bottom
    const seatsPerSide = Math.ceil(capacity / 2);
    const topSeats = distributeSeatsOnEdge(
      seatsPerSide,
      width,
      0,
      -(halfH + CLEARANCE),
      180,
      seatRadius,
      seatGap
    );
    const bottomSeats = distributeSeatsOnEdge(
      capacity - seatsPerSide,
      width,
      0,
      halfH + CLEARANCE,
      0,
      seatRadius,
      seatGap,
      seatsPerSide + 1
    );
    return [...topSeats, ...bottomSeats];
  }

  if (pattern === 'booth') {
    // One seat at each head + rest on long sides
    const headSeats = 2;
    const sideSeats = capacity - headSeats;
    const seatsPerSide = Math.ceil(sideSeats / 2);

    seats.push({
      seatNumber: 1,
      relativeX: 0,
      relativeY: -(halfH + CLEARANCE),
      angle: ANGLE.DOWN,
    });

    const rightSeats = distributeSeatsOnEdge(
      seatsPerSide,
      height,
      halfW + CLEARANCE,
      0,
      270,
      seatRadius,
      seatGap,
      2,
      true
    );
    seats.push(...rightSeats);

    seats.push({
      seatNumber: 2 + seatsPerSide,
      relativeX: 0,
      relativeY: halfH + CLEARANCE,
      angle: ANGLE.UP,
    });

    const leftSeats = distributeSeatsOnEdge(
      sideSeats - seatsPerSide,
      height,
      -(halfW + CLEARANCE),
      0,
      90,
      seatRadius,
      seatGap,
      3 + seatsPerSide,
      true
    );
    seats.push(...leftSeats);

    return seats;
  }

  // Default: all_around pattern
  // Calculate perimeter and distribute proportionally
  const perimeter = 2 * (width + height);
  const topCount = Math.round((width / perimeter) * capacity);
  const rightCount = Math.round((height / perimeter) * capacity);
  const bottomCount = Math.round((width / perimeter) * capacity);
  const leftCount = capacity - topCount - rightCount - bottomCount;

  let seatNum = 1;

  // Top edge (left to right)
  const topSeats = distributeSeatsOnEdge(
    topCount,
    width,
    0,
    -(halfH + CLEARANCE),
    180,
    seatRadius,
    seatGap,
    seatNum
  );
  seats.push(...topSeats);
  seatNum += topCount;

  // Right edge (top to bottom)
  const rightSeats = distributeSeatsOnEdge(
    rightCount,
    height,
    halfW + CLEARANCE,
    0,
    270,
    seatRadius,
    seatGap,
    seatNum,
    true
  );
  seats.push(...rightSeats);
  seatNum += rightCount;

  // Bottom edge (right to left)
  const bottomSeats = distributeSeatsOnEdge(
    bottomCount,
    width,
    0,
    halfH + CLEARANCE,
    0,
    seatRadius,
    seatGap,
    seatNum,
    false,
    true // Reverse for right-to-left
  );
  seats.push(...bottomSeats);
  seatNum += bottomCount;

  // Left edge (bottom to top)
  const leftSeats = distributeSeatsOnEdge(
    leftCount,
    height,
    -(halfW + CLEARANCE),
    0,
    90,
    seatRadius,
    seatGap,
    seatNum,
    true,
    true // Reverse for bottom-to-top
  );
  seats.push(...leftSeats);

  return seats;
}

/**
 * Helper: Distribute seats evenly along an edge
 */
function distributeSeatsOnEdge(
  count: number,
  edgeLength: number,
  baseX: number,
  baseY: number,
  angle: number,
  seatRadius: number,
  seatGap: number,
  startSeatNum = 1,
  vertical = false,
  reverse = false
): SeatPosition[] {
  if (count === 0) return [];

  const seats: SeatPosition[] = [];
  const seatDiameter = seatRadius * 2;
  const availableSpace = edgeLength - seatDiameter;
  const spacing = count > 1 ? availableSpace / (count - 1) : 0;

  for (let i = 0; i < count; i++) {
    const index = reverse ? count - 1 - i : i;
    const offset = count === 1 ? 0 : -availableSpace / 2 + index * spacing;

    seats.push({
      seatNumber: startSeatNum + i,
      relativeX: vertical ? baseX : baseX + offset,
      relativeY: vertical ? baseY + offset : baseY,
      angle: angle,
    });
  }

  return seats;
}

// =============================================================================
// ROUND SEATS
// =============================================================================

/**
 * Generate seats for round tables
 * Evenly distributed around circumference, starting at top (12 o'clock)
 */
export function generateRoundSeats(
  params: GenerateSeatPositionsParams
): SeatPosition[] {
  const {
    capacity,
    width,
    height,
    seatRadius = SEAT_RADIUS,
  } = params;

  const seats: SeatPosition[] = [];
  const radius = Math.min(width, height) / 2 + CLEARANCE;

  // Start at top (12 o'clock = -90 degrees = -PI/2)
  const startAngle = -Math.PI / 2;
  const angleStep = (2 * Math.PI) / capacity;

  for (let i = 0; i < capacity; i++) {
    const angle = startAngle + i * angleStep;
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);

    // Calculate facing angle (toward center)
    // Angle in our system: 0 = up, 90 = right, 180 = down, 270 = left
    const facingAngle = ((angle + Math.PI) * 180) / Math.PI;
    const normalizedAngle = ((facingAngle % 360) + 360) % 360;

    seats.push({
      seatNumber: i + 1,
      relativeX: Math.round(x),
      relativeY: Math.round(y),
      angle: Math.round(normalizedAngle),
    });
  }

  return seats;
}

// =============================================================================
// OVAL SEATS
// =============================================================================

/**
 * Generate seats for oval tables
 * Similar to round but with stretched ellipse
 */
export function generateOvalSeats(
  params: GenerateSeatPositionsParams
): SeatPosition[] {
  const {
    capacity,
    width,
    height,
    seatRadius = SEAT_RADIUS,
  } = params;

  const seats: SeatPosition[] = [];
  const radiusX = width / 2 + CLEARANCE;
  const radiusY = height / 2 + CLEARANCE;

  // Start at top (12 o'clock = -90 degrees = -PI/2)
  const startAngle = -Math.PI / 2;
  const angleStep = (2 * Math.PI) / capacity;

  for (let i = 0; i < capacity; i++) {
    const angle = startAngle + i * angleStep;
    const x = radiusX * Math.cos(angle);
    const y = radiusY * Math.sin(angle);

    // Calculate facing angle (toward center)
    const facingAngle = ((angle + Math.PI) * 180) / Math.PI;
    const normalizedAngle = ((facingAngle % 360) + 360) % 360;

    seats.push({
      seatNumber: i + 1,
      relativeX: Math.round(x),
      relativeY: Math.round(y),
      angle: Math.round(normalizedAngle),
    });
  }

  return seats;
}

// =============================================================================
// BOOTH SEATS
// =============================================================================

/**
 * Generate seats for booth tables
 * All seats on front (open) side
 */
export function generateBoothSeats(
  params: GenerateSeatPositionsParams
): SeatPosition[] {
  const {
    capacity,
    width,
    seatRadius = SEAT_RADIUS,
    seatGap = DEFAULT_SEAT_GAP,
  } = params;

  // All seats on bottom edge (open side)
  return distributeSeatsOnEdge(
    capacity,
    width,
    0,
    params.height / 2 + CLEARANCE,
    0, // Face up toward table
    seatRadius,
    seatGap
  );
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Redistribute seats when capacity changes
 * Maintains clockwise ordering, recalculates positions
 */
export function redistributeSeats(
  existingPositions: SeatPosition[],
  newSeatCount: number,
  shape: TableShape,
  width: number,
  height: number
): SeatPosition[] {
  // Generate fresh positions with new count
  return generateSeatPositions({
    shape,
    pattern: 'all_around',
    capacity: newSeatCount,
    width,
    height,
  });
}

/**
 * Insert a new seat at a specific index
 * Renumbers all seats and redistributes positions
 */
export function insertSeatAt(
  existingPositions: SeatPosition[],
  insertAtIndex: number, // 0-based
  shape: TableShape,
  width: number,
  height: number
): SeatPosition[] {
  const newCapacity = existingPositions.length + 1;

  // Generate positions for new capacity
  const newPositions = generateSeatPositions({
    shape,
    pattern: 'all_around',
    capacity: newCapacity,
    width,
    height,
  });

  // Renumber to reflect insertion point
  const result: SeatPosition[] = [];

  for (let i = 0; i < newPositions.length; i++) {
    if (i < insertAtIndex) {
      // Before insertion point - keep original numbering
      result.push({
        ...newPositions[i],
        seatNumber: i + 1,
      });
    } else if (i === insertAtIndex) {
      // New seat at insertion point
      result.push({
        ...newPositions[i],
        seatNumber: insertAtIndex + 1,
      });
    } else {
      // After insertion point - increment numbering
      result.push({
        ...newPositions[i],
        seatNumber: i + 1,
      });
    }
  }

  return result;
}



################################################################################
# FILE: src/lib/seat-utils.ts
################################################################################

/**
 * Seat Management Utilities (Skill 121)
 *
 * Per-seat balance calculations and status determination.
 */

export type SeatStatus = 'empty' | 'stale' | 'active' | 'printed' | 'paid'

export interface SeatInfo {
  seatNumber: number
  subtotal: number
  taxAmount: number
  total: number
  itemCount: number
  status: SeatStatus
  addedAt?: string
}

export interface OrderItemForSeat {
  id: string
  seatNumber?: number | null
  price: number
  quantity: number
  kitchenStatus?: string
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  modifiers?: { price: number }[]
}

export interface PaymentForSeat {
  metadata?: { seatNumber?: number } | null
  status: string
}

/**
 * Seat status color mapping
 */
export const SEAT_STATUS_COLORS: Record<SeatStatus, string> = {
  empty: '#6b7280',     // gray-500 - No items
  stale: '#f59e0b',     // amber-500 - Items but no recent activity
  active: '#22c55e',    // green-500 - Recent activity
  printed: '#3b82f6',   // blue-500 - Items sent to kitchen
  paid: '#a855f7',      // purple-500 - Seat fully paid
}

/**
 * Seat status background colors (lighter variants)
 */
export const SEAT_STATUS_BG_COLORS: Record<SeatStatus, string> = {
  empty: 'rgba(107, 114, 128, 0.2)',
  stale: 'rgba(245, 158, 11, 0.2)',
  active: 'rgba(34, 197, 94, 0.2)',
  printed: 'rgba(59, 130, 246, 0.2)',
  paid: 'rgba(168, 85, 247, 0.2)',
}

/**
 * Seat status glow colors for selected state
 */
export const SEAT_STATUS_GLOW: Record<SeatStatus, string> = {
  empty: 'rgba(107, 114, 128, 0.5)',
  stale: 'rgba(245, 158, 11, 0.5)',
  active: 'rgba(34, 197, 94, 0.5)',
  printed: 'rgba(59, 130, 246, 0.5)',
  paid: 'rgba(168, 85, 247, 0.5)',
}

/**
 * Calculate per-seat balance
 */
export function calculateSeatBalance(
  items: OrderItemForSeat[],
  seatNumber: number,
  taxRate: number = 0.08
): { subtotal: number; taxAmount: number; total: number; itemCount: number } {
  const seatItems = items.filter(item => item.seatNumber === seatNumber)

  const subtotal = seatItems.reduce((sum, item) => {
    const itemBase = Number(item.price) * item.quantity
    const modTotal = (item.modifiers || []).reduce((m, mod) => m + Number(mod.price), 0) * item.quantity
    return sum + itemBase + modTotal
  }, 0)

  const taxAmount = Math.round(subtotal * taxRate * 100) / 100
  const total = Math.round((subtotal + taxAmount) * 100) / 100
  const itemCount = seatItems.reduce((sum, item) => sum + item.quantity, 0)

  return {
    subtotal: Math.round(subtotal * 100) / 100,
    taxAmount,
    total,
    itemCount,
  }
}

/**
 * Determine seat status based on items and payments
 */
export function determineSeatStatus(
  items: OrderItemForSeat[],
  seatNumber: number,
  payments: PaymentForSeat[] = [],
  staleThresholdMinutes: number = 5
): SeatStatus {
  // Check if seat is paid
  const isPaid = payments.some(p =>
    p.status === 'completed' &&
    (p.metadata as { seatNumber?: number } | null)?.seatNumber === seatNumber
  )
  if (isPaid) return 'paid'

  const seatItems = items.filter(item => item.seatNumber === seatNumber)
  if (seatItems.length === 0) return 'empty'

  // Check if any items have been sent to kitchen
  const hasPrintedItems = seatItems.some(item =>
    item.kitchenStatus && item.kitchenStatus !== 'pending'
  )
  if (hasPrintedItems) return 'printed'

  // Check for recent activity
  const staleThreshold = new Date(Date.now() - staleThresholdMinutes * 60 * 1000)
  const hasRecentActivity = seatItems.some(item => {
    const updated = item.updatedAt ? new Date(item.updatedAt) : null
    const created = item.createdAt ? new Date(item.createdAt) : null
    return (updated && updated > staleThreshold) || (created && created > staleThreshold)
  })

  return hasRecentActivity ? 'active' : 'stale'
}

/**
 * Calculate all seat balances for an order
 */
export function calculateAllSeatBalances(
  items: OrderItemForSeat[],
  totalSeats: number,
  payments: PaymentForSeat[] = [],
  taxRate: number = 0.08
): SeatInfo[] {
  const seats: SeatInfo[] = []

  for (let seatNum = 1; seatNum <= totalSeats; seatNum++) {
    const balance = calculateSeatBalance(items, seatNum, taxRate)
    const status = determineSeatStatus(items, seatNum, payments)

    seats.push({
      seatNumber: seatNum,
      ...balance,
      status,
    })
  }

  return seats
}

/**
 * Position seats around a circular orbit
 */
export function calculateSeatPositions(
  seatCount: number,
  orbitRadius: number,
  startAngle: number = -90 // Start at top
): { x: number; y: number; angle: number }[] {
  const positions: { x: number; y: number; angle: number }[] = []
  const angleStep = 360 / seatCount

  for (let i = 0; i < seatCount; i++) {
    const angle = startAngle + i * angleStep
    const radians = (angle * Math.PI) / 180
    const x = Math.cos(radians) * orbitRadius
    const y = Math.sin(radians) * orbitRadius

    positions.push({ x, y, angle })
  }

  return positions
}

/**
 * Format currency for display
 */
export function formatSeatBalance(amount: number): string {
  if (amount === 0) return ''
  return `$${amount.toFixed(2)}`
}



################################################################################
# FILE: src/lib/virtual-group-seats.ts
################################################################################

/**
 * Virtual Group Seat Numbering Logic
 *
 * Handles seat renumbering and labeling when tables are virtually combined.
 * Virtual groups link tables logically without moving them physically.
 */

export interface VirtualSeatInfo {
  seatId: string
  tableId: string
  tableName: string
  originalSeatNumber: number // Number within original table (1, 2, 3...)
  virtualSeatNumber: number // Sequential number within group (1..N)
  originalLabel: string // Original label before grouping
  virtualLabel: string // Display label with table prefix ("T1-3")
}

export interface TableWithSeats {
  id: string
  name: string
  abbreviation?: string | null
  posX: number
  posY: number
  seats: Array<{
    id: string
    seatNumber: number
    label: string
    relativeX: number
    relativeY: number
  }>
}

/**
 * Calculate virtual seat numbers for a group of tables
 *
 * Algorithm:
 * 1. Primary table's seats come first (1, 2, 3...)
 * 2. Secondary tables ordered by position (top-left clockwise)
 * 3. Each table's seats ordered by seatNumber
 * 4. Returns mapping for each seat
 */
export function calculateVirtualSeatNumbers(
  primaryTableId: string,
  tables: TableWithSeats[]
): VirtualSeatInfo[] {
  const result: VirtualSeatInfo[] = []

  // Find primary table
  const primaryTable = tables.find((t) => t.id === primaryTableId)
  if (!primaryTable) {
    throw new Error(`Primary table ${primaryTableId} not found`)
  }

  // Sort secondary tables by position (top-left first, then clockwise)
  const secondaryTables = tables
    .filter((t) => t.id !== primaryTableId)
    .sort((a, b) => {
      // Calculate angle from primary table center to secondary table center
      const primaryCenterX = primaryTable.posX
      const primaryCenterY = primaryTable.posY

      const angleA = Math.atan2(a.posY - primaryCenterY, a.posX - primaryCenterX)
      const angleB = Math.atan2(b.posY - primaryCenterY, b.posX - primaryCenterX)

      // Convert to 0-360 degrees, starting from top (12 o'clock) going clockwise
      const degreesA = ((angleA * 180) / Math.PI + 90 + 360) % 360
      const degreesB = ((angleB * 180) / Math.PI + 90 + 360) % 360

      return degreesA - degreesB
    })

  // Combine tables in order: primary first, then secondaries
  const orderedTables = [primaryTable, ...secondaryTables]

  let virtualSeatNumber = 1

  // Process each table's seats
  for (const table of orderedTables) {
    // Sort seats by seat number
    const sortedSeats = [...table.seats].sort((a, b) => a.seatNumber - b.seatNumber)

    for (const seat of sortedSeats) {
      // Create short name: use abbreviation if set, otherwise "T" + table number
      // Examples: "Table 20" -> "T20", "Bar Top 1" -> "BT1", abbreviation "VIP" -> "VIP"
      const shortName = table.abbreviation || (() => {
        // Extract numbers from table name (e.g., "Table 20" -> "20")
        const numbers = table.name.replace(/[^0-9]/g, '')
        if (numbers) {
          return `T${numbers}`
        }
        // Fallback: First letter of each word (e.g., "Bar Top" -> "BT")
        return table.name.split(' ').map(w => w[0]).join('').toUpperCase().slice(0, 3)
      })()

      result.push({
        seatId: seat.id,
        tableId: table.id,
        tableName: table.name,
        originalSeatNumber: seat.seatNumber,
        virtualSeatNumber,
        originalLabel: seat.label,
        virtualLabel: `${shortName}-${seat.seatNumber}`,
      })

      virtualSeatNumber++
    }
  }

  return result
}

/**
 * Restore original seat numbers after dissolving a virtual group
 */
export function restoreOriginalSeatNumbers(
  virtualSeats: VirtualSeatInfo[]
): Map<string, { seatNumber: number; label: string }> {
  const result = new Map<string, { seatNumber: number; label: string }>()

  for (const virtualSeat of virtualSeats) {
    result.set(virtualSeat.seatId, {
      seatNumber: virtualSeat.originalSeatNumber,
      label: virtualSeat.originalLabel,
    })
  }

  return result
}

/**
 * Get display label for a virtual seat
 *
 * @param virtualInfo - Virtual seat info
 * @param showTablePrefix - If true, returns "T1-3", if false returns "3"
 */
export function getVirtualSeatLabel(
  virtualInfo: VirtualSeatInfo,
  showTablePrefix: boolean
): string {
  if (showTablePrefix) {
    return virtualInfo.virtualLabel
  }
  return String(virtualInfo.originalSeatNumber)
}

/**
 * Calculate total seat count for a virtual group
 */
export function getVirtualGroupSeatCount(tables: TableWithSeats[]): number {
  return tables.reduce((total, table) => total + table.seats.length, 0)
}

/**
 * Get seat distribution summary (useful for display)
 */
export function getVirtualGroupSeatSummary(
  tables: TableWithSeats[]
): Array<{ tableName: string; seatCount: number; seatRange: string }> {
  const primaryTable = tables[0] // Assumes primary is first
  const secondaryTables = tables.slice(1)
  const orderedTables = [primaryTable, ...secondaryTables]

  let startNumber = 1
  const summary = []

  for (const table of orderedTables) {
    const seatCount = table.seats.length
    const endNumber = startNumber + seatCount - 1
    const seatRange = seatCount === 1 ? `${startNumber}` : `${startNumber}-${endNumber}`

    summary.push({
      tableName: table.name,
      seatCount,
      seatRange,
    })

    startNumber = endNumber + 1
  }

  return summary
}



################################################################################
# FILE: src/lib/virtual-group-colors.ts
################################################################################

// src/lib/virtual-group-colors.ts
// Virtual group color management

// Color palette for virtual groups (distinct from physical combine)
const VIRTUAL_GROUP_COLORS = [
  '#06b6d4', // cyan
  '#84cc16', // lime
  '#f472b6', // pink
  '#a855f7', // purple
  '#fb923c', // orange
  '#34d399', // emerald
  '#60a5fa', // blue
  '#fbbf24', // amber
]

/**
 * Get a consistent color for a virtual group based on its ID
 */
export function getVirtualGroupColor(groupId: string): string {
  let hash = 0
  for (let i = 0; i < groupId.length; i++) {
    hash = ((hash << 5) - hash) + groupId.charCodeAt(i)
    hash = hash & hash // Convert to 32bit integer
  }
  return VIRTUAL_GROUP_COLORS[Math.abs(hash) % VIRTUAL_GROUP_COLORS.length]
}


================================================================================
SECTION 7: DOCUMENTATION
================================================================================

################################################################################
# FILE: docs/changelogs/FLOOR-PLAN-CHANGELOG.md
################################################################################

# Floor Plan Domain - Change Log

## Session: February 5, 2026 (Final Session)

###  FLOOR PLAN DOMAIN COMPLETE

The Floor Plan domain has been completed and is now ready for production. All core functionality is working:
- Tables, seats, fixtures, sections
- Virtual groups with colored borders
- Entertainment elements integration (now moving to dedicated Entertainment domain)

### Workers Completed Today

| Worker | Task | Status | Files Changed |
|--------|------|--------|---------------|
| **74** | Virtual Group Glow/Ring Visibility Fix |  Complete | `TableNode.tsx` - moved glow elements outside overflow:hidden container |
| **75** | Virtual Group Styling Refinement |  Complete | `TableNode.tsx` - softened border, removed pulsing animation |
| **76** | Debug Console.log Cleanup |  Complete | `TableNode.tsx` - removed all debug logging |
| **77** | Integrate Entertainment Palette into Editor |  Complete | `FloorPlanEditor.tsx` - AddEntertainmentPalette integration |
| **78** | Render Entertainment in EditorCanvas |  Complete | `EditorCanvas.tsx` - renderEntertainmentElements() with SVG visuals |
| **79** | Add Entertainment to /api/floor-plan |  Complete | `route.ts` - entertainment in aggregate response |
| **80** | Create EntertainmentProperties Panel |  Complete | NEW: `EntertainmentProperties.tsx` |
| **82** | Route Entertainment to Builder |  Complete | `menu/page.tsx` - routes to /timed-rentals |
| **83** | Enhance Timed Rentals Page |  Complete | `timed-rentals/page.tsx` - full entertainment builder |

### Entertainment Integration (Moving to New Domain)

Entertainment features were integrated into Floor Plan but are now being spun off into a dedicated Entertainment domain for better organization:

**Completed in Floor Plan:**
- `AddEntertainmentPalette` component for placing items
- `FloorPlanEntertainment` rendering component
- 12 SVG visual types (pool_table, dartboard, arcade, etc.)
- Integration in EditorCanvas and FloorPlanEditor
- `/api/floor-plan` returns entertainment elements

**Moving to Entertainment Domain:**
- `/timed-rentals` page (entertainment builder)
- Entertainment session management
- Waitlist functionality
- Block time / per-minute pricing
- Entertainment status tracking

### Files Changed Today

| File | Changes |
|------|---------|
| `src/components/floor-plan/TableNode.tsx` | Virtual group styling, removed debug logs |
| `src/domains/floor-plan/admin/FloorPlanEditor.tsx` | Entertainment palette integration |
| `src/domains/floor-plan/admin/EditorCanvas.tsx` | Entertainment rendering |
| `src/domains/floor-plan/admin/EntertainmentProperties.tsx` | NEW - Properties panel |
| `src/app/api/floor-plan/route.ts` | Entertainment in aggregate |
| `src/app/(admin)/menu/page.tsx` | Entertainment routing to /timed-rentals |
| `src/app/(admin)/timed-rentals/page.tsx` | Full entertainment builder UI |

### Domain Handoff: Entertainment

The Entertainment domain is now being created as a separate domain. See:
- `/docs/changelogs/ENTERTAINMENT-CHANGELOG.md` (to be created)
- `/docs/domains/ENTERTAINMENT-DOMAIN.md` (to be created)

---

## Session: February 4, 2026

### Workers Completed

| Worker | Task | Status | Files Changed |
|--------|------|--------|---------------|
| **1** | Seat API CRUD Endpoints |  Complete | `/api/seats/route.ts`, `/api/seats/[id]/route.ts`, `/api/tables/[id]/seats/route.ts`, `/api/tables/[id]/seats/generate/route.ts` |
| **2** | Seat Position Generation Algorithm |  Complete | `/src/lib/seat-generation.ts` |
| **3** | Seat Renderer Component |  Complete | `/src/domains/floor-plan/admin/SeatRenderer.tsx`, `TableRenderer.tsx` modified |
| **4** | Virtual Group Seat Logic |  Complete | `/src/lib/virtual-group-seats.ts`, `/api/tables/virtual-combine/route.ts`, `/api/tables/virtual-combine/[groupId]/dissolve/route.ts` |
| **5** | Schema Enhancement for Virtual Seats |  Complete | `prisma/schema.prisma` - Added virtualGroupId, virtualSeatNumber, status, etc. to Seat model |
| **6** | Table Resize Handles |  Complete | `TableRenderer.tsx`, `EditorCanvas.tsx` |
| **7** | Smooth Table Rotation Handle |  Complete | `TableRenderer.tsx`, `EditorCanvas.tsx` |
| **8** | Fix Toolbar Icon (Table not Chair) |  Complete | `FixtureToolbar.tsx` |
| **9** | Manual Seat Positioning with Boundary |  Complete | `EditorCanvas.tsx`, `types.ts` |
| **10** | Generate Seats Button |  Already Existed | `TableProperties.tsx`, `FloorPlanEditor.tsx`, `/api/tables/[id]/seats/auto-generate/route.ts` |

### Workers In Progress / Pending

| Worker | Task | Status | Notes |
|--------|------|--------|-------|
| **11** | Seats Reflow on Table Resize |  Complete | API endpoint + EditorCanvas integration |
| **12** | Fix Table Resize Minimum for Bar |  Complete | Shape-specific minimums, edge handle fixes |

### Issues Discovered During Testing (RESOLVED)

1. ~~**Seats don't reflow on table resize**~~ -  FIXED: Created `/api/tables/[id]/seats/reflow` endpoint, integrated into EditorCanvas
2. ~~**Bar table minimum size too restrictive**~~ -  FIXED: Bar tables now allow 80x30 minimum, edge handles only affect one dimension
3. ~~**Seat dragging not working**~~ -  FIXED: Added `handleSeatUpdate` callback, `dbSeats` computed property, passed props to EditorCanvas
4. ~~**Regenerate seats 500 error**~~ -  FIXED: `generateSeatPositions()` called with params object, added `label` field generation
5. ~~**Seats stacking/disappearing on resize**~~ -  FIXED: Reflow algorithm now only pushes out seats if BOTH x AND y are inside table bounds

### Key Architectural Decisions

1. **Seats are managed by Seat API, NOT Table API** - Clean layer separation
2. **Admin-saved positions are the "default"** - `relativeX`, `relativeY` in database IS the source of truth for reset
3. **Virtual groups use label prefixes** - When combined, seats get "T1-3" format labels
4. **Soft deletes only** - All seat deletes set `deletedAt`, never hard delete
5. **Socket dispatch on all mutations** - Real-time updates via `dispatchFloorPlanUpdate()`

### Schema Changes Made

```prisma
// Added to Seat model:
virtualGroupId        String?   // Matches Table.virtualGroupId
virtualSeatNumber     Int?      // Seat number within combined group
virtualGroupCreatedAt DateTime? // When joined virtual group
status                String    @default("available")
currentOrderItemId    String?   // Active order item at seat
lastOccupiedAt        DateTime?
lastOccupiedBy        String?

@@index([virtualGroupId])
```

### API Endpoints Created/Modified

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/api/seats` | GET | List seats with filters |
| `/api/seats` | POST | Create single seat |
| `/api/seats/[id]` | GET | Get seat details |
| `/api/seats/[id]` | PUT | Update seat |
| `/api/seats/[id]` | DELETE | Soft delete seat |
| `/api/tables/[id]/seats` | GET | Get table's seats |
| `/api/tables/[id]/seats` | POST | Add seat to table |
| `/api/tables/[id]/seats/generate` | POST | Generate default layout |
| `/api/tables/[id]/seats/auto-generate` | POST | Comprehensive generation |
| `/api/tables/[id]/seats/save-as-default` | POST | Save positions |
| `/api/tables/[id]/seats/bulk` | POST | Bulk operations |
| `/api/tables/seats/reflow` | POST | Reflow after resize |

### Components Created/Modified

| Component | File | Changes |
|-----------|------|---------|
| SeatRenderer | `/src/domains/floor-plan/admin/SeatRenderer.tsx` | NEW - Renders individual seats with states |
| TableRenderer | `/src/domains/floor-plan/admin/TableRenderer.tsx` | Added seats, resize handles, rotation handle |
| EditorCanvas | `/src/domains/floor-plan/admin/EditorCanvas.tsx` | Seat dragging, boundary, collision, resize, rotation |
| FixtureToolbar | `/src/domains/floor-plan/admin/FixtureToolbar.tsx` | Table icon (was chair) |
| TableProperties | `/src/domains/floor-plan/admin/TableProperties.tsx` | Already had Generate Seats button |

### Previous Session Work (Earlier Feb 4)

- Table-to-fixture collision detection
- Table-to-table collision detection
- Table API cleanup (removed seat code from Table layer)
- FOH view rendering database tables
- PM Mode workflow added to CLAUDE.md

---

## How to Resume This Work

1. **Start with:** `PM Mode: Floor Plan`
2. **Review this changelog** for context
3. **All 12 workers COMPLETE** - no pending workers
4. **Test current implementation** in Floor Plan Editor

## Next Priority Tasks

1.  ~~Send Worker 11 & 12 prompts to fix resize issues~~ DONE
2. Test seat generation with different table shapes
3. Test virtual combine/uncombine with seats
4. Integrate seats into FOH view for ordering
5. Seat-to-order integration (assign items to seats)

## Additional Files Created/Modified (Workers 11 & 12 + Bug Fixes)

| File | Purpose |
|------|---------|
| `/api/tables/[id]/seats/reflow/route.ts` | Reflow seats when table resized |
| `EditorCanvas.tsx` | Added `onSeatsReflow` prop, resize-complete detection, seat dragging integration |
| `FloorPlanEditor.tsx` | Added `handleSeatsReflow` callback, `handleSeatUpdate`, `dbSeats` computed property |

## Bug Fixes (End of Session)

### 1. Seat Dragging Not Working
**Root Cause:** `dbSeats` and `onSeatUpdate` props weren't being passed to EditorCanvas

**Fix in FloorPlanEditor.tsx:**
```typescript
// Added handleSeatUpdate callback
const handleSeatUpdate = useCallback(
  async (seatId: string, updates: { relativeX?: number; relativeY?: number }) => {
    if (!useDatabase) return;
    const response = await fetch(`/api/seats/${seatId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates),
    });
    if (response.ok) {
      await fetchTables();
      setRefreshKey((prev) => prev + 1);
    }
  },
  [useDatabase, fetchTables]
);

// Added dbSeats computed property
const dbSeats = React.useMemo(() => {
  if (!useDatabase) return undefined;
  return dbTables.flatMap(table =>
    (table.seats || []).map(seat => ({ ...seat, tableId: table.id }))
  );
}, [useDatabase, dbTables]);

// Passed to EditorCanvas
<EditorCanvas
  dbSeats={dbSeats}
  onSeatUpdate={handleSeatUpdate}
  // ...
/>
```

### 2. Regenerate Seats 500 Error
**Root Cause:** `generateSeatPositions()` was called with wrong function signature (5 individual args instead of params object), and `SeatPosition` type doesn't have `label` field

**Fix in `/api/tables/[id]/seats/generate/route.ts`:**
```typescript
// Changed from:
generateSeatPositions(table.shape, finalPattern, finalCount, table.width, table.height)

// To:
const seatPositions = generateSeatPositions({
  shape: (table.shape as 'rectangle' | 'square' | 'round' | 'oval' | 'booth') || 'rectangle',
  pattern: finalPattern,
  capacity: finalCount,
  width: table.width,
  height: table.height,
});

// Added label generation in seat creation:
label: String(pos.seatNumber),
```

### 3. Seats Stacking/Disappearing on Resize
**Root Cause:** Reflow algorithm was treating edge seats (outside on one axis, inside on other) as "inside" and pushing them all out

**Fix in `/api/tables/[id]/seats/reflow/route.ts`:**
```typescript
// Changed from checking each axis independently to:
const isInsideX = absRelX < halfWidth;
const isInsideY = absRelY < halfHeight;

// Only push out if BOTH x AND y are inside table bounds
if (isInsideX && isInsideY) {
  // Calculate nearest edge and push out
}
```

## Shape-Specific Minimum Sizes (Worker 12)

| Shape | Min Width | Min Height |
|-------|-----------|------------|
| bar | 80px | 30px |
| booth | 60px | 80px |
| round | 50px | 50px |
| square | 50px | 50px |
| oval | 60px | 40px |
| rectangle | 60px | 40px |



================================================================================
END OF EXPORT
Total Lines:    45001
================================================================================
