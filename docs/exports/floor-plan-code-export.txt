================================================================================
FILE: /src/domains/floor-plan/groups/perimeterSeats.ts
================================================================================

     1→/**
     2→ * GWI POS - Floor Plan Domain
     3→ * Perimeter Seat Renumbering for Virtual Table Groups
     4→ *
     5→ * Traces the outer perimeter of combined tables clockwise from upper-left,
     6→ * assigning sequential seat numbers 1, 2, 3...
     7→ */
     8→
     9→import type { Point } from '../shared/types';
    10→
    11→export interface SeatWithPosition {
    12→  id: string;
    13→  tableId: string;
    14→  seatNumber: number;
    15→  label: string;
    16→  // Absolute position on canvas (table center + seat relative offset)
    17→  absoluteX: number;
    18→  absoluteY: number;
    19→}
    20→
    21→export interface TableForPerimeter {
    22→  id: string;
    23→  name: string;
    24→  posX: number;
    25→  posY: number;
    26→  width: number;
    27→  height: number;
    28→  seats: Array<{
    29→    id: string;
    30→    seatNumber: number;
    31→    label: string;
    32→    relativeX: number;
    33→    relativeY: number;
    34→  }>;
    35→}
    36→
    37→export interface PerimeterSeatResult {
    38→  seatId: string;
    39→  tableId: string;
    40→  tableName: string;
    41→  originalNumber: number;
    42→  perimeterNumber: number; // 1, 2, 3... around combined group
    43→  originalLabel: string;
    44→  perimeterLabel: string; // Just the number as string
    45→}
    46→
    47→/**
    48→ * Calculate the combined bounding box of all tables
    49→ */
    50→function getCombinedBounds(tables: TableForPerimeter[]): {
    51→  minX: number;
    52→  minY: number;
    53→  maxX: number;
    54→  maxY: number;
    55→  centerX: number;
    56→  centerY: number;
    57→} {
    58→  let minX = Infinity;
    59→  let minY = Infinity;
    60→  let maxX = -Infinity;
    61→  let maxY = -Infinity;
    62→
    63→  for (const table of tables) {
    64→    minX = Math.min(minX, table.posX);
    65→    minY = Math.min(minY, table.posY);
    66→    maxX = Math.max(maxX, table.posX + table.width);
    67→    maxY = Math.max(maxY, table.posY + table.height);
    68→  }
    69→
    70→  return {
    71→    minX,
    72→    minY,
    73→    maxX,
    74→    maxY,
    75→    centerX: (minX + maxX) / 2,
    76→    centerY: (minY + maxY) / 2,
    77→  };
    78→}
    79→
    80→/**
    81→ * Convert relative seat positions to absolute canvas positions
    82→ */
    83→function getAbsoluteSeats(tables: TableForPerimeter[]): SeatWithPosition[] {
    84→  const seats: SeatWithPosition[] = [];
    85→
    86→  for (const table of tables) {
    87→    const tableCenterX = table.posX + table.width / 2;
    88→    const tableCenterY = table.posY + table.height / 2;
    89→
    90→    for (const seat of table.seats) {
    91→      seats.push({
    92→        id: seat.id,
    93→        tableId: table.id,
    94→        seatNumber: seat.seatNumber,
    95→        label: seat.label,
    96→        absoluteX: tableCenterX + seat.relativeX,
    97→        absoluteY: tableCenterY + seat.relativeY,
    98→      });
    99→    }
   100→  }
   101→
   102→  return seats;
   103→}
   104→
   105→/**
   106→ * Calculate angle from center point, normalized to start from upper-left (NW)
   107→ * and go clockwise.
   108→ *
   109→ * Standard atan2: 0° = East, increases counter-clockwise
   110→ * We want: 0° = upper-left (NW), increases clockwise
   111→ */
   112→function getClockwiseAngleFromUpperLeft(
   113→  seatX: number,
   114→  seatY: number,
   115→  centerX: number,
   116→  centerY: number
   117→): number {
   118→  // Standard angle (0 = East, counter-clockwise positive)
   119→  const standardAngle = Math.atan2(seatY - centerY, seatX - centerX);
   120→
   121→  // Convert to degrees
   122→  let degrees = standardAngle * (180 / Math.PI);
   123→
   124→  // Rotate so 0° is at upper-left (-135° in standard)
   125→  // and make clockwise positive
   126→  degrees = degrees + 135;
   127→
   128→  // Normalize to 0-360
   129→  if (degrees < 0) degrees += 360;
   130→  if (degrees >= 360) degrees -= 360;
   131→
   132→  return degrees;
   133→}
   134→
   135→/**
   136→ * Main function: Calculate perimeter seat numbers for a virtual group
   137→ *
   138→ * @param tables - Array of tables with positions and seats
   139→ * @returns Array of seat results with perimeter numbers, ordered clockwise from upper-left
   140→ */
   141→export function calculatePerimeterSeats(
   142→  tables: TableForPerimeter[]
   143→): PerimeterSeatResult[] {
   144→  if (tables.length === 0) return [];
   145→
   146→  // Get combined bounds
   147→  const bounds = getCombinedBounds(tables);
   148→
   149→  // Convert to absolute positions
   150→  const absoluteSeats = getAbsoluteSeats(tables);
   151→
   152→  if (absoluteSeats.length === 0) return [];
   153→
   154→  // Calculate clockwise angle for each seat from upper-left
   155→  const seatsWithAngles = absoluteSeats.map((seat) => ({
   156→    ...seat,
   157→    angle: getClockwiseAngleFromUpperLeft(
   158→      seat.absoluteX,
   159→      seat.absoluteY,
   160→      bounds.centerX,
   161→      bounds.centerY
   162→    ),
   163→  }));
   164→
   165→  // Sort by angle (clockwise from upper-left)
   166→  seatsWithAngles.sort((a, b) => a.angle - b.angle);
   167→
   168→  // Find table name by ID (for results)
   169→  const tableNameMap = new Map(tables.map((t) => [t.id, t.name]));
   170→
   171→  // Assign perimeter numbers
   172→  return seatsWithAngles.map((seat, index) => ({
   173→    seatId: seat.id,
   174→    tableId: seat.tableId,
   175→    tableName: tableNameMap.get(seat.tableId) || 'Unknown',
   176→    originalNumber: seat.seatNumber,
   177→    perimeterNumber: index + 1,
   178→    originalLabel: seat.label,
   179→    perimeterLabel: String(index + 1),
   180→  }));
   181→}
   182→
   183→/**
   184→ * Get perimeter seat count for a group of tables
   185→ */
   186→export function getPerimeterSeatCount(tables: TableForPerimeter[]): number {
   187→  return tables.reduce((sum, t) => sum + t.seats.length, 0);
   188→}
   189→
   190→/**
   191→ * Get display summary for a virtual group
   192→ * e.g., "Tables 5 & 6 • Party of 12"
   193→ */
   194→export function getGroupDisplayName(tables: TableForPerimeter[]): string {
   195→  const tableNames = tables.map((t) => t.name);
   196→  const seatCount = getPerimeterSeatCount(tables);
   197→
   198→  if (tableNames.length === 0) return '';
   199→  if (tableNames.length === 1) return `${tableNames[0]} • ${seatCount} seats`;
   200→  if (tableNames.length === 2) {
   201→    return `${tableNames[0]} & ${tableNames[1]} • Party of ${seatCount}`;
   202→  }
   203→
   204→  // 3+ tables: "Tables 5, 6 & 7 • Party of 18"
   205→  const allButLast = tableNames.slice(0, -1);
   206→  const last = tableNames[tableNames.length - 1];
   207→  return `${allButLast.join(', ')} & ${last} • Party of ${seatCount}`;
   208→}
   209→
   210→/**
   211→ * Create a lookup map from seatId to perimeterNumber
   212→ * Useful for quick lookups during rendering
   213→ */
   214→export function createPerimeterLookup(
   215→  results: PerimeterSeatResult[]
   216→): Map<string, number> {
   217→  return new Map(results.map((r) => [r.seatId, r.perimeterNumber]));
   218→}


================================================================================
FILE: /src/domains/floor-plan/groups/dragCombine.ts
================================================================================

     1→/**
     2→ * Drag-to-Combine Utilities
     3→ *
     4→ * Handles gesture detection and target finding for drag-to-combine.
     5→ */
     6→
     7→export interface DragState {
     8→  isDragging: boolean;
     9→  draggedTableId: string | null;
    10→  startX: number;
    11→  startY: number;
    12→  currentX: number;
    13→  currentY: number;
    14→  offsetX: number; // Offset from table center to pointer
    15→  offsetY: number;
    16→}
    17→
    18→export interface DropTarget {
    19→  tableId: string;
    20→  tableName: string;
    21→  distance: number; // Distance from dragged table center to target center
    22→  edge: 'top' | 'bottom' | 'left' | 'right'; // Closest edge
    23→}
    24→
    25→export interface TableBounds {
    26→  id: string;
    27→  name: string;
    28→  x: number; // posX
    29→  y: number; // posY
    30→  width: number;
    31→  height: number;
    32→  centerX: number;
    33→  centerY: number;
    34→}
    35→
    36→/**
    37→ * Convert table data to bounds for hit testing
    38→ */
    39→export function getTableBounds(table: {
    40→  id: string;
    41→  name: string;
    42→  posX: number;
    43→  posY: number;
    44→  width: number;
    45→  height: number;
    46→}): TableBounds {
    47→  return {
    48→    id: table.id,
    49→    name: table.name,
    50→    x: table.posX,
    51→    y: table.posY,
    52→    width: table.width,
    53→    height: table.height,
    54→    centerX: table.posX + table.width / 2,
    55→    centerY: table.posY + table.height / 2,
    56→  };
    57→}
    58→
    59→/**
    60→ * Find the closest edge of target table to the dragged table
    61→ */
    62→function findClosestEdge(
    63→  draggedCenter: { x: number; y: number },
    64→  target: TableBounds
    65→): 'top' | 'bottom' | 'left' | 'right' {
    66→  const dx = draggedCenter.x - target.centerX;
    67→  const dy = draggedCenter.y - target.centerY;
    68→
    69→  // Determine which edge is closest based on angle
    70→  if (Math.abs(dx) > Math.abs(dy)) {
    71→    return dx > 0 ? 'right' : 'left';
    72→  } else {
    73→    return dy > 0 ? 'bottom' : 'top';
    74→  }
    75→}
    76→
    77→/**
    78→ * Calculate distance between two points
    79→ */
    80→function distance(x1: number, y1: number, x2: number, y2: number): number {
    81→  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    82→}
    83→
    84→/**
    85→ * Check if a point is within a table's bounds (with padding)
    86→ */
    87→export function isPointInTable(
    88→  x: number,
    89→  y: number,
    90→  table: TableBounds,
    91→  padding: number = 0
    92→): boolean {
    93→  return (
    94→    x >= table.x - padding &&
    95→    x <= table.x + table.width + padding &&
    96→    y >= table.y - padding &&
    97→    y <= table.y + table.height + padding
    98→  );
    99→}
   100→
   101→/**
   102→ * Find potential drop target for a dragged table
   103→ *
   104→ * @param draggedTableId - ID of the table being dragged
   105→ * @param dragX - Current X position of dragged table center
   106→ * @param dragY - Current Y position of dragged table center
   107→ * @param allTables - All tables to check against
   108→ * @param snapDistance - Max distance to consider a valid drop target (pixels)
   109→ * @returns DropTarget if found, null otherwise
   110→ */
   111→export function findDropTarget(
   112→  draggedTableId: string,
   113→  dragX: number,
   114→  dragY: number,
   115→  allTables: Array<{
   116→    id: string;
   117→    name: string;
   118→    posX: number;
   119→    posY: number;
   120→    width: number;
   121→    height: number;
   122→    virtualGroupId?: string | null;
   123→    combinedWithId?: string | null;
   124→  }>,
   125→  snapDistance: number = 60 // pixels
   126→): DropTarget | null {
   127→  let closest: DropTarget | null = null;
   128→  let minDist = Infinity;
   129→
   130→  for (const table of allTables) {
   131→    // Skip the dragged table itself
   132→    if (table.id === draggedTableId) continue;
   133→
   134→    // NOTE: We DO allow dropping onto tables in virtual groups
   135→    // This enables adding more tables to an existing group
   136→
   137→    // Skip tables that are physically combined (database-level combining)
   138→    if (table.combinedWithId) continue;
   139→
   140→    const bounds = getTableBounds(table);
   141→
   142→    // Calculate distance from drag position to table edge (not center)
   143→    // This makes it easier to "connect" tables
   144→    const edgeDistX = Math.max(0, Math.abs(dragX - bounds.centerX) - bounds.width / 2);
   145→    const edgeDistY = Math.max(0, Math.abs(dragY - bounds.centerY) - bounds.height / 2);
   146→    const edgeDist = Math.sqrt(edgeDistX ** 2 + edgeDistY ** 2);
   147→
   148→    if (edgeDist < snapDistance && edgeDist < minDist) {
   149→      minDist = edgeDist;
   150→      closest = {
   151→        tableId: table.id,
   152→        tableName: table.name,
   153→        distance: edgeDist,
   154→        edge: findClosestEdge({ x: dragX, y: dragY }, bounds),
   155→      };
   156→    }
   157→  }
   158→
   159→  return closest;
   160→}
   161→
   162→/**
   163→ * Create initial drag state
   164→ */
   165→export function createDragState(
   166→  tableId: string,
   167→  tableCenterX: number,
   168→  tableCenterY: number,
   169→  pointerX: number,
   170→  pointerY: number
   171→): DragState {
   172→  return {
   173→    isDragging: true,
   174→    draggedTableId: tableId,
   175→    startX: pointerX,
   176→    startY: pointerY,
   177→    currentX: pointerX,
   178→    currentY: pointerY,
   179→    offsetX: pointerX - tableCenterX,
   180→    offsetY: pointerY - tableCenterY,
   181→  };
   182→}
   183→
   184→/**
   185→ * Update drag state with new pointer position
   186→ */
   187→export function updateDragState(
   188→  state: DragState,
   189→  pointerX: number,
   190→  pointerY: number
   191→): DragState {
   192→  return {
   193→    ...state,
   194→    currentX: pointerX,
   195→    currentY: pointerY,
   196→  };
   197→}
   198→
   199→/**
   200→ * Get the visual position for the dragged table
   201→ */
   202→export function getDraggedTablePosition(state: DragState): { x: number; y: number } {
   203→  return {
   204→    x: state.currentX - state.offsetX,
   205→    y: state.currentY - state.offsetY,
   206→  };
   207→}
   208→
   209→/**
   210→ * Reset drag state
   211→ */
   212→export function resetDragState(): DragState {
   213→  return {
   214→    isDragging: false,
   215→    draggedTableId: null,
   216→    startX: 0,
   217→    startY: 0,
   218→    currentX: 0,
   219→    currentY: 0,
   220→    offsetX: 0,
   221→    offsetY: 0,
   222→  };
   223→}


================================================================================
FILE: /src/domains/floor-plan/groups/colorPalette.ts
================================================================================

     1→/**
     2→ * Color Palette for Virtual Table Groups
     3→ *
     4→ * Provides color families with multiple shades so each table in a combined
     5→ * group can have a distinct but related color. Seats are slightly lighter
     6→ * than their parent table.
     7→ */
     8→
     9→export type ColorFamilyName = 'blue' | 'green' | 'purple' | 'amber' | 'teal' | 'rose';
    10→
    11→export interface ColorFamily {
    12→  name: ColorFamilyName;
    13→  displayName: string;
    14→  // Shades from darkest to lightest (for tables)
    15→  tableShades: string[];
    16→  // Corresponding seat shades (lighter than table)
    17→  seatShades: string[];
    18→  // Base color for the family (used for group outline)
    19→  base: string;
    20→}
    21→
    22→/**
    23→ * Color families optimized for visual distinction on floor plan
    24→ * Each family has 6 shades to support up to 6 tables per group
    25→ */
    26→export const COLOR_FAMILIES: Record<ColorFamilyName, ColorFamily> = {
    27→  blue: {
    28→    name: 'blue',
    29→    displayName: 'Blue',
    30→    base: '#3B82F6',
    31→    tableShades: ['#1E40AF', '#1D4ED8', '#2563EB', '#3B82F6', '#60A5FA', '#93C5FD'],
    32→    seatShades: ['#3B82F6', '#60A5FA', '#93C5FD', '#BFDBFE', '#DBEAFE', '#EFF6FF'],
    33→  },
    34→  green: {
    35→    name: 'green',
    36→    displayName: 'Green',
    37→    base: '#22C55E',
    38→    tableShades: ['#14532D', '#15803D', '#16A34A', '#22C55E', '#4ADE80', '#86EFAC'],
    39→    seatShades: ['#22C55E', '#4ADE80', '#86EFAC', '#BBF7D0', '#DCFCE7', '#F0FDF4'],
    40→  },
    41→  purple: {
    42→    name: 'purple',
    43→    displayName: 'Purple',
    44→    base: '#A855F7',
    45→    tableShades: ['#581C87', '#7E22CE', '#9333EA', '#A855F7', '#C084FC', '#D8B4FE'],
    46→    seatShades: ['#A855F7', '#C084FC', '#D8B4FE', '#E9D5FF', '#F3E8FF', '#FAF5FF'],
    47→  },
    48→  amber: {
    49→    name: 'amber',
    50→    displayName: 'Amber',
    51→    base: '#F59E0B',
    52→    tableShades: ['#78350F', '#92400E', '#B45309', '#D97706', '#F59E0B', '#FBBF24'],
    53→    seatShades: ['#F59E0B', '#FBBF24', '#FCD34D', '#FDE68A', '#FEF3C7', '#FFFBEB'],
    54→  },
    55→  teal: {
    56→    name: 'teal',
    57→    displayName: 'Teal',
    58→    base: '#14B8A6',
    59→    tableShades: ['#134E4A', '#115E59', '#0F766E', '#0D9488', '#14B8A6', '#2DD4BF'],
    60→    seatShades: ['#14B8A6', '#2DD4BF', '#5EEAD4', '#99F6E4', '#CCFBF1', '#F0FDFA'],
    61→  },
    62→  rose: {
    63→    name: 'rose',
    64→    displayName: 'Rose',
    65→    base: '#F43F5E',
    66→    tableShades: ['#881337', '#9F1239', '#BE123C', '#E11D48', '#F43F5E', '#FB7185'],
    67→    seatShades: ['#F43F5E', '#FB7185', '#FDA4AF', '#FECDD3', '#FFE4E6', '#FFF1F2'],
    68→  },
    69→};
    70→
    71→/**
    72→ * Get all available color family names
    73→ */
    74→export function getColorFamilyNames(): ColorFamilyName[] {
    75→  return Object.keys(COLOR_FAMILIES) as ColorFamilyName[];
    76→}
    77→
    78→/**
    79→ * Get a color family by name
    80→ */
    81→export function getColorFamily(name: ColorFamilyName): ColorFamily {
    82→  return COLOR_FAMILIES[name];
    83→}
    84→
    85→/**
    86→ * Get a color family for a group based on group index
    87→ * Cycles through families if more groups than families
    88→ */
    89→export function getColorFamilyForGroup(groupIndex: number): ColorFamily {
    90→  const families = getColorFamilyNames();
    91→  const familyName = families[groupIndex % families.length];
    92→  return COLOR_FAMILIES[familyName];
    93→}
    94→
    95→/**
    96→ * Get table color within a family based on table index in group
    97→ * @param family - The color family
    98→ * @param tableIndex - 0-based index of table within the group
    99→ */
   100→export function getTableColor(family: ColorFamily, tableIndex: number): string {
   101→  const shades = family.tableShades;
   102→  return shades[tableIndex % shades.length];
   103→}
   104→
   105→/**
   106→ * Get seat color for a table (lighter than the table color)
   107→ * @param family - The color family
   108→ * @param tableIndex - 0-based index of table within the group
   109→ */
   110→export function getSeatColor(family: ColorFamily, tableIndex: number): string {
   111→  const shades = family.seatShades;
   112→  return shades[tableIndex % shades.length];
   113→}
   114→
   115→/**
   116→ * Get the group outline/glow color (base color of family)
   117→ */
   118→export function getGroupOutlineColor(family: ColorFamily): string {
   119→  return family.base;
   120→}
   121→
   122→/**
   123→ * Generate color assignments for all tables in a group
   124→ * Returns a map of tableId → { tableColor, seatColor }
   125→ */
   126→export interface TableColorAssignment {
   127→  tableId: string;
   128→  tableColor: string;
   129→  seatColor: string;
   130→  familyName: ColorFamilyName;
   131→}
   132→
   133→export function assignColorsToGroup(
   134→  tableIds: string[],
   135→  groupIndex: number = 0
   136→): TableColorAssignment[] {
   137→  const family = getColorFamilyForGroup(groupIndex);
   138→
   139→  return tableIds.map((tableId, index) => ({
   140→    tableId,
   141→    tableColor: getTableColor(family, index),
   142→    seatColor: getSeatColor(family, index),
   143→    familyName: family.name,
   144→  }));
   145→}
   146→
   147→/**
   148→ * Create a lookup map from tableId to colors
   149→ */
   150→export function createColorLookup(
   151→  assignments: TableColorAssignment[]
   152→): Map<string, { tableColor: string; seatColor: string }> {
   153→  return new Map(
   154→    assignments.map((a) => [a.tableId, { tableColor: a.tableColor, seatColor: a.seatColor }])
   155→  );
   156→}
   157→
   158→/**
   159→ * Get a semi-transparent version of a color for overlays/glows
   160→ * @param hexColor - Hex color string (e.g., '#3B82F6')
   161→ * @param opacity - Opacity value 0-1 (default 0.3)
   162→ */
   163→export function getColorWithOpacity(hexColor: string, opacity: number = 0.3): string {
   164→  // Convert opacity to hex (0-255)
   165→  const alphaHex = Math.round(opacity * 255).toString(16).padStart(2, '0');
   166→  return `${hexColor}${alphaHex}`;
   167→}
   168→
   169→/**
   170→ * Get CSS box-shadow for group glow effect
   171→ */
   172→export function getGroupGlowStyle(family: ColorFamily): string {
   173→  const color = family.base;
   174→  return `0 0 20px ${getColorWithOpacity(color, 0.4)}, 0 0 40px ${getColorWithOpacity(color, 0.2)}`;
   175→}
   176→
   177→/**
   178→ * Get CSS border style for a table in a group
   179→ */
   180→export function getTableBorderStyle(tableColor: string): string {
   181→  return `3px solid ${tableColor}`;
   182→}
   183→
   184→// =============================================================================
   185→// LEGACY COMPATIBILITY FUNCTIONS
   186→// These functions support the older tableGroupAPI.ts which uses a different
   187→// color assignment approach (single color per group vs per-table shades)
   188→// =============================================================================
   189→
   190→// Track which colors are in use (for legacy API)
   191→const colorsInUse = new Set<string>();
   192→
   193→// Simple color list for legacy API (one color per group)
   194→const LEGACY_GROUP_COLORS = [
   195→  '#3B82F6', // blue
   196→  '#22C55E', // green
   197→  '#A855F7', // purple
   198→  '#F59E0B', // amber
   199→  '#14B8A6', // teal
   200→  '#F43F5E', // rose
   201→  '#6366F1', // indigo
   202→  '#EC4899', // pink
   203→];
   204→
   205→/**
   206→ * Get the next available color for a group (legacy API)
   207→ */
   208→export function getNextAvailableColor(): string {
   209→  for (const color of LEGACY_GROUP_COLORS) {
   210→    if (!colorsInUse.has(color)) {
   211→      return color;
   212→    }
   213→  }
   214→  // If all colors in use, return a random one
   215→  return LEGACY_GROUP_COLORS[Math.floor(Math.random() * LEGACY_GROUP_COLORS.length)];
   216→}
   217→
   218→/**
   219→ * Mark a color as in use (legacy API)
   220→ */
   221→export function markColorInUse(color: string): void {
   222→  colorsInUse.add(color);
   223→}
   224→
   225→/**
   226→ * Release a color back to the pool (legacy API)
   227→ */
   228→export function releaseColor(color: string): void {
   229→  colorsInUse.delete(color);
   230→}
   231→
   232→/**
   233→ * Clear all color assignments (legacy API)
   234→ */
   235→export function clearColorAssignments(): void {
   236→  colorsInUse.clear();
   237→}


================================================================================
FILE: /src/app/test-floorplan/page.tsx
================================================================================
     1→'use client';
     2→
     3→/**
     4→ * GWI POS - Floor Plan Test Page (Frontend / FOH View)
     5→ *
     6→ * Visual test page for the Floor Plan domain components.
     7→ * Access at: http://localhost:3000/test-floorplan
     8→ *
     9→ * This page receives real-time updates from the Editor via socket events.
    10→ * Changes made in /test-floorplan/editor will appear here automatically.
    11→ */
    12→
    13→import React, { useEffect, useState, useCallback, useRef } from 'react';
    14→import { FloorCanvas, RoomSelector, FloorCanvasAPI } from '@/domains/floor-plan/canvas';
    15→import { Table as TableComponent, SmartObject, TableAPI } from '@/domains/floor-plan/tables';
    16→import { Seat, SeatAPI } from '@/domains/floor-plan/seats';
    17→import type { Point, Table, Seat as SeatType, Fixture } from '@/domains/floor-plan/shared/types';
    18→import { sampleFloorPlans, sampleFixtures, sampleTables } from './sampleData';
    19→import { PIXELS_PER_FOOT, CANVAS_WIDTH, CANVAS_HEIGHT, GRID_SIZE } from '@/lib/floorplan/constants';
    20→import { useTableGroups } from '@/domains/floor-plan/hooks/useTableGroups';
    21→import { MERGE_CONSTANTS } from '@/domains/floor-plan/groups/types';
    22→import {
    23→  DragState,
    24→  DropTarget,
    25→  findDropTarget,
    26→  createDragState,
    27→  updateDragState,
    28→  getDraggedTablePosition,
    29→  resetDragState,
    30→  calculatePerimeterSeats,
    31→  getGroupDisplayName,
    32→  createPerimeterLookup,
    33→  createEnhancedPerimeterLookup,
    34→  generateVirtualSeatPositions,
    35→  assignColorsToGroup,
    36→  createColorLookup,
    37→  getColorFamilyForGroup,
    38→  getGroupGlowStyle,
    39→  getColorWithOpacity,
    40→  findBestSnap,
    41→  type TableForPerimeter,
    42→  type PerimeterSeatResult,
    43→  type TableColorAssignment,
    44→  type SnapPreview,
    45→  type VirtualSeatPosition,
    46→} from '@/domains/floor-plan/groups';
    47→
    48→// =============================================================================
    49→// DATABASE FIXTURE CONVERSION
    50→// =============================================================================
    51→// IMPORTANT: Database stores positions in PIXELS for direct rendering
    52→// These fixtures are rendered DIRECTLY using pixel values (no feet conversion)
    53→
    54→interface DbFloorPlanElement {
    55→  id: string;
    56→  name: string;
    57→  elementType: string;
    58→  visualType: string;
    59→  geometry: unknown;
    60→  posX: number;
    61→  posY: number;
    62→  width: number;
    63→  height: number;
    64→  rotation: number;
    65→  thickness: number;
    66→  fillColor: string | null;
    67→  opacity: number;
    68→  isLocked: boolean;
    69→  sectionId: string | null;
    70→}
    71→
    72→interface DbSeat {
    73→  id: string;
    74→  label: string;
    75→  seatNumber: number;
    76→  relativeX: number;
    77→  relativeY: number;
    78→  angle: number;
    79→  seatType: string;
    80→}
    81→
    82→interface DbTable {
    83→  id: string;
    84→  name: string;
    85→  abbreviation: string | null;
    86→  capacity: number;
    87→  posX: number;
    88→  posY: number;
    89→  width: number;
    90→  height: number;
    91→  rotation: number;
    92→  shape: string;
    93→  status: string;
    94→  section: { id: string; name: string; color: string | null } | null;
    95→  seats: DbSeat[];
    96→  virtualGroupId?: string | null;
    97→  virtualGroupColor?: string | null;
    98→  virtualGroupPrimary?: boolean;
    99→}
   100→
   101→// Convert database element to a "pixel fixture" for DIRECT rendering (no feet conversion)
   102→// The returned fixture has geometry in PIXELS, not feet
   103→interface PixelFixture {
   104→  id: string;
   105→  floorPlanId: string;
   106→  roomId: string;
   107→  type: string;
   108→  category: string;
   109→  label: string;
   110→  geometry: {
   111→    type: 'rectangle';
   112→    position: { x: number; y: number };
   113→    width: number;
   114→    height: number;
   115→    rotation: number;
   116→  } | {
   117→    type: 'circle';
   118→    center: { x: number; y: number };
   119→    radius: number;
   120→  } | {
   121→    type: 'line';
   122→    start: { x: number; y: number };
   123→    end: { x: number; y: number };
   124→  };
   125→  color: string;
   126→  opacity: number;
   127→  thickness: number;
   128→  isActive: boolean;
   129→}
   130→
   131→function dbElementToPixelFixture(el: DbFloorPlanElement, roomId: string): PixelFixture {
   132→  const geometry = el.geometry as { type: string; [key: string]: unknown } | null;
   133→
   134→  let fixtureGeometry: PixelFixture['geometry'];
   135→  if (geometry?.type === 'line') {
   136→    fixtureGeometry = {
   137→      type: 'line',
   138→      start: (geometry.start as { x: number; y: number }) || { x: el.posX, y: el.posY },
   139→      end: (geometry.end as { x: number; y: number }) || { x: el.posX + el.width, y: el.posY },
   140→    };
   141→  } else if (geometry?.type === 'circle') {
   142→    // For circles, reconstruct from posX/posY/width/height (bounding box)
   143→    const centerX = el.posX + el.width / 2;
   144→    const centerY = el.posY + el.height / 2;
   145→    const radius = el.width / 2;
   146→    fixtureGeometry = {
   147→      type: 'circle',
   148→      center: { x: centerX, y: centerY },
   149→      radius: radius,
   150→    };
   151→  } else {
   152→    fixtureGeometry = {
   153→      type: 'rectangle',
   154→      position: { x: el.posX, y: el.posY },
   155→      width: el.width,
   156→      height: el.height,
   157→      rotation: el.rotation,
   158→    };
   159→  }
   160→
   161→  return {
   162→    id: el.id,
   163→    floorPlanId: roomId,
   164→    roomId: roomId,
   165→    type: el.visualType || 'custom_fixture',
   166→    category: 'barrier',
   167→    label: el.name,
   168→    geometry: fixtureGeometry,
   169→    color: el.fillColor || '#666666',
   170→    opacity: el.opacity,
   171→    thickness: el.thickness,
   172→    isActive: true,
   173→  };
   174→}
   175→
   176→// =============================================================================
   177→// DATABASE FIXTURE RENDERER (PIXELS - NO CONVERSION)
   178→// =============================================================================
   179→// Renders fixtures using PIXEL coordinates directly from the database
   180→// NO feetToPixels conversion because DB already stores pixels
   181→
   182→interface DbFixtureRendererProps {
   183→  fixture: PixelFixture;
   184→  onClick?: () => void;
   185→}
   186→
   187→function DbFixtureRenderer({ fixture, onClick }: DbFixtureRendererProps) {
   188→  const baseStyle: React.CSSProperties = {
   189→    position: 'absolute',
   190→    backgroundColor: fixture.color,
   191→    opacity: fixture.opacity,
   192→    cursor: onClick ? 'pointer' : 'default',
   193→    border: '1px solid rgba(0,0,0,0.2)',
   194→  };
   195→
   196→  // Render based on geometry type - using PIXEL values directly
   197→  if (fixture.geometry.type === 'rectangle') {
   198→    const { position, width, height, rotation } = fixture.geometry;
   199→    return (
   200→      <div
   201→        onClick={onClick}
   202→        style={{
   203→          ...baseStyle,
   204→          left: position.x,  // Already in pixels
   205→          top: position.y,   // Already in pixels
   206→          width: width,      // Already in pixels
   207→          height: height,    // Already in pixels
   208→          transform: `rotate(${rotation}deg)`,
   209→          transformOrigin: 'center center',
   210→        }}
   211→        title={fixture.label}
   212→      />
   213→    );
   214→  }
   215→
   216→  if (fixture.geometry.type === 'circle') {
   217→    const { center, radius } = fixture.geometry;
   218→    const diameter = radius * 2;
   219→    return (
   220→      <div
   221→        onClick={onClick}
   222→        style={{
   223→          ...baseStyle,
   224→          left: center.x - radius,  // Already in pixels
   225→          top: center.y - radius,   // Already in pixels
   226→          width: diameter,          // Already in pixels
   227→          height: diameter,         // Already in pixels
   228→          borderRadius: '50%',
   229→        }}
   230→        title={fixture.label}
   231→      />
   232→    );
   233→  }
   234→
   235→  if (fixture.geometry.type === 'line') {
   236→    const { start, end } = fixture.geometry;
   237→    const thickness = fixture.thickness || 10; // Default thickness in pixels
   238→    const dx = end.x - start.x;
   239→    const dy = end.y - start.y;
   240→    const length = Math.sqrt(dx * dx + dy * dy);
   241→    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
   242→
   243→    return (
   244→      <div
   245→        onClick={onClick}
   246→        style={{
   247→          ...baseStyle,
   248→          left: start.x,              // Already in pixels
   249→          top: start.y - thickness / 2, // Already in pixels
   250→          width: length,              // Already in pixels
   251→          height: thickness,          // Already in pixels
   252→          transform: `rotate(${angle}deg)`,
   253→          transformOrigin: 'left center',
   254→        }}
   255→        title={fixture.label}
   256→      />
   257→    );
   258→  }
   259→
   260→  return null;
   261→}
   262→
   263→// =============================================================================
   264→// DATABASE TABLE RENDERER
   265→// =============================================================================
   266→
   267→interface DbTableRendererProps {
   268→  table: DbTable;
   269→  showSeats?: boolean;
   270→  onClick?: () => void;
   271→  onPointerDown?: (e: React.PointerEvent) => void;
   272→  onPointerUp?: () => void;
   273→  isSelectedForCombine?: boolean;
   274→  isHolding?: boolean;
   275→  tableColor?: string;
   276→  seatColor?: string;
   277→  groupGlow?: string;
   278→  perimeterLookup?: Map<string, number>;
   279→  enhancedLookup?: Map<string, { perimeterNumber: number; isVisible: boolean }>;  // Includes visibility
   280→  visualOffset?: { offsetX: number; offsetY: number };  // Visual snap offset for grouped tables
   281→  isInGroup?: boolean;  // If true, skip rendering seats (virtual seats rendered separately)
   282→}
   283→
   284→function DbTableRenderer({
   285→  table,
   286→  showSeats,
   287→  onClick,
   288→  onPointerDown,
   289→  onPointerUp,
   290→  isSelectedForCombine,
   291→  isHolding,
   292→  tableColor,
   293→  seatColor,
   294→  groupGlow,
   295→  perimeterLookup,
   296→  enhancedLookup,
   297→  visualOffset,
   298→  isInGroup,
   299→}: DbTableRendererProps) {
   300→  const isRound = table.shape === 'round' || table.shape === 'circle' || table.shape === 'oval';
   301→
   302→  // Apply visual offset if provided (for grouped tables to appear snapped together)
   303→  const visualPosX = table.posX + (visualOffset?.offsetX || 0);
   304→  const visualPosY = table.posY + (visualOffset?.offsetY || 0);
   305→
   306→  const tableCenterX = visualPosX + table.width / 2;
   307→  const tableCenterY = visualPosY + table.height / 2;
   308→
   309→  // Render seats with rotation and perimeter numbers
   310→  const renderSeats = () => {
   311→    // If table is in a group, don't render individual seats
   312→    // Virtual seats are rendered separately around the combined shape
   313→    if (isInGroup) return null;
   314→
   315→    if (!showSeats || !table.seats || table.seats.length === 0) return null;
   316→
   317→    return table.seats.map((seat) => {
   318→      // Check if this seat should be hidden (inner seat between combined tables)
   319→      const enhancedInfo = enhancedLookup?.get(seat.id);
   320→      if (enhancedInfo && !enhancedInfo.isVisible) {
   321→        // This is an inner seat - don't render it
   322→        return null;
   323→      }
   324→
   325→      // Apply table rotation to seat position
   326→      const angleRad = (table.rotation * Math.PI) / 180;
   327→      const cos = Math.cos(angleRad);
   328→      const sin = Math.sin(angleRad);
   329→
   330→      const rotatedX = seat.relativeX * cos - seat.relativeY * sin;
   331→      const rotatedY = seat.relativeX * sin + seat.relativeY * cos;
   332→
   333→      const seatAbsX = tableCenterX + rotatedX;
   334→      const seatAbsY = tableCenterY + rotatedY;
   335→
   336→      // Smaller seats (24px) to prevent overlap and allow tapping
   337→      const SEAT_SIZE = 24;
   338→      const SEAT_HALF = SEAT_SIZE / 2;
   339→
   340→      // Get perimeter number if in group (use enhanced lookup first, fallback to basic)
   341→      const perimeterNum = enhancedInfo?.perimeterNumber ?? perimeterLookup?.get(seat.id);
   342→      const seatLabel = perimeterNum !== undefined ? String(perimeterNum) : String(seat.seatNumber);
   343→
   344→      return (
   345→        <div
   346→          key={seat.id}
   347→          onClick={(e) => {
   348→            e.stopPropagation();
   349→            // When we integrate with orders, this will select the seat
   350→            console.log(`Seat ${seatLabel} tapped on table ${table.name}`);
   351→          }}
   352→          style={{
   353→            position: 'absolute',
   354→            left: seatAbsX - SEAT_HALF,
   355→            top: seatAbsY - SEAT_HALF,
   356→            width: SEAT_SIZE,
   357→            height: SEAT_SIZE,
   358→            backgroundColor: seatColor || '#fff',
   359→            border: '2px solid #555',
   360→            borderRadius: '50%',
   361→            display: 'flex',
   362→            alignItems: 'center',
   363→            justifyContent: 'center',
   364→            fontSize: 10,
   365→            fontWeight: 600,
   366→            color: '#333',
   367→            cursor: 'pointer',
   368→            pointerEvents: 'auto',
   369→            boxShadow: '0 1px 3px rgba(0,0,0,0.2)',
   370→            transition: 'all 0.2s ease',
   371→          }}
   372→          onMouseEnter={(e) => {
   373→            e.currentTarget.style.transform = 'scale(1.15)';
   374→            e.currentTarget.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
   375→            e.currentTarget.style.zIndex = '100';
   376→          }}
   377→          onMouseLeave={(e) => {
   378→            e.currentTarget.style.transform = 'scale(1)';
   379→            e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
   380→            e.currentTarget.style.zIndex = 'auto';
   381→          }}
   382→          title={`Seat ${seatLabel}`}
   383→        >
   384→          {seatLabel}
   385→        </div>
   386→      );
   387→    });
   388→  };
   389→
   390→  return (
   391→    <>
   392→      <div
   393→        onClick={onClick}
   394→        onPointerDown={onPointerDown}
   395→        onPointerUp={onPointerUp}
   396→        style={{
   397→          position: 'absolute',
   398→          left: visualPosX,  // Use visual position (with snap offset applied)
   399→          top: visualPosY,   // Use visual position (with snap offset applied)
   400→          width: table.width,
   401→          height: table.height,
   402→          backgroundColor: tableColor || (table.status === 'occupied' ? '#ffcdd2' : '#e8f5e9'),
   403→          border: isSelectedForCombine
   404→            ? '3px solid #06b6d4'
   405→            : tableColor
   406→            ? `3px solid ${tableColor}`
   407→            : '2px solid #666',
   408→          borderRadius: isRound ? '50%' : 8,
   409→          cursor: 'pointer',
   410→          display: 'flex',
   411→          alignItems: 'center',
   412→          justifyContent: 'center',
   413→          fontSize: 12,
   414→          fontWeight: 600,
   415→          color: tableColor ? '#fff' : '#333',
   416→          transform: isHolding
   417→            ? `rotate(${table.rotation}deg) scale(1.02)`
   418→            : `rotate(${table.rotation}deg)`,
   419→          transformOrigin: 'center center',
   420→          boxShadow: isSelectedForCombine
   421→            ? '0 0 20px rgba(6, 182, 212, 0.6), inset 0 0 10px rgba(6, 182, 212, 0.2)'
   422→            : isHolding
   423→            ? '0 0 15px rgba(251, 191, 36, 0.5)'
   424→            : groupGlow
   425→            ? groupGlow
   426→            : undefined,
   427→          transition: visualOffset ? 'all 0.3s ease-out' : 'all 0.2s ease',  // Smooth snap animation
   428→          // Prevent text selection and touch scrolling during long-hold
   429→          userSelect: 'none',
   430→          WebkitUserSelect: 'none',
   431→          touchAction: 'none',
   432→        }}
   433→        title={`${table.name} (${table.capacity} seats)`}
   434→      >
   435→        {table.abbreviation || table.name}
   436→      </div>
   437→      {renderSeats()}
   438→    </>
   439→  );
   440→}
   441→
   442→// =============================================================================
   443→// TABLE RENDERER - Using Layer 2 Components
   444→// =============================================================================
   445→
   446→// =============================================================================
   447→// TEST PAGE COMPONENT
   448→// =============================================================================
   449→
   450→// Database section type
   451→interface DbSection {
   452→  id: string;
   453→  name: string;
   454→  widthFeet: number;
   455→  heightFeet: number;
   456→}
   457→
   458→export default function TestFloorPlanPage() {
   459→  const [selectedRoomId, setSelectedRoomId] = useState<string>('room-main');
   460→  const [clickedPosition, setClickedPosition] = useState<Point | null>(null);
   461→  const [selectedTable, setSelectedTable] = useState<Table | null>(null);
   462→  const [selectedSeat, setSelectedSeat] = useState<SeatType | null>(null);
   463→
   464→  // Database fixtures from FloorPlanElement table
   465→  const [dbFixtures, setDbFixtures] = useState<PixelFixture[]>([]);
   466→  const [dbSections, setDbSections] = useState<DbSection[]>([]);
   467→  const [dbTables, setDbTables] = useState<DbTable[]>([]);
   468→  const [locationId, setLocationId] = useState<string | null>(null);
   469→  const [isDbMode, setIsDbMode] = useState(false);
   470→  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
   471→  const [showDbSeats, setShowDbSeats] = useState(true);
   472→
   473→  // Virtual combining state
   474→  const [isCombineMode, setIsCombineMode] = useState(false);
   475→  const [selectedForCombine, setSelectedForCombine] = useState<string[]>([]);
   476→  const [holdingTableId, setHoldingTableId] = useState<string | null>(null);
   477→  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);
   478→
   479→  // Drag-to-combine state
   480→  const [dragState, setDragState] = useState<DragState>(resetDragState());
   481→  const [dropTarget, setDropTarget] = useState<DropTarget | null>(null);
   482→  const longHoldTimerRef = useRef<NodeJS.Timeout | null>(null);
   483→  const canvasContainerRef = useRef<HTMLDivElement | null>(null);
   484→  const LONG_HOLD_MS = 750;
   485→  const SNAP_DISTANCE_PX = 60;
   486→
   487→  // Helper to convert screen coordinates to canvas coordinates
   488→  const screenToCanvas = useCallback((screenX: number, screenY: number) => {
   489→    if (!canvasContainerRef.current) {
   490→      return { x: screenX, y: screenY };
   491→    }
   492→    const rect = canvasContainerRef.current.getBoundingClientRect();
   493→    return {
   494→      x: screenX - rect.left,
   495→      y: screenY - rect.top,
   496→    };
   497→  }, []);
   498→
   499→  // Virtual group visual state
   500→  const [virtualGroupData, setVirtualGroupData] = useState<{
   501→    groups: Map<string, {
   502→      groupId: string;
   503→      tableIds: string[];
   504→      colorAssignments: TableColorAssignment[];
   505→      colorLookup: Map<string, { tableColor: string; seatColor: string }>;
   506→      perimeterSeats: PerimeterSeatResult[];
   507→      perimeterLookup: Map<string, number>;
   508→      enhancedLookup: Map<string, { perimeterNumber: number; isVisible: boolean }>;
   509→      virtualSeats: VirtualSeatPosition[];  // New: regenerated seat positions around combined shape
   510→      displayName: string;
   511→      groupIndex: number;
   512→    }>;
   513→  }>({ groups: new Map() });
   514→
   515→  // Visual offsets for tables in virtual groups (makes them appear snapped together)
   516→  // Key: tableId, Value: { offsetX, offsetY } - how much to shift the table visually
   517→  const [visualOffsets, setVisualOffsets] = useState<Map<string, { offsetX: number; offsetY: number }>>(new Map());
   518→
   519→  // Store snap positions when groups are created (persists the exact drag-preview position)
   520→  // Key: groupId, Value: { draggedTableId, snapPosition }
   521→  const [storedSnapPositions, setStoredSnapPositions] = useState<Map<string, { draggedTableId: string; snapPosition: { x: number; y: number } }>>(new Map());
   522→
   523→  // Snap preview during drag
   524→  const [snapPreview, setSnapPreview] = useState<SnapPreview | null>(null);
   525→
   526→  // Use table groups hook
   527→  const { createVirtualGroup, dissolveGroup, addToGroup, isLoading: isCreatingGroup } = useTableGroups({
   528→    locationId: locationId || 'loc-1',
   529→    autoLoad: false,
   530→  });
   531→
   532→  // Fetch database fixtures
   533→  const fetchDbFixtures = useCallback(async (locId: string) => {
   534→    try {
   535→      const res = await fetch(`/api/floor-plan-elements?locationId=${locId}`);
   536→      if (res.ok) {
   537→        const data = await res.json();
   538→        const fixtures = (data.elements || []).map((el: DbFloorPlanElement) =>
   539→          dbElementToPixelFixture(el, el.sectionId || 'db-room')
   540→        );
   541→        setDbFixtures(fixtures);
   542→        setIsDbMode(fixtures.length > 0);
   543→        setLastUpdate(new Date());
   544→        console.log(`[FOH] Loaded ${fixtures.length} fixtures from database`);
   545→      }
   546→    } catch (error) {
   547→      console.error('[FOH] Failed to fetch database fixtures:', error);
   548→    }
   549→  }, []);
   550→
   551→  // Fetch database sections
   552→  const fetchDbSections = useCallback(async (locId: string) => {
   553→    try {
   554→      const res = await fetch(`/api/sections?locationId=${locId}`);
   555→      if (res.ok) {
   556→        const data = await res.json();
   557→        const sections = data.sections || [];
   558→        setDbSections(sections);
   559→        console.log(`[FOH] Loaded ${sections.length} sections from database`);
   560→        // Auto-select first section if available
   561→        if (sections.length > 0) {
   562→          setSelectedRoomId(sections[0].id);
   563→        }
   564→        return sections;
   565→      }
   566→    } catch (error) {
   567→      console.error('[FOH] Failed to fetch sections:', error);
   568→    }
   569→    return [];
   570→  }, []);
   571→
   572→  // Fetch database tables
   573→  const fetchDbTables = useCallback(async (locId: string, sectionId?: string) => {
   574→    try {
   575→      let url = `/api/tables?locationId=${locId}&includeSeats=true`;
   576→      if (sectionId) {
   577→        url += `&sectionId=${sectionId}`;
   578→      }
   579→      const res = await fetch(url);
   580→      if (res.ok) {
   581→        const data = await res.json();
   582→        setDbTables(data.tables || []);
   583→        console.log(`[FOH] Loaded ${(data.tables || []).length} tables from database`);
   584→      }
   585→    } catch (error) {
   586→      console.error('[FOH] Failed to fetch database tables:', error);
   587→    }
   588→  }, []);
   589→
   590→  // Reset all virtual groups (for testing)
   591→  const handleResetAllGroups = useCallback(async () => {
   592→    if (!locationId) return;
   593→
   594→    // Find all unique virtual group IDs
   595→    const groupIds = new Set<string>();
   596→    dbTables.forEach(table => {
   597→      if (table.virtualGroupId) {
   598→        groupIds.add(table.virtualGroupId);
   599→      }
   600→    });
   601→
   602→    if (groupIds.size === 0) {
   603→      alert('No virtual groups to reset');
   604→      return;
   605→    }
   606→
   607→    const confirmed = window.confirm(`Reset ${groupIds.size} virtual group(s)? Tables will return to their original positions.`);
   608→    if (!confirmed) return;
   609→
   610→    // Dissolve each group
   611→    for (const groupId of groupIds) {
   612→      await dissolveGroup(groupId);
   613→    }
   614→
   615→    // Clear stored snap positions
   616→    setStoredSnapPositions(new Map());
   617→
   618→    // Refresh table data
   619→    await fetchDbTables(locationId);
   620→    console.log(`[FOH] Reset ${groupIds.size} virtual groups`);
   621→  }, [locationId, dbTables, dissolveGroup, fetchDbTables]);
   622→
   623→  // Get location ID and initialize
   624→  useEffect(() => {
   625→    async function init() {
   626→      // Get location ID
   627→      try {
   628→        const res = await fetch('/api/locations');
   629→        if (res.ok) {
   630→          const data = await res.json();
   631→          if (data.locations && data.locations.length > 0) {
   632→            const locId = data.locations[0].id;
   633→            setLocationId(locId);
   634→            // Fetch database sections and fixtures
   635→            const sections = await fetchDbSections(locId);
   636→            await fetchDbFixtures(locId);
   637→            await fetchDbTables(locId);
   638→            // If we have sections, we're in DB mode
   639→            if (sections.length > 0) {
   640→              setIsDbMode(true);
   641→            }
   642→          }
   643→        }
   644→      } catch {
   645→        console.log('[FOH] No locations API available');
   646→      }
   647→
   648→      // Initialize in-memory data as fallback
   649→      if (FloorCanvasAPI.getAllRooms().length === 0) {
   650→        FloorCanvasAPI.initializeFloorPlans(sampleFloorPlans, sampleFixtures);
   651→      }
   652→
   653→      // Only initialize tables if not already done
   654→      if (TableAPI.getAllTables().length === 0) {
   655→        TableAPI.initializeTables(sampleTables);
   656→
   657→        // Generate seats for seatable tables
   658→        sampleTables.forEach((table) => {
   659→          if (table.category === 'seatable') {
   660→            SeatAPI.generateSeatsForTable(
   661→              table.id,
   662→              table.defaultCapacity,
   663→              table.shape
   664→            );
   665→          }
   666→        });
   667→      }
   668→
   669→      // Only set to room-main if not already set to a DB section
   670→      if (!isDbMode) {
   671→        setSelectedRoomId('room-main');
   672→      }
   673→    }
   674→    init();
   675→  }, [fetchDbFixtures, fetchDbSections, fetchDbTables, isDbMode]);
   676→
   677→  // Listen for floor-plan:updated socket events
   678→  useEffect(() => {
   679→    if (!locationId) return;
   680→
   681→    // Set up EventSource for Server-Sent Events (simple polling fallback)
   682→    // For a full implementation, use socket.io-client
   683→    let intervalId: NodeJS.Timeout | null = null;
   684→
   685→    // Poll for updates every 5 seconds (simple approach without socket.io)
   686→    // Don't pass sectionId - fetch ALL tables and filter client-side
   687→    // This prevents the "0 tables" bug when polling with wrong section filter
   688→    intervalId = setInterval(() => {
   689→      fetchDbFixtures(locationId);
   690→      fetchDbTables(locationId); // No sectionId filter - client filters by section
   691→    }, 5000);
   692→
   693→    console.log('[FOH] Started polling for floor plan updates');
   694→
   695→    return () => {
   696→      if (intervalId) {
   697→        clearInterval(intervalId);
   698→        console.log('[FOH] Stopped polling');
   699→      }
   700→    };
   701→  }, [locationId, fetchDbFixtures, fetchDbTables]);
   702→
   703→  // Compute virtual group data and visual offsets whenever dbTables changes
   704→  useEffect(() => {
   705→    if (!dbTables || dbTables.length === 0) {
   706→      setVirtualGroupData({ groups: new Map() });
   707→      setVisualOffsets(new Map());
   708→      return;
   709→    }
   710→
   711→    // Find all unique virtual group IDs
   712→    const groupIds = new Set<string>();
   713→    dbTables.forEach(table => {
   714→      if (table.virtualGroupId) {
   715→        groupIds.add(table.virtualGroupId);
   716→        console.log('[Groups] Table', table.name, 'is in group', table.virtualGroupId);
   717→      }
   718→    });
   719→
   720→    console.log('[Groups] Found', groupIds.size, 'virtual groups');
   721→
   722→    // Build group data for each virtual group
   723→    const groups = new Map<string, {
   724→      groupId: string;
   725→      tableIds: string[];
   726→      colorAssignments: TableColorAssignment[];
   727→      colorLookup: Map<string, { tableColor: string; seatColor: string }>;
   728→      perimeterSeats: PerimeterSeatResult[];
   729→      perimeterLookup: Map<string, number>;
   730→      enhancedLookup: Map<string, { perimeterNumber: number; isVisible: boolean }>;
   731→      virtualSeats: VirtualSeatPosition[];
   732→      displayName: string;
   733→      groupIndex: number;
   734→    }>();
   735→
   736→    // Calculate visual offsets for tables in groups (to make them appear snapped together)
   737→    const newVisualOffsets = new Map<string, { offsetX: number; offsetY: number }>();
   738→
   739→    let groupIndex = 0;
   740→
   741→    groupIds.forEach(groupId => {
   742→      // Get tables in this group
   743→      const groupTables = dbTables.filter(t => t.virtualGroupId === groupId);
   744→      if (groupTables.length === 0) return;
   745→
   746→      const tableIds = groupTables.map(t => t.id);
   747→
   748→      // Calculate color assignments
   749→      const colorAssignments = assignColorsToGroup(tableIds, groupIndex);
   750→      const colorLookup = createColorLookup(colorAssignments);
   751→
   752→      // Find the primary table (anchor - doesn't move visually)
   753→      const primaryTable = groupTables.find(t => t.virtualGroupPrimary) || groupTables[0];
   754→
   755→      // Check if we have a stored snap position for this group
   756→      const storedSnap = storedSnapPositions.get(groupId);
   757→
   758→      // Visual offsets - snap tables together based on proximity
   759→      // Tables in a group should appear touching each other
   760→      // Primary table stays at its database position, others snap to it
   761→
   762→      // First pass: set primary table (no offset)
   763→      newVisualOffsets.set(primaryTable.id, { offsetX: 0, offsetY: 0 });
   764→
   765→      // Track which tables have been positioned
   766→      const positionedTables = new Map<string, { posX: number; posY: number; width: number; height: number }>();
   767→      positionedTables.set(primaryTable.id, {
   768→        posX: primaryTable.posX,
   769→        posY: primaryTable.posY,
   770→        width: primaryTable.width,
   771→        height: primaryTable.height,
   772→      });
   773→
   774→      // Position remaining tables by snapping to nearest positioned table
   775→      const remainingTables = groupTables.filter(t => t.id !== primaryTable.id);
   776→      const MAX_SNAP_DISTANCE = 150; // Only snap if tables are reasonably close in database
   777→
   778→      // Keep processing until all tables are positioned (or no more can be snapped)
   779→      let iterations = 0;
   780→      while (remainingTables.length > 0 && iterations < 10) {
   781→        iterations++;
   782→        let snappedAny = false;
   783→
   784→        for (let i = remainingTables.length - 1; i >= 0; i--) {
   785→          const table = remainingTables[i];
   786→
   787→          // Check for stored snap position first (from current session drag)
   788→          const perTableSnap = storedSnapPositions.get(`${groupId}-${table.id}`);
   789→          const groupSnap = storedSnapPositions.get(groupId);
   790→
   791→          if (perTableSnap && perTableSnap.draggedTableId === table.id) {
   792→            const offsetX = perTableSnap.snapPosition.x - table.posX;
   793→            const offsetY = perTableSnap.snapPosition.y - table.posY;
   794→            newVisualOffsets.set(table.id, { offsetX, offsetY });
   795→            positionedTables.set(table.id, {
   796→              posX: table.posX + offsetX,
   797→              posY: table.posY + offsetY,
   798→              width: table.width,
   799→              height: table.height,
   800→            });
   801→            remainingTables.splice(i, 1);
   802→            snappedAny = true;
   803→            console.log(`[VisualSnap] Table ${table.name} using PER-TABLE snap`);
   804→            continue;
   805→          }
   806→
   807→          if (groupSnap && groupSnap.draggedTableId === table.id) {
   808→            const offsetX = groupSnap.snapPosition.x - table.posX;
   809→            const offsetY = groupSnap.snapPosition.y - table.posY;
   810→            newVisualOffsets.set(table.id, { offsetX, offsetY });
   811→            positionedTables.set(table.id, {
   812→              posX: table.posX + offsetX,
   813→              posY: table.posY + offsetY,
   814→              width: table.width,
   815→              height: table.height,
   816→            });
   817→            remainingTables.splice(i, 1);
   818→            snappedAny = true;
   819→            console.log(`[VisualSnap] Table ${table.name} using GROUP snap`);
   820→            continue;
   821→          }
   822→
   823→          // Find the closest positioned table to snap to
   824→          let bestTarget: { id: string; edge: 'left' | 'right' | 'top' | 'bottom'; distance: number } | null = null;
   825→
   826→          for (const [positionedId, positioned] of positionedTables) {
   827→            // Calculate distance between table centers
   828→            const tableCenterX = table.posX + table.width / 2;
   829→            const tableCenterY = table.posY + table.height / 2;
   830→            const positionedCenterX = positioned.posX + positioned.width / 2;
   831→            const positionedCenterY = positioned.posY + positioned.height / 2;
   832→
   833→            const dx = tableCenterX - positionedCenterX;
   834→            const dy = tableCenterY - positionedCenterY;
   835→            const distance = Math.sqrt(dx * dx + dy * dy);
   836→
   837→            if (distance > MAX_SNAP_DISTANCE) continue;
   838→
   839→            // Determine which edge to snap to based on relative position
   840→            const isHorizontal = Math.abs(dx) > Math.abs(dy);
   841→            let edge: 'left' | 'right' | 'top' | 'bottom';
   842→
   843→            if (isHorizontal) {
   844→              edge = dx > 0 ? 'right' : 'left';
   845→            } else {
   846→              edge = dy > 0 ? 'bottom' : 'top';
   847→            }
   848→
   849→            if (!bestTarget || distance < bestTarget.distance) {
   850→              bestTarget = { id: positionedId, edge, distance };
   851→            }
   852→          }
   853→
   854→          if (bestTarget) {
   855→            const target = positionedTables.get(bestTarget.id)!;
   856→            let snapX = table.posX;
   857→            let snapY = table.posY;
   858→
   859→            // Snap to the appropriate edge of the target
   860→            switch (bestTarget.edge) {
   861→              case 'right':
   862→                snapX = target.posX + target.width;
   863→                snapY = target.posY + (target.height - table.height) / 2; // Center vertically
   864→                break;
   865→              case 'left':
   866→                snapX = target.posX - table.width;
   867→                snapY = target.posY + (target.height - table.height) / 2;
   868→                break;
   869→              case 'bottom':
   870→                snapX = target.posX + (target.width - table.width) / 2; // Center horizontally
   871→                snapY = target.posY + target.height;
   872→                break;
   873→              case 'top':
   874→                snapX = target.posX + (target.width - table.width) / 2;
   875→                snapY = target.posY - table.height;
   876→                break;
   877→            }
   878→
   879→            const offsetX = snapX - table.posX;
   880→            const offsetY = snapY - table.posY;
   881→            newVisualOffsets.set(table.id, { offsetX, offsetY });
   882→            positionedTables.set(table.id, {
   883→              posX: snapX,
   884→              posY: snapY,
   885→              width: table.width,
   886→              height: table.height,
   887→            });
   888→            remainingTables.splice(i, 1);
   889→            snappedAny = true;
   890→            console.log(`[VisualSnap] Table ${table.name} snapped to ${bestTarget.edge} of positioned table`);
   891→          }
   892→        }
   893→
   894→        // If we couldn't snap any tables this iteration, break to avoid infinite loop
   895→        if (!snappedAny) break;
   896→      }
   897→
   898→      // Any remaining tables that couldn't be snapped - just use database position
   899→      for (const table of remainingTables) {
   900→        newVisualOffsets.set(table.id, { offsetX: 0, offsetY: 0 });
   901→        console.log(`[VisualSnap] Table ${table.name} could not snap - using database position`);
   902→      }
   903→
   904→      // Calculate perimeter seats using VISUAL positions (snapped positions)
   905→      let tablesForPerimeter: TableForPerimeter[] = groupTables.map(t => {
   906→        const offset = newVisualOffsets.get(t.id) || { offsetX: 0, offsetY: 0 };
   907→        return {
   908→          id: t.id,
   909→          name: t.name,
   910→          posX: t.posX + offset.offsetX,  // Use visual position
   911→          posY: t.posY + offset.offsetY,  // Use visual position
   912→          width: t.width,
   913→          height: t.height,
   914→          seats: t.seats || [],
   915→        };
   916→      });
   917→
   918→      // Generate virtual seat positions around the combined bounding box
   919→      // This places seats evenly around the perimeter instead of using original positions
   920→      // seatDistance = 22px (seat radius 12px + 10px gap from table edge)
   921→      // Seats are ALWAYS placed OUTSIDE the table bounds, never on top
   922→      let virtualSeats = generateVirtualSeatPositions(tablesForPerimeter, 22);
   923→
   924→      // AUTO-NUDGE: Check if any seats fall outside the canvas and nudge the group inward
   925→      // This prevents seats from being cut off at the edges
   926→      const SEAT_RADIUS = 12;
   927→      const EDGE_PADDING = 10; // Extra padding from canvas edge
   928→      const CANVAS_MIN_X = EDGE_PADDING;
   929→      const CANVAS_MIN_Y = EDGE_PADDING;
   930→      const CANVAS_MAX_X = CANVAS_WIDTH - EDGE_PADDING;
   931→      const CANVAS_MAX_Y = CANVAS_HEIGHT - EDGE_PADDING;
   932→
   933→      // Find the extent of all virtual seats
   934→      let seatsMinX = Infinity, seatsMinY = Infinity;
   935→      let seatsMaxX = -Infinity, seatsMaxY = -Infinity;
   936→      virtualSeats.forEach(seat => {
   937→        seatsMinX = Math.min(seatsMinX, seat.absoluteX - SEAT_RADIUS);
   938→        seatsMinY = Math.min(seatsMinY, seat.absoluteY - SEAT_RADIUS);
   939→        seatsMaxX = Math.max(seatsMaxX, seat.absoluteX + SEAT_RADIUS);
   940→        seatsMaxY = Math.max(seatsMaxY, seat.absoluteY + SEAT_RADIUS);
   941→      });
   942→
   943→      // Calculate how much to nudge the group to keep seats on canvas
   944→      let edgeCorrectionX = 0;
   945→      let edgeCorrectionY = 0;
   946→
   947→      if (seatsMinX < CANVAS_MIN_X) {
   948→        edgeCorrectionX = CANVAS_MIN_X - seatsMinX;
   949→      } else if (seatsMaxX > CANVAS_MAX_X) {
   950→        edgeCorrectionX = CANVAS_MAX_X - seatsMaxX;
   951→      }
   952→
   953→      if (seatsMinY < CANVAS_MIN_Y) {
   954→        edgeCorrectionY = CANVAS_MIN_Y - seatsMinY;
   955→      } else if (seatsMaxY > CANVAS_MAX_Y) {
   956→        edgeCorrectionY = CANVAS_MAX_Y - seatsMaxY;
   957→      }
   958→
   959→      // Apply edge correction to all tables in the group if needed
   960→      if (edgeCorrectionX !== 0 || edgeCorrectionY !== 0) {
   961→        console.log(`[EdgeNudge] Group ${groupId} nudged by (${edgeCorrectionX}, ${edgeCorrectionY}) to keep seats on canvas`);
   962→
   963→        // Update visual offsets for all tables in this group
   964→        groupTables.forEach(table => {
   965→          const currentOffset = newVisualOffsets.get(table.id) || { offsetX: 0, offsetY: 0 };
   966→          newVisualOffsets.set(table.id, {
   967→            offsetX: currentOffset.offsetX + edgeCorrectionX,
   968→            offsetY: currentOffset.offsetY + edgeCorrectionY,
   969→          });
   970→        });
   971→
   972→        // Recalculate tablesForPerimeter with corrected offsets
   973→        tablesForPerimeter = groupTables.map(t => {
   974→          const offset = newVisualOffsets.get(t.id) || { offsetX: 0, offsetY: 0 };
   975→          return {
   976→            id: t.id,
   977→            name: t.name,
   978→            posX: t.posX + offset.offsetX,
   979→            posY: t.posY + offset.offsetY,
   980→            width: t.width,
   981→            height: t.height,
   982→            seats: t.seats || [],
   983→          };
   984→        });
   985→
   986→        // Regenerate virtual seats with corrected positions
   987→        virtualSeats = generateVirtualSeatPositions(tablesForPerimeter, 22);
   988→      }
   989→
   990→      // Debug: Log virtual seat positions
   991→      console.log('[VirtualSeats] Group', groupId, '- generated', virtualSeats.length, 'virtual seats');
   992→
   993→      const perimeterSeats = calculatePerimeterSeats(tablesForPerimeter);
   994→      const perimeterLookup = createPerimeterLookup(perimeterSeats);
   995→      const enhancedLookup = createEnhancedPerimeterLookup(tablesForPerimeter);
   996→
   997→      // Get display name
   998→      const displayName = getGroupDisplayName(tablesForPerimeter);
   999→
  1000→      groups.set(groupId, {
  1001→        groupId,
  1002→        tableIds,
  1003→        colorAssignments,
  1004→        colorLookup,
  1005→        perimeterSeats,
  1006→        perimeterLookup,
  1007→        enhancedLookup,
  1008→        virtualSeats,
  1009→        displayName,
  1010→        groupIndex,
  1011→      });
  1012→
  1013→      groupIndex++;
  1014→    });
  1015→
  1016→    setVirtualGroupData({ groups });
  1017→    setVisualOffsets(newVisualOffsets);
  1018→  }, [dbTables, storedSnapPositions]);
  1019→
  1020→  // Helper function to calculate where a secondary table should snap to the primary table
  1021→  function calculateSnapPositionForTable(
  1022→    secondary: DbTable,
  1023→    primary: DbTable
  1024→  ): { x: number; y: number } {
  1025→    // Calculate centers
  1026→    const primaryCenterX = primary.posX + primary.width / 2;
  1027→    const primaryCenterY = primary.posY + primary.height / 2;
  1028→    const secondaryCenterX = secondary.posX + secondary.width / 2;
  1029→    const secondaryCenterY = secondary.posY + secondary.height / 2;
  1030→
  1031→    // Determine which edge to snap to based on relative position
  1032→    const dx = secondaryCenterX - primaryCenterX;
  1033→    const dy = secondaryCenterY - primaryCenterY;
  1034→
  1035→    // Determine primary direction (horizontal or vertical)
  1036→    const isHorizontal = Math.abs(dx) > Math.abs(dy);
  1037→
  1038→    let snapX: number;
  1039→    let snapY: number;
  1040→
  1041→    if (isHorizontal) {
  1042→      if (dx > 0) {
  1043→        // Secondary is to the RIGHT of primary - snap to primary's right edge
  1044→        snapX = primary.posX + primary.width;  // Left edge of secondary touches right edge of primary
  1045→      } else {
  1046→        // Secondary is to the LEFT of primary - snap to primary's left edge
  1047→        snapX = primary.posX - secondary.width;  // Right edge of secondary touches left edge of primary
  1048→      }
  1049→      // Align centers vertically (with small offset to preserve original offset)
  1050→      const verticalOffset = Math.min(Math.abs(dy), Math.min(primary.height, secondary.height) * 0.3);
  1051→      snapY = primary.posY + (primary.height - secondary.height) / 2 + (dy > 0 ? verticalOffset : -verticalOffset) * 0.5;
  1052→    } else {
  1053→      if (dy > 0) {
  1054→        // Secondary is BELOW primary - snap to primary's bottom edge
  1055→        snapY = primary.posY + primary.height;  // Top edge of secondary touches bottom edge of primary
  1056→      } else {
  1057→        // Secondary is ABOVE primary - snap to primary's top edge
  1058→        snapY = primary.posY - secondary.height;  // Bottom edge of secondary touches top edge of primary
  1059→      }
  1060→      // Align centers horizontally (with small offset to preserve original offset)
  1061→      const horizontalOffset = Math.min(Math.abs(dx), Math.min(primary.width, secondary.width) * 0.3);
  1062→      snapX = primary.posX + (primary.width - secondary.width) / 2 + (dx > 0 ? horizontalOffset : -horizontalOffset) * 0.5;
  1063→    }
  1064→
  1065→    return { x: snapX, y: snapY };
  1066→  }
  1067→
  1068→  // Helper function to calculate snap position for a table joining an existing group with multiple tables
  1069→  // Finds the nearest already-positioned table and snaps to it
  1070→  function calculateSnapPositionForTableInGroup(
  1071→    newTable: DbTable,
  1072→    primaryTable: DbTable,
  1073→    allGroupTables: DbTable[],
  1074→    currentOffsets: Map<string, { offsetX: number; offsetY: number }>
  1075→  ): { x: number; y: number } {
  1076→    // Get all tables that already have positions calculated (including primary)
  1077→    const positionedTables = allGroupTables.filter(t =>
  1078→      t.id === primaryTable.id || currentOffsets.has(t.id)
  1079→    );
  1080→
  1081→    if (positionedTables.length === 0) {
  1082→      // Fallback to primary
  1083→      return calculateSnapPositionForTable(newTable, primaryTable);
  1084→    }
  1085→
  1086→    // Find the nearest positioned table to snap to
  1087→    let nearestTable = primaryTable;
  1088→    let nearestDistance = Infinity;
  1089→
  1090→    for (const table of positionedTables) {
  1091→      const offset = currentOffsets.get(table.id) || { offsetX: 0, offsetY: 0 };
  1092→      const visualX = table.posX + offset.offsetX;
  1093→      const visualY = table.posY + offset.offsetY;
  1094→
  1095→      // Calculate distance from new table's original position to this positioned table
  1096→      const dx = newTable.posX - visualX;
  1097→      const dy = newTable.posY - visualY;
  1098→      const distance = Math.sqrt(dx * dx + dy * dy);
  1099→
  1100→      if (distance < nearestDistance) {
  1101→        nearestDistance = distance;
  1102→        nearestTable = table;
  1103→      }
  1104→    }
  1105→
  1106→    // Create a virtual table with the visual position for snapping
  1107→    const nearestOffset = currentOffsets.get(nearestTable.id) || { offsetX: 0, offsetY: 0 };
  1108→    const virtualNearestTable: DbTable = {
  1109→      ...nearestTable,
  1110→      posX: nearestTable.posX + nearestOffset.offsetX,
  1111→      posY: nearestTable.posY + nearestOffset.offsetY,
  1112→    };
  1113→
  1114→    return calculateSnapPositionForTable(newTable, virtualNearestTable);
  1115→  }
  1116→
  1117→  // Get tables for current room using TableAPI
  1118→  const tablesInRoom = TableAPI.getTablesForRoom(selectedRoomId);
  1119→
  1120→  // Get all seats for tables in the current room
  1121→  const seatsInRoom: SeatType[] = [];
  1122→  tablesInRoom.forEach((table) => {
  1123→    const tableSeats = SeatAPI.getSeatsForTable(table.id);
  1124→    seatsInRoom.push(...tableSeats);
  1125→  });
  1126→
  1127→  // Virtual combining handlers with drag-to-combine
  1128→  const handleTablePointerDown = useCallback((
  1129→    tableId: string,
  1130→    tableCenterX: number,
  1131→    tableCenterY: number,
  1132→    e: React.PointerEvent
  1133→  ) => {
  1134→    console.log('[PointerDown] Table pressed:', { tableId, isCombineMode });
  1135→
  1136→    // Don't start drag if already in combine mode
  1137→    if (isCombineMode) return;
  1138→
  1139→    // Convert screen coordinates to canvas coordinates
  1140→    const canvasCoords = screenToCanvas(e.clientX, e.clientY);
  1141→
  1142→    console.log('[PointerDown] Starting long-hold timer');
  1143→    setHoldingTableId(tableId);
  1144→
  1145→    // Start long-hold timer for drag mode
  1146→    longHoldTimerRef.current = setTimeout(() => {
  1147→      // After 750ms, activate drag mode
  1148→      // Use canvas coordinates for both table center and pointer
  1149→      console.log('[Drag] Starting drag:', { tableId, tableCenterX, tableCenterY, canvasCoords });
  1150→      setDragState(createDragState(tableId, tableCenterX, tableCenterY, canvasCoords.x, canvasCoords.y));
  1151→      setHoldingTableId(null);
  1152→    }, LONG_HOLD_MS);
  1153→  }, [isCombineMode, LONG_HOLD_MS, screenToCanvas]);
  1154→
  1155→  // Handle pointer move for dragging
  1156→  const handlePointerMove = useCallback((e: React.PointerEvent) => {
  1157→    if (!dragState.isDragging) return;
  1158→
  1159→    // Convert screen coordinates to canvas coordinates
  1160→    const canvasCoords = screenToCanvas(e.clientX, e.clientY);
  1161→    const newState = updateDragState(dragState, canvasCoords.x, canvasCoords.y);
  1162→    setDragState(newState);
  1163→
  1164→    // Find potential drop target (now using canvas coordinates)
  1165→    const dragPos = getDraggedTablePosition(newState);
  1166→    const target = findDropTarget(
  1167→      dragState.draggedTableId!,
  1168→      dragPos.x,
  1169→      dragPos.y,
  1170→      dbTables,
  1171→      SNAP_DISTANCE_PX
  1172→    );
  1173→    setDropTarget(target);
  1174→
  1175→    // Calculate snap preview
  1176→    const draggedTable = dbTables.find(t => t.id === dragState.draggedTableId);
  1177→    if (draggedTable) {
  1178→      // Only consider tables in the SAME SECTION as visible targets
  1179→      // This matches the rendering filter logic
  1180→      const visibleTables = dbTables.filter(t => {
  1181→        if (t.section?.id === selectedRoomId) return true;
  1182→        if (!t.section && dbSections.length > 0 && dbSections[0].id === selectedRoomId) return true;
  1183→        return false;
  1184→      });
  1185→
  1186→      // Allow snapping to ANY table (including those in groups) so users can add to existing groups
  1187→      // Only exclude the table being dragged
  1188→      // IMPORTANT: Use VISUAL positions for tables in groups (with snap offsets applied)
  1189→      const tableRects = visibleTables
  1190→        .filter(t => t.id !== dragState.draggedTableId)
  1191→        .map(t => {
  1192→          // Get visual offset if table is in a group
  1193→          const offset = visualOffsets.get(t.id) || { offsetX: 0, offsetY: 0 };
  1194→          return {
  1195→            id: t.id,
  1196→            x: t.posX + offset.offsetX,  // Use visual position
  1197→            y: t.posY + offset.offsetY,  // Use visual position
  1198→            width: t.width,
  1199→            height: t.height,
  1200→          };
  1201→        });
  1202→
  1203→      const draggedRect = {
  1204→        id: draggedTable.id,
  1205→        x: dragPos.x - draggedTable.width / 2,
  1206→        y: dragPos.y - draggedTable.height / 2,
  1207→        width: draggedTable.width,
  1208→        height: draggedTable.height,
  1209→      };
  1210→
  1211→      // Debug logging
  1212→      console.log('[Snap] Checking:', {
  1213→        draggedName: draggedTable.name,
  1214→        visibleCount: visibleTables.length,
  1215→        availableTargets: tableRects.length,
  1216→        selectedRoomId,
  1217→        draggedPos: { x: draggedRect.x, y: draggedRect.y }
  1218→      });
  1219→
  1220→      const snap = findBestSnap(draggedRect, tableRects);
  1221→      setSnapPreview(snap);
  1222→    }
  1223→  }, [dragState, dbTables, dbSections, selectedRoomId, SNAP_DISTANCE_PX, screenToCanvas, visualOffsets]);
  1224→
  1225→  // Handle pointer up - only snap and combine if we have a valid snap position
  1226→  const handleTablePointerUp = useCallback(async () => {
  1227→    // Clear long-hold timer
  1228→    if (longHoldTimerRef.current) {
  1229→      clearTimeout(longHoldTimerRef.current);
  1230→      longHoldTimerRef.current = null;
  1231→    }
  1232→    setHoldingTableId(null);
  1233→
  1234→    // Only proceed if we were dragging AND have a valid snap preview
  1235→    // If no valid snap, table returns to original position (no action taken)
  1236→    if (dragState.isDragging && snapPreview?.isValid && dragState.draggedTableId) {
  1237→      try {
  1238→        // IMPORTANT: FOH view does NOT move table positions!
  1239→        // Virtual groups are visual-only - tables stay in their original positions
  1240→        // Only the Editor can change table positions
  1241→
  1242→        // Check if the target table is already in a virtual group
  1243→        const targetTable = dbTables.find(t => t.id === snapPreview.targetTableId);
  1244→        const draggedTable = dbTables.find(t => t.id === dragState.draggedTableId);
  1245→
  1246→        if (targetTable?.virtualGroupId) {
  1247→          // Target is already in a group - ADD the dragged table to that existing group
  1248→          console.log('[Snap] Adding table to existing group:', {
  1249→            draggedTableId: dragState.draggedTableId,
  1250→            targetGroupId: targetTable.virtualGroupId,
  1251→          });
  1252→
  1253→          const success = await addToGroup(
  1254→            targetTable.virtualGroupId,
  1255→            dragState.draggedTableId,
  1256→            'emp-1' // TODO: Get from auth context
  1257→          );
  1258→
  1259→          if (success) {
  1260→            console.log('[Snap] Table added to existing group');
  1261→
  1262→            // Store the snap position for this table in the existing group
  1263→            setStoredSnapPositions(prev => {
  1264→              const updated = new Map(prev);
  1265→              // We need to update the stored snap for this group to include the new table
  1266→              const existingSnap = updated.get(targetTable.virtualGroupId!);
  1267→              // For additional tables, store under the group ID with tableId as key
  1268→              updated.set(`${targetTable.virtualGroupId}-${dragState.draggedTableId}`, {
  1269→                draggedTableId: dragState.draggedTableId!,
  1270→                snapPosition: snapPreview.snapPosition,
  1271→              });
  1272→              return updated;
  1273→            });
  1274→
  1275→            // Refresh floor plan data to show the updated group
  1276→            if (locationId) {
  1277→              await fetchDbTables(locationId);
  1278→            }
  1279→          }
  1280→        } else if (draggedTable?.virtualGroupId) {
  1281→          // Dragged table is already in a group - ADD the target to that group
  1282→          console.log('[Snap] Adding target table to dragged table\'s group:', {
  1283→            targetTableId: snapPreview.targetTableId,
  1284→            draggedGroupId: draggedTable.virtualGroupId,
  1285→          });
  1286→
  1287→          const success = await addToGroup(
  1288→            draggedTable.virtualGroupId,
  1289→            snapPreview.targetTableId,
  1290→            'emp-1' // TODO: Get from auth context
  1291→          );
  1292→
  1293→          if (success) {
  1294→            console.log('[Snap] Target table added to existing group');
  1295→
  1296→            // Store the snap position
  1297→            setStoredSnapPositions(prev => {
  1298→              const updated = new Map(prev);
  1299→              updated.set(`${draggedTable.virtualGroupId}-${snapPreview.targetTableId}`, {
  1300→                draggedTableId: snapPreview.targetTableId,
  1301→                snapPosition: { x: targetTable?.posX || 0, y: targetTable?.posY || 0 },
  1302→              });
  1303→              return updated;
  1304→            });
  1305→
  1306→            // Refresh floor plan data to show the updated group
  1307→            if (locationId) {
  1308→              await fetchDbTables(locationId);
  1309→            }
  1310→          }
  1311→        } else {
  1312→          // Neither table is in a group - CREATE a new virtual group
  1313→          console.log('[Snap] Creating new virtual group:', {
  1314→            draggedTableId: dragState.draggedTableId,
  1315→            targetTableId: snapPreview.targetTableId,
  1316→          });
  1317→
  1318→          // Create the virtual group with TARGET table as PRIMARY (first in array)
  1319→          // This means the dragged table will snap TO the target table's position
  1320→          const result = await createVirtualGroup(
  1321→            [snapPreview.targetTableId, dragState.draggedTableId],  // Target first = primary
  1322→            'emp-1' // TODO: Get from auth context
  1323→          );
  1324→
  1325→          if (result) {
  1326→            console.log('[Snap] Virtual group created:', result.id);
  1327→
  1328→            // Store the snap position so we can use it for visual positioning
  1329→            // This ensures the dragged table lands EXACTLY where the preview showed
  1330→            setStoredSnapPositions(prev => {
  1331→              const updated = new Map(prev);
  1332→              updated.set(result.id, {
  1333→                draggedTableId: dragState.draggedTableId!,
  1334→                snapPosition: snapPreview.snapPosition,
  1335→              });
  1336→              return updated;
  1337→            });
  1338→
  1339→            // Refresh floor plan data to show the group
  1340→            if (locationId) {
  1341→              await fetchDbTables(locationId);
  1342→            }
  1343→          }
  1344→        }
  1345→      } catch (error) {
  1346→        console.error('Failed to combine tables:', error);
  1347→      }
  1348→    } else if (dragState.isDragging) {
  1349→      // No valid snap - table returns to original position (just reset state, no API calls)
  1350→      console.log('[Snap] No valid snap, canceling drag');
  1351→    }
  1352→
  1353→    // Reset drag state - table visual returns to original position
  1354→    setDragState(resetDragState());
  1355→    setDropTarget(null);
  1356→    setSnapPreview(null);
  1357→  }, [dragState, snapPreview, dbTables, createVirtualGroup, addToGroup, locationId, fetchDbTables]);
  1358→
  1359→  // Cancel drag if pointer leaves the canvas
  1360→  const handlePointerLeave = useCallback(() => {
  1361→    if (longHoldTimerRef.current) {
  1362→      clearTimeout(longHoldTimerRef.current);
  1363→      longHoldTimerRef.current = null;
  1364→    }
  1365→    setHoldingTableId(null);
  1366→    setDragState(resetDragState());
  1367→    setDropTarget(null);
  1368→    setSnapPreview(null);
  1369→  }, []);
  1370→
  1371→  const handleTableTap = useCallback((tableId: string) => {
  1372→    if (isCombineMode) {
  1373→      // Toggle selection
  1374→      setSelectedForCombine(prev =>
  1375→        prev.includes(tableId)
  1376→          ? prev.filter(id => id !== tableId)
  1377→          : [...prev, tableId]
  1378→      );
  1379→    } else {
  1380→      // Normal tap - show info (for now just log)
  1381→      console.log(`Table ${tableId} tapped`);
  1382→    }
  1383→  }, [isCombineMode]);
  1384→
  1385→  const handleConfirmCombine = useCallback(async () => {
  1386→    if (selectedForCombine.length < 2) return;
  1387→
  1388→    const result = await createVirtualGroup(
  1389→      selectedForCombine,
  1390→      'employee-default', // TODO: Get from auth context
  1391→    );
  1392→
  1393→    if (result) {
  1394→      // Refresh tables to show virtual group
  1395→      if (locationId && selectedRoomId) {
  1396→        await fetchDbTables(locationId, selectedRoomId);
  1397→      }
  1398→      setIsCombineMode(false);
  1399→      setSelectedForCombine([]);
  1400→    }
  1401→  }, [selectedForCombine, createVirtualGroup, locationId, selectedRoomId, fetchDbTables]);
  1402→
  1403→  const handleCancelCombine = useCallback(() => {
  1404→    setIsCombineMode(false);
  1405→    setSelectedForCombine([]);
  1406→  }, []);
  1407→
  1408→  const handlePositionClick = (position: Point) => {
  1409→    setClickedPosition(position);
  1410→    setSelectedTable(null);
  1411→    setSelectedSeat(null);
  1412→  };
  1413→
  1414→  const handleTableClick = (table: Table) => {
  1415→    setSelectedTable(table);
  1416→    setClickedPosition(null);
  1417→    setSelectedSeat(null);
  1418→  };
  1419→
  1420→  const handleSeatClick = (seatId: string) => {
  1421→    const seat = SeatAPI.getSeat(seatId);
  1422→    if (seat) {
  1423→      setSelectedSeat(seat);
  1424→      setSelectedTable(null);
  1425→      setClickedPosition(null);
  1426→    }
  1427→  };
  1428→
  1429→  const handleFixtureClick = (fixture: PixelFixture | Fixture) => {
  1430→    alert(`Fixture clicked: ${fixture.label} (${fixture.type})`);
  1431→  };
  1432→
  1433→  // Combine in-memory fixtures with database fixtures for display
  1434→  const allFixtures = isDbMode ? dbFixtures : FloorCanvasAPI.getFixtures(selectedRoomId);
  1435→
  1436→  return (
  1437→    <div style={{ padding: 24, fontFamily: 'system-ui, sans-serif' }}>
  1438→      <h1 style={{ marginBottom: 8 }}>Floor Plan Test Page (FOH View)</h1>
  1439→      <p style={{ color: '#666', marginBottom: 24 }}>
  1440→        {isDbMode ? (
  1441→          <>Real-time sync enabled. Fixtures from database: <strong>{dbFixtures.length}</strong>
  1442→            {lastUpdate && <span style={{ marginLeft: 8, fontSize: 12 }}>(Updated: {lastUpdate.toLocaleTimeString()})</span>}
  1443→          </>
  1444→        ) : (
  1445→          'Using sample data. Create fixtures in Editor to enable database sync.'
  1446→        )}
  1447→      </p>
  1448→
  1449→      {/* Room/Section Selector */}
  1450→      {isDbMode && dbSections.length > 0 ? (
  1451→        <div style={{ display: 'flex', gap: 8, marginBottom: 16, alignItems: 'center' }}>
  1452→          {dbSections.map((section) => (
  1453→            <button
  1454→              key={section.id}
  1455→              onClick={() => setSelectedRoomId(section.id)}
  1456→              style={{
  1457→                padding: '8px 16px',
  1458→                borderRadius: 8,
  1459→                border: selectedRoomId === section.id ? '2px solid #3498db' : '1px solid #ccc',
  1460→                backgroundColor: selectedRoomId === section.id ? '#e3f2fd' : 'white',
  1461→                cursor: 'pointer',
  1462→                fontWeight: selectedRoomId === section.id ? 600 : 400,
  1463→                fontSize: 14,
  1464→              }}
  1465→            >
  1466→              {section.name}
  1467→            </button>
  1468→          ))}
  1469→
  1470→          {/* Show/Hide Seats Toggle */}
  1471→          <button
  1472→            onClick={() => setShowDbSeats(!showDbSeats)}
  1473→            style={{
  1474→              padding: '8px 16px',
  1475→              borderRadius: 8,
  1476→              border: '1px solid #ccc',
  1477→              backgroundColor: showDbSeats ? '#e3f2fd' : 'white',
  1478→              cursor: 'pointer',
  1479→              fontSize: 14,
  1480→              fontWeight: showDbSeats ? 600 : 400,
  1481→              marginLeft: 'auto',
  1482→            }}
  1483→          >
  1484→            {showDbSeats ? 'Hide Seats' : 'Show Seats'}
  1485→          </button>
  1486→
  1487→          {/* Reset All Groups Button (for testing) */}
  1488→          <button
  1489→            onClick={handleResetAllGroups}
  1490→            disabled={virtualGroupData.groups.size === 0}
  1491→            style={{
  1492→              padding: '8px 16px',
  1493→              borderRadius: 8,
  1494→              border: '1px solid #ef4444',
  1495→              backgroundColor: virtualGroupData.groups.size > 0 ? '#fef2f2' : '#f5f5f5',
  1496→              color: virtualGroupData.groups.size > 0 ? '#dc2626' : '#9ca3af',
  1497→              cursor: virtualGroupData.groups.size > 0 ? 'pointer' : 'not-allowed',
  1498→              fontSize: 14,
  1499→              fontWeight: 500,
  1500→            }}
  1501→          >
  1502→            Reset Groups ({virtualGroupData.groups.size})
  1503→          </button>
  1504→        </div>
  1505→      ) : (
  1506→        <RoomSelector
  1507→          selectedRoomId={selectedRoomId}
  1508→          onRoomSelect={setSelectedRoomId}
  1509→        />
  1510→      )}
  1511→
  1512→      {/* Main Canvas */}
  1513→      <div style={{ display: 'flex', gap: 24 }}>
  1514→        <div
  1515→          ref={canvasContainerRef}
  1516→          onPointerMove={handlePointerMove}
  1517→          onPointerUp={handleTablePointerUp}
  1518→          onPointerLeave={handlePointerLeave}
  1519→          style={{
  1520→            position: 'relative',
  1521→            // Prevent text selection during drag
  1522→            userSelect: dragState.isDragging ? 'none' : 'auto',
  1523→            WebkitUserSelect: dragState.isDragging ? 'none' : 'auto',
  1524→          }}
  1525→        >
  1526→          <FloorCanvas
  1527→            roomId={selectedRoomId}
  1528→            showGrid={!isDbMode} // Disable grid in DB mode (we render our own canvas)
  1529→            showFixtures={!isDbMode}
  1530→            // Use FIXED canvas dimensions to match Editor (stable coordinates)
  1531→            width={CANVAS_WIDTH}
  1532→            height={CANVAS_HEIGHT}
  1533→            onPositionClick={handlePositionClick}
  1534→            onFixtureClick={handleFixtureClick}
  1535→          >
  1536→            {/* Render database fixtures when in DB mode - filter by selected section */}
  1537→            {isDbMode && dbFixtures
  1538→              .filter((fixture) => {
  1539→                // In DB mode, filter by sectionId (stored as roomId in PixelFixture)
  1540→                return fixture.roomId === selectedRoomId;
  1541→              })
  1542→              .map((fixture) => (
  1543→                <DbFixtureRenderer
  1544→                  key={fixture.id}
  1545→                  fixture={fixture}
  1546→                  onClick={() => handleFixtureClick(fixture)}
  1547→                />
  1548→              ))}
  1549→
  1550→            {/* Render database tables when in DB mode - filter by selected section */}
  1551→            {/* Tables without a section will show in first section as fallback */}
  1552→            {isDbMode && dbTables
  1553→              .filter((table) => {
  1554→                // Show tables that match the selected section
  1555→                if (table.section?.id === selectedRoomId) return true;
  1556→                // Also show tables with no section in the first section
  1557→                if (!table.section && dbSections.length > 0 && dbSections[0].id === selectedRoomId) return true;
  1558→                return false;
  1559→              })
  1560→              .map((table) => {
  1561→                const isSelectedForCombine = selectedForCombine.includes(table.id);
  1562→                const isHolding = holdingTableId === table.id;
  1563→                const isDragged = dragState.isDragging && dragState.draggedTableId === table.id;
  1564→                const isDropTarget = dropTarget?.tableId === table.id;
  1565→
  1566→                // Calculate table center
  1567→                const tableCenterX = table.posX + table.width / 2;
  1568→                const tableCenterY = table.posY + table.height / 2;
  1569→
  1570→                // Get group colors, perimeter data, and visual offset if in a virtual group
  1571→                let tableColor: string | undefined;
  1572→                let seatColor: string | undefined;
  1573→                let groupGlow: string | undefined;
  1574→                let perimeterLookup: Map<string, number> | undefined;
  1575→                let enhancedLookup: Map<string, { perimeterNumber: number; isVisible: boolean }> | undefined;
  1576→                let visualOffset: { offsetX: number; offsetY: number } | undefined;
  1577→
  1578→                if (table.virtualGroupId) {
  1579→                  const groupData = virtualGroupData.groups.get(table.virtualGroupId);
  1580→                  if (groupData) {
  1581→                    const colors = groupData.colorLookup.get(table.id);
  1582→                    tableColor = colors?.tableColor;
  1583→                    seatColor = colors?.seatColor;
  1584→                    perimeterLookup = groupData.perimeterLookup;
  1585→                    enhancedLookup = groupData.enhancedLookup;
  1586→
  1587→                    // Get group glow
  1588→                    const family = getColorFamilyForGroup(groupData.groupIndex);
  1589→                    groupGlow = getGroupGlowStyle(family);
  1590→                  }
  1591→
  1592→                  // Get visual offset for snapped position
  1593→                  visualOffset = visualOffsets.get(table.id);
  1594→                }
  1595→
  1596→                return (
  1597→                  <React.Fragment key={table.id}>
  1598→                    <DbTableRenderer
  1599→                      table={table}
  1600→                      showSeats={showDbSeats}
  1601→                      onClick={() => handleTableTap(table.id)}
  1602→                      onPointerDown={(e) => handleTablePointerDown(table.id, tableCenterX, tableCenterY, e)}
  1603→                      onPointerUp={handleTablePointerUp}
  1604→                      isSelectedForCombine={isSelectedForCombine}
  1605→                      isHolding={isHolding}
  1606→                      tableColor={tableColor}
  1607→                      seatColor={seatColor}
  1608→                      groupGlow={groupGlow}
  1609→                      perimeterLookup={perimeterLookup}
  1610→                      enhancedLookup={enhancedLookup}
  1611→                      visualOffset={visualOffset}
  1612→                      isInGroup={!!table.virtualGroupId}
  1613→                    />
  1614→
  1615→                    {/* Drop target highlight - use visual position if available */}
  1616→                    {isDropTarget && (
  1617→                      <div
  1618→                        style={{
  1619→                          position: 'absolute',
  1620→                          left: (table.posX + (visualOffset?.offsetX || 0)) - 4,
  1621→                          top: (table.posY + (visualOffset?.offsetY || 0)) - 4,
  1622→                          width: table.width + 8,
  1623→                          height: table.height + 8,
  1624→                          border: '3px solid #22c55e',
  1625→                          borderRadius: table.shape === 'circle' ? '50%' : 12,
  1626→                          backgroundColor: 'rgba(34, 197, 94, 0.2)',
  1627→                          pointerEvents: 'none',
  1628→                          animation: 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
  1629→                        }}
  1630→                      />
  1631→                    )}
  1632→                  </React.Fragment>
  1633→                );
  1634→              })}
  1635→
  1636→            {/* Dragged table ghost - now using canvas coordinates (position: absolute) */}
  1637→            {dragState.isDragging && dragState.draggedTableId && (() => {
  1638→              const draggedTable = dbTables.find(t => t.id === dragState.draggedTableId);
  1639→              if (!draggedTable) return null;
  1640→
  1641→              const dragPos = getDraggedTablePosition(dragState);
  1642→
  1643→              return (
  1644→                <div
  1645→                  style={{
  1646→                    position: 'absolute',
  1647→                    left: dragPos.x - draggedTable.width / 2,
  1648→                    top: dragPos.y - draggedTable.height / 2,
  1649→                    width: draggedTable.width,
  1650→                    height: draggedTable.height,
  1651→                    backgroundColor: 'rgba(6, 182, 212, 0.4)',
  1652→                    border: '3px dashed #06b6d4',
  1653→                    borderRadius: draggedTable.shape === 'circle' ? '50%' : 8,
  1654→                    pointerEvents: 'none',
  1655→                    zIndex: 1000,
  1656→                    display: 'flex',
  1657→                    alignItems: 'center',
  1658→                    justifyContent: 'center',
  1659→                    fontSize: 14,
  1660→                    fontWeight: 600,
  1661→                    color: '#06b6d4',
  1662→                  }}
  1663→                >
  1664→                  {draggedTable.abbreviation || draggedTable.name}
  1665→                </div>
  1666→              );
  1667→            })()}
  1668→
  1669→            {/* Snap preview ghost */}
  1670→            {snapPreview && snapPreview.isValid && dragState.isDragging && dragState.draggedTableId && (() => {
  1671→              const draggedTable = dbTables.find(t => t.id === dragState.draggedTableId);
  1672→              if (!draggedTable) return null;
  1673→
  1674→              return (
  1675→                <div
  1676→                  style={{
  1677→                    position: 'absolute',
  1678→                    left: snapPreview.snapPosition.x,
  1679→                    top: snapPreview.snapPosition.y,
  1680→                    width: draggedTable.width,
  1681→                    height: draggedTable.height,
  1682→                    backgroundColor: 'rgba(34, 197, 94, 0.3)',
  1683→                    border: '2px dashed #22c55e',
  1684→                    borderRadius: draggedTable.shape === 'circle' ? '50%' : 8,
  1685→                    pointerEvents: 'none',
  1686→                    zIndex: 999,
  1687→                    transition: 'all 0.15s ease-out',
  1688→                  }}
  1689→                />
  1690→              );
  1691→            })()}
  1692→
  1693→            {/* Virtual seats for combined groups - rendered around bounding box perimeter */}
  1694→            {isDbMode && showDbSeats && Array.from(virtualGroupData.groups.entries()).map(([groupId, groupData]) => {
  1695→              // Get tables in this group for this section
  1696→              const groupTables = dbTables.filter(
  1697→                t => t.virtualGroupId === groupId &&
  1698→                (t.section?.id === selectedRoomId || (!t.section && dbSections[0]?.id === selectedRoomId))
  1699→              );
  1700→              if (groupTables.length === 0) return null;
  1701→
  1702→              const family = getColorFamilyForGroup(groupData.groupIndex);
  1703→              const SEAT_SIZE = 24;
  1704→              const SEAT_HALF = SEAT_SIZE / 2;
  1705→
  1706→              return (
  1707→                <React.Fragment key={`group-seats-${groupId}`}>
  1708→                  {groupData.virtualSeats.map((seat) => (
  1709→                    <div
  1710→                      key={seat.id}
  1711→                      onClick={(e) => {
  1712→                        e.stopPropagation();
  1713→                        console.log(`Virtual seat ${seat.perimeterNumber} tapped (original: table ${seat.originalTableId}, seat ${seat.originalSeatNumber})`);
  1714→                      }}
  1715→                      style={{
  1716→                        position: 'absolute',
  1717→                        left: seat.absoluteX - SEAT_HALF,
  1718→                        top: seat.absoluteY - SEAT_HALF,
  1719→                        width: SEAT_SIZE,
  1720→                        height: SEAT_SIZE,
  1721→                        backgroundColor: family.seatShades[3], // Light shade from family
  1722→                        border: `2px solid ${family.base}`,
  1723→                        borderRadius: '50%',
  1724→                        display: 'flex',
  1725→                        alignItems: 'center',
  1726→                        justifyContent: 'center',
  1727→                        fontSize: 10,
  1728→                        fontWeight: 600,
  1729→                        color: '#333',
  1730→                        cursor: 'pointer',
  1731→                        pointerEvents: 'auto',
  1732→                        boxShadow: '0 1px 3px rgba(0,0,0,0.2)',
  1733→                        transition: 'all 0.2s ease',
  1734→                        zIndex: 50,
  1735→                      }}
  1736→                      onMouseEnter={(e) => {
  1737→                        e.currentTarget.style.transform = 'scale(1.15)';
  1738→                        e.currentTarget.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
  1739→                        e.currentTarget.style.zIndex = '100';
  1740→                      }}
  1741→                      onMouseLeave={(e) => {
  1742→                        e.currentTarget.style.transform = 'scale(1)';
  1743→                        e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
  1744→                        e.currentTarget.style.zIndex = '50';
  1745→                      }}
  1746→                      title={`Seat ${seat.perimeterNumber}`}
  1747→                    >
  1748→                      {seat.perimeterNumber}
  1749→                    </div>
  1750→                  ))}
  1751→                </React.Fragment>
  1752→              );
  1753→            })}
  1754→
  1755→            {/* Group display name badges - positioned using visual (snapped) positions */}
  1756→            {/* Dynamically positions at top or bottom based on available space */}
  1757→            {isDbMode && Array.from(virtualGroupData.groups.entries()).map(([groupId, groupData]) => {
  1758→              // Get tables in this group for this section
  1759→              const groupTables = dbTables.filter(
  1760→                t => t.virtualGroupId === groupId &&
  1761→                (t.section?.id === selectedRoomId || (!t.section && dbSections[0]?.id === selectedRoomId))
  1762→              );
  1763→              if (groupTables.length === 0) return null;
  1764→
  1765→              // Calculate bounding box using VISUAL positions (with snap offsets)
  1766→              let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  1767→              groupTables.forEach(t => {
  1768→                const offset = visualOffsets.get(t.id) || { offsetX: 0, offsetY: 0 };
  1769→                const visualX = t.posX + offset.offsetX;
  1770→                const visualY = t.posY + offset.offsetY;
  1771→                minX = Math.min(minX, visualX);
  1772→                minY = Math.min(minY, visualY);
  1773→                maxX = Math.max(maxX, visualX + t.width);
  1774→                maxY = Math.max(maxY, visualY + t.height);
  1775→              });
  1776→
  1777→              const centerX = (minX + maxX) / 2;
  1778→              const family = getColorFamilyForGroup(groupData.groupIndex);
  1779→
  1780→              // Account for seat extension (base 22px + potential stagger rings up to 40px + seat radius 12px)
  1781→              const SEAT_EXTENSION_TOP = 60; // Larger for potential stagger
  1782→              const SEAT_EXTENSION_BOTTOM = 60;
  1783→              const BADGE_HEIGHT = 24; // Approximate badge height
  1784→              const BADGE_MARGIN = 8;
  1785→
  1786→              // Dynamically choose top or bottom based on available space
  1787→              // Prefer top, but use bottom if badge would go off-screen (minY - extension < threshold)
  1788→              const MIN_TOP_SPACE = 80; // Minimum pixels from canvas top edge
  1789→              const topPosition = minY - SEAT_EXTENSION_TOP - BADGE_MARGIN;
  1790→              const bottomPosition = maxY + SEAT_EXTENSION_BOTTOM + BADGE_MARGIN;
  1791→
  1792→              // Use bottom if top would be too close to edge (or negative)
  1793→              const useBottom = topPosition < MIN_TOP_SPACE;
  1794→
  1795→              return (
  1796→                <div
  1797→                  key={`group-badge-${groupId}`}
  1798→                  style={{
  1799→                    position: 'absolute',
  1800→                    left: centerX,
  1801→                    top: useBottom ? bottomPosition : topPosition,
  1802→                    transform: 'translateX(-50%)',
  1803→                    backgroundColor: getColorWithOpacity(family.base, 0.9),
  1804→                    color: 'white',
  1805→                    padding: '4px 12px',
  1806→                    borderRadius: 12,
  1807→                    fontSize: 12,
  1808→                    fontWeight: 600,
  1809→                    whiteSpace: 'nowrap',
  1810→                    boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
  1811→                    zIndex: 100,
  1812→                    pointerEvents: 'none',
  1813→                  }}
  1814→                >
  1815→                  {groupData.displayName}
  1816→                </div>
  1817→              );
  1818→            })}
  1819→
  1820→            {/* Render tables using Layer 2 components (SVG) */}
  1821→            <svg
  1822→              style={{
  1823→                position: 'absolute',
  1824→                top: 0,
  1825→                left: 0,
  1826→                width: '100%',
  1827→                height: '100%',
  1828→                pointerEvents: 'none',
  1829→              }}
  1830→            >
  1831→              <g style={{ pointerEvents: 'auto' }}>
  1832→                {tablesInRoom.map((table) =>
  1833→                  table.category === 'seatable' ? (
  1834→                    <TableComponent
  1835→                      key={table.id}
  1836→                      table={table}
  1837→                      pixelsPerFoot={PIXELS_PER_FOOT}
  1838→                      isSelected={selectedTable?.id === table.id}
  1839→                      onSelect={(id) => {
  1840→                        const t = TableAPI.getTable(id);
  1841→                        if (t) setSelectedTable(t);
  1842→                      }}
  1843→                    />
  1844→                  ) : (
  1845→                    <SmartObject
  1846→                      key={table.id}
  1847→                      object={table}
  1848→                      pixelsPerFoot={PIXELS_PER_FOOT}
  1849→                      isSelected={selectedTable?.id === table.id}
  1850→                      onSelect={(id) => {
  1851→                        const t = TableAPI.getTable(id);
  1852→                        if (t) setSelectedTable(t);
  1853→                      }}
  1854→                    />
  1855→                  )
  1856→                )}
  1857→
  1858→                {/* Render seats around tables */}
  1859→                {seatsInRoom.map((seat) => {
  1860→                  const table = TableAPI.getTable(seat.tableId);
  1861→                  if (!table) return null;
  1862→
  1863→                  return (
  1864→                    <Seat
  1865→                      key={seat.id}
  1866→                      seat={seat}
  1867→                      tableX={table.positionX}
  1868→                      tableY={table.positionY}
  1869→                      pixelsPerFoot={PIXELS_PER_FOOT}
  1870→                      isSelected={selectedSeat?.id === seat.id}
  1871→                      onSelect={handleSeatClick}
  1872→                    />
  1873→                  );
  1874→                })}
  1875→              </g>
  1876→            </svg>
  1877→          </FloorCanvas>
  1878→        </div>
  1879→
  1880→        {/* Info Panel */}
  1881→        <div style={{ width: 300 }}>
  1882→          <div
  1883→            style={{
  1884→              padding: 16,
  1885→              backgroundColor: '#f5f5f5',
  1886→              borderRadius: 8,
  1887→              marginBottom: 16,
  1888→            }}
  1889→          >
  1890→            <h3 style={{ margin: '0 0 12px 0' }}>Click Info</h3>
  1891→            {clickedPosition ? (
  1892→              <div>
  1893→                <p><strong>Position:</strong> ({clickedPosition.x.toFixed(1)}ft, {clickedPosition.y.toFixed(1)}ft)</p>
  1894→                <p><strong>Blocked:</strong> {FloorCanvasAPI.isPositionBlocked(selectedRoomId, clickedPosition, 3, 3) ? 'Yes' : 'No'}</p>
  1895→              </div>
  1896→            ) : selectedSeat ? (
  1897→              <div>
  1898→                <p><strong>Seat:</strong> #{selectedSeat.seatNumber}</p>
  1899→                <p><strong>Table:</strong> {(() => {
  1900→                  const table = TableAPI.getTable(selectedSeat.tableId);
  1901→                  return table ? table.label : 'Unknown';
  1902→                })()}</p>
  1903→                <p><strong>Position Index:</strong> {selectedSeat.positionIndex}</p>
  1904→                <p><strong>Offset:</strong> ({selectedSeat.offsetX.toFixed(2)}ft, {selectedSeat.offsetY.toFixed(2)}ft)</p>
  1905→                <p><strong>Occupied:</strong> {selectedSeat.isOccupied ? 'Yes' : 'No'}</p>
  1906→                <p><strong>Virtual:</strong> {selectedSeat.isVirtual ? 'Yes' : 'No'}</p>
  1907→              </div>
  1908→            ) : selectedTable ? (
  1909→              <div>
  1910→                <p><strong>Table:</strong> {selectedTable.label}</p>
  1911→                <p><strong>Type:</strong> {selectedTable.objectType}</p>
  1912→                <p><strong>Shape:</strong> {selectedTable.shape}</p>
  1913→                <p><strong>Capacity:</strong> {selectedTable.minCapacity}-{selectedTable.maxCapacity}</p>
  1914→                <p><strong>Position:</strong> ({selectedTable.positionX}ft, {selectedTable.positionY}ft)</p>
  1915→                <p><strong>Seats:</strong> {SeatAPI.getSeatsForTable(selectedTable.id).length}</p>
  1916→              </div>
  1917→            ) : (
  1918→              <p style={{ color: '#999' }}>Click on canvas, table, or seat</p>
  1919→            )}
  1920→          </div>
  1921→
  1922→          <div
  1923→            style={{
  1924→              padding: 16,
  1925→              backgroundColor: '#f5f5f5',
  1926→              borderRadius: 8,
  1927→              marginBottom: 16,
  1928→            }}
  1929→          >
  1930→            <h3 style={{ margin: '0 0 12px 0' }}>Room Info</h3>
  1931→            {(() => {
  1932→              const room = FloorCanvasAPI.getFloorPlan(selectedRoomId);
  1933→              if (!room) return <p>No room selected</p>;
  1934→              return (
  1935→                <div>
  1936→                  <p><strong>Name:</strong> {room.name}</p>
  1937→                  <p><strong>Type:</strong> {room.type}</p>
  1938→                  <p><strong>Size:</strong> {room.widthFeet}ft x {room.heightFeet}ft</p>
  1939→                  <p><strong>Grid:</strong> {room.gridSizeFeet}ft</p>
  1940→                  <p><strong>Tables:</strong> {tablesInRoom.length}</p>
  1941→                  <p><strong>Fixtures:</strong> {isDbMode ? dbFixtures.length : FloorCanvasAPI.getFixtures(selectedRoomId).length}</p>
  1942→                  {isDbMode && <p style={{ color: '#4caf50', fontSize: 12 }}>Database Mode Active</p>}
  1943→                </div>
  1944→              );
  1945→            })()}
  1946→          </div>
  1947→
  1948→          <div
  1949→            style={{
  1950→              padding: 16,
  1951→              backgroundColor: isDbMode ? '#e8f5e9' : '#e3f2fd',
  1952→              borderRadius: 8,
  1953→            }}
  1954→          >
  1955→            <h3 style={{ margin: '0 0 12px 0' }}>Sync Status</h3>
  1956→            {isDbMode ? (
  1957→              <>
  1958→                <p style={{ color: '#2e7d32' }}>Database Connected</p>
  1959→                <p style={{ fontSize: 12 }}>Fixtures: {dbFixtures.length}</p>
  1960→                <p style={{ fontSize: 12 }}>Polling: every 5s</p>
  1961→                {lastUpdate && (
  1962→                  <p style={{ fontSize: 11, color: '#666' }}>
  1963→                    Last: {lastUpdate.toLocaleTimeString()}
  1964→                  </p>
  1965→                )}
  1966→              </>
  1967→            ) : (
  1968→              <>
  1969→                <p style={{ color: '#1976d2' }}>In-Memory Mode</p>
  1970→                <p style={{ fontSize: 12 }}>Using sample data</p>
  1971→                <p style={{ fontSize: 12 }}>Create fixtures in Editor to enable sync</p>
  1972→              </>
  1973→            )}
  1974→          </div>
  1975→
  1976→          <div
  1977→            style={{
  1978→              padding: 16,
  1979→              backgroundColor: '#fff3e0',
  1980→              borderRadius: 8,
  1981→              marginTop: 16,
  1982→            }}
  1983→          >
  1984→            <h3 style={{ margin: '0 0 12px 0' }}>Test Pages</h3>
  1985→            <p><a href="/test-floorplan" style={{ color: '#e65100' }}>✓ Frontend Test (Current)</a></p>
  1986→            <p><a href="/test-floorplan/api" style={{ color: '#e65100' }}>Backend API Test</a></p>
  1987→            <p>
  1988→              <a
  1989→                href="/test-floorplan/editor"
  1990→                style={{
  1991→                  color: '#e65100',
  1992→                  fontWeight: 'bold',
  1993→                  textDecoration: 'none',
  1994→                  display: 'inline-block',
  1995→                  padding: '4px 8px',
  1996→                  backgroundColor: '#ffebee',
  1997→                  borderRadius: 4,
  1998→                }}
  1999→              >
  2000→                ✏️ Edit Floor Plan →
  2001→              </a>
  2002→            </p>
  2003→            <p style={{ fontSize: 12, color: '#666', marginTop: 8 }}>
  2004→              {isDbMode
  2005→                ? 'Changes made in Editor will appear here automatically (5s polling)'
  2006→                : 'Create fixtures in Editor to enable real-time sync'}
  2007→            </p>
  2008→          </div>
  2009→        </div>
  2010→      </div>
  2011→
  2012→      {/* Combine Bar - Fixed at bottom when in combine mode */}
  2013→      {isCombineMode && (
  2014→        <div style={{
  2015→          position: 'fixed',
  2016→          bottom: 24,
  2017→          left: '50%',
  2018→          transform: 'translateX(-50%)',
  2019→          backgroundColor: 'rgba(15, 23, 42, 0.95)',
  2020→          padding: '12px 24px',
  2021→          borderRadius: 12,
  2022→          display: 'flex',
  2023→          alignItems: 'center',
  2024→          gap: 16,
  2025→          boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
  2026→          border: '1px solid rgba(255,255,255,0.1)',
  2027→          zIndex: 1000,
  2028→        }}>
  2029→          {/* Status Indicator */}
  2030→          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
  2031→            <div
  2032→              style={{
  2033→                width: 8,
  2034→                height: 8,
  2035→                borderRadius: '50%',
  2036→                backgroundColor: '#06b6d4',
  2037→                animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
  2038→              }}
  2039→            />
  2040→            <span style={{ color: 'white', fontWeight: 500, fontSize: 14 }}>
  2041→              {selectedForCombine.length} table{selectedForCombine.length !== 1 ? 's' : ''} selected
  2042→            </span>
  2043→          </div>
  2044→
  2045→          {/* Hint Text */}
  2046→          <span style={{ color: 'rgba(255, 255, 255, 0.6)', fontSize: 13, fontStyle: 'italic' }}>
  2047→            Tap tables to add/remove
  2048→          </span>
  2049→
  2050→          {/* Action Buttons */}
  2051→          <div style={{ display: 'flex', gap: 8, marginLeft: 8 }}>
  2052→            <button
  2053→              onClick={handleCancelCombine}
  2054→              disabled={isCreatingGroup}
  2055→              style={{
  2056→                padding: '8px 16px',
  2057→                borderRadius: 8,
  2058→                border: '1px solid rgba(255, 255, 255, 0.2)',
  2059→                backgroundColor: 'rgba(239, 68, 68, 0.2)',
  2060→                color: 'white',
  2061→                cursor: isCreatingGroup ? 'not-allowed' : 'pointer',
  2062→                fontWeight: 500,
  2063→                fontSize: 14,
  2064→                opacity: isCreatingGroup ? 0.5 : 1,
  2065→                transition: 'all 0.2s',
  2066→              }}
  2067→              onMouseEnter={(e) => {
  2068→                if (!isCreatingGroup) {
  2069→                  e.currentTarget.style.backgroundColor = 'rgba(239, 68, 68, 0.3)';
  2070→                }
  2071→              }}
  2072→              onMouseLeave={(e) => {
  2073→                e.currentTarget.style.backgroundColor = 'rgba(239, 68, 68, 0.2)';
  2074→              }}
  2075→            >
  2076→              Cancel
  2077→            </button>
  2078→            <button
  2079→              onClick={handleConfirmCombine}
  2080→              disabled={selectedForCombine.length < 2 || isCreatingGroup}
  2081→              style={{
  2082→                padding: '8px 20px',
  2083→                borderRadius: 8,
  2084→                border: 'none',
  2085→                backgroundColor: selectedForCombine.length >= 2
  2086→                  ? (isCreatingGroup ? 'rgba(6, 182, 212, 0.5)' : '#06b6d4')
  2087→                  : 'rgba(100, 116, 139, 0.5)',
  2088→                color: 'white',
  2089→                cursor: (selectedForCombine.length >= 2 && !isCreatingGroup) ? 'pointer' : 'not-allowed',
  2090→                fontWeight: 600,
  2091→                fontSize: 14,
  2092→                transition: 'all 0.2s',
  2093→              }}
  2094→              onMouseEnter={(e) => {
  2095→                if (selectedForCombine.length >= 2 && !isCreatingGroup) {
  2096→                  e.currentTarget.style.backgroundColor = '#0891b2';
  2097→                }
  2098→              }}
  2099→              onMouseLeave={(e) => {
  2100→                if (selectedForCombine.length >= 2 && !isCreatingGroup) {
  2101→                  e.currentTarget.style.backgroundColor = '#06b6d4';
  2102→                }
  2103→              }}
  2104→            >
  2105→              {isCreatingGroup ? 'Creating...' : 'Create Group'}
  2106→            </button>
  2107→          </div>
  2108→        </div>
  2109→      )}
  2110→
  2111→      {/* Pulse Animation Styles */}
  2112→      <style jsx>{`
  2113→        @keyframes pulse {
  2114→          0%, 100% {
  2115→            opacity: 1;
  2116→            transform: scale(1);
  2117→          }
  2118→          50% {
  2119→            opacity: 0.5;
  2120→            transform: scale(1.05);
  2121→          }
  2122→        }
  2123→      `}</style>
  2124→
  2125→      {/* Tables List */}
  2126→      <div style={{ marginTop: 24 }}>
  2127→        <h3>Tables in {FloorCanvasAPI.getFloorPlan(selectedRoomId)?.name || 'Room'}</h3>
  2128→        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
  2129→          {tablesInRoom.map((table) => (
  2130→            <div
  2131→              key={table.id}
  2132→              onClick={() => handleTableClick(table)}
  2133→              style={{
  2134→                padding: '8px 16px',
  2135→                backgroundColor: selectedTable?.id === table.id ? '#3498db' : '#f5f5f5',
  2136→                color: selectedTable?.id === table.id ? 'white' : 'black',
  2137→                borderRadius: 8,
  2138→                cursor: 'pointer',
  2139→              }}
  2140→            >
  2141→              {table.label} ({table.objectType})
  2142→            </div>
  2143→          ))}
  2144→          {tablesInRoom.length === 0 && (
  2145→            <p style={{ color: '#999' }}>No tables in this room</p>
  2146→          )}
  2147→        </div>
  2148→      </div>
  2149→    </div>
  2150→  );
  2151→}
