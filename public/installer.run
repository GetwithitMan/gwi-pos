#!/usr/bin/env bash
# =============================================================================
# GWI POS Installer — installer.run
# =============================================================================
#
# Provisions Ubuntu 22.04+ NUCs as POS stations.
#
# Roles:
#   Server   — POS app + Chromium kiosk + heartbeat + sync agent + backups
#   Terminal — Chromium kiosk pointing at server + optional RealVNC
#
# Usage:
#   curl -sSL https://gwi-pos.vercel.app/installer.run | sudo bash
#
# Re-running is idempotent: detects existing registration, backs up data,
# pulls latest code, restarts services.
# =============================================================================

set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Constants
# ─────────────────────────────────────────────────────────────────────────────

APP_BASE="/opt/gwi-pos"
APP_DIR="$APP_BASE/app"
ENV_FILE="$APP_BASE/.env"
KEY_DIR="$APP_BASE/keys"
BACKUP_DIR="$APP_BASE/backups"
BACKUP_SCRIPT="$APP_BASE/backup-pos.sh"
MC_URL="https://app.thepasspos.com"
MC_REGISTER_URL="$MC_URL/api/fleet/register"
GIT_REPO="https://github.com/GetwithitMan/gwi-pos.git"

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log()    { echo -e "${GREEN}[GWI POS]${NC} $*"; }
warn()   { echo -e "${YELLOW}[WARNING]${NC} $*"; }
err()    { echo -e "${RED}[ERROR]${NC} $*" >&2; }
header() { echo -e "\n${CYAN}═══════════════════════════════════════════════════════${NC}"; echo -e "${CYAN}  $*${NC}"; echo -e "${CYAN}═══════════════════════════════════════════════════════${NC}\n"; }

# ─────────────────────────────────────────────────────────────────────────────
# Pre-flight Checks
# ─────────────────────────────────────────────────────────────────────────────

header "GWI POS Installer"

# Must be root
if [[ $EUID -ne 0 ]]; then
  err "This installer must be run as root. Use: sudo bash installer.run"
  exit 1
fi

# Must be Ubuntu 22.04+
if [ -f /etc/os-release ]; then
  . /etc/os-release
  if [[ "$ID" != "ubuntu" ]] || [[ "${VERSION_ID%%.*}" -lt 22 ]]; then
    err "GWI POS requires Ubuntu 22.04 or later. Detected: $PRETTY_NAME"
    exit 1
  fi
  log "OS: $PRETTY_NAME"
else
  err "Cannot detect OS. /etc/os-release not found."
  exit 1
fi

# Resolve service user (the non-root user who will run services)
# Supports: --user <name> flag, SUDO_USER, or auto-detect UID 1000
POSUSER=""
for arg in "$@"; do
  if [[ "$prev_arg" == "--user" ]]; then POSUSER="$arg"; break; fi
  prev_arg="$arg"
done

if [[ -z "$POSUSER" ]]; then
  POSUSER="${SUDO_USER:-}"
fi

if [[ -z "$POSUSER" ]] || [[ "$POSUSER" == "root" ]]; then
  # Auto-detect: list non-root users with UID >= 1000 and a real home dir
  POSUSER=$(getent passwd 1000 | cut -d: -f1 || echo "")
  if [[ -z "$POSUSER" ]]; then
    err "Cannot determine service user."
    err "Run with: curl -sSL ... | sudo bash -s -- --user <username>"
    exit 1
  fi
  warn "Auto-detected service user: $POSUSER (UID 1000)"
  warn "If this is wrong, re-run with: --user <correct-username>"
fi

POSUSER_HOME=$(eval echo "~$POSUSER")
if [[ ! -d "$POSUSER_HOME" ]]; then
  err "Home directory for '$POSUSER' does not exist: $POSUSER_HOME"
  err "Create the user first or specify a different one with --user <name>"
  exit 1
fi
log "Service user: $POSUSER (home: $POSUSER_HOME)"

# ─────────────────────────────────────────────────────────────────────────────
# Install Essential Tools (BEFORE registration — jq and openssl required)
# ─────────────────────────────────────────────────────────────────────────────

header "Installing Essential Tools"

apt-get update -y
apt-get install -y curl git jq openssl ca-certificates gnupg

log "Essential tools installed."

# Network check (after curl is guaranteed installed)
log "Checking network connectivity..."
if ! curl -fsS --max-time 10 "$MC_URL" >/dev/null 2>&1; then
  warn "Cannot reach Mission Control ($MC_URL). Checking general internet..."
  if ! curl -fsS --max-time 10 "https://google.com" >/dev/null 2>&1; then
    err "No internet connection. Connect to the network and try again."
    exit 1
  fi
  warn "Internet is available but Mission Control is unreachable. Registration may fail."
fi
log "Network: OK"

# ─────────────────────────────────────────────────────────────────────────────
# Prompts
# ─────────────────────────────────────────────────────────────────────────────

header "Station Configuration"

# 1. Role
echo "What role is this station?"
echo "  1) Server  — Runs POS app + database + kiosk"
echo "  2) Terminal — Kiosk only (connects to a server)"
echo ""
while true; do
  read -rp "Select (1 or 2): " role_choice < /dev/tty
  case $role_choice in
    1) STATION_ROLE="server"; break ;;
    2) STATION_ROLE="terminal"; break ;;
    *) echo "Please enter 1 or 2." ;;
  esac
done
log "Role: $STATION_ROLE"

# 2. Check if already registered with Mission Control
ALREADY_REGISTERED=false
if [[ -f "$ENV_FILE" ]] && grep -q "SERVER_NODE_ID=" "$ENV_FILE" && grep -q "SERVER_API_KEY=" "$ENV_FILE"; then
  ALREADY_REGISTERED=true
  log "Existing registration found in $ENV_FILE"
  echo ""
  echo "This station is already registered with Mission Control."
  echo "  1) Keep existing registration (update code only)"
  echo "  2) Re-register with a new code"
  echo ""
  while true; do
    read -rp "Select (1 or 2): " reg_choice < /dev/tty
    case $reg_choice in
      1) break ;;
      2) ALREADY_REGISTERED=false; break ;;
      *) echo "Please enter 1 or 2." ;;
    esac
  done
fi

# 3. Registration code (if not already registered and server role)
REG_CODE=""
if [[ "$ALREADY_REGISTERED" == "false" ]] && [[ "$STATION_ROLE" == "server" ]]; then
  echo ""
  echo "Enter the registration code from Mission Control."
  echo "(Generate one at: Settings > Venue > NUC Registration)"
  echo ""
  read -rp "Registration code: " REG_CODE < /dev/tty
  if [[ -z "$REG_CODE" ]]; then
    err "Registration code is required for new server installations."
    exit 1
  fi
  # Validate UUID format (MC expects a UUID v4)
  UUID_REGEX='^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'
  if [[ ! "$REG_CODE" =~ $UUID_REGEX ]]; then
    err "Invalid registration code format. Expected UUID (e.g., 550e8400-e29b-41d4-a716-446655440000)"
    exit 1
  fi
fi

# 4. RealVNC (optional)
echo ""
echo "RealVNC Remote Access (optional — press Enter to skip)"
read -rp "Company name (for VNC grouping): " COMPANY_NAME < /dev/tty
read -rp "Location / terminal name: " TERMINAL_NAME < /dev/tty
read -rp "RealVNC cloud connectivity token: " REALVNC_TOKEN < /dev/tty

# 5. Terminal: server URL
SERVER_URL=""
if [[ "$STATION_ROLE" == "terminal" ]]; then
  echo ""
  read -rp "Server URL (e.g., 192.168.1.50:3000): " SERVER_URL < /dev/tty
  if [[ -z "$SERVER_URL" ]]; then
    err "Server URL is required for terminal stations."
    exit 1
  fi
  # Auto-prepend http:// if user just typed an IP or hostname
  if [[ ! "$SERVER_URL" =~ ^https?:// ]]; then
    SERVER_URL="http://$SERVER_URL"
    log "Using: $SERVER_URL"
  fi
  # Validate URL format (prevent injection into systemd ExecStart)
  URL_REGEX='^https?://[A-Za-z0-9._:-]+(/[A-Za-z0-9._/-]*)?$'
  if [[ ! "$SERVER_URL" =~ $URL_REGEX ]]; then
    err "Invalid server URL format. Example: 192.168.1.50:3000"
    exit 1
  fi
fi

# ─────────────────────────────────────────────────────────────────────────────
# Existing Install Detection (Idempotent)
# ─────────────────────────────────────────────────────────────────────────────

PREV_ROLE=""
if [[ -d "$APP_BASE" ]]; then
  header "Existing Installation Detected"
  log "Found existing install at $APP_BASE"

  # Detect previous role from .env
  if [[ -f "$ENV_FILE" ]]; then
    PREV_ROLE=$(grep -oP '(?<=^STATION_ROLE=).*' "$ENV_FILE" 2>/dev/null || echo "")
  fi

  if [[ "$STATION_ROLE" == "server" ]] && [[ -f "$BACKUP_SCRIPT" ]]; then
    log "Running pre-update backup..."
    bash "$BACKUP_SCRIPT" || warn "Backup failed — continuing anyway."
  fi

  # Role change: disable services from old role
  if [[ -n "$PREV_ROLE" ]] && [[ "$PREV_ROLE" != "$STATION_ROLE" ]]; then
    warn "Role change detected: $PREV_ROLE → $STATION_ROLE"
    if [[ "$PREV_ROLE" == "server" ]] && [[ "$STATION_ROLE" == "terminal" ]]; then
      log "Disabling server services..."
      systemctl disable --now pulse-pos 2>/dev/null || true
      systemctl disable --now pulse-sync 2>/dev/null || true
      # Stop local PostgreSQL if running (terminal doesn't need it)
      systemctl disable --now postgresql 2>/dev/null || true
    elif [[ "$PREV_ROLE" == "terminal" ]] && [[ "$STATION_ROLE" == "server" ]]; then
      log "Disabling terminal-only kiosk..."
      systemctl disable --now pulse-kiosk 2>/dev/null || true
    fi
  fi

  log "Updating existing installation..."
else
  log "Fresh installation."
fi

# ─────────────────────────────────────────────────────────────────────────────
# Mission Control Registration (Server Role Only)
# ─────────────────────────────────────────────────────────────────────────────

# Variables populated by registration or loaded from existing .env
DEPLOY_TOKEN=""
DATABASE_URL=""
DIRECT_URL=""
HARDWARE_FINGERPRINT=""
USE_LOCAL_PG=false

if [[ "$ALREADY_REGISTERED" == "false" ]] && [[ "$STATION_ROLE" == "server" ]]; then
  header "Registering with Mission Control"

  # ── Generate hardware fingerprint (SHA-256 of machine-id + MAC addresses) ──
  MACHINE_ID=$(cat /etc/machine-id 2>/dev/null || echo "no-machine-id")
  MAC_ADDRS=$(ip link show 2>/dev/null | awk '/ether/{print $2}' | sort | tr '\n' ':')
  HARDWARE_FINGERPRINT=$(printf '%s:%s' "$MACHINE_ID" "$MAC_ADDRS" | sha256sum | cut -d' ' -f1)
  log "Hardware fingerprint: ${HARDWARE_FINGERPRINT:0:16}..."

  # ── Generate RSA 2048-bit keypair (skip if already exists) ──
  mkdir -p "$APP_BASE" "$KEY_DIR"
  chmod 700 "$KEY_DIR"
  if [[ ! -f "$KEY_DIR/private.pem" ]]; then
    log "Generating RSA keypair..."
    openssl genrsa -out "$KEY_DIR/private.pem" 2048 2>/dev/null
    openssl rsa -in "$KEY_DIR/private.pem" -pubout -out "$KEY_DIR/public.pem" 2>/dev/null
  fi
  chmod 600 "$KEY_DIR/private.pem"
  chown -R "$POSUSER":"$POSUSER" "$APP_BASE"
  PUBLIC_KEY=$(cat "$KEY_DIR/public.pem")
  log "RSA keypair ready."

  # ── Build registration payload ──
  REG_PAYLOAD=$(jq -n \
    --arg token "$REG_CODE" \
    --arg fp "$HARDWARE_FINGERPRINT" \
    --arg pk "$PUBLIC_KEY" \
    '{registrationToken: $token, hardwareFingerprint: $fp, fingerprintVersion: 1, publicKey: $pk}')

  log "Calling $MC_REGISTER_URL..."

  HTTP_CODE=$(curl -sS --max-time 30 -X POST \
    "$MC_REGISTER_URL" \
    -H "Content-Type: application/json" \
    -d "$REG_PAYLOAD" \
    -o /tmp/gwi-reg-response.json \
    -w "%{http_code}" 2>/tmp/gwi-reg-error.txt) || HTTP_CODE="000"

  REG_RESPONSE=$(cat /tmp/gwi-reg-response.json 2>/dev/null || echo "{}")
  rm -f /tmp/gwi-reg-response.json /tmp/gwi-reg-error.txt

  if [[ "$HTTP_CODE" != "201" ]] && [[ "$HTTP_CODE" != "200" ]]; then
    err "Mission Control registration failed (HTTP $HTTP_CODE)."
    # Try to extract error message from response
    ERR_MSG=$(echo "$REG_RESPONSE" | jq -r '.error // .message // empty' 2>/dev/null || echo "")
    if [[ -n "$ERR_MSG" ]]; then
      err "  $ERR_MSG"
    else
      err "  Response: $REG_RESPONSE"
    fi
    err ""
    err "Check:"
    err "  - Registration code is a valid UUID from Mission Control"
    err "  - Code has not expired (24-hour window)"
    err "  - Code has not already been used"
    err "  - Network can reach $MC_URL"
    exit 1
  fi

  # ── Parse response ──
  SERVER_NODE_ID=$(echo "$REG_RESPONSE" | jq -r '.data.serverNodeId // empty')
  LOCATION_ID=$(echo "$REG_RESPONSE" | jq -r '.data.locationId // empty')
  ENCRYPTED_API_KEY=$(echo "$REG_RESPONSE" | jq -r '.data.encryptedApiKey // empty')
  ENCRYPTED_DB_URL=$(echo "$REG_RESPONSE" | jq -r '.data.encryptedDatabaseUrl // empty')
  ENCRYPTED_DIRECT_URL=$(echo "$REG_RESPONSE" | jq -r '.data.encryptedDirectUrl // empty')
  ENCRYPTED_DEPLOY_TOKEN=$(echo "$REG_RESPONSE" | jq -r '.data.encryptedDeployToken // empty')

  if [[ -z "$SERVER_NODE_ID" ]] || [[ -z "$ENCRYPTED_API_KEY" ]]; then
    err "Invalid response from Mission Control (missing serverNodeId or encryptedApiKey)."
    err "Response: $REG_RESPONSE"
    exit 1
  fi

  log "Registration successful! Server node: $SERVER_NODE_ID"

  # ── Decrypt secrets using RSA private key (OAEP-SHA256) ──
  # MC encrypts with: crypto.publicEncrypt({ key, oaepHash: 'sha256', padding: RSA_PKCS1_OAEP_PADDING })
  # NUC decrypts with matching: openssl pkeyutl with OAEP + SHA-256 for both digest and MGF1
  decrypt_rsa() {
    local encrypted_b64="$1"
    local label="$2"
    if [[ -z "$encrypted_b64" ]] || [[ "$encrypted_b64" == "null" ]]; then
      echo ""
      return
    fi
    local decrypted
    decrypted=$(echo "$encrypted_b64" | base64 -d 2>/dev/null | openssl pkeyutl -decrypt \
      -inkey "$KEY_DIR/private.pem" \
      -pkeyopt rsa_padding_mode:oaep \
      -pkeyopt rsa_oaep_md:sha256 \
      -pkeyopt rsa_mgf1_md:sha256 2>&1) || {
      warn "  RSA decrypt failed for: ${label:-unknown}"
      warn "  This may indicate a padding mismatch between MC and NUC."
      warn "  Expected: RSA-OAEP with SHA-256 digest + SHA-256 MGF1"
      echo ""
      return
    }
    echo "$decrypted"
  }

  log "Decrypting secrets..."
  SERVER_API_KEY=$(decrypt_rsa "$ENCRYPTED_API_KEY" "serverApiKey")
  DATABASE_URL=$(decrypt_rsa "$ENCRYPTED_DB_URL" "databaseUrl")
  DIRECT_URL=$(decrypt_rsa "$ENCRYPTED_DIRECT_URL" "directUrl")
  DEPLOY_TOKEN=$(decrypt_rsa "$ENCRYPTED_DEPLOY_TOKEN" "deployToken")

  if [[ -z "$SERVER_API_KEY" ]]; then
    err "Failed to decrypt server API key."
    err ""
    err "Possible causes:"
    err "  1. RSA padding mismatch — MC must use OAEP with SHA-256 (oaepHash: 'sha256')"
    err "  2. Key rotation — MC encrypted with a different public key than this NUC's"
    err "  3. Corrupted response — base64 data was truncated or malformed"
    err ""
    err "Fix: delete $KEY_DIR and re-run the installer to generate a new keypair."
    exit 1
  fi

  log "Secrets decrypted successfully."

  # ── Determine if local PostgreSQL is needed ──
  if [[ -z "$DATABASE_URL" ]]; then
    USE_LOCAL_PG=true
    log "No cloud database URL provided — will set up local PostgreSQL."
  else
    USE_LOCAL_PG=false
    log "Cloud database URL provided — will use Neon."
  fi

  # ── Write environment file (DEPLOY_TOKEN is never stored here — goes to .git-credentials only) ──
  mkdir -p "$APP_BASE"
  cat > "$ENV_FILE" <<ENVEOF
# Generated by installer.run — $(date -u +%Y-%m-%dT%H:%M:%SZ)
STATION_ROLE=$STATION_ROLE

# Mission Control
SERVER_NODE_ID=$SERVER_NODE_ID
SERVER_API_KEY=$SERVER_API_KEY
HARDWARE_FINGERPRINT=$HARDWARE_FINGERPRINT
MISSION_CONTROL_URL=$MC_URL
LOCATION_ID=$LOCATION_ID

# Database
DATABASE_URL=$DATABASE_URL
DIRECT_URL=$DIRECT_URL

# App Configuration
NODE_ENV=production
NEXT_PUBLIC_EVENT_PROVIDER=socket
PORT=3000
ENVEOF

  chmod 600 "$ENV_FILE"
  chown "$POSUSER":"$POSUSER" "$ENV_FILE"
  log "Environment written to $ENV_FILE"

elif [[ "$STATION_ROLE" == "server" ]]; then
  # Already registered — load values from existing .env
  log "Using existing registration from $ENV_FILE"
  while IFS= read -r line; do
    # Skip blank lines and lines starting with #
    [[ -z "$line" ]] && continue
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    # Strip leading whitespace only (preserve # in values like DB passwords)
    line="${line#"${line%%[![:space:]]*}"}"
    [[ -z "$line" ]] && continue
    key="${line%%=*}"; val="${line#*=}"
    case "$key" in
      STATION_ROLE) PREV_ROLE="$val" ;;
      DATABASE_URL) DATABASE_URL="$val" ;;
      DIRECT_URL)   DIRECT_URL="$val" ;;
      HARDWARE_FINGERPRINT) HARDWARE_FINGERPRINT="$val" ;;
    esac
  done < "$ENV_FILE"

  # Determine local PG
  if [[ -z "$DATABASE_URL" ]] || [[ "$DATABASE_URL" == *"localhost"* ]] || [[ "$DATABASE_URL" == *"127.0.0.1"* ]]; then
    USE_LOCAL_PG=true
  fi
fi

# ─────────────────────────────────────────────────────────────────────────────
# Common Setup (Both Roles)
# ─────────────────────────────────────────────────────────────────────────────

header "Installing Dependencies"

# Ensure cron is installed (needed for heartbeat + backup jobs)
apt-get install -y cron 2>/dev/null || true
systemctl enable cron 2>/dev/null || true
systemctl start cron 2>/dev/null || true

# Install Chromium (try both package names)
apt-get install -y chromium-browser 2>/dev/null \
  || apt-get install -y chromium 2>/dev/null \
  || warn "Chromium install failed — kiosk mode may not work."

log "Browser installed."

# Install Node.js 20 if not present or too old
install_node20() {
  log "Setting up NodeSource repository for Node.js 20..."
  local SETUP_SCRIPT="/tmp/nodesource-setup-20.sh"
  curl -fsSL https://deb.nodesource.com/setup_20.x -o "$SETUP_SCRIPT"
  if [[ ! -s "$SETUP_SCRIPT" ]]; then
    err "Failed to download NodeSource setup script."
    exit 1
  fi
  bash "$SETUP_SCRIPT"
  rm -f "$SETUP_SCRIPT"
  apt-get install -y nodejs
}

if ! command -v node >/dev/null 2>&1; then
  log "Installing Node.js 20..."
  install_node20
elif [[ "$(node -v | cut -d. -f1 | tr -d v)" -lt 20 ]]; then
  log "Upgrading Node.js to 20..."
  install_node20
fi
log "Node.js: $(node -v)"
log "npm: $(npm -v)"

# ─────────────────────────────────────────────────────────────────────────────
# Server Role: Local PostgreSQL (only if no cloud database URL)
# ─────────────────────────────────────────────────────────────────────────────

if [[ "$STATION_ROLE" == "server" ]] && [[ "$USE_LOCAL_PG" == "true" ]]; then
  header "Setting Up Local PostgreSQL"

  apt-get install -y postgresql postgresql-contrib

  # Ensure PostgreSQL is running
  systemctl enable postgresql
  systemctl start postgresql

  DB_USER="pulse_pos"
  DB_NAME="pulse_pos"

  # Reuse existing password from .env on re-runs; generate random on first install
  EXISTING_DB_PW=""
  if [[ -f "$ENV_FILE" ]]; then
    EXISTING_DB_PW=$(grep -oP '(?<=pulse_pos:)[^@]+' "$ENV_FILE" 2>/dev/null | head -1 || echo "")
  fi
  if [[ -n "$EXISTING_DB_PW" ]]; then
    DB_PASSWORD="$EXISTING_DB_PW"
    log "Reusing existing database password."
  else
    DB_PASSWORD=$(openssl rand -hex 16)
    log "Generated new random database password."
  fi

  # Create database and user (idempotent)
  log "Creating database '$DB_NAME' and user '$DB_USER'..."
  sudo -u postgres psql -v ON_ERROR_STOP=0 <<EOSQL
DO \$\$
BEGIN
  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '$DB_USER') THEN
    CREATE ROLE $DB_USER LOGIN PASSWORD '$DB_PASSWORD';
  ELSE
    ALTER ROLE $DB_USER WITH PASSWORD '$DB_PASSWORD';
  END IF;
END\$\$;

SELECT 'CREATE DATABASE $DB_NAME OWNER $DB_USER'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$DB_NAME')\gexec
EOSQL

  # Allow local connections with password
  PG_HBA=$(sudo -u postgres psql -t -c "SHOW hba_file;" | tr -d '[:space:]')
  if ! grep -q "$DB_USER" "$PG_HBA" 2>/dev/null; then
    log "Adding $DB_USER to pg_hba.conf..."
    # Append a clearly marked block (safer than sed insert which can break on format differences)
    cat >> "$PG_HBA" <<HBAEOF

# GWI POS — added by installer.run
local   $DB_NAME   $DB_USER   md5
host    $DB_NAME   $DB_USER   127.0.0.1/32   md5
HBAEOF
    systemctl reload postgresql
  fi

  # Verify database connection works
  if sudo -u "$POSUSER" PGPASSWORD="$DB_PASSWORD" psql -h localhost -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1" >/dev/null 2>&1; then
    log "Database connection verified."
  else
    err "Cannot connect to PostgreSQL as $DB_USER."
    err "Check pg_hba.conf at: $PG_HBA"
    err "Ensure the line 'local $DB_NAME $DB_USER md5' exists."
    exit 1
  fi

  # Create .pgpass for passwordless pg_dump in backups/cron
  PGPASS_FILE="$POSUSER_HOME/.pgpass"
  echo "localhost:5432:$DB_NAME:$DB_USER:$DB_PASSWORD" > "$PGPASS_FILE"
  chmod 600 "$PGPASS_FILE"
  chown "$POSUSER":"$POSUSER" "$PGPASS_FILE"

  # Set DATABASE_URL for local PostgreSQL
  DATABASE_URL="postgresql://$DB_USER:$DB_PASSWORD@localhost:5432/$DB_NAME"
  DIRECT_URL="$DATABASE_URL"

  # Update .env with local database URLs
  if grep -q "^DATABASE_URL=" "$ENV_FILE" 2>/dev/null; then
    sed -i "s|^DATABASE_URL=.*|DATABASE_URL=$DATABASE_URL|" "$ENV_FILE"
    sed -i "s|^DIRECT_URL=.*|DIRECT_URL=$DIRECT_URL|" "$ENV_FILE"
  else
    echo "" >> "$ENV_FILE"
    echo "# Local PostgreSQL" >> "$ENV_FILE"
    echo "DATABASE_URL=$DATABASE_URL" >> "$ENV_FILE"
    echo "DIRECT_URL=$DIRECT_URL" >> "$ENV_FILE"
  fi

  # Also add DB_USER/DB_NAME for backup script
  if ! grep -q "^DB_USER=" "$ENV_FILE" 2>/dev/null; then
    echo "DB_USER=$DB_USER" >> "$ENV_FILE"
    echo "DB_NAME=$DB_NAME" >> "$ENV_FILE"
  fi

  log "PostgreSQL ready: $DB_NAME owned by $DB_USER"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Server Role: POS App Install
# ─────────────────────────────────────────────────────────────────────────────

if [[ "$STATION_ROLE" == "server" ]]; then
  header "Installing POS Application"

  # Set up git credential store so deploy token stays out of remote URL
  CRED_FILE="$APP_BASE/.git-credentials"
  if [[ -n "${DEPLOY_TOKEN:-}" ]] && [[ "${DEPLOY_TOKEN:-}" != "null" ]]; then
    log "Configuring deploy token via git credential store."
    echo "https://${DEPLOY_TOKEN}:x-oauth-basic@github.com" > "$CRED_FILE"
    chmod 600 "$CRED_FILE"
    chown "$POSUSER":"$POSUSER" "$CRED_FILE"
  else
    log "No deploy token — using public repo URL."
  fi

  # Clone or update (remote URL is always clean — no token embedded)
  if [[ -d "$APP_DIR/.git" ]]; then
    log "Updating existing app code..."
    if ! sudo -u "$POSUSER" bash -c "
      cd '$APP_DIR'
      git config credential.helper 'store --file=$CRED_FILE'
      git remote set-url origin '$GIT_REPO' 2>/dev/null || true
      git fetch --all && git reset --hard origin/main
    "; then
      err "Failed to update app code from git."
      err "Check network connectivity and deploy token validity."
      exit 1
    fi
  else
    log "Cloning app from repository..."
    mkdir -p "$APP_DIR"
    chown "$POSUSER":"$POSUSER" "$APP_BASE"
    if ! sudo -u "$POSUSER" bash -c "
      git config --global credential.helper 'store --file=$CRED_FILE'
      git clone '$GIT_REPO' '$APP_DIR'
      cd '$APP_DIR'
      git config credential.helper 'store --file=$CRED_FILE'
    "; then
      err "Failed to clone app repository."
      err "Check: network connectivity, deploy token, repo access."
      exit 1
    fi
    # Remove global credential helper (keep it repo-local only)
    sudo -u "$POSUSER" git config --global --unset credential.helper 2>/dev/null || true
  fi

  log "App code ready at $APP_DIR"

  # Copy env files into app directory (always — ensures .env.local stays in sync)
  # Remove existing symlinks/files first to avoid "same file" error on re-install
  rm -f "$APP_DIR/.env" "$APP_DIR/.env.local"
  cp "$ENV_FILE" "$APP_DIR/.env"
  cp "$ENV_FILE" "$APP_DIR/.env.local"
  chown "$POSUSER":"$POSUSER" "$APP_DIR/.env" "$APP_DIR/.env.local"

  # Build the application (each step checked explicitly)
  log "Installing npm dependencies..."
  if ! sudo -u "$POSUSER" bash -c "cd '$APP_DIR' && npm ci --production=false"; then
    err "npm install failed. Check Node.js version and network."
    exit 1
  fi

  log "Generating Prisma client..."
  if ! sudo -u "$POSUSER" bash -c "cd '$APP_DIR' && npx prisma generate"; then
    err "Prisma generate failed. Check schema.prisma for errors."
    exit 1
  fi

  log "Applying database migrations..."
  sudo -u "$POSUSER" bash -c "cd '$APP_DIR' && npx prisma migrate deploy 2>/dev/null || npx prisma db push" || {
    err "Database migration failed. Check DATABASE_URL and PostgreSQL status."
    exit 1
  }

  log "Building Next.js application..."
  if ! sudo -u "$POSUSER" bash -c "cd '$APP_DIR' && npm run build"; then
    err "Application build failed. Check build logs above."
    exit 1
  fi

  log "POS application built successfully!"

  # ───────────────────────────────────────────────────────────────────────────
  # Server Role: Systemd Services
  # ───────────────────────────────────────────────────────────────────────────

  header "Configuring Systemd Services"

  # pulse-pos.service — POS backend/UI
  cat > /etc/systemd/system/pulse-pos.service <<SVCEOF
[Unit]
Description=GWI POS Server
After=network-online.target postgresql.service
Wants=network-online.target postgresql.service

[Service]
User=$POSUSER
WorkingDirectory=$APP_DIR
EnvironmentFile=$ENV_FILE
Environment=NODE_ENV=production
ExecStart=/usr/bin/node -r ./preload.js server.js
Restart=always
RestartSec=3
StandardOutput=journal
StandardError=journal
SyslogIdentifier=pulse-pos

[Install]
WantedBy=multi-user.target
SVCEOF

  # ── Kiosk preflight: verify X11 session is available ──
  KIOSK_OK=true
  CHROMIUM_BIN=""
  if command -v chromium-browser >/dev/null 2>&1; then
    CHROMIUM_BIN="chromium-browser"
  elif command -v chromium >/dev/null 2>&1; then
    CHROMIUM_BIN="chromium"
  else
    warn "Chromium not found — kiosk mode will not work."
    KIOSK_OK=false
  fi

  # Check for Wayland vs X11
  if [[ "$KIOSK_OK" == "true" ]]; then
    SESSION_TYPE=$(loginctl show-session $(loginctl list-sessions --no-legend | awk '{print $1}' | head -1) -p Type --value 2>/dev/null || echo "unknown")
    if [[ "$SESSION_TYPE" == "wayland" ]]; then
      warn "Wayland session detected. GWI POS kiosk requires X11."
      warn "Reconfigure Ubuntu for X11 auto-login, then re-run the installer."
      warn "  1. Edit /etc/gdm3/custom.conf and set: WaylandEnable=false"
      warn "  2. Reboot and re-run the installer."
      KIOSK_OK=false
    elif [[ "$SESSION_TYPE" == "unknown" ]]; then
      warn "No active graphical session detected."
      warn "Ensure auto-login is configured for '$POSUSER' before rebooting."
    fi
  fi

  # pulse-kiosk.service — Chromium in kiosk mode
  cat > /etc/systemd/system/pulse-kiosk.service <<SVCEOF
[Unit]
Description=GWI POS Kiosk
After=graphical.target pulse-pos.service
Wants=pulse-pos.service

[Service]
Type=simple
User=$POSUSER
Environment=DISPLAY=:0
Environment=XAUTHORITY=$POSUSER_HOME/.Xauthority
ExecStartPre=/bin/sleep 5
ExecStart=/usr/bin/${CHROMIUM_BIN:-chromium-browser} --kiosk --noerrdialogs --disable-infobars --disable-session-crashed-bubble --no-first-run --disable-features=TranslateUI --incognito --check-for-update-interval=31536000 http://localhost:3000
Restart=on-failure
RestartSec=10

[Install]
WantedBy=graphical.target
SVCEOF

  systemctl daemon-reload
  systemctl enable pulse-pos
  systemctl enable pulse-kiosk

  log "Starting POS server..."
  systemctl restart pulse-pos

  # Wait for POS to be ready before starting kiosk
  log "Waiting for POS to start..."
  for i in $(seq 1 30); do
    if curl -fsS http://localhost:3000/api/health >/dev/null 2>&1; then
      log "POS is ready!"
      break
    fi
    sleep 2
  done

  systemctl restart pulse-kiosk
  log "Services configured and started."

  # ───────────────────────────────────────────────────────────────────────────
  # Server Role: Backup Script + Cron (local PostgreSQL only)
  # ───────────────────────────────────────────────────────────────────────────

  if [[ "$USE_LOCAL_PG" == "true" ]]; then
    header "Setting Up Backups"

    mkdir -p "$BACKUP_DIR"
    chown "$POSUSER":"$POSUSER" "$BACKUP_DIR"

    # Install backup script
    cat > "$BACKUP_SCRIPT" <<'BKEOF'
#!/usr/bin/env bash
set -euo pipefail
BACKUP_DIR=/opt/gwi-pos/backups
RETENTION_DAYS=7

if [ -f /opt/gwi-pos/.env ]; then
  DB_NAME=$(grep -oP '^DB_NAME=\K.*' /opt/gwi-pos/.env 2>/dev/null || echo "pulse_pos")
  DB_USER=$(grep -oP '^DB_USER=\K.*' /opt/gwi-pos/.env 2>/dev/null || echo "pulse_pos")
else
  DB_NAME="${DB_NAME:-pulse_pos}"
  DB_USER="${DB_USER:-pulse_pos}"
fi

mkdir -p "$BACKUP_DIR"
timestamp=$(date +%Y%m%d-%H%M%S)
backup_file="$BACKUP_DIR/pos-$timestamp.sql.gz"

echo "[Backup] Starting PostgreSQL backup of '$DB_NAME'..."
if pg_dump -U "$DB_USER" "$DB_NAME" 2>/dev/null | gzip > "$backup_file"; then
  size=$(du -h "$backup_file" | cut -f1)
  echo "[Backup] Success: $backup_file ($size)"
else
  echo "[Backup] WARNING: pg_dump failed."
  rm -f "$backup_file"
  exit 1
fi

find "$BACKUP_DIR" -type f -name 'pos-*.sql.gz' -mtime +"$RETENTION_DAYS" -delete
echo "[Backup] Done."
BKEOF

    chmod +x "$BACKUP_SCRIPT"
    chown "$POSUSER":"$POSUSER" "$BACKUP_SCRIPT"

    # Add cron entry (idempotent)
    CRON_LINE="0 4 * * * $BACKUP_SCRIPT"
    ( crontab -u "$POSUSER" -l 2>/dev/null | grep -v "$BACKUP_SCRIPT" || true ; echo "$CRON_LINE" ) | crontab -u "$POSUSER" -

    log "Daily backup configured (4 AM, 7-day retention)."
  else
    log "Cloud database (Neon) — backups managed by provider. Skipping local backup."
  fi

  # ───────────────────────────────────────────────────────────────────────────
  # Server Role: Sudoers Rules
  # ───────────────────────────────────────────────────────────────────────────

  header "Configuring Sudoers"

  cat > /etc/sudoers.d/gwi-pos <<SUDEOF
# GWI POS — allow service user to manage POS services without password
$POSUSER ALL=(ALL) NOPASSWD: /usr/bin/systemctl restart pulse-pos
$POSUSER ALL=(ALL) NOPASSWD: /usr/bin/systemctl stop pulse-kiosk
$POSUSER ALL=(ALL) NOPASSWD: /usr/bin/systemctl start pulse-kiosk
$POSUSER ALL=(ALL) NOPASSWD: /usr/bin/systemctl restart pulse-kiosk
$POSUSER ALL=(ALL) NOPASSWD: /usr/bin/pkill -f chromium*
SUDEOF
  chmod 440 /etc/sudoers.d/gwi-pos

  log "Sudoers rules configured."

  # ───────────────────────────────────────────────────────────────────────────
  # Server Role: Heartbeat Script + Cron
  # ───────────────────────────────────────────────────────────────────────────

  header "Setting Up Heartbeat"

  # Ensure POSUSER owns the base directory (needed to write heartbeat.log)
  chown "$POSUSER":"$POSUSER" "$APP_BASE"

  HB_SCRIPT="$APP_BASE/heartbeat.sh"
  cat > "$HB_SCRIPT" <<'HBEOF'
#!/usr/bin/env bash
# GWI POS Heartbeat — sends system metrics to Mission Control
set -uo pipefail

LOG="/opt/gwi-pos/heartbeat.log"
ENV_FILE="/opt/gwi-pos/.env"
if [[ ! -f "$ENV_FILE" ]]; then
  echo "ERR no-env $(date -u +%H:%M:%S)" >> "$LOG"
  exit 1
fi

# Parse env (line-by-line, handles values with = signs and # in values)
SERVER_NODE_ID="" SERVER_API_KEY="" HARDWARE_FINGERPRINT="" MISSION_CONTROL_URL="" LOCATION_ID=""
while IFS= read -r line; do
  [[ -z "$line" ]] && continue
  [[ "$line" =~ ^[[:space:]]*# ]] && continue
  line="${line#"${line%%[![:space:]]*}"}"
  [[ -z "$line" ]] && continue
  key="${line%%=*}"; val="${line#*=}"
  case "$key" in
    SERVER_NODE_ID)       SERVER_NODE_ID="$val" ;;
    SERVER_API_KEY)       SERVER_API_KEY="$val" ;;
    HARDWARE_FINGERPRINT) HARDWARE_FINGERPRINT="$val" ;;
    MISSION_CONTROL_URL)  MISSION_CONTROL_URL="$val" ;;
    LOCATION_ID)          LOCATION_ID="$val" ;;
  esac
done < "$ENV_FILE"

if [[ -z "$SERVER_NODE_ID" || -z "$SERVER_API_KEY" || -z "$MISSION_CONTROL_URL" ]]; then
  echo "ERR missing-env NODE=${SERVER_NODE_ID:-(empty)} KEY=${SERVER_API_KEY:+set} MC=${MISSION_CONTROL_URL:-(empty)} $(date -u +%H:%M:%S)" >> "$LOG"
  exit 1
fi

# Metrics
UPTIME=$(awk '{printf "%d", $1}' /proc/uptime 2>/dev/null || echo 0)
CPU=$(awk '/^cpu /{u=$2+$4; t=$2+$4+$5; printf "%.1f", u*100/t}' /proc/stat 2>/dev/null || echo "0")
MEM_TOTAL=$(free -m 2>/dev/null | awk '/Mem:/{print $2}' || echo 1)
MEM_USED=$(free -m 2>/dev/null | awk '/Mem:/{print $3}' || echo 0)
DISK_TOTAL=$(df -BG / 2>/dev/null | awk 'NR==2{gsub("G",""); print $2+0}' || echo 1)
DISK_USED=$(df -BG / 2>/dev/null | awk 'NR==2{gsub("G",""); print $3+0}' || echo 0)
VERSION=$(jq -r '.version // "unknown"' /opt/gwi-pos/app/package.json 2>/dev/null || echo "unknown")
LOCAL_IP=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "")

BODY=$(printf '{"version":"%s","uptime":%d,"activeOrders":0,"cpuPercent":%s,"memoryUsedMb":%d,"memoryTotalMb":%d,"diskUsedGb":%s,"diskTotalGb":%s,"localIp":"%s","posLocationId":"%s"}' \
  "$VERSION" "$UPTIME" "$CPU" "$MEM_USED" "$MEM_TOTAL" "$DISK_USED" "$DISK_TOTAL" "$LOCAL_IP" "${LOCATION_ID:-}")

SIG=$(printf '%s' "$BODY" | openssl dgst -sha256 -hmac "$SERVER_API_KEY" 2>/dev/null | awk '{print $NF}')

RESP_FILE=$(mktemp)
HTTP_CODE=$(curl -sS --max-time 15 -o "$RESP_FILE" -w "%{http_code}" -X POST \
  "${MISSION_CONTROL_URL}/api/fleet/heartbeat" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $SERVER_API_KEY" \
  -H "X-Server-Node-Id: $SERVER_NODE_ID" \
  -H "X-Hardware-Fingerprint: ${HARDWARE_FINGERPRINT:-none}" \
  -H "X-Request-Signature: $SIG" \
  -d "$BODY" 2>&1) || HTTP_CODE="err"

# Log result — include response body on failures for debugging
if [[ "$HTTP_CODE" == "200" ]] || [[ "$HTTP_CODE" == "201" ]]; then
  echo "OK $HTTP_CODE $(date -u +%H:%M:%S)" >> "$LOG"
else
  RESP_BODY=$(cat "$RESP_FILE" 2>/dev/null | head -c 200 || echo "")
  echo "FAIL $HTTP_CODE $(date -u +%H:%M:%S) $RESP_BODY" >> "$LOG"
fi
rm -f "$RESP_FILE"

# Keep log small
if [[ -f "$LOG" ]] && [[ $(wc -l < "$LOG") -gt 500 ]]; then
  tail -200 "$LOG" > "$LOG.tmp" && mv "$LOG.tmp" "$LOG"
fi
HBEOF

  chmod +x "$HB_SCRIPT"
  chown "$POSUSER":"$POSUSER" "$HB_SCRIPT"

  # Add heartbeat cron (every minute, as POSUSER)
  HB_CRON="* * * * * $HB_SCRIPT"
  ( crontab -u "$POSUSER" -l 2>/dev/null | grep -v "$HB_SCRIPT" || true ; echo "$HB_CRON" ) | crontab -u "$POSUSER" -

  # Run first heartbeat NOW (visible output so user can see if it works)
  log "Testing first heartbeat..."
  if sudo -u "$POSUSER" bash "$HB_SCRIPT"; then
    LAST_HB=$(tail -1 "$APP_BASE/heartbeat.log" 2>/dev/null || echo "no log")
    if [[ "$LAST_HB" == OK* ]]; then
      log "Heartbeat: $LAST_HB"
    else
      warn "Heartbeat response: $LAST_HB"
      warn "Check /opt/gwi-pos/heartbeat.log for details."
    fi
  else
    warn "First heartbeat failed. Check /opt/gwi-pos/heartbeat.log"
  fi

  log "Heartbeat configured (every 60 seconds)."

  # ───────────────────────────────────────────────────────────────────────────
  # Server Role: Sync Agent (receives deploy commands from Mission Control)
  # ───────────────────────────────────────────────────────────────────────────

  header "Setting Up Sync Agent"

  SYNC_SCRIPT="$APP_BASE/sync-agent.js"
  cat > "$SYNC_SCRIPT" <<'SAEOF'
// GWI POS Sync Agent — receives fleet commands from Mission Control
// Runs as systemd service (pulse-sync). No npm dependencies — native Node.js only.
'use strict'
const https = require('https')
const http = require('http')
const crypto = require('crypto')
const { execSync } = require('child_process')
const fs = require('fs')
const path = require('path')

const ENV_FILE = '/opt/gwi-pos/.env'
const APP_DIR = '/opt/gwi-pos/app'
const LOG_FILE = '/opt/gwi-pos/sync-agent.log'

// ── Load config from .env ──────────────────────────────────────────────────
const env = {}
try {
  fs.readFileSync(ENV_FILE, 'utf-8').split('\n').forEach(line => {
    const t = line.trim()
    if (!t || t.startsWith('#')) return
    const eq = t.indexOf('=')
    if (eq > 0) env[t.slice(0, eq)] = t.slice(eq + 1)
  })
} catch (e) {
  console.error('[Sync] Cannot read .env:', e.message)
  process.exit(1)
}

const NODE_ID = env.SERVER_NODE_ID
const API_KEY = env.SERVER_API_KEY
const HW_FP   = env.HARDWARE_FINGERPRINT || 'none'
const MC_URL  = env.MISSION_CONTROL_URL

if (!NODE_ID || !API_KEY || !MC_URL) {
  console.error('[Sync] Missing SERVER_NODE_ID, SERVER_API_KEY, or MISSION_CONTROL_URL')
  process.exit(1)
}

function log(msg) {
  const line = new Date().toISOString() + ' ' + msg
  console.log(line)
  try { fs.appendFileSync(LOG_FILE, line + '\n') } catch {}
}

// ── HMAC Auth ──────────────────────────────────────────────────────────────
function sign(body) {
  return crypto.createHmac('sha256', API_KEY).update(body).digest('hex')
}

function authHeaders(body) {
  return {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer ' + API_KEY,
    'X-Server-Node-Id': NODE_ID,
    'X-Hardware-Fingerprint': HW_FP,
    'X-Request-Signature': sign(body),
  }
}

// ── HTTP helpers ───────────────────────────────────────────────────────────
function postJson(urlPath, data) {
  return new Promise(function(resolve, reject) {
    var body = JSON.stringify(data)
    var url = new URL(urlPath, MC_URL)
    var mod = url.protocol === 'https:' ? https : http
    var req = mod.request(url, { method: 'POST', headers: authHeaders(body) }, function(res) {
      var d = ''
      res.on('data', function(c) { d += c })
      res.on('end', function() { resolve({ status: res.statusCode, body: d }) })
    })
    req.on('error', reject)
    req.write(body)
    req.end()
  })
}

// ── Shell exec ─────────────────────────────────────────────────────────────
function run(cmd, cwd, timeoutSec) {
  try {
    execSync(cmd, { cwd: cwd, timeout: (timeoutSec || 300) * 1000, stdio: 'pipe', encoding: 'utf-8' })
    return true
  } catch (e) {
    log('  FAILED: ' + (e.stderr || e.message || '').slice(0, 300))
    return false
  }
}

// ── FORCE_UPDATE handler ───────────────────────────────────────────────────
function handleForceUpdate(payload) {
  log('[Update] Starting FORCE_UPDATE...')
  var steps = []

  function step(name, cmd, failOk, timeout) {
    log('  ' + name + '...')
    var ok = run(cmd, APP_DIR, timeout)
    steps.push(name + (ok ? ' OK' : ' FAIL'))
    return ok || failOk
  }

  step('git stash', 'git stash', true, 30)
  if (!step('git pull', 'git pull --ff-only', false, 60)) {
    return { ok: false, error: 'git pull failed', steps: steps }
  }
  step('git stash pop', 'git stash pop', true, 30)

  // Re-copy env files in case they were updated
  try { fs.copyFileSync(ENV_FILE, path.join(APP_DIR, '.env')) } catch (e) {}
  try { fs.copyFileSync(ENV_FILE, path.join(APP_DIR, '.env.local')) } catch (e) {}

  if (!step('npm install', 'npm install --production=false', false, 180)) {
    return { ok: false, error: 'npm install failed', steps: steps }
  }
  step('prisma generate', 'npx prisma generate', true, 60)
  step('prisma migrate', 'npx prisma migrate deploy', true, 60)
  if (!step('build', 'npm run build', false, 300)) {
    return { ok: false, error: 'build failed', steps: steps }
  }
  if (!step('restart', 'sudo systemctl restart pulse-pos', false, 30)) {
    return { ok: false, error: 'restart failed', steps: steps }
  }

  var ver = 'unknown'
  try { ver = JSON.parse(fs.readFileSync(path.join(APP_DIR, 'package.json'), 'utf-8')).version } catch (e) {}
  log('[Update] SUCCESS — v' + ver)
  return { ok: true, version: ver, steps: steps }
}

// ── Command ACK ────────────────────────────────────────────────────────────
function ack(cmdId, result) {
  var body = result.ok
    ? { status: 'COMPLETED', resultPayload: { version: result.version, steps: result.steps } }
    : { status: 'FAILED', errorMessage: result.error || 'Unknown', resultPayload: { steps: result.steps } }
  postJson('/api/fleet/commands/' + cmdId + '/ack', body)
    .then(function(r) { log('[Sync] ACK ' + body.status + ' (HTTP ' + r.status + ')') })
    .catch(function(e) { log('[Sync] ACK failed: ' + e.message) })
}

// ── Process received command ───────────────────────────────────────────────
function processCommand(dataStr) {
  try {
    var cmd = JSON.parse(dataStr)
    log('[Sync] Command: ' + cmd.type + ' (' + cmd.id + ')')

    var result
    if (cmd.type === 'FORCE_UPDATE') {
      result = handleForceUpdate(cmd.payload || {})
    } else if (cmd.type === 'KILL_SWITCH') {
      log('[Sync] KILL_SWITCH received — acknowledged')
      result = { ok: true }
    } else {
      log('[Sync] Unknown command: ' + cmd.type + ', ACK OK')
      result = { ok: true }
    }
    ack(cmd.id, result)
  } catch (e) {
    log('[Sync] Error processing command: ' + e.message)
  }
}

// ── SSE Stream ─────────────────────────────────────────────────────────────
var reconnectDelay = 1000

function connectStream() {
  var url = new URL('/api/fleet/commands/stream', MC_URL)
  var mod = url.protocol === 'https:' ? https : http

  log('[Sync] Connecting to ' + MC_URL + '...')

  var req = mod.get(url, { headers: authHeaders('') }, function(res) {
    if (res.statusCode !== 200) {
      log('[Sync] Stream HTTP ' + res.statusCode)
      scheduleReconnect()
      return
    }

    log('[Sync] Connected to command stream')
    reconnectDelay = 1000

    var buf = ''
    var evt = {}

    res.on('data', function(chunk) {
      buf += chunk.toString()
      var lines = buf.split('\n')
      buf = lines.pop() // keep incomplete last line

      for (var i = 0; i < lines.length; i++) {
        var line = lines[i]
        if (line.startsWith(':')) continue  // keepalive comment
        if (line === '') {
          // End of event
          if (evt.event === 'command' && evt.data) {
            processCommand(evt.data)
          } else if (evt.data) {
            log('[SSE] Ignoring non-command event: ' + (evt.event || 'none'))
          }
          evt = {}
          continue
        }
        var ci = line.indexOf(': ')
        if (ci < 0) {
          // SSE field without ": " separator — log for debugging
          if (line.trim().length > 0) {
            log('[SSE] Unparseable line: ' + line.slice(0, 200))
          }
          continue
        }
        var field = line.slice(0, ci)
        var value = line.slice(ci + 2)
        if (field === 'id') evt.id = value
        else if (field === 'event') evt.event = value
        else if (field === 'data') evt.data = (evt.data ? evt.data + '\n' + value : value)  // support multi-line data
      }
    })

    res.on('end', function() {
      log('[Sync] Stream ended, reconnecting...')
      scheduleReconnect()
    })

    res.on('error', function(err) {
      log('[Sync] Stream error: ' + err.message)
      scheduleReconnect()
    })
  })

  req.on('error', function(err) {
    log('[Sync] Connection error: ' + err.message)
    scheduleReconnect()
  })
}

function scheduleReconnect() {
  log('[Sync] Reconnect in ' + (reconnectDelay / 1000) + 's')
  setTimeout(connectStream, reconnectDelay)
  reconnectDelay = Math.min(reconnectDelay * 2, 60000)
}

// ── Start ──────────────────────────────────────────────────────────────────
log('[Sync] GWI POS Sync Agent started')
log('[Sync] MC: ' + MC_URL + '  Node: ' + NODE_ID)
connectStream()

// Trim log periodically (every hour)
setInterval(function() {
  try {
    var lines = fs.readFileSync(LOG_FILE, 'utf-8').split('\n')
    if (lines.length > 1000) {
      fs.writeFileSync(LOG_FILE, lines.slice(-500).join('\n'))
    }
  } catch (e) {}
}, 3600000)
SAEOF

  chown "$POSUSER":"$POSUSER" "$SYNC_SCRIPT"

  # pulse-sync.service — Sync Agent
  cat > /etc/systemd/system/pulse-sync.service <<SVCEOF
[Unit]
Description=GWI POS Sync Agent
After=network-online.target pulse-pos.service
Wants=network-online.target

[Service]
User=$POSUSER
WorkingDirectory=$APP_BASE
ExecStart=/usr/bin/node $APP_BASE/sync-agent.js
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=pulse-sync

[Install]
WantedBy=multi-user.target
SVCEOF

  systemctl daemon-reload
  systemctl enable pulse-sync
  systemctl restart pulse-sync

  log "Sync agent configured and started."

fi  # end server role

# ─────────────────────────────────────────────────────────────────────────────
# Terminal Role: Kiosk Only
# ─────────────────────────────────────────────────────────────────────────────

if [[ "$STATION_ROLE" == "terminal" ]]; then
  header "Configuring Terminal Kiosk"

  # Detect Chromium binary
  TERM_CHROMIUM="chromium-browser"
  if command -v chromium-browser >/dev/null 2>&1; then
    TERM_CHROMIUM="chromium-browser"
  elif command -v chromium >/dev/null 2>&1; then
    TERM_CHROMIUM="chromium"
  else
    warn "Chromium not found — kiosk may not start."
  fi

  # Kill any existing Chromium instances before starting kiosk
  pkill -f "$TERM_CHROMIUM" 2>/dev/null || true
  sleep 1

  # pulse-kiosk.service — Chromium pointing at server
  cat > /etc/systemd/system/pulse-kiosk.service <<SVCEOF
[Unit]
Description=GWI POS Kiosk (Terminal)
After=graphical.target network-online.target
Wants=network-online.target

[Service]
Type=simple
User=$POSUSER
Environment=DISPLAY=:0
Environment=XAUTHORITY=$POSUSER_HOME/.Xauthority
ExecStartPre=/bin/sleep 2
ExecStart=/usr/bin/$TERM_CHROMIUM --kiosk --noerrdialogs --disable-infobars --disable-session-crashed-bubble --no-first-run --disable-features=TranslateUI --incognito --check-for-update-interval=31536000 $SERVER_URL
Restart=on-failure
RestartSec=10

[Install]
WantedBy=graphical.target
SVCEOF

  systemctl daemon-reload
  systemctl enable pulse-kiosk
  systemctl restart pulse-kiosk

  log "Terminal kiosk configured → $SERVER_URL"
fi

# ─────────────────────────────────────────────────────────────────────────────
# RealVNC Enrollment (Both Roles)
# ─────────────────────────────────────────────────────────────────────────────

if [[ -n "${REALVNC_TOKEN:-}" ]]; then
  header "Setting Up RealVNC Remote Access"

  if ! command -v vncserver-x11 >/dev/null 2>&1; then
    log "Installing RealVNC Server..."
    wget -q -O /tmp/vncserver.deb \
      "https://www.realvnc.com/download/file/vnc.files/VNC-Server-Latest-Linux-x64.deb" || {
      warn "Failed to download RealVNC. Skipping VNC setup."
      REALVNC_TOKEN=""
    }

    if [[ -n "$REALVNC_TOKEN" ]]; then
      apt-get install -y /tmp/vncserver.deb
      rm -f /tmp/vncserver.deb
    fi
  fi

  if [[ -n "$REALVNC_TOKEN" ]]; then
    ROLE_SUFFIX="Server"
    [[ "$STATION_ROLE" == "terminal" ]] && ROLE_SUFFIX="Terminal"

    # Build friendly name: PulsePOS-CompanyName-LocationName-Role
    FRIENDLY_NAME="PulsePOS"
    [[ -n "${COMPANY_NAME:-}" ]] && FRIENDLY_NAME="$FRIENDLY_NAME-$COMPANY_NAME"
    [[ -n "${TERMINAL_NAME:-}" ]] && FRIENDLY_NAME="$FRIENDLY_NAME-$TERMINAL_NAME"
    FRIENDLY_NAME="$FRIENDLY_NAME-$ROLE_SUFFIX"

    # Remove spaces and special chars from name
    FRIENDLY_NAME=$(echo "$FRIENDLY_NAME" | tr ' ' '-' | tr -cd 'A-Za-z0-9-_')

    log "Enrolling as: $FRIENDLY_NAME"
    vncserver-x11 -service -joinCloud "$REALVNC_TOKEN" -joinName "$FRIENDLY_NAME" 2>&1 || {
      warn "RealVNC enrollment failed. Check your cloud token and try manually."
    }
  fi
else
  log "RealVNC: Skipped (no token provided)."
fi

# ─────────────────────────────────────────────────────────────────────────────
# Desktop Launcher
# ─────────────────────────────────────────────────────────────────────────────

header "Creating Desktop Launcher"

mkdir -p "$APP_BASE"

POS_URL="http://localhost:3000"
[[ "$STATION_ROLE" == "terminal" ]] && POS_URL="$SERVER_URL"

LOCATION_NAME="${TERMINAL_NAME:-GWI POS}"

# Detect Chromium binary (may already be set from kiosk section)
if [[ -z "${CHROMIUM_BIN:-}" ]]; then
  if command -v chromium-browser >/dev/null 2>&1; then
    CHROMIUM_BIN="chromium-browser"
  elif command -v chromium >/dev/null 2>&1; then
    CHROMIUM_BIN="chromium"
  fi
fi

# Download icon to shared location (works for both server and terminal roles)
POS_ICON="$APP_BASE/icon.svg"
if [[ ! -f "$POS_ICON" ]]; then
  curl -fsSL "https://gwi-pos.vercel.app/icon.svg" -o "$POS_ICON" 2>/dev/null || true
fi
if [[ ! -f "$POS_ICON" ]]; then
  # Fall back to system icon if download fails
  POS_ICON="web-browser"
fi

# Build Exec command: use Chromium with fullscreen if available, else xdg-open
if [[ -n "${CHROMIUM_BIN:-}" ]]; then
  LAUNCHER_EXEC="/usr/bin/${CHROMIUM_BIN} --start-fullscreen --noerrdialogs --disable-infobars --disable-session-crashed-bubble --incognito $POS_URL"
else
  LAUNCHER_EXEC="xdg-open $POS_URL"
fi

# Create a launcher shell script (easy to double-click or run from terminal)
LAUNCHER_SCRIPT="$APP_BASE/launch-pos.sh"
cat > "$LAUNCHER_SCRIPT" <<LSEOF
#!/usr/bin/env bash
# GWI POS Launcher — opens the POS in fullscreen Chromium
$LAUNCHER_EXEC &
LSEOF
chmod +x "$LAUNCHER_SCRIPT"
chown "$POSUSER":"$POSUSER" "$LAUNCHER_SCRIPT"

# Application menu entry (.desktop file)
cat > /usr/share/applications/gwi-pos.desktop <<DTEOF
[Desktop Entry]
Type=Application
Name=GWI POS
Comment=Launch GWI POS — $LOCATION_NAME
Exec=$LAUNCHER_SCRIPT
Icon=$POS_ICON
Terminal=false
Categories=Office;Utility;
StartupNotify=true
DTEOF

# Copy to user desktop (create Desktop dir if it doesn't exist — fresh Ubuntu installs)
DESKTOP_DIR="$POSUSER_HOME/Desktop"
mkdir -p "$DESKTOP_DIR"
chown "$POSUSER":"$POSUSER" "$DESKTOP_DIR"
cp /usr/share/applications/gwi-pos.desktop "$DESKTOP_DIR/"
chown "$POSUSER":"$POSUSER" "$DESKTOP_DIR/gwi-pos.desktop"
chmod +x "$DESKTOP_DIR/gwi-pos.desktop"

# Mark as trusted — different desktops need different approaches
# GNOME (Ubuntu): gio metadata::trusted
if command -v gio >/dev/null 2>&1; then
  sudo -u "$POSUSER" gio set "$DESKTOP_DIR/gwi-pos.desktop" metadata::trusted true 2>/dev/null || true
fi
# KDE Plasma (Kubuntu): writes TryExec and marks executable — that's enough for KDE
# KDE trusts .desktop files if they are executable + have valid Exec= line
# No extra metadata needed — chmod +x (done above) is sufficient

log "Desktop launcher created: $DESKTOP_DIR/gwi-pos.desktop"
log "  Quick launch: $LAUNCHER_SCRIPT"

# ─────────────────────────────────────────────────────────────────────────────
# Summary
# ─────────────────────────────────────────────────────────────────────────────

header "Installation Complete!"

echo -e "  ${GREEN}Role:${NC}     $STATION_ROLE"
echo -e "  ${GREEN}Location:${NC} $LOCATION_NAME"

if [[ "$STATION_ROLE" == "server" ]]; then
  echo -e "  ${GREEN}POS URL:${NC}  http://localhost:3000"
  if [[ "$USE_LOCAL_PG" == "true" ]]; then
    echo -e "  ${GREEN}Database:${NC} PostgreSQL (local)"
    echo -e "  ${GREEN}Backups:${NC}  $BACKUP_DIR (daily 4 AM, 7-day retention)"
  else
    echo -e "  ${GREEN}Database:${NC} Neon (cloud)"
  fi
  echo -e "  ${GREEN}Heartbeat:${NC} Every 60 seconds → Mission Control"
  echo -e "  ${GREEN}Sync:${NC}     Listening for deploy commands"
  echo ""
  echo -e "  ${CYAN}Services:${NC}"
  echo "    pulse-pos    — $(systemctl is-active pulse-pos 2>/dev/null || echo 'unknown')"
  echo "    pulse-kiosk  — $(systemctl is-active pulse-kiosk 2>/dev/null || echo 'unknown')"
  echo "    pulse-sync   — $(systemctl is-active pulse-sync 2>/dev/null || echo 'unknown')"
  echo "    postgresql   — $(systemctl is-active postgresql 2>/dev/null || echo 'unknown')"
else
  echo -e "  ${GREEN}Server:${NC}   $SERVER_URL"
fi

if [[ -n "${REALVNC_TOKEN:-}" ]]; then
  echo -e "  ${GREEN}RealVNC:${NC}  Enrolled as $FRIENDLY_NAME"
fi

echo ""
echo -e "  ${CYAN}Useful commands:${NC}"
echo "    sudo systemctl status pulse-pos    — Check POS status"
echo "    sudo systemctl status pulse-sync   — Check sync agent"
echo "    sudo journalctl -u pulse-pos -f    — View POS logs"
echo "    sudo journalctl -u pulse-sync -f   — View sync agent logs"
echo "    sudo systemctl restart pulse-pos   — Restart POS"
if [[ "$STATION_ROLE" == "server" ]]; then
  if [[ "$USE_LOCAL_PG" == "true" ]]; then
    echo "    sudo bash $BACKUP_SCRIPT     — Run manual backup"
  fi
  echo "    cat /opt/gwi-pos/heartbeat.log   — View heartbeat log"
fi
echo ""
echo -e "  ${CYAN}Re-run this installer to update:${NC}"
echo "    curl -sSL https://gwi-pos.vercel.app/installer.run | sudo bash"
echo ""
log "Done! GWI POS is ready."
