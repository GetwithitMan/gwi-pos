================================================================================
DATACAP SIMULATED PAYMENT INTEGRATION - CODE REVIEW
================================================================================
Reviewer: Claude Code
Date: February 6, 2026
Scope: Simulated reader API routes, useDatacap hook, PaymentModal integration

================================================================================
EXECUTIVE SUMMARY
================================================================================

Overall Assessment: âš ï¸ SIGNIFICANT ISSUES FOUND - Do not deploy to production

Critical Issues: 3 (must fix before shipping)
Warnings: 4 (should fix but not blocking)
Suggestions: 5 (nice-to-have improvements)
Verified OK: 12 (components working correctly)

================================================================================
1. CRITICAL ISSUES (MUST FIX BEFORE SHIPPING)
================================================================================

âŒ CRITICAL-1: Missing terminalId in PaymentModal instances
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/app/(pos)/orders/page.tsx (lines 4007-4053)

Issue:
PaymentModal is instantiated WITHOUT passing terminalId prop. The component 
expects terminalId to be passed, and uses fallback 'default' if not provided.
However, useDatacap.ts will try to fetch terminal config from 
/api/hardware/terminals/undefined, which will fail.

Evidence:
  <PaymentModal
    isOpen={showPaymentModal}
    orderId={orderToPayId}
    orderTotal={...}
    dualPricing={dualPricing}
    paymentSettings={paymentSettings}
    onPaymentComplete={handlePaymentComplete}
    employeeId={employee?.id}
    // âŒ terminalId is MISSING
  />

Impact:
- All card payments from orders/page.tsx will FAIL
- useDatacap will call fetch('/api/hardware/terminals/undefined')
- No reader will be loaded, isReaderOnline will be false
- User gets stuck with "No payment reader configured" error

Required Fix:
Add terminalId prop to ALL PaymentModal instances in orders/page.tsx:
  terminalId="terminal-1"  // or fetch from location config

Found in:
- Line 2739 (floor-plan inline ordering)
- Line 2851 (bartender view) 
- Line 4008 (traditional POS view)

All three instances are missing terminalId.


âŒ CRITICAL-2: No authentication on simulated reader API routes
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/app/api/simulated-reader/**/route.ts (all 4 routes)

Issue:
The simulated reader API routes have ZERO authentication/authorization.
Anyone can hit these endpoints and simulate card transactions.

Affected Endpoints:
- GET  /api/simulated-reader/device/info
- POST /api/simulated-reader/process
- POST /api/simulated-reader/cancel
- POST /api/simulated-reader/device/beep

Attack Scenarios:
1. External attacker submits fake transactions via /process endpoint
2. Malicious actor floods system with process requests (DoS)
3. Browser extensions or XSS could hit endpoints from client side

Required Fix:
Option A (Recommended): Gate behind NODE_ENV check at top of each route:
  if (process.env.NODE_ENV === 'production') {
    return NextResponse.json(
      { error: 'Simulated reader not available in production' },
      { status: 403 }
    )
  }

Option B: Add authentication middleware to verify request source
Option C: Use internal API key in request headers

Without this, simulated reader routes are a security vulnerability.


âŒ CRITICAL-3: No validation on Amount/TipAmount in process route
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/app/api/simulated-reader/process/route.ts (lines 12-14)

Issue:
The process endpoint accepts Amount and TipAmount from request body with
ZERO validation. This allows:
- Negative amounts: { Amount: "-100.00" } 
- Zero amounts: { Amount: "0.00" }
- Non-numeric values: { Amount: "abc" }
- Extremely large amounts: { Amount: "999999999.99" }

Current Code:
  const { Amount, TranType, Invoice, TipAmount } = body
  // No validation here - goes directly to response:
  amountAuthorized: Amount,  // âŒ Unvalidated input returned

Impact:
- Negative amounts could create credit on orders
- Invalid amounts cause downstream parsing errors
- No protection against malformed requests

Required Fix:
Add validation before processing:
  const amount = parseFloat(Amount)
  const tipAmount = parseFloat(TipAmount || '0')
  
  if (isNaN(amount) || amount <= 0) {
    return NextResponse.json(
      { approved: false, ResponseCode: '12', Message: 'Invalid Amount' },
      { status: 400 }
    )
  }
  
  if (isNaN(tipAmount) || tipAmount < 0) {
    return NextResponse.json(
      { approved: false, ResponseCode: '12', Message: 'Invalid Tip Amount' },
      { status: 400 }
    )
  }

Additionally validate:
- TranType should be 'Sale' or 'Auth' only
- Invoice should be non-empty string
- All required fields present


================================================================================
2. WARNINGS (SHOULD FIX BUT NOT BLOCKING)
================================================================================

âš ï¸  WARNING-1: db.ts missing WAL mode pragmas (mentioned in review scope)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/lib/db.ts

Issue:
Review request mentions "WAL mode + busy_timeout pragmas" as a modified
component, but the file shows no PRAGMA statements. Only standard
PrismaClient initialization.

Expected (based on review scope):
  const db = globalForPrisma.prisma ?? createPrismaClient()
  
  // Enable WAL mode for better concurrency
  await db.$executeRaw`PRAGMA journal_mode = WAL;`
  await db.$executeRaw`PRAGMA busy_timeout = 5000;`

Current Reality:
  No PRAGMA statements found in db.ts

Impact:
- If this was meant to be added but wasn't, SQLite will use default
  journal mode (DELETE) which has worse concurrency under load
- busy_timeout defaults to 0, causing "database is locked" errors
  when multiple requests hit simultaneously

Recommendation:
Clarify if WAL pragmas should be added. If yes, they should run
synchronously during client creation, not async after export.


âš ï¸  WARNING-2: Simulated reader routes accessible in production
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: All /api/simulated-reader/* routes

Issue:
No environment gating. If code ships to production with these routes
active, they remain accessible even though they should be dev-only.

Current State:
  export async function POST(request: NextRequest) {
    // âŒ No environment check
    return NextResponse.json({ ... })
  }

Risk:
- Production system with real transactions could accidentally route
  through simulated reader if terminal paymentProvider='SIMULATED'
- Training mode in production would use fake reader instead of real one
- Security audit would flag publicly accessible simulation endpoints

Best Practice:
Add environment guard at top of EVERY simulated reader route:
  if (process.env.NODE_ENV === 'production') {
    return NextResponse.json(
      { error: 'Simulated reader not available in production' },
      { status: 403 }
    )
  }

This ensures production deployments are safe even if terminal config
is misconfigured.


âš ï¸  WARNING-3: Type cleanup incomplete (SimulatedCardReaderProps still exists)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/types/payment.ts (lines 21-25), src/types/index.ts (line 534)

Issue:
Review scope states "SimulatedCardReaderProps removed" but the types
still exist and are being re-exported.

Current State:
  // src/types/payment.ts
  export interface SimulatedCardReaderProps {
    amount: number
    onResult: (result: SimulatedPaymentResult) => void
    disabled?: boolean
  }
  
  // src/types/index.ts
  export type {
    SimulatedPaymentResult,
    SimulatedCardReaderProps,  // âŒ Still exported
    CardReadMethod,
    CardReaderState,
  } from './payment'

Impact:
- Dead code that's no longer used (SimulatedCardReader component removed)
- Confusing for future developers who see "SimulatedCardReaderProps" 
  and think the component still exists
- Import statements referencing this type will fail

Recommendation:
Remove SimulatedCardReaderProps from:
1. src/types/payment.ts (delete interface)
2. src/types/index.ts (remove from export list)

Keep SimulatedPaymentResult as it's used by DatacapResult parsing.


âš ï¸  WARNING-4: isSimulated flag set after getReaderUrl dependency
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/hooks/useDatacap.ts (lines 144-181, 281-288)

Issue:
getReaderUrl() depends on isSimulated flag, but isSimulated is set
inside refreshReaderConfig() which runs async on mount. There's a timing
window where getReaderUrl could be called before isSimulated is set.

Current Flow:
  1. Component mounts
  2. useEffect calls refreshReaderConfig() (async)
  3. Meanwhile, user could trigger processPayment()
  4. processPayment calls getReaderUrl() 
  5. isSimulated is still false (default) âŒ
  6. getReaderUrl returns wrong URL (physical reader IP instead of /api)

Evidence:
  const [isSimulated, setIsSimulated] = useState(false)  // Default: false
  
  const refreshReaderConfig = useCallback(async () => {
    // ... fetch happens here ...
    const simulated = terminal.paymentProvider === 'SIMULATED'
    setIsSimulated(simulated)  // âš ï¸  Async - could be late
  }, [terminalId])
  
  const getReaderUrl = useCallback((path: string) => {
    if (isSimulated) {  // Could be stale 'false'
      return `/api/simulated-reader${path}`
    }
    // ...
  }, [isSimulated, reader])

Impact:
- First payment attempt after page load could fail
- Race condition is timing-dependent (hard to reproduce)
- More likely on slow networks or busy servers

Recommendation:
Option A: Check terminal.paymentProvider in getReaderUrl directly:
  const getReaderUrl = useCallback((path: string) => {
    if (reader && reader.paymentProvider === 'SIMULATED') {
      return `/api/simulated-reader${path}`
    }
    // ...
  }, [reader])

Option B: Store paymentProvider in separate state that's set synchronously

Option C: Make processPayment check isSimulated and refreshReaderConfig
before proceeding if reader is null


================================================================================
3. SUGGESTIONS (NICE-TO-HAVE IMPROVEMENTS)
================================================================================

ğŸ’¡ SUGGESTION-1: Add explicit error state for missing terminalId
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/payment/PaymentModal.tsx (line 669)

Current:
  terminalId={terminalId || 'default'}

Issue:
Falls back to 'default' silently. If terminal config doesn't exist,
user sees generic "Failed to fetch terminal config" error.

Suggestion:
Show clearer error in PaymentModal when terminalId is undefined:
  {!terminalId && (
    <div className="p-4 bg-red-50 text-red-700 rounded">
      <p className="font-bold">Terminal Not Configured</p>
      <p className="text-sm">
        This device needs to be assigned a terminal ID. 
        Contact your manager or system administrator.
      </p>
    </div>
  )}

Better UX than letting payment flow continue with fallback that will fail.


ğŸ’¡ SUGGESTION-2: Add logging to simulated reader routes
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: All /api/simulated-reader/* routes

Suggestion:
Add console.log statements in dev mode for debugging:
  export async function POST(request: NextRequest) {
    if (process.env.NODE_ENV === 'development') {
      console.log('[Simulated Reader] Process request:', {
        Amount, TranType, Invoice
      })
    }
    // ... rest of logic
  }

Benefits:
- Easier to debug when payments fail
- Can see full transaction flow in terminal
- Helps training sessions when demonstrating system


ğŸ’¡ SUGGESTION-3: Consider retry logic for terminal config fetch failures
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/hooks/useDatacap.ts (lines 144-181)

Current:
  If fetch('/api/hardware/terminals/${terminalId}') fails, error is
  logged to console but state is left in broken state. No retry.

Suggestion:
Add exponential backoff retry for terminal config:
  const refreshReaderConfig = useCallback(async (retries = 3) => {
    try {
      const response = await fetch(...)
      // ... success path
    } catch (err) {
      if (retries > 0) {
        console.warn(`[useDatacap] Retrying config fetch (${retries} left)`)
        setTimeout(() => refreshReaderConfig(retries - 1), 1000)
      } else {
        console.error('[useDatacap] Failed to fetch terminal config after retries')
      }
    }
  }, [terminalId])

Rationale:
- Network blips shouldn't permanently break payment functionality
- Startup race conditions (DB not ready) can self-heal with retry


ğŸ’¡ SUGGESTION-4: Add cleanup warning for SimulatedCardReader.tsx
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/payment/SimulatedCardReader.tsx

Observation:
This file is no longer imported anywhere (removed from PaymentModal).
It's dead code.

Suggestion:
Either:
A) Delete the file completely if not used elsewhere
B) Add comment at top warning developers:
   // âš ï¸  DEPRECATED: This component is no longer used.
   // Card payments now use DatacapPaymentProcessor for all modes.
   // Kept for reference only - do not import.

Prevents confusion and accidental re-introduction.


ğŸ’¡ SUGGESTION-5: Validate response shape from simulated reader
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/hooks/useDatacap.ts (lines 418-447)

Current:
  const txResult = await txResponse.json()
  // Directly parse without validating structure

Suggestion:
Add runtime validation using Zod or manual checks:
  const txResult = await txResponse.json()
  
  // Validate required fields
  if (!txResult.ResponseCode) {
    throw new Error('Invalid response: missing ResponseCode')
  }
  
  if (txResult.approved && !txResult.authCode) {
    throw new Error('Invalid response: approved but no authCode')
  }

Benefits:
- Catches API contract violations early
- Better error messages for debugging
- Prevents downstream parsing failures


================================================================================
4. VERIFIED OK (COMPONENTS WORKING CORRECTLY)
================================================================================

âœ… VERIFIED-1: Simulated reader response fields match useDatacap expectations
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
useDatacap.ts expects these fields (lines 429-446):
- approved, status, ResponseCode âœ“
- authCode, AuthCode âœ“
- refNumber, RefNumber, ReferenceNumber âœ“
- cardBrand, CardBrand, CardType âœ“
- cardLast4, CardLast4 âœ“
- entryMethod, EntryMethod âœ“
- amountAuthorized, AmountAuthorized, AuthorizedAmount âœ“

Simulated reader returns (process/route.ts lines 60-71):
  {
    approved: true,
    status: 'APPROVED',
    ResponseCode: '00',
    authCode: generateAuthCode(),
    CardBrand: cardBrand,
    CardLast4: card.lastFour,
    EntryMethod: entryMethod,
    amountAuthorized: Amount,
    ReferenceNumber: referenceNumber,
    Message: 'APPROVED',
  }

All fields present with correct capitalization variants. Parser will work.


âœ… VERIFIED-2: getReaderUrl routing logic is correct
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/hooks/useDatacap.ts (lines 281-288)

Logic:
  if (isSimulated) return `/api/simulated-reader${path}`
  if (!reader) return ''
  return `http://${reader.ipAddress}:${reader.port}${path}`

This correctly:
- Routes to local API when simulated
- Returns empty string if no reader (prevents fetch to "undefined")
- Constructs physical reader URL from IP and port

âœ“ Routing logic is sound (assuming isSimulated is set correctly - see WARNING-4)


âœ… VERIFIED-3: Serial verification skipped for simulated mode
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/hooks/useDatacap.ts (lines 373-383)

Code:
  if (!isSimulated) {
    const deviceSerial = deviceInfo.serialNumber || ...
    if (deviceSerial && deviceSerial !== reader.serialNumber) {
      // Error: wrong device
    }
  }

This correctly bypasses serial number verification for simulated reader,
which is necessary because simulated reader returns 'SIM-001-DEV' that
won't match a real reader's serial.

âœ“ Security check properly gated


âœ… VERIFIED-4: Payment flow complete in PaymentModal
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/payment/PaymentModal.tsx

Flow verified:
1. Select payment method â†’ setStep('tip') if tips enabled
2. Continue from tip â†’ setStep('datacap_card') for card payments
3. Datacap step renders DatacapPaymentProcessor âœ“
4. onSuccess callback â†’ handleDatacapSuccess creates PendingPayment âœ“
5. processPayments() sends to /api/orders/[id]/pay âœ“
6. API response â†’ onPaymentComplete callback âœ“

No missing steps. Flow is complete.


âœ… VERIFIED-5: paymentTerms ?? 30 fixes are correct
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Locations:
- src/app/api/orders/[id]/pay/route.ts (line 391)
- src/app/api/house-accounts/route.ts (line 115)
- src/app/(admin)/house-accounts/page.tsx (lines 144, 176)

All use correct ?? 30 fallback instead of || which would fail for
paymentTerms = 0. This is the correct fix.

Note: Could also be written as:
  paymentTerms ?? 30  // Nullish coalescing (best)
  paymentTerms == null ? 30 : paymentTerms  // Explicit check (verbose)

Current implementation is idiomatic and correct.


âœ… VERIFIED-6: parseInt coercion in house accounts page
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/app/(admin)/house-accounts/page.tsx (lines 144, 176)

Code:
  paymentTerms: parseInt(formPaymentTerms) || 30

This is correct. parseInt() is necessary because form inputs are strings.
The || 30 fallback handles:
- Empty string â†’ NaN â†’ 30
- "0" â†’ 0 â†’ 30 (correct behavior - 0 payment terms makes no sense)
- "abc" â†’ NaN â†’ 30

âœ“ No issues with coercion


âœ… VERIFIED-7: Seed data uses upsert correctly
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: prisma/seed.ts (lines 37-77)

Code:
  const terminal = await prisma.terminal.upsert({
    where: { id: 'terminal-1' },
    update: {},
    create: { id: 'terminal-1', ... }
  })
  
  const simulatedReader = await prisma.paymentReader.upsert({
    where: { serialNumber: 'SIM-001-DEV' },
    update: {},
    create: { serialNumber: 'SIM-001-DEV', ... }
  })

Upsert prevents duplicate key errors on re-seed. Will NOT conflict with
existing data - just skips creation if already exists.

âœ“ Safe for repeated seeding


âœ… VERIFIED-8: DatacapPaymentProcessor receives correct props
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/payment/PaymentModal.tsx (lines 664-673)

Props passed:
  <DatacapPaymentProcessor
    orderId={orderId}               âœ“ String
    amount={currentTotal}           âœ“ Number (card-priced total)
    subtotal={effectiveSubtotal}    âœ“ Number (for tip calculation basis)
    tipSettings={tipSettings}       âœ“ TipSettings object
    terminalId={terminalId || 'default'}  âœ“ String with fallback
    employeeId={employeeId || 'unknown'}  âœ“ String with fallback
    onSuccess={handleDatacapSuccess}      âœ“ Callback
    onCancel={() => setStep('method')}    âœ“ Callback
  />

All props have correct types and sensible defaults.


âœ… VERIFIED-9: handleDatacapSuccess creates correct PendingPayment
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/payment/PaymentModal.tsx (lines 315-328)

Code:
  const handleDatacapSuccess = (result: DatacapResult & { tipAmount: number }) => {
    const payment: PendingPayment = {
      method: selectedMethod as 'credit' | 'debit',
      amount: currentTotal,
      tipAmount: result.tipAmount,
      cardBrand: result.cardBrand || 'card',
      cardLast4: result.cardLast4 || '****',
      authCode: result.authCode,
      transactionId: result.refNumber,
      entryMethod: result.entryMethod,
    }
    setPendingPayments([...pendingPayments, payment])
    processPayments([...pendingPayments, payment])
  }

All DatacapResult fields mapped correctly to PendingPayment structure.
Fallbacks provided for optional fields.

âœ“ Payment record creation is correct


âœ… VERIFIED-10: processPayments API call matches route expectations
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: PaymentModal sends to /api/orders/[id]/pay

Payload structure (lines 339-355):
  {
    payments: [{
      method: 'credit' | 'debit',
      amount: number,
      tipAmount: number,
      cardBrand: string,
      cardLast4: string,
      authCode: string,
      transactionId: string,
      entryMethod: string,
    }],
    employeeId: string,
  }

API route expects (verified in pay/route.ts):
- payments array âœ“
- method, amount, tipAmount âœ“
- cardBrand, cardLast4, authCode, transactionId âœ“
- employeeId âœ“

All fields match. API will accept the payload.


âœ… VERIFIED-11: Heartbeat polling uses refs to prevent interval restarts
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/floor-plan/FloorPlanHome.tsx (lines 1016-1042)

Code:
  const callbacksRef = useRef({ clearExpiredUndos, clearExpiredFlashes })
  
  useEffect(() => {
    callbacksRef.current = { clearExpiredUndos, clearExpiredFlashes }
  })
  
  useEffect(() => {
    const heartbeat = setInterval(() => {
      callbacksRef.current.clearExpiredUndos()
      // ...
    }, 1000)
    return () => clearInterval(heartbeat)
  }, [])  // Empty deps - refs keep callbacks fresh

This is the correct pattern. Prevents interval from restarting on every
render when callbacks change. Good performance optimization.

âœ“ Heartbeat implementation is sound


âœ… VERIFIED-12: Datacap rendering condition simplified correctly
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Location: src/components/payment/PaymentModal.tsx (line 663)

Old condition: step === 'datacap_card' && orderId && terminalId && employeeId
New condition: step === 'datacap_card' && orderId

Rationale:
- terminalId check removed because fallback 'default' is always truthy
- employeeId check removed because fallback 'unknown' is always truthy
- Only orderId needs to be checked (string or null)

This is correct. If terminalId or employeeId are undefined, the fallbacks
ensure DatacapPaymentProcessor always receives valid strings.

âœ“ Condition simplification is safe


================================================================================
5. EDGE CASES & RACE CONDITIONS
================================================================================

ğŸ” EDGE-1: What if simulated reader process route called with amount=0?
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Current Behavior:
  { Amount: "0.00" } â†’ approved=true, amountAuthorized="0.00"

This creates $0 payment record, which is technically valid but weird.
Real reader would likely reject. Covered by CRITICAL-3 validation fix.


ğŸ” EDGE-2: What if DatacapPaymentProcessor unmounts mid-transaction?
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Scenario:
  1. User clicks Pay â†’ DatacapPaymentProcessor mounts
  2. processPayment() called â†’ fetch to /api/simulated-reader/process starts
  3. User clicks Cancel or closes modal â†’ component unmounts
  4. Fetch completes â†’ tries to call onSuccess callback

Actual Behavior:
  useDatacap cleanup (line 189-197) aborts the fetch:
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }

  Aborted fetch throws AbortError, caught in processPayment (line 462).
  No memory leak, no state update on unmounted component.

âœ“ Edge case handled correctly by abort controller cleanup


ğŸ” EDGE-3: Can user spam payment button and create duplicate charges?
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Protection:
  useDatacap sets isProcessing state, derived from processingStatus:
    const isProcessing = processingStatus !== 'idle' && 
                        processingStatus !== 'approved' && ...

  DatacapPaymentProcessor should disable Pay button when isProcessing=true.

Risk:
  If DatacapPaymentProcessor doesn't respect isProcessing prop,
  multiple clicks could trigger multiple processPayment() calls.

Recommendation:
  Verify DatacapPaymentProcessor disables action buttons during processing.


ğŸ” EDGE-4: Heartbeat polling could cause flash on table data change
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Mitigation:
  FloorPlanHome uses refs to track previous data (line 1169):
    const prevTablesJsonRef = useRef<string>('')
    
  loadFloorPlanData only updates state if data actually changed (line 1199):
    if (newJson !== prevTablesJsonRef.current) {
      prevTablesJsonRef.current = newJson
      setTables(newTables)
    }

This prevents unnecessary re-renders when polling returns identical data.

âœ“ Flash prevention implemented correctly


================================================================================
6. SECURITY AUDIT SUMMARY
================================================================================

Critical Vulnerabilities:
  âŒ Unauthenticated simulated reader routes (CRITICAL-2)
  âŒ No input validation on transaction amounts (CRITICAL-3)

Medium Risk:
  âš ï¸  Simulated reader accessible in production (WARNING-2)
  âš ï¸  Race condition on isSimulated flag (WARNING-4)

Low Risk:
  ğŸ’¡ Missing terminal ID could confuse users (SUGGESTION-1)

Recommended Mitigations:
  1. Add NODE_ENV checks to all simulated reader routes (MUST DO)
  2. Add amount validation to /process endpoint (MUST DO)
  3. Pass terminalId prop to PaymentModal instances (MUST DO)
  4. Remove unused SimulatedCardReaderProps types (SHOULD DO)
  5. Fix isSimulated timing issue (SHOULD DO)


================================================================================
7. MULTI-TERMINAL CONSIDERATIONS
================================================================================

Current Hardcoding:
  orders/page.tsx would need terminalId="terminal-1" hardcoded.

Multi-Terminal Future:
  - Each POS terminal will have unique ID (terminal-1, terminal-2, etc.)
  - terminalId should come from device registration or login context
  - Location could have multiple terminals with different readers bound

Recommended Architecture:
  1. Store terminalId in localStorage on device registration
  2. Pass to orders page via props or context provider
  3. Each terminal independently binds to its own PaymentReader

For Now:
  Hardcoding "terminal-1" is acceptable for single-terminal MVP.
  Must be refactored before multi-terminal rollout.


================================================================================
8. TESTING CHECKLIST (MUST VERIFY BEFORE PRODUCTION)
================================================================================

Manual Testing Required:

Payment Flow:
  [ ] Create order â†’ Pay with card â†’ Simulated reader processes
  [ ] Verify approved transaction creates payment record
  [ ] Verify declined transaction shows error message
  [ ] Test with tipAmount included in transaction
  [ ] Test cancel button during "waiting for card" state

Error Handling:
  [ ] Test with missing terminalId (should show error or use default)
  [ ] Test with invalid orderId (should fail gracefully)
  [ ] Test network timeout during transaction (60s timeout)
  [ ] Test reader offline scenario (should show swap modal if backup exists)

Edge Cases:
  [ ] Close PaymentModal mid-transaction (should abort cleanly)
  [ ] Switch tabs during transaction (should abort cleanly)
  [ ] Submit transaction with $0 amount (should reject)
  [ ] Submit transaction with negative amount (should reject)

Security:
  [ ] Verify simulated reader routes return 403 in production
  [ ] Verify authentication on /api/hardware/terminals endpoint
  [ ] Verify payment API validates amounts server-side

Multi-Terminal:
  [ ] Test two terminals with different terminalIds
  [ ] Verify each terminal uses its bound reader
  [ ] Test failover to backup reader when primary offline


================================================================================
9. DEPLOYMENT READINESS CHECKLIST
================================================================================

Before merging to main:
  [ ] Fix CRITICAL-1: Add terminalId to PaymentModal instances
  [ ] Fix CRITICAL-2: Add NODE_ENV guards to simulated reader routes
  [ ] Fix CRITICAL-3: Add amount validation to /process endpoint

Before deploying to staging:
  [ ] Remove SimulatedCardReaderProps from types (WARNING-3)
  [ ] Add environment variable NODE_ENV=production

Before deploying to production:
  [ ] Verify simulated reader routes return 403
  [ ] Verify all tests in section 8 pass
  [ ] Review error logs from staging
  [ ] Document multi-terminal setup process for ops team


================================================================================
10. RECOMMENDATIONS FOR IMMEDIATE ACTION
================================================================================

HIGH PRIORITY (Fix Today):
  1. Add terminalId prop to PaymentModal in orders/page.tsx (CRITICAL-1)
  2. Add NODE_ENV checks to simulated reader routes (CRITICAL-2)
  3. Add amount validation to /process endpoint (CRITICAL-3)

MEDIUM PRIORITY (Fix This Week):
  4. Remove unused SimulatedCardReaderProps types (WARNING-3)
  5. Fix isSimulated timing issue in useDatacap (WARNING-4)
  6. Add error UI for missing terminalId (SUGGESTION-1)

LOW PRIORITY (Can Wait):
  7. Add logging to simulated reader routes (SUGGESTION-2)
  8. Add retry logic to terminal config fetch (SUGGESTION-3)
  9. Add deprecation comment to SimulatedCardReader.tsx (SUGGESTION-4)
  10. Add response validation in useDatacap (SUGGESTION-5)


================================================================================
END OF REVIEW
================================================================================

Overall: The integration is well-structured and mostly correct, but has
three critical issues that MUST be fixed before production deployment:
1. Missing terminalId prop (payments will fail)
2. Unauthenticated API routes (security risk)
3. No input validation (allows invalid transactions)

Once these are addressed, the system will be production-ready for
single-terminal deployments with simulated reader support.

